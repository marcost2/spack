From b7ad38151fa78165752fa7a39de033eea42bed55 Mon Sep 17 00:00:00 2001
From: marcost2 <marcostolcachir@gmail.com>
Date: Sat, 7 May 2022 17:35:51 -0300
Subject: [PATCH] Add elec changes

---
 Registry/Registry.EM_COMMON       |     2 +-
 dyn_em/solve_em.F                 |   121 +
 main/depend.common                |    14 +-
 phys/Makefile                     |     1 +
 phys/module_microphysics_driver.F |   303 +-
 phys/module_mp_nssl_2mom.F        | 22534 +++++++++++++++++-----------
 phys/module_mp_nudge_light.F      |   115 +
 phys/module_physics_init.F        |    29 +-
 share/module_check_a_mundo.F      |    48 +-
 9 files changed, 14488 insertions(+), 8679 deletions(-)
 create mode 100644 phys/module_mp_nudge_light.F

diff --git a/Registry/Registry.EM_COMMON b/Registry/Registry.EM_COMMON
index 6eb6ee2f0b..408497ed5d 100644
--- a/Registry/Registry.EM_COMMON
+++ b/Registry/Registry.EM_COMMON
@@ -1298,7 +1298,7 @@ state    real    vmi3d          ikj     misc        1         -     hdu       "v
 state    real    di3d           ikj     misc        1         -     hdu       "d_ice"                 "Mass-weighted mean ice size"  "m"
 state    real    rhopo3d        ikj     misc        1         -     hdu       "rho_ice"               "Mass-weighted mean ice density"  "kg m-3"
 # LIGHTNING NUDGING
-#state    real    ltg_dat        ij      misc        1         -      r         "ltg_dat"               "gridded lightning data"  "Flash per xkm x xkm per LAD_INT sec"
+state    real    ltg_dat        ij      misc        1         -      r         "ltg_dat"               "gridded lightning data"  "Flash per xkm x xkm per LAD_INT sec"
 # END LIGHTNING NUDGING
 state    real  NCA              ij      misc        1         -      r        "NCA"                   "COUNTER OF THE CLOUD RELAXATION TIME IN KF CUMULUS SCHEME"    ""      
 state    integer  LOWLYR        ij      misc        1         -     -         "LOWLYR"                "INDEX OF LOWEST MODEL LAYER ABOVE THE GROUND IN BMJ SCHEME"   ""      
diff --git a/dyn_em/solve_em.F b/dyn_em/solve_em.F
index a386590ada..41f47d7d5d 100644
--- a/dyn_em/solve_em.F
+++ b/dyn_em/solve_em.F
@@ -140,6 +140,17 @@ SUBROUTINE solve_em ( grid , config_flags  &
 ! time.  Potential problem on stack-limited architectures: increases
 ! amount of data on program stack by making these automatic arrays.
 
+! LIGHTNING NUDGING, Fierro et al. (2012, MWR)
+
+   REAL :: time_chk, time_chk2
+   INTEGER :: time_secs, light_assim_int !, light_assim_int_old
+   INTEGER, SAVE :: light_assim_int_old
+   REAL    :: ltg_val
+!   INTEGER, DIMENSION (grid%sm31:grid%em31, grid%sm32:grid%em32, grid%sm33:grid%em33) :: gridlight3d
+   CHARACTER :: char_assim_int*10, dom*5
+
+! END LIGHTNING NUDGING
+
    INTEGER :: rc 
    INTEGER :: number_of_small_timesteps, rk_step
    INTEGER :: klevel,ijm,ijp,i,j,k,size1,size2    ! for prints/plots only
@@ -301,6 +312,80 @@ SUBROUTINE solve_em ( grid , config_flags  &
    grid%itimestep = grid%itimestep + 1
    grid%dtbc = grid%dtbc + grid%dt
 
+
+! LIGHTNING QV NUDGING, Fierro et al. (2012, MWR)
+
+
+!   gridlight3d(:,:,:)=0 ! Set to zero to avoid using lightning data when assimilation is turned off  
+   tmpTimeInterval = domain_get_current_time ( grid ) - domain_get_start_time ( grid )
+   curr_secs = real_time(tmpTimeInterval)
+
+!    IF (LIGHT_ASSIM_FLAG.AND.grid%id.eq.2) THEN  ! for nested domain 
+!    IF (LIGHT_ASSIM_FLAG) THEN    ! assumes one parent domain
+
+      IF (grid%nudge_lightning.eq.1) THEN    
+
+      IF ( curr_secs .EQ. grid%nudge_light_times) light_assim_int_old=0
+ 
+      IF ( curr_secs .GE. grid%nudge_light_times .AND. curr_secs .LT. grid%nudge_light_timee) THEN  ! LIGHT ASSIM interval
+
+       light_assim_int = INT( curr_secs / grid%nudge_light_int ) + 1 
+
+      IF (light_assim_int .ne. light_assim_int_old) THEN
+
+        light_assim_int_old=light_assim_int
+
+!       IF ( light_assim_int .LT. 10 ) THEN
+!         WRITE ( char_assim_int, '(i1.1)' ) light_assim_int
+!       ELSEIF ( light_assim_int .LT. 100 ) THEN
+!         WRITE ( char_assim_int, '(i2.2)' ) light_assim_int
+!       ELSEIF ( light_assim_int .LT. 1000 ) THEN
+!         WRITE ( char_assim_int, '(i3.3)' ) light_assim_int
+!       ELSEIF ( light_assim_int .LT. 10000 ) THEN
+!         WRITE ( char_assim_int, '(i4.4)' ) light_assim_int
+!       ELSE
+!         WRITE ( char_assim_int, '(i5.5)' ) light_assim_int
+         WRITE ( char_assim_int, '(i5.5)' ) light_assim_int-(INT( grid%nudge_light_times/grid%nudge_light_int ))
+!       ENDIF
+
+       WRITE ( dom, '(i1.1)' ) grid%id
+
+       print *,'filename= ',' light.d0',trim(dom),'.out.',trim(char_assim_int),'.txt'
+
+       OPEN ( UNIT=14, FILE=trim(grid%path_to_files)//'light.d0'//trim(dom)//'.out.'//trim(char_assim_int)//'.txt',  &
+         FORM='formatted', STATUS='old' )
+ 
+       DO i = ids, ide
+       DO j = jds, jde
+         READ ( 14, * ) ltg_val
+      
+         IF ( i .GE. ims .AND. i .LE. ime .AND. j .GE. jms .AND. j .LE. jme ) THEN
+           grid%ltg_dat(i,j) = ltg_val
+!           DO k = kms, kme
+!             gridlight3d(i,k,j) =  grid%ltg_dat(i,j)
+!           ENDDO
+         ENDIF
+       ENDDO
+       ENDDO
+
+       CALL wrf_debug ( 0 , ' DONE reading lightning data ' )
+       print *,' light.d0',trim(dom),'.out.',trim(char_assim_int),'.txt'
+       print *,'curr_secs ',curr_secs
+
+       CLOSE ( 14 )
+
+      ENDIF  ! light_assim_int .ne. light_assim_int_old
+
+   ENDIF ! curr_secs if-test
+
+!   ELSE
+!
+!   gridlight3d(:,:,:)=0 ! Set to zero to avoid using lightning data when assimilation is turned off  
+!
+   ENDIF  ! LIGHT NUDGING 
+
+
+
    IF( coupler_on ) CALL cpl_store_input( grid, config_flags )
 
    IF (config_flags%polar) dclat = 90./REAL(jde-jds) !(0.5 * 180/ny)
@@ -3723,6 +3808,7 @@ SUBROUTINE solve_em ( grid , config_flags  &
       &        ,F_RAIN_PHY=grid%f_rain_phy                                &
       &        ,F_RIMEF_PHY=grid%f_rimef_phy                              &
       &        ,MP_PHYSICS=config_flags%mp_physics                        &
+      &        ,elec_PHYSICS=config_flags%elec_physics                    &
       &        ,ID=grid%id                                                &
       &        ,IDS=ids,IDE=ide, JDS=jds,JDE=jde, KDS=kds,KDE=kde         &
       &        ,IMS=ims,IME=ime, JMS=jms,JME=jme, KMS=kms,KME=kme         &
@@ -3801,6 +3887,41 @@ SUBROUTINE solve_em ( grid , config_flags  &
       &        , QVOLG_CURR=scalar(ims,kms,jms,P_QVOLG), F_QVOLG=F_QVOLG    & ! for nssl_2mom
       &        , QVOLH_CURR=scalar(ims,kms,jms,P_QVOLH), F_QVOLH=F_QVOLH    & ! for nssl_2mom
       &        , cu_used=config_flags%cu_used                             &
+!--------------EXPLICIT LIGHTNING (Fierro et al. 2013, MWR)-----------------
+      &        , RSCGHIS_2d=grid%rscghis_2d                               &
+      &        , NONINDUC=grid%noninduc                                   &
+#ifdef WRF_ELEC
+      &        , ELECMAG=grid%elecmag                                     &
+      &        , ELECX=grid%elecx, F_ELECX=(size(grid%elecx,3) > 1)       &
+      &        , ELECY=grid%elecy                                         &
+      &        , ELECZ=grid%elecz                                         &
+      &        , INDUC=grid%induc                                         &
+      &        , POT=grid%pot                                             &
+      &        , LIGHT=grid%light                                         &
+      &        , LIGHTDENS=grid%lightdens                                 &
+      &        , LIGHTDIS=grid%lightdis                                   &
+      &        , SCR=scalar(ims,kms,jms,P_SCR), F_SCR=F_SCR               & 
+      &        , SCW=scalar(ims,kms,jms,P_SCW), F_SCW=F_SCW               & 
+      &        , SCI=scalar(ims,kms,jms,P_SCI), F_SCI=F_SCI               &  
+      &        , SCS=scalar(ims,kms,jms,P_SCS), F_SCS=F_SCS               & 
+      &        , SCH=scalar(ims,kms,jms,P_SCH), F_SCH=F_SCH               & 
+      &        , SCHL=scalar(ims,kms,jms,P_SCHL), F_SCHL=F_SCHL           & 
+      &        , SCIONA=scalar(ims,kms,jms,P_SCIONA), F_SCIONA=F_SCIONA   & 
+      &        , SCTOT=grid%sctot                                         &  
+      &        , HISTORY_INTERVAL=grid%history_interval                   &
+      &        , CURR_SECS=curr_secs                                      &
+      &        , ipelectmp=grid%nssl_ipelec                               &
+      &        , idischarge=grid%nssl_idischarge                          &
+      &        , iscreen=grid%nssl_iscreen                                &
+      &        , lightradtmp=grid%nssl_lightrad                           &
+      &        , ecrittmp=grid%nssl_ecrit                                 &
+      &        , ibrkdtmp=grid%nssl_ibrkd                                 &
+      &        , disfrac=grid%nssl_disfrac                                &
+#endif
+!--------------END EXPLICIT LIGHTNING -------------------------------------
+      &        , nudge_lightning=grid%nudge_lightning                     & ! for lightning Qv nudging (Fierro et al. 2012, MWR)
+!      &        , GRIDLIGHT=gridlight3d                                    & ! for lightning Qv nudging (Fierro et al. 2012, MWR)
+      &        , GRIDLIGHT=grid%ltg_dat                                   & ! for lightning Qv nudging (Fierro et al. 2012, MWR)
       &        , qrcuten=grid%rqrcuten, qscuten=grid%rqscuten             &
       &        , qicuten=grid%rqicuten, qccuten=grid%rqccuten             &
       &        , HAIL=config_flags%gsfcgce_hail                           & ! for gsfcgce
diff --git a/main/depend.common b/main/depend.common
index 8d0aa81254..777eac81c6 100644
--- a/main/depend.common
+++ b/main/depend.common
@@ -362,6 +362,16 @@ module_mp_thompson.o : ../frame/module_wrf_error.o \
 module_mp_nssl_2mom.o : ../frame/module_wrf_error.o \
 		../share/module_model_constants.o
 
+module_mp_nudge_light.o : ../frame/module_dm.o ../frame/module_wrf_error.o
+
+module_mp_boxmgsetup.o : ../frame/module_wrf_error.o 
+
+module_commasmpi.o : ../frame/module_wrf_error.o
+
+module_mp_discharge.o : module_commasmpi.o ../frame/module_dm.o ../frame/module_wrf_error.o 
+
+module_mp_screen.o : ../frame/module_dm.o module_commasmpi.o ../frame/module_wrf_error.o
+
 module_mp_fast_sbm.o : module_mp_radar.o
 
 module_mp_full_sbm.o : module_mp_radar.o
@@ -592,13 +602,15 @@ module_microphysics_driver.o: \
                 module_mp_morr_two_moment.o     \
                 module_mp_milbrandt2mom.o     \
                 module_mp_nssl_2mom.o         \
+		module_mp_nudge_light.o             \
 		module_mp_wdm5.o module_mp_wdm6.o \
 		module_mp_cammgmp_driver.o \
 		../frame/module_driver_constants.o \
 		../frame/module_state_description.o \
 		../frame/module_wrf_error.o \
 		../frame/module_configure.o \
-		../share/module_model_constants.o 
+		../share/module_model_constants.o \
+		$(EF)
 
 module_shallowcu_driver.o: \
 		module_shcu_camuwshcu_driver.o \
diff --git a/phys/Makefile b/phys/Makefile
index a629af7a02..b57fd8c178 100644
--- a/phys/Makefile
+++ b/phys/Makefile
@@ -87,6 +87,7 @@ MODULES = \
 	module_mp_morr_two_moment.o \
         module_mp_p3.o \
 	module_mp_milbrandt2mom.o \
+	module_mp_nudge_light.o \
 	module_mp_nssl_2mom.o \
 	module_mp_wdm5.o \
 	module_mp_wdm6.o \
diff --git a/phys/module_microphysics_driver.F b/phys/module_microphysics_driver.F
index 7aa54e976b..067752b75b 100644
--- a/phys/module_microphysics_driver.F
+++ b/phys/module_microphysics_driver.F
@@ -7,10 +7,11 @@ MODULE module_microphysics_driver
 SUBROUTINE microphysics_driver(                                          &
                        th, rho, pi_phy, p                                &
                       ,ht, dz8w, p8w, dt,dx,dy                           &
-                      ,mp_physics, spec_zone                             &
+                      ,mp_physics, elec_physics, spec_zone               &
                       ,specified, channel_switch                         &
                       ,warm_rain                                         &
                       ,t8w                                               &
+                      ,history_interval,curr_secs                        &
                       ,chem_opt, progn                                   &
                       ,cldfra, cldfra_old, exch_h, nsource               &
                       ,qlsink, precr, preci, precs, precg                &
@@ -59,6 +60,13 @@ SUBROUTINE microphysics_driver(                                          &
                       ,f_qir,f_qib                                       & ! for P3
                       ,f_effr,f_ice_effr,f_tot_effr                      &
                       ,f_qic_effr,f_qip_effr,f_qid_effr                  &                 
+                      ,scr,scw,sci,scs,sch,schl,sciona,sctot             &
+                      ,f_scr,f_scw,f_sci,f_scs,f_sch,f_schl,f_sciona     &
+                      ,ipelectmp                                         & ! Explicit lightning namelist flags
+#ifdef WRF_ELEC 
+                      ,iscreen,lightradtmp,ibrkdtmp,ecrittmp,disfrac,idischarge   & ! Explicit lightning namelist flags
+#endif
+                      ,nudge_lightning                                   & ! lightnign Qv nudging flag
                       ,cu_used                                           &
                       ,qrcuten, qscuten, qicuten, qccuten                &
                       ,qt_curr,f_qt                                      &
@@ -66,6 +74,13 @@ SUBROUTINE microphysics_driver(                                          &
                       ,hail,ice2                                         & ! for mp_gsfcgce
 !                     ,ccntype                                           & ! for mp_milbrandt2mom
                       ,u,v,w,z                                          &   
+#ifdef WRF_ELEC 
+                      ,induc,pot,elecmag                                 &
+                      ,elecx,f_elecx,elecy,elecz                         &
+                      ,light,lightdens,lightdis                          &
+#endif
+                      ,gridlight                                         &
+                      ,noninduc,  rscghis_2d                             &
                       ,rainnc,    rainncv                                &
                       ,snownc,    snowncv                                &
                       ,hailnc,    hailncv                                &
@@ -120,6 +135,15 @@ SUBROUTINE microphysics_driver(                                          &
                  local_communicator, mytask,  wrf_dm_min_real, wrf_dm_max_real
 #endif
 
+#ifdef WRF_ELEC 
+! BOXMG Solver
+  USE module_mp_boxmgsetup
+  USE module_mp_discharge
+  USE module_mp_screen
+#endif
+
+  USE module_mp_nudge_light
+
 ! Model Layer
    USE module_model_constants
    USE module_wrf_error
@@ -316,12 +340,41 @@ SUBROUTINE microphysics_driver(                                          &
 !-- num_tiles     number of tiles
 !-- diagflag      Logical to tell us when to produce diagnostics for history or restart
 !
+!======================================================================
+!======================================================================
+! Explicit Lightning (Mansell et al. 2005, Fierro et al. 2013, MWR):
+!
+!--induc        total inductive/polarization charging rates in C/m3*s (Ziegler et al. 1991,MWR)
+!--noninduc     total non inductive charging rates in C/m3*s
+!--rscghis_2d   maximum non inductive charging rate in the column in C/m3*s.
+!--elec         electric field vector (V/m)
+!--elecmag      electric field magnitude (V/m)
+!--elecx        X-component of the ambient electric field (V/m).
+!--elecy        Y-component of the ambient electric field (V/m).
+!--elecz        vertical, Z-component of the ambient electric field (V/m).
+!--pot          electric potential (V)
+!--sctot        total net space charge in C/kg
+!--scx           total net space charge on hydrometeor species x
+!--light         2D flash origin densities per output time
+!--lightdens     2D flash extent densities per output time
+!--lightdis      2D total number of discharge points per output time 
+!
+! Lightning assimilation/nudging (Fierro et al. 2012, MWR):
+!
+!  activate by setting the flag LIGHT_ASSIM_FLAG to .true. - 
+!  nudging is called by the subroutine "nudge_light" in module_mp_nudge_light.F (which
+!  contains nudging parameters)
+!  set model time intervals for nudging in solve.em.F
+!--gridlight     gridded lightning data for nudging   
+!
 !======================================================================
   INTEGER,parameter :: iunit=6
   INTEGER :: mpi_error_code=1
 
+   INTEGER,    INTENT(IN   )    :: history_interval
+   REAL   ,    INTENT(IN   )    :: curr_secs 
    TYPE(grid_config_rec_type),  INTENT(IN   ) , OPTIONAL   :: config_flags
-   INTEGER,    INTENT(IN   )    :: mp_physics
+   INTEGER,    INTENT(IN   )    :: mp_physics,elec_physics
    LOGICAL,    INTENT(IN   )    :: specified
    INTEGER, OPTIONAL, INTENT(IN   )    :: chem_opt, progn
    INTEGER, OPTIONAL, INTENT(IN   )    :: hail, ice2 !, ccntype
@@ -454,6 +507,24 @@ SUBROUTINE microphysics_driver(                                          &
    REAL, OPTIONAL, DIMENSION( ims:ime , kms:kme, jms:jme ) , INTENT(OUT) :: refl_10cm
    REAL, OPTIONAL, DIMENSION( ims:ime , kms:kme, jms:jme ) , INTENT(OUT) :: vmi3d,di3d,rhopo3d ! for P3
 
+
+! Explicit lightning
+#ifdef WRF_ELEC 
+   REAL, OPTIONAL, DIMENSION( ims:ime , kms:kme, jms:jme ) , INTENT(INOUT) :: pot
+   REAL, OPTIONAL, DIMENSION( ims:ime , kms:kme, jms:jme ) , INTENT(INOUT)   :: elecmag,induc,elecx,elecy,elecz
+   REAL, OPTIONAL, DIMENSION( ims:ime , jms:jme )          , INTENT(INOUT)   :: light,lightdens
+   INTEGER, OPTIONAL, DIMENSION( ims:ime , jms:jme )       , INTENT(INOUT)   :: lightdis
+   REAL,   DIMENSION( ims:ime , kms:kme, jms:jme,1:4) :: elec ! local array for the driver-only emag is used for I/O-ALWAYS USED IN 1D so NOT OPTIONAL !.
+   REAL, OPTIONAL, DIMENSION( ims:ime , jms:jme )          , INTENT(INOUT) ::  rscghis_2d
+   REAL, OPTIONAL, DIMENSION( ims:ime , kms:kme, jms:jme ) , INTENT(INOUT)   :: noninduc
+
+   REAL,   DIMENSION( ims:ime , kms:kme, jms:jme,1:2) :: scion ! local array for the driver- 1=-, 2=+
+! End Explicit lightning
+#endif
+!   lightning nudging/assimilation
+   REAL, DIMENSION( ims:ime, jms:jme ) ::      gridlight
+
+
    LOGICAL,  OPTIONAL,   INTENT(IN   )    :: channel_switch
    REAL, OPTIONAL,  INTENT(INOUT   ) :: naer  ! aerosol number concentration (/kg)
    REAL, DIMENSION( ims:ime, jms:jme ), INTENT(IN) , OPTIONAL :: qnwfa2d      ! Added by G. Thompson
@@ -477,7 +548,8 @@ SUBROUTINE microphysics_driver(                                          &
                  ,kext_ft_qic,kext_ft_qip,kext_ft_qid &
                  ,kext_ft_qs,kext_ft_qg                           &
                  ,qnwfa_curr,qnifa_curr                           & ! Added by G. Thompson
-                 ,qvolg_curr,qvolh_curr, qrimef_curr
+                 ,qvolg_curr,qvolh_curr, qrimef_curr              &
+                 ,scw,scr,sci,scs,sch,schl,sctot,sciona             ! Explicit Lightning
 
 
 
@@ -530,11 +602,23 @@ SUBROUTINE microphysics_driver(                                          &
                        ,f_qic_effr,f_qip_effr,f_qid_effr &
                       ,f_qic,f_qip,f_qid &
                       ,f_qnic,f_qnip,f_qnid                                  &
+#ifdef WRF_ELEC
+! Explicit lightning
+                       ,f_elecx                                 & !lightning
+                       ,f_scw,f_scr,f_sci,f_scs,f_sch,f_schl,f_sciona & ! lightning
+#endif
                        ,f_qzi,f_qzs,f_qzg,f_qzh,f_qvolg,f_qvolh              &
                        ,f_qrimef                                             &
                        ,f_qir,f_qib                                          & ! for P3
                        ,f_qnwfa, f_qnifa                         ! Added by G. Thompson
 
+#ifdef WRF_ELEC
+   real,    OPTIONAL :: lightradtmp,ecrittmp,disfrac
+   integer, OPTIONAL :: iscreen,idischarge,ibrkdtmp
+#endif
+   integer,optional :: ipelectmp,nudge_lightning
+! End explicit lightning
+
 
    LOGICAL, OPTIONAL, INTENT(IN) :: diagflag
    REAL, INTENT(IN) :: ccn_conc ! RAS
@@ -555,6 +639,28 @@ SUBROUTINE microphysics_driver(                                          &
    real :: wmin, wmax
    integer :: ierr
 
+! Explicit lightning
+    
+#ifdef WRF_ELEC
+   integer l,iter,lgtstp,loccur,nxdg,nydg,nzdg
+   logical :: irelax = .false.
+   integer :: maxiter = 60
+   integer, save :: iboxmgsetup = 0, isetup = 1
+   REAL, DIMENSION(ims:ime, kms:kme, jms:jme ) ::  ezfair,height2
+   REAL, DIMENSION(kms:kme) ::  potfair
+   double precision :: etot
+   double precision :: dt1,dt4,timeboxmg
+   real, parameter :: jc = -2.0e-12  ! fair weather current density J (Amp m**-2) (Helsdon & Farley 1987; Chiu (1978) has -2.7e-12, quoting Gish (1944))
+   real, parameter :: eperao = 8.8592e-12 ! permittivity of air
+!   fair weather elec field params
+
+   double precision, parameter :: ezfairo = -80.00d0
+   double precision, parameter :: efa1 = 4.5d-3, efa2 = 3.8d-4, efa3 = 1.0d-4
+   double precision, parameter :: efb1 = 0.50, efb2 = 0.65, efb3 = 0.10
+#endif
+   integer :: ng =3
+! End explicit lightning
+
 !---------------------------------------------------------------------
 !  check for microphysics type.  We need a clean way to
 !  specify these things!
@@ -571,7 +677,7 @@ SUBROUTINE microphysics_driver(                                          &
    ENDIF
 
 ! set this to true to print out the global max/min for W on each time step.
-   IF ( .false. ) THEN
+   IF ( .true. ) THEN
       wmax = maxval( w(ips:ipe,kps:kpe,jps:jpe) )
       wmin = minval( w(ips:ipe,kps:kpe,jps:jpe) )
 #if ( defined(DM_PARALLEL)  &&   ! defined(STUBMPI) )
@@ -1341,6 +1447,7 @@ SUBROUTINE microphysics_driver(                                          &
              PRESENT (QVOLG_CURR) .AND. F_QVOLG  .AND.         &
              PRESENT (QVOLH_CURR) .AND. F_QVOLH ) THEN
              
+         IF ( elec_physics == 0 ) THEN
 
          CALL nssl_2mom_driver(                          &
                      ITIMESTEP=itimestep,                &
@@ -1398,6 +1505,88 @@ SUBROUTINE microphysics_driver(                                          &
                   ITS=its,ITE=ite, JTS=jts,JTE=jte, KTS=kts,KTE=kte  &
                                                                     )
 
+
+        ELSEIF ( elec_physics > 0 .and. f_scw ) THEN
+
+#if ( WRF_ELEC >= 1 )
+         CALL nssl_2mom_driver(                          &
+                     ITIMESTEP=itimestep,                &
+                     TH=th,                              &
+                     QV=qv_curr,                         &
+                     QC=qc_curr,                         &
+                     QR=qr_curr,                         &
+                     QI=qi_curr,                         &
+                     QS=qs_curr,                         &
+                     QH=qg_curr,                         &
+                     QHL=qh_curr,                        &
+!                     cn=qnn_curr,                        &
+                     CCW=qndrop_curr,                       &
+                     CRW=qnr_curr,                       &
+                     CCI=qni_curr,                       &
+                     CSW=qns_curr,                       &
+                     CHW=qng_curr,                       &
+                     CHL=qnh_curr,                       &
+                     SCR=scr,                            &
+                     SCW=scw,                            &
+                     SCI=sci,                            &
+                     SCS=scs,                            &
+                     SCH=sch,                            &
+                     SCHL=schl,                          &
+                     SCTOT=sctot,                        &
+                     NONINDUC = noninduc,                &
+                     rscghis_2d = rscghis_2d,            &
+                     INDUC = induc,                      & 
+                     ELEC = elecz,                       & 
+                     SCION = scion,                      & 
+                     SCIONA = sciona,                    & 
+                     VHW=qvolg_curr,                     &
+                     VHL=qvolh_curr,                     &
+                     PII=pi_phy,                         &
+                     P=p,                                &
+                     W=w,                                &
+                     DZ=dz8w,                            &
+                     dx=dx, dy=dy,                       &
+                     DTP=dt,                             &
+                     DN=rho,                             &
+                     RAINNC   = RAINNC,                  &
+                     RAINNCV  = RAINNCV,                 &
+                     SNOWNC   = SNOWNC,                  &
+                     SNOWNCV  = SNOWNCV,                 &
+                     HAILNC   = HAILNC,                  &
+                     HAILNCV  = HAILNCV,                 &
+                     GRPLNC   = GRAUPELNC,               &
+                     GRPLNCV  = GRAUPELNCV,              &
+                     SR=SR,                              &
+                     diagflag = diagflag,                &
+                     ipelectmp = ipelectmp,                &
+                     dbz      = refl_10cm,               &
+                     nssl_progn=nssl_progn,              &
+                     cu_used=cu_used,                    &
+                     qrcuten=qrcuten,                    &  ! hm
+                     qscuten=qscuten,                    &  ! hm
+                     qicuten=qicuten,                    &  ! hm
+                     qccuten=qccuten,                    &  ! hm
+                     re_cloud=re_cloud,                  &
+                     re_ice=re_ice,                      &
+                     re_snow=re_snow,                    &
+                     has_reqc=has_reqc,                  & ! ala G. Thompson
+                     has_reqi=has_reqi,                  & ! ala G. Thompson
+                     has_reqs=has_reqs,                  & ! ala G. Thompson
+#if ( WRF_CHEM == 1 )
+                     EVAPPROD=evapprod,RAINPROD=rainprod,&
+#endif
+                  IDS=ids,IDE=ide, JDS=jds,JDE=jde, KDS=kds,KDE=kde, &
+                  IMS=ims,IME=ime, JMS=jms,JME=jme, KMS=kms,KME=kme, &
+                  ITS=its,ITE=ite, JTS=jts,JTE=jte, KTS=kts,KTE=kte  &
+                                                       )
+
+#else
+        Call wrf_error_fatal( 'for elec_physics > 0, need to rebuild WRF with -DWRF_ELEC')
+#endif
+
+
+        ENDIF ! elec_physics
+
         ELSE
            Call wrf_error_fatal( 'arguments not present for calling nssl_2mom')
         ENDIF
@@ -1498,6 +1687,8 @@ SUBROUTINE microphysics_driver(                                          &
              PRESENT( QNN_CURR )                          ) THEN
              
 
+         IF ( elec_physics == 0 ) THEN
+         
          CALL nssl_2mom_driver(                          &
                      ITIMESTEP=itimestep,                &
                      TH=th,                              &
@@ -1554,6 +1745,87 @@ SUBROUTINE microphysics_driver(                                          &
                   IMS=ims,IME=ime, JMS=jms,JME=jme, KMS=kms,KME=kme, &
                   ITS=its,ITE=ite, JTS=jts,JTE=jte, KTS=kts,KTE=kte  &
                                                                     )
+
+         ELSEIF ( elec_physics > 0 .and. f_scw) THEN
+
+#if ( WRF_ELEC == 1 )
+         CALL nssl_2mom_driver(                          &
+                     ITIMESTEP=itimestep,                &
+                     TH=th,                              &
+                     QV=qv_curr,                         &
+                     QC=qc_curr,                         &
+                     QR=qr_curr,                         &
+                     QI=qi_curr,                         &
+                     QS=qs_curr,                         &
+                     QH=qg_curr,                         &
+                     QHL=qh_curr,                        &
+                     cn=qnn_curr,                        &
+                     CCW=qndrop_curr,                       &
+                     CRW=qnr_curr,                       &
+                     CCI=qni_curr,                       &
+                     CSW=qns_curr,                       &
+                     CHW=qng_curr,                       &
+                     CHL=qnh_curr,                       &
+                     SCR=scr,                            &
+                     SCW=scw,                            &
+                     SCI=sci,                            &
+                     SCS=scs,                            &
+                     SCH=sch,                            &
+                     SCHL=schl,                          &
+                     SCTOT=sctot,                        &
+                     NONINDUC = noninduc,                &
+                     rscghis_2d = rscghis_2d,            &
+                     INDUC = induc,                      & 
+                     ELEC = elecz,                       & 
+                     SCION = scion,                      & 
+                     SCIONA = sciona,                    & 
+                     VHW=qvolg_curr,                     &
+                     VHL=qvolh_curr,                     &
+                     PII=pi_phy,                         &
+                     P=p,                                &
+                     W=w,                                &
+                     DZ=dz8w,                            &
+                     dx=dx, dy=dy,                       &
+                     DTP=dt,                             &
+                     DN=rho,                             &
+                     RAINNC   = RAINNC,                  &
+                     RAINNCV  = RAINNCV,                 &
+                     SNOWNC   = SNOWNC,                  &
+                     SNOWNCV  = SNOWNCV,                 &
+                     HAILNC   = HAILNC,                  &
+                     HAILNCV  = HAILNCV,                 &
+                     GRPLNC   = GRAUPELNC,               &
+                     GRPLNCV  = GRAUPELNCV,              &
+                     SR=SR,                              &
+                     diagflag = diagflag,                &
+                     ipelectmp = ipelectmp,                &
+                     dbz      = refl_10cm,               &
+                     nssl_progn=nssl_progn,              &
+                     cu_used=cu_used,                    &
+                     qrcuten=qrcuten,                    &  ! hm
+                     qscuten=qscuten,                    &  ! hm
+                     qicuten=qicuten,                    &  ! hm
+                     qccuten=qccuten,                    &  ! hm
+                     re_cloud=re_cloud,                  &
+                     re_ice=re_ice,                      &
+                     re_snow=re_snow,                    &
+                     has_reqc=has_reqc,                  & ! ala G. Thompson
+                     has_reqi=has_reqi,                  & ! ala G. Thompson
+                     has_reqs=has_reqs,                  & ! ala G. Thompson
+#if ( WRF_CHEM == 1 )
+                     EVAPPROD=evapprod,RAINPROD=rainprod,&
+#endif
+                  IDS=ids,IDE=ide, JDS=jds,JDE=jde, KDS=kds,KDE=kde, &
+                  IMS=ims,IME=ime, JMS=jms,JME=jme, KMS=kms,KME=kme, &
+                  ITS=its,ITE=ite, JTS=jts,JTE=jte, KTS=kts,KTE=kte  &
+                                                       )
+#else
+        Call wrf_error_fatal( 'for elec_physics > 0, need to rebuild WRF with -DWRF_ELEC')
+#endif
+         
+         ENDIF
+        
+
         ELSE
            Call wrf_error_fatal( 'arguments not present for calling nssl_2momccn')
         ENDIF
@@ -2091,6 +2363,29 @@ SUBROUTINE microphysics_driver(                                          &
 
       END SELECT micro_select
 
+      
+#if ( WRF_ELEC == 1 )
+#include "../elec/include_microphysics_driver_elec.F"
+#endif
+
+! LIGHTNING NUDGING - 
+
+      IF (nudge_lightning.eq.1) THEN
+     
+      if (maxval(gridlight(its:ite,jts:jte)).gt.0) then 
+        write(0,*) 'TILE MAXVAL GRIDLIGHT',maxval(gridlight(its:ite,jts:jte))
+      endif
+
+
+     CALL nudge_light(ite-its+1,jte-jts+1,kte-kts+1,qg_curr(its:ite,kts:kte,jts:jte),   &
+                   & qv_curr(its:ite,kts:kte,jts:jte),gridlight(its:ite,jts:jte),  &
+                   & t8w(its:ite,kts:kte,jts:jte),p8w(its:ite,kts:kte,jts:jte),  &
+                   & dz8w(its:ite,kts:kte,jts:jte),dx,dy,dt)
+
+      ENDIF
+
+! END LIGHTNING NUDGING
+
    ENDDO
    !$OMP END PARALLEL DO
 
diff --git a/phys/module_mp_nssl_2mom.F b/phys/module_mp_nssl_2mom.F
index fafd4eec80..cfb4ea1e99 100644
--- a/phys/module_mp_nssl_2mom.F
+++ b/phys/module_mp_nssl_2mom.F
@@ -1,6 +1,7 @@
 !WRF:MODEL_LAYER:PHYSICS
 
-! prepocessed on "Nov 18 2016" at "14:51:08"
+
+! prepocessed on "Oct 20 2017" at "16:21:24"
 
 
 
@@ -70,6 +71,7 @@
 !   Adjusted Meyers number of activated nuclei by the local air density to compensate for using data at surface
 !   Minor updates to rain-ice crystal and hail-rain collection efficiencies
 !
+!   
 !   Reduced minimum mean snow diameter from 100 microns to 10 microns
 !
 ! WRF 3.8 updates:
@@ -222,6 +224,7 @@ MODULE module_mp_nssl_2mom
   integer, private :: irimtim = 0 ! future use
 !  integer, private :: infdo = 1   ! 1 = calculate number-weighted fall speeds
 
+  integer, private :: irimdenopt = 1 ! = 1 for default Maklin; = 2 for experimental Cober and List (1993)
   real   , private :: rimc1 = 300.0, rimc2 = 0.44  ! rime density coeff. and power (Default Heymsfield and Pflaum, 1985)
   real   , private :: rimc3 = 170.0                ! minimum rime density
   real    :: rimc4 = 900.0                ! maximum rime density
@@ -263,7 +266,7 @@ MODULE module_mp_nssl_2mom
                                  ! (0=off; 1=drops > 500micron diameter; 2 = > 300micron)
   integer, private :: ibfr = 2            ! Flag for Bigg freezing conversion of freezing drops to graupel
                                  ! (1=min graupel size is vr1mm; 2=use min size of dfrz, 5= as for 2 and apply dbz conservation)
-  integer, private :: ibiggopt = 2        ! 1 = old Bigg; 2 = experimental Bigg (only for imurain = 1, however)
+  integer, private :: ibiggopt = 1        ! 1 = old Bigg; 2 = experimental Bigg (only for imurain = 1, however)
   integer :: ibiggsmallrain = 0  ! 1 = When rain is too small, freeze none to graupel and send all to snow (experimental)
   integer, private :: iacrsize = 5        ! assumed min size of drops freezing by capture
                                  !  1: > 500 micron diam
@@ -284,11 +287,14 @@ MODULE module_mp_nssl_2mom
   integer, private :: iehlw = 1           ! 0 -> ehlw=ehlw0; 1 -> old ehlw; 2 -> test ehlw with Mason table data
                                  ! For ehw/ehlw = 1, ehw0/ehlw0 act as maximum limit on collection efficiency (defaults are 1.0)
   integer, private :: ierw = 1            ! for single-moment rain (LFO/Z)
+  integer, private :: iehr0c = 0          ! 0 -> no collection for T > 0C;  1 -> turn on collection/shedding for T > 0C
+  integer, private :: iehlr0c = 0         ! 0 -> no collection for T > 0C;  1 -> turn on collection/shedding for T > 0C
   real   , private :: ehw0 = 0.5          ! constant or max assumed graupel-droplet collection efficiency
   real   , private :: erw0 = 1.0          ! constant assumed rain-droplet collection efficiency
   real   , private :: ehlw0 = 0.75        ! constant or max assumed hail-droplet collection efficiency
   real    :: ehr0 = 1.0          ! constant or max assumed graupel-rain collection efficiency
   real    :: ehlr0 = 1.0         ! constant or max assumed hail-rain collection efficiency
+  real   , private :: exwmindiam = 0.0    ! minimum diameter of droplets for riming. If set > 0, will exclude that fraction of mass/number from accretion (idea from Furtado and Field 2017 JAS but also Fierro and Mansell 2017)
   
 
   real   , private :: esilfo0 = 1.0       ! factor for LFO collection efficiency of snow for cloud ice.
@@ -315,7 +321,7 @@ MODULE module_mp_nssl_2mom
   real   , private :: esi0 = 0.1              ! linear factor in snow-ice collection efficiency
   real   , private :: ehs0 = 0.1, ehs1 = 0.1  ! graupel-snow coll. eff. parameters: ehs0*exp(ehs1*min(temcg(mgs),0.0))
                                      ! set ehs1 = 0 to get a constant value of ehs0
-  real   , private :: ess0 = 0.5, ess1 = 0.05 ! snow aggregation coefficients: ess0*exp(ess1*min(temcg(mgs),0.0))
+  real   , private :: ess0 = 1.0, ess1 = 0.05 ! snow aggregation coefficients: ess0*exp(ess1*min(temcg(mgs),0.0))
                                      ! set ess1 = 0 to get a constant value of ess0
   real   , private :: esstem1 = -25.  ! lower temperature where snow aggregation turns on
   real   , private :: esstem2 = -20.  ! higher temperature for linear ramp of ess from zero at esstem1 to formula value at esstem2
@@ -324,7 +330,7 @@ MODULE module_mp_nssl_2mom
   real   , private :: ehimax = 1.0 ! Maximum collection efficiency (graupel - ice crystal)
   real   , private :: ehsmax = 0.5 ! Maximum collection efficiency (graupel - snow)
   real   , private :: ecollmx = 0.5 ! Maximum collision efficiency for graup/hail with ice; used only for charging rates
-  integer, private :: iglcnvi = 2  ! flag for riming conversion from cloud ice to rimed ice/graupel
+  integer, private :: iglcnvi = 1  ! flag for riming conversion from cloud ice to rimed ice/graupel
   integer, private :: iglcnvs = 2  ! flag for conversion from snow to rimed ice/graupel
 
   real   , private :: rz          ! reflectivity conservation factor for graupel/rain
@@ -352,7 +358,7 @@ MODULE module_mp_nssl_2mom
   real   , private :: dshd = 1.0e-3  ! nominal diameter for drops shed from graupel/hail
 
   integer, private :: ihmlt = 2      ! 1=old melting with vmlt; 2=new melting using mean volume diam of graupel/hail
-  integer, private :: imltshddmr = 1 ! 0 (default)=mean diameter of drops produced during melting+shedding as before (using mean diameter of graupel/hail
+  integer, private :: imltshddmr = 2 ! 0 (default)=mean diameter of drops produced during melting+shedding as before (using mean diameter of graupel/hail
                             ! and max mean diameter of rain)
                             ! 1=new method where mean diameter of rain during melting is adjusted linearly downward 
                             ! toward 3 mm for large (> sheddiam) graupel and hail, to take into account shedding of 
@@ -368,6 +374,9 @@ MODULE module_mp_nssl_2mom
 
 !  integer, private :: denscale = 1  ! 1=scale num. conc. and charge by air density for advection, 0=turn off for comparison
 
+  real, private  :: qhdpvdn = -1.
+  real, private  :: qhacidn = -1.
+
   logical, private :: mixedphase = .false.   ! .false.=off, true=on to include mixed phase graupel
   integer, private :: imixedphase = 0
   logical, private :: qsdenmod = .false.     ! true = modify snow density by linear interpolation of snow and rain density
@@ -419,7 +428,7 @@ MODULE module_mp_nssl_2mom
                               ! =  0 limit crcnw when qr > 1.2*L (Cohard-Pinty 2002)
                               ! =  1 DTD version based on MY code
                               ! =  2 DTD mass-weighted version based on MY code
-                              ! =  3 Milbrandt version (from Cohard and Pinty's code
+                              ! =  3 Milbrandt version (from Cohard and Pinty code
   real, parameter :: alpharaut = 0.0 ! MY2005 for autoconversion
   real    :: cxmin = 1.e-4  ! threshold cutoff for number concentration
   real    :: zxmin = 1.e-28 ! threshold cutoff for reflectivity moment
@@ -437,7 +446,7 @@ MODULE module_mp_nssl_2mom
 
   integer, private :: isnowdens = 1   ! Option for choosing between snow density options
                              ! 1 = constant of 100 kg m^-3
-                             ! 2 = Option based on Cox
+                             ! 2 = Option based on Cox 
   
   integer, private  :: ibiggsnow   = 3 ! 1 = switch conversion over to snow for small frozen drops from Bigg freezing
                                        ! 2 = switch conversion over to snow for small frozen drops from rain-ice interaction
@@ -455,9 +464,17 @@ MODULE module_mp_nssl_2mom
                            ! =2 to test melting by temporary bins
   integer, private :: ibinhlmlr = 0  ! =1 use incomplete gammas to determine melting from larger and smaller sizes of hail, and appropriate shed drop sizes 
                             ! =2 to test melting by temporary bins
+  real, private :: snowmeltdia = 0 ! If nonzero, sets the size of rain drops from melting snow.
+  real, private :: delta_alphamlr = 0.5 ! offset from alphamax at which melting does not further collapse the shape parameter
   
   integer :: iqvsopt = 0 ! =0 use old default for tabqvs; =1 use Bolton formulation (Rogers and Yau)
 
+  real    :: maxsupersat = 1.9 ! maximum supersaturation ratio, above which a saturation adustment is done
+  
+  integer :: ihailrain = 0 ! =0 default turns off graupel/hail rain collection for T < tfr
+                           ! =1  turns on graupel/hail rain collection for T < tfr (old behavior)
+  
+
   integer, parameter :: icespheres = 0 ! turn ice spheres (frozen droplets) on (1) or off (0). NOT COMPLETE IN WRF/ARPS/CM1 CODE!
   integer, parameter :: lqmx = 30
   integer, parameter :: lt = 1
@@ -580,11 +597,42 @@ MODULE module_mp_nssl_2mom
   integer :: ipelec = 0
   integer :: isaund = 0
   logical :: idonic = .false.
+  integer, private :: elec_on_time = -1     ! time (seconds) to turn on charge separation.
+  integer, private :: elec_ramp_time = 0   ! time (interval) for linear ramp after elec_on_time 
+                                   ! (i.e., linear factor on chg sep to smoothly turn on elec)
+                                   ! full charging rate is achieved at time = elec_on_time + elec_ramp_time
   integer :: jchgs = 3  ! number of points near boundary where charging is turned off (to keep lightning from getting wonky)
   integer :: jchgn = 2
   integer :: ichge = 3
   integer :: ichgw = 2
   real    :: charging_border = 4000. ! width of no-charging zone from boundary
+  integer :: nic_noliq = 0  ! switch for NIC without riming (MST, 2006)
+  real    :: qc_noliq = 0.1 ! charge per collision (in fC) for non-riming NIC.
+  logical :: largeion = .false.   ! true: use large ion category 
+  integer :: nonigrd = 0
+  integer :: ftauopt = 1
+  real    :: rgard1  = 1.0
+  real    :: rarfac  = 1.0
+  real    :: trever = -15.0
+  real    :: cidiamin = 0.0  ! minimum crystal size for charging
+  
+  real    :: erbnd  = 0.01
+  real    :: fdgt   = 1.0
+  real    :: costhe = 0.35
+  real    :: delqnsa = -50.0e-14
+  real    :: delqxsa =  50.0e-14
+  real    :: delqnsb = -2.0e-14
+  real    :: delqxsb =  2.0e-14
+  real    :: delqnia = -50.0e-14
+  real    :: delqxia =  50.0e-14
+  real    :: scxacymax = 3000.e-12 ! Maximum charging rate magnitude (C s-1 m-3)
+
+!
+! Takahashi lookup table
+!
+      integer, parameter :: nlwc=30, ntem=31
+      real takalu(0:ntem,0:nlwc) 
+
       real, private    :: delqnw = -1.0e-10!-1.0e-12 !
       real, private    :: delqxw =  1.0e-10! 1.0e-12 !
       real :: tindmn = 233, tindmx = 298.0  ! min and max temperatures where inductive charging is allowed
@@ -693,7 +741,7 @@ MODULE module_mp_nssl_2mom
       real, parameter :: xvimn=0.523599*(2.*5.e-6)**3    ! mks  min volume = 5 micron radius
       real, parameter :: xvimx=0.523599*(2.*1.e-3)**3    ! mks  max volume = 1 mm radius (solid sphere approx)
       
-      real     :: xvdmx = -1.0 ! 3.0e-3
+      real, private   :: xvdmx = -1.0 ! 3.0e-3
       real     :: xvrmx
       parameter( xvrmn=0.523599*(80.e-6)**3, xvrmx0=0.523599*(6.e-3)**3 ) !( was 4.1887e-9 )  ! mks
       parameter( xvsmn=0.523599*(0.01e-3)**3, xvsmx=0.523599*(10.e-3)**3 ) !( was 4.1887e-9 )  ! mks
@@ -815,14 +863,18 @@ SUBROUTINE nssl_2mom_init(  &
      real    :: bxh,bxhl
 
       real    :: alp,ratio,x,y,y7
+      logical :: turn_on_ccna
      
+     IF ( present(idonictmp) ) THEN
+       idonic = idonictmp
+     ENDIF
 
-
+     turn_on_ccna = .false.
 !
 ! set some global values from namelist input
 !
 
-      ccn      = nssl_params(1)
+      ccn      = Abs( nssl_params(1) )
       alphah   = nssl_params(2)
       alphahl  = nssl_params(3)
       cnoh     = nssl_params(4)
@@ -832,6 +884,18 @@ SUBROUTINE nssl_2mom_init(  &
       rho_qh   = nssl_params(8)
       rho_qhl  = nssl_params(9)
       rho_qs   = nssl_params(10)
+      
+      IF ( Nint(nssl_params(13)) == 1 ) THEN
+      ! hack to switch CCN field to CCNA (activated ccn)
+!       invertccn = .true.
+       turn_on_ccna = .true.
+       irenuc = 7
+      
+      ENDIF
+      
+      
+      ipelec   = Nint(nssl_params(11))
+      isaund   = Nint(nssl_params(12))
 
 
       cwccn = ccn
@@ -847,7 +911,7 @@ SUBROUTINE nssl_2mom_init(  &
       ENDIF
       IF ( ihvol <= -1 .or. ihvol == 2 ) THEN
         IF ( ihvol == -1 .or. ihvol == -2 ) THEN
-        lhab = lhab - 1  ! turns off hail
+        lhab = lhab - 1  ! turns off hail 
         lhl = 0
         ehw0 = 0.75
         iehw = 2
@@ -871,15 +935,15 @@ SUBROUTINE nssl_2mom_init(  &
       temq = 163.15 + (l-1)*fqsat
       IF ( iqvsopt == 0 ) THEN
       tabqvs(l) = exp(caw*(temq-273.15)/(temq-cbw))
-      dtabqvs(l) = ((-caw*(-273.15 + temq))/(temq - cbw)**2 + &
+      dtabqvs(l) = ((-caw*(-273.15 + temq))/(temq - cbw)**2 + & 
      &                 caw/(temq - cbw))*tabqvs(l)
       ELSE
       tabqvs(l) = exp(caw*(temq-273.15)/(temq-cbw))
-      dtabqvs(l) = ((-cawbolton*(-273.15 + temq))/(temq - cbwbolton)**2 + &
+      dtabqvs(l) = ((-cawbolton*(-273.15 + temq))/(temq - cbwbolton)**2 + & 
      &                 cawbolton/(temq - cbwbolton))*tabqvs(l)
       ENDIF
       tabqis(l) = exp(cai*(temq-273.15)/(temq-cbi))
-      dtabqis(l) = ((-cai*(-273.15 + temq))/(temq - cbi)**2 + &
+      dtabqis(l) = ((-cai*(-273.15 + temq))/(temq - cbi)**2 + & 
      &                 cai/(temq - cbi))*tabqis(l)
       end do
 
@@ -956,7 +1020,7 @@ SUBROUTINE nssl_2mom_init(  &
 
       IF ( alp > 1.1 ) THEN
 !       gamxinflu(i,j,7,1) = gamxinf( alp - 1., ratio )/y
-       gamxinflu(i,j,7,1) = (gamma_sp(alp - 1.) - gamxinf( alp - 1., ratio ))/y
+       gamxinflu(i,j,7,1) = (gamma_sp(alp - 1.) - gamxinf( alp - 1., ratio ))/y 
 !       gamxinflu(i,j,8,1) = gamxinf( alp - 0.5 + 0.5*bxh, ratio )/y
        gamxinflu(i,j,8,1) = (gamma_sp(alp - 0.5 + 0.5*bxh) - gamxinf( alp - 0.5 + 0.5*bxh, ratio ))/y
 !       gamxinflu(i,j,8,2) = gamxinf( alp - 0.5 + 0.5*bxhl, ratio )/y
@@ -1097,8 +1161,41 @@ SUBROUTINE nssl_2mom_init(  &
       CALL wrf_error_fatal( 'nssl_2mom_init: Invalid value of ipctmp' )
     ENDIF
 
+! if charging, then add them
+    IF ( ipelec > 0 .or. idonic ) THEN
+      lscw  = ltmp+1
+      lscr  = ltmp+2
+      lsci  = ltmp+3
+      lscs  = ltmp+4
+      lsch  = ltmp+5
+      ltmp = lsch
+      IF ( lhl > 1 ) THEN
+       ltmp = ltmp + 1
+       lschl = ltmp
+      ENDIF
+
+      denscale(lscw:ltmp) = 1
+
+      lscpi = ltmp+1
+      lscni = ltmp+2
+      ltmp = lscni
+    ENDIF
+!    write(0,*) 'lscw,etc. = ',lscw,lscr,lsci,lscs,lsch,lschl
+
+      IF ( nonigrd .eq. -1 .and. ipelec .gt. 0 ) THEN
+       open(unit=90,file='takahashi.txt',form='formatted')
+       DO i=nlwc,0,-1
+        read(90,*) (takalu(j,i), j=0,31)
+       END DO
+       close(90)
+      END IF
+
 
     
+      IF ( turn_on_ccna ) THEN
+        ltmp = ltmp + 1
+        lccna = ltmp
+      ENDIF
       na = ltmp
       
       ln(lc) = lnc
@@ -1231,7 +1328,7 @@ SUBROUTINE nssl_2mom_init(  &
         ibinhlmlr = 0
       ENDIF
 
-      IF ( ipconc > 5 .and. (ibinhmlr == 0 .and. ibinhlmlr == 0 ) ) THEN
+      IF ( ipconc > 5 .and. (ibinhmlr == 0 .and. ibinhlmlr == 0 ) ) THEN 
         imltshddmr = Min(1, imltshddmr)
       ENDIF
 
@@ -1336,6 +1433,9 @@ SUBROUTINE nssl_2mom_init(  &
          ELSE
            xvhmx = 0.523599*(dhmx)**3
          ENDIF
+         
+         IF ( qhdpvdn < 0. ) qhdpvdn = xdnmn(lh)
+         IF ( qhacidn < 0. ) qhacidn = xdnmn(lh)
 
 ! load max/min diameters
       xvmn(lc) = xvcmn
@@ -1382,7 +1482,7 @@ SUBROUTINE nssl_2mom_init(  &
 !       ELSE
         ventrn =  Gamma_sp(rnu + 1.5 + br/6.)/(Gamma_sp(rnu + 1.)*(rnu + 1.)**((1.+br)/6. + 1./3.) ) ! adapted from Wisner et al. 1972; for second term in rwvent
 !        ventr = Gamma_sp(rnu + 4./3.)/((rnu + 1.)**(1./3.)*Gamma_sp(rnu + 1.)) ! Ziegler 1985, still use for first term in rwvent
-!        ventr  = Gamma_sp(rnu + 4./3.)/Gamma_sp(rnu + 1.)
+!        ventr  = Gamma_sp(rnu + 4./3.)/Gamma_sp(rnu + 1.) 
 !       ENDIF
       ELSE ! imurain == 1
 !       IF ( iferwisventr == 1 ) THEN
@@ -1392,7 +1492,7 @@ SUBROUTINE nssl_2mom_init(  &
 !       ENDIF
       ENDIF
       ventc   = Gamma_sp(cnu + 4./3.)/(cnu + 1.)**(1./3.)/Gamma_sp(cnu + 1.)
-      c1sw = Gamma_sp(snu + 4./3.)*(snu + 1.0)**(-1./3.)/gamma_sp(snu + 1.0)
+      c1sw = Gamma_sp(snu + 4./3.)*(snu + 1.0)**(-1./3.)/gamma_sp(snu + 1.0) 
 
   ! set threshold mixing ratios
 
@@ -1497,7 +1597,7 @@ END SUBROUTINE nssl_2mom_init
 ! #####################################################################
 
 SUBROUTINE nssl_2mom_driver(qv, qc, qr, qi, qs, qh, qhl, ccw, crw, cci, csw, chw, chl,  &
-                              cn, vhw, vhl,                                             &
+                              cn, vhw, vhl, cna, f_cn, f_cna,                           &
                               zrw, zhw, zhl,                                            &
                               qsw, qhw, qhlw,                                           &
                               th, pii, p, w, dn, dz, dtp, itimestep,                    &
@@ -1537,8 +1637,22 @@ SUBROUTINE nssl_2mom_driver(qv, qc, qr, qi, qs, qh, qhl, ccw, crw, cci, csw, chw
                               its,ite, jts,jte, kts,kte)                                   ! tile dims
 
 
+
+#if ( defined(DM_PARALLEL)  &&   ! defined(STUBMPI) )
+#define MPI
+      USE module_dm, ONLY : &
+         local_communicator, mytask
+! keep a spacing line here to keep Apple cpp from adding a space in front of the endif
+#endif
+
       implicit none
 
+#if ( defined(DM_PARALLEL)  &&   ! defined(STUBMPI) ) || defined(MPI)
+      INCLUDE 'mpif.h'
+#else
+      integer :: mytask = 0
+#endif
+
  !Subroutine arguments:
 
       integer, intent(in)::                                                             &
@@ -1551,7 +1665,7 @@ SUBROUTINE nssl_2mom_driver(qv, qc, qr, qi, qs, qh, qhl, ccw, crw, cci, csw, chw
                               zrw, zhw, zhl,                                            &
                               qsw, qhw, qhlw,                                           &
                             qi,qhl,ccw,crw,cci,csw,chw,chl,vhw,vhl
-      real, dimension(ims:ime, kms:kme, jms:jme), optional, intent(inout):: dbz, vzf, cn
+      real, dimension(ims:ime, kms:kme, jms:jme), optional, intent(inout):: dbz, vzf, cn, cna
       real, dimension(ims:ime, jms:jme), optional, intent(inout):: compdbz
       real, dimension(ims:ime, jms:jme), optional, intent(inout):: rscghis_2d
 !      real, dimension(ims:ime, kms:kme, jms:jme), optional, intent(inout)::rscghis_3d
@@ -1591,7 +1705,7 @@ SUBROUTINE nssl_2mom_driver(qv, qc, qr, qi, qs, qh, qhl, ccw, crw, cci, csw, chw
       real, optional, intent(in) :: dx,dy
       real, intent(in)::    dtp
       integer, intent(in):: itimestep !, ccntype
-      logical, optional, intent(in) :: diagflag
+      logical, optional, intent(in) :: diagflag, f_cna, f_cn
       integer, optional, intent(in) :: ipelectmp
 
   LOGICAL, INTENT(IN), OPTIONAL ::    nssl_progn  ! wrf-chem
@@ -1614,6 +1728,7 @@ SUBROUTINE nssl_2mom_driver(qv, qc, qr, qi, qs, qh, qhl, ccw, crw, cci, csw, chw
 ! local variables
 !
      real, dimension(its:ite, 1, kts:kte) :: elec2 ! ez = elecsave slab
+     real, dimension(its:ite, 1, kts:kte) :: sciona2d
 !     real, dimension(its:ite, 1, kts:kte,2) :: scion2 ! 1=- , 2=+
      real, dimension(its:ite, kts:kte) :: rainprod2d, evapprod2d,tke2d,qrcuten2d, qscuten2d, qicuten2d,qccuten2d
      real, dimension(its:ite, 1, kts:kte, na) :: an, ancuten
@@ -1630,7 +1745,7 @@ SUBROUTINE nssl_2mom_driver(qv, qc, qr, qi, qs, qh, qhl, ccw, crw, cci, csw, chw
      double precision :: dp1
      integer :: jye, lnb
      integer :: imx,kmx
-     real    :: dbzmx
+     real    :: dbzmx,refl
      integer :: vzflag0 = 0
      logical :: makediag
       real, parameter :: cnin20 = 1.0e3
@@ -1639,12 +1754,27 @@ SUBROUTINE nssl_2mom_driver(qv, qc, qr, qi, qs, qh, qhl, ccw, crw, cci, csw, chw
       real, parameter :: cnin2a = 12.96
       real, parameter :: cnin2b = 0.639
 
+      double precision :: chgneg1,chgpos1,chgneg2,chgpos2,chgneg3,chgpos3
+      double precision :: chgiona1,chgiona2,chgiona3,sctot3,scwtot,scrtot,scitot,scstot,schtot,schltot
+      double precision :: scwmax,scrmax,scimax,scsmax,schmax,schlmax
+      double precision :: scwmin,scrmin,scimin,scsmin,schmin,schlmin
       real :: tmp,dv
 
       double precision :: dt1,dt2
       double precision :: timesed,timesed1,timesed2,timesed3, timegs, timenucond, timedbz,zmaxsed
       double precision :: timevtcalc,timesetvt
       
+      logical :: f_cnatmp
+      
+#ifdef MPI
+
+#if defined(MPI) 
+      integer, parameter :: ntot = 50
+      double precision  mpitotindp(ntot), mpitotoutdp(ntot)
+      INTEGER :: mpi_error_code = 1
+#endif
+#endif
+
 
 ! -------------------------------------------------------------------
 
@@ -1654,6 +1784,13 @@ SUBROUTINE nssl_2mom_driver(qv, qc, qr, qi, qs, qh, qhl, ccw, crw, cci, csw, chw
 
      flag_qndrop = .false.
      IF ( PRESENT ( nssl_progn ) ) flag_qndrop = nssl_progn
+
+     IF ( present( f_cna ) ) THEN
+       f_cnatmp = f_cna
+     ELSE 
+       f_cnatmp = .false.
+     ENDIF
+   
        
      IF ( present( vzf ) ) vzflag0 = 1
      
@@ -1672,6 +1809,25 @@ SUBROUTINE nssl_2mom_driver(qv, qc, qr, qi, qs, qh, qhl, ccw, crw, cci, csw, chw
 !       ENDDO
 !       ENDIF
 
+     IF ( cleardiag ) THEN
+!       IF ( present( rscghis_3d ) ) THEN
+!       DO jy = jts,jte
+!         DO kz = kts,kte
+!           DO ix = its,ite
+!             rscghis_3d(ix,kz,jy) = 0.0
+!           ENDDO
+!         ENDDO
+!       ENDDO
+!       ENDIF
+
+       IF ( present( rscghis_2d ) ) THEN
+       DO jy = jts,jte
+         DO ix = its,ite
+            rscghis_2d(ix,jy) = 0.0
+         ENDDO
+       ENDDO
+       ENDIF
+     ENDIF
      
      makediag = .true.
      IF ( present( diagflag ) ) THEN
@@ -1705,7 +1861,7 @@ SUBROUTINE nssl_2mom_driver(qv, qc, qr, qi, qs, qh, qhl, ccw, crw, cci, csw, chw
      ENDIF
 
      IF ( itimestep == 1 .and. invertccn .and.  present( cn ) ) THEN
-     ! this is not needed for WRF 3.8 and later because it is done in physics_init,
+     ! this is not needed for WRF 3.8 and later because it is done in physics_init, 
      ! but kept for backwards compatibility with earlier versions
         DO jy = jts,jte
          DO kz = kts,kte
@@ -1716,7 +1872,7 @@ SUBROUTINE nssl_2mom_driver(qv, qc, qr, qi, qs, qh, qhl, ccw, crw, cci, csw, chw
         ENDDO
       ENDIF
      
-      IF ( invertccn .and.  present( cn ) ) THEN ! hack for WRF to convert activated ccn to unactivated, then don't have to 
+      IF ( invertccn .and.  present( cn ) ) THEN ! hack for WRF to convert activated ccn to unactivated, then do not have to 
                                               ! worry about initial and boundary conditions - they are zero
         DO jy = jts,jte
          DO kz = kts,kte
@@ -1773,6 +1929,37 @@ SUBROUTINE nssl_2mom_driver(qv, qc, qr, qi, qs, qh, qhl, ccw, crw, cci, csw, chw
       timegs = 0.0d0
       timenucond = 0.0d0
 
+     chgiona1 = 0.0d0
+     chgiona2 = 0.0d0
+     chgiona3 = 0.0d0
+     chgneg1 = 0.0
+     chgpos1 = 0.0
+     chgneg2 = 0.0
+     chgpos2 = 0.0
+     chgneg3 = 0.0
+     chgpos3 = 0.0
+     sctot3  = 0.0d0
+     scwtot  = 0.0d0
+     scrtot  = 0.0d0
+     scitot  = 0.0d0
+     scstot  = 0.0d0
+     schtot  = 0.0d0
+     schltot  = 0.0d0
+
+     scwmax  = 0.0d0
+     scrmax  = 0.0d0
+     scimax  = 0.0d0
+     scsmax  = 0.0d0
+     schmax  = 0.0d0
+     schlmax  = 0.0d0
+
+     scwmin  = 0.0d0
+     scrmin  = 0.0d0
+     scimin  = 0.0d0
+     scsmin  = 0.0d0
+     schmin  = 0.0d0
+     schlmin  = 0.0d0
+
 
 !     write(0,*) 'N2M: jy loop 1, lhl,na = ',lhl,na,present(qhl)
 
@@ -1812,9 +1999,21 @@ SUBROUTINE nssl_2mom_driver(qv, qc, qr, qi, qs, qh, qhl, ccw, crw, cci, csw, chw
            IF ( present( cn ) ) THEN
             an(ix,1,kz,lccn) = cn(ix,kz,jy)
            ELSE
-            an(ix,1,kz,lccn) = qccn - ccw(ix,kz,jy)
+            IF ( lccna == 0 .and. ( f_cnatmp .eqv. .false. ) ) THEN
+              an(ix,1,kz,lccn) = qccn - ccw(ix,kz,jy)
+           ELSE
+              an(ix,1,kz,lccn) = qccn 
            ENDIF
+           
+           ENDIF
+          ENDIF
+
+          IF ( lccna > 1 ) THEN
+            IF ( present( cna ) .and. f_cnatmp ) THEN
+              an(ix,1,kz,lccna) = cna(ix,kz,jy)
+            ENDIF
           ENDIF
+
           IF ( ipconc >= 5 ) THEN
              an(ix,1,kz,lnc)  = ccw(ix,kz,jy)
           IF ( constccw > 0.0 ) THEN
@@ -1836,6 +2035,44 @@ SUBROUTINE nssl_2mom_driver(qv, qc, qr, qi, qs, qh, qhl, ccw, crw, cci, csw, chw
           
 
 
+!     space charge
+          IF ( present(scw) .and. ipelec > 0 ) THEN
+
+          an(ix,1,kz,lscw)   = scw(ix,kz,jy)
+          an(ix,1,kz,lscr)   = scr(ix,kz,jy)
+          an(ix,1,kz,lsci)   = sci(ix,kz,jy)
+          an(ix,1,kz,lscs)   = scs(ix,kz,jy)
+          an(ix,1,kz,lsch)   = sch(ix,kz,jy)
+          IF ( lhl > 1 ) an(ix,1,kz,lschl)   = schl(ix,kz,jy)
+          
+          ! Fake ions for now -- will need to change this if real ions ever get used in WRF
+          ! convert net ion density to positive or negative ions, so that underlying code is
+          ! still ion-friendly
+!          scion2(ix,1,kz,1) = 0.0
+!          scion2(ix,1,kz,2) = 0.0
+             an(ix,1,kz,lscpi) = Max(0.0, sciona(ix,kz,jy))*eci*dn(ix,kz,jy)
+             an(ix,1,kz,lscni) = -Min(0.0,sciona(ix,kz,jy))*eci*dn(ix,kz,jy)
+          sciona2d(ix,1,kz)   = sciona(ix,kz,jy)*dn(ix,kz,jy)
+          
+          tmp =  dn(ix,kz,jy)*(an(ix,1,kz,lscw)+an(ix,1,kz,lscr)+an(ix,1,kz,lsci)+ &
+     &                         an(ix,1,kz,lscs)+an(ix,1,kz,lsch)+an(ix,1,kz,lschl)+ &
+     &                         sciona(ix,kz,jy) )*dx*dy*dz(ix,kz,jy)
+          chgneg1 = chgneg1 + Min(0.0, tmp)
+          chgpos1 = chgpos1 + Max(0.0, tmp)
+!          chgiona1 = chgiona1 + sciona(ix,kz,jy)*dn(ix,kz,jy)*dx*dy*dz(ix,kz,jy)
+          chgiona1 = chgiona1 + (an(ix,1,kz,lscpi)-an(ix,1,kz,lscni))*ec*dn(ix,kz,jy)*dx*dy*dz(ix,kz,jy)
+
+          
+
+!          IF ( present(elec) .and. ipelec > 1) THEN
+          IF (  ipelec > 1) THEN
+
+          elec2(ix,1,kz)   =  elec(ix,kz,jy) ! Ez here =elecsave
+!         sctot is only passed out  - not in nssl 2 mom
+
+          ENDIF
+    
+          ENDIF ! scw
 
           
           t0(ix,1,kz) = th(ix,kz,jy)*pii(ix,kz,jy) ! temperature (Kelvin)
@@ -1900,7 +2137,7 @@ SUBROUTINE nssl_2mom_driver(qv, qc, qr, qi, qs, qh, qhl, ccw, crw, cci, csw, chw
       ENDIF
 
       ELSEIF ( icenucopt == 2 ) THEN ! Thompson/Cooper; Note Thompson 2004 has constants of
-                                     ! 0.005 and 0.304 because the line function was estimated from Cooper's plot
+                                     ! 0.005 and 0.304 because the line function was estimated from Cooper plot
                                      ! Here, the fit line values from Cooper 1986 are converted. Very little difference 
                                      ! in practice
       
@@ -1959,17 +2196,17 @@ SUBROUTINE nssl_2mom_driver(qv, qc, qr, qi, qs, qh, qhl, ccw, crw, cci, csw, chw
          call calcnfromq(nx,ny,nz,an,na,nor,nor,dn1)
        ENDIF
 
-      IF ( present(cu_used) .and.         &
+      IF (  present(cu_used) .and.         &
            ( present( qrcuten ) .or. present( qscuten ) .or.  &
              present( qicuten ) .or. present( qccuten ) ) ) THEN
 
        IF ( cu_used == 1 ) THEN
        DO kz = kts,kte
         DO ix = its,ite
-!         IF ( present( qrcuten ) ) qrcuten2d(ix,kz)   = qrcuten(ix,kz,jy)
-!         IF ( present( qscuten ) ) qscuten2d(ix,kz)   = qscuten(ix,kz,jy)
-!         IF ( present( qicuten ) ) qicuten2d(ix,kz)   = qicuten(ix,kz,jy)
-!         IF ( present( qccuten ) ) qccuten2d(ix,kz)   = qccuten(ix,kz,jy)
+!         IF ( present( qrcuten ) ) qrcuten2d(ix,kz)   = qrcuten(ix,kz,jy)/mu(ix,jy)
+!         IF ( present( qscuten ) ) qscuten2d(ix,kz)   = qscuten(ix,kz,jy)/mu(ix,jy)
+!         IF ( present( qicuten ) ) qicuten2d(ix,kz)   = qicuten(ix,kz,jy)/mu(ix,jy)
+!         IF ( present( qccuten ) ) qccuten2d(ix,kz)   = qccuten(ix,kz,jy)/mu(ix,jy)
 
          IF ( present( qrcuten ) ) ancuten(ix,1,kz,lr) = dtp*qrcuten(ix,kz,jy)
          IF ( present( qscuten ) ) ancuten(ix,1,kz,ls) = dtp*qscuten(ix,kz,jy)
@@ -1981,14 +2218,17 @@ SUBROUTINE nssl_2mom_driver(qv, qc, qr, qi, qs, qh, qhl, ccw, crw, cci, csw, chw
        
          call calcnfromcuten(nx,ny,nz,ancuten,an,na,nor,nor,dn1)
 
-!      DO kz = kts,kte
-!       DO ix = its,ite
-!           an(ix,1,kz,lnr)  = an(ix,1,kz,lnr) + ancuten(ix,1,kz,lnr)
-!           an(ix,1,kz,lns)  = an(ix,1,kz,lns) + ancuten(ix,1,kz,lns)
-!           an(ix,1,kz,lni)  = an(ix,1,kz,lni) + ancuten(ix,1,kz,lni)
-!           an(ix,1,kz,lnc)  = an(ix,1,kz,lnc) + ancuten(ix,1,kz,lnc)
-!       ENDDO
-!      ENDDO
+       DO kz = kts,kte
+        DO ix = its,ite
+
+!           an(ix,1,kz,lnr)  = an(ix,1,kz,lnr) + ancuten(ix,1,kz,lnr) 
+!           an(ix,1,kz,lns)  = an(ix,1,kz,lns) + ancuten(ix,1,kz,lns) 
+!           an(ix,1,kz,lni)  = an(ix,1,kz,lni) + ancuten(ix,1,kz,lni) 
+!           an(ix,1,kz,lnc)  = an(ix,1,kz,lnc) + ancuten(ix,1,kz,lnc) 
+
+         
+        ENDDO
+       ENDDO
        
        ENDIF
        
@@ -2053,6 +2293,26 @@ SUBROUTINE nssl_2mom_driver(qv, qc, qr, qi, qs, qh, qhl, ccw, crw, cci, csw, chw
        
       ENDIF ! .false.
  
+      IF ( present(scw) .and. ipelec >= 1 ) THEN
+       DO kz = kts,kte
+        DO ix = its,ite
+        IF ( lhl > 1 ) THEN
+          tmp =   (an(ix,1,kz,lscw)+an(ix,1,kz,lscr)+an(ix,1,kz,lsci)+ &
+     &             an(ix,1,kz,lscs)+an(ix,1,kz,lsch)+an(ix,1,kz,lschl)+ &
+     &             (an(ix,1,kz,lscpi)-an(ix,1,kz,lscni))*ec )*dx*dy*dz(ix,kz,jy)
+        ELSE
+          tmp =   (an(ix,1,kz,lscw)+an(ix,1,kz,lscr)+an(ix,1,kz,lsci)+ &
+     &             an(ix,1,kz,lscs)+an(ix,1,kz,lsch)+ &
+     &             (an(ix,1,kz,lscpi)-an(ix,1,kz,lscni))*ec )*dx*dy*dz(ix,kz,jy)
+        ENDIF
+          chgneg2 = chgneg2 + Min(0.0, tmp)
+          chgpos2 = chgpos2 + Max(0.0, tmp)
+!          chgiona2 = chgiona2 + sciona(ix,kz,jy)*dn(ix,kz,jy)*dx*dy*dz(ix,kz,jy)
+          chgiona2 = chgiona2 + (an(ix,1,kz,lscpi)-an(ix,1,kz,lscni))*ec*dn(ix,kz,jy)*dx*dy*dz(ix,kz,jy)
+        ENDDO
+       ENDDO
+      ENDIF
+
       IF ( isedonly /= 1 ) THEN
    ! call nssl_2mom_gs: main gather-scatter routine to calculate microphysics
 
@@ -2082,6 +2342,34 @@ SUBROUTINE nssl_2mom_driver(qv, qc, qr, qi, qs, qh, qhl, ccw, crw, cci, csw, chw
 
 
 
+   IF ( present( noninduc ) .and. ipelec >= 1 ) THEN
+
+!       rscghis_2d(:,jy) = 0.0
+
+       t9(:,1,1) = 0.0
+
+       DO kz = kts,kte
+        DO ix = its,ite
+!       copy 2D slab to 3D into the big Y loop
+!         rscghis_3d(ix,kz,jy) = (t2(ix,1,kz) + t3(ix,1,kz) + t6(ix,1,kz) + t8(ix,1,kz))*1.e9
+!         rscghis_3d(ix,kz,jy) = t3(ix,1,kz)
+          induc(ix,kz,jy)  = t5(ix,1,kz)
+          noninduc(ix,kz,jy) = (t2(ix,1,kz) + t3(ix,1,kz) + t6(ix,1,kz) + t8(ix,1,kz))
+          IF ( present( rscghis_2d ) ) THEN
+!            rscghis_2d(ix,jy) = rscghis_2d(ix,jy) + Abs( t5(ix,1,kz) )*dz2d(ix,1,kz) 
+             t9(ix,1,1) = t9(ix,1,1) + Abs( noninduc(ix,kz,jy) )*dz(ix,kz,jy) 
+          ENDIF
+        ENDDO
+       ENDDO
+       
+       IF ( present( rscghis_2d ) ) THEN
+       DO ix = its,ite
+         rscghis_2d(ix,jy) = Max( rscghis_2d(ix,jy), t9(ix,1,1) )
+       ENDDO
+       ENDIF
+
+   ENDIF
+
 
    ENDIF ! isedonly /= 1
    
@@ -2100,6 +2388,16 @@ SUBROUTINE nssl_2mom_driver(qv, qc, qr, qi, qs, qh, qhl, ccw, crw, cci, csw, chw
 
    ENDIF
 
+ IF ( present( sciona ) .and. lnh > 1 .and. ipelec > 0) THEN
+ ! attach ions
+   CALL SCIONATT    &
+     &  (nx,ny,nz,na,jy &
+     &  ,nor,nor &
+     &  ,dtp,dz2d &
+     &  ,an,dn1,t77 &
+     &  ,pn,wn &
+     &  ,dbz2d)
+  ENDIF
 
 
 ! compute diagnostic S-band reflectivity if needed
@@ -2117,6 +2415,12 @@ SUBROUTINE nssl_2mom_driver(qv, qc, qr, qi, qs, qh, qhl, ccw, crw, cci, csw, chw
          dbz(ix,kz,jy) = dbz2d(ix,1,kz)
          IF ( present( vzf ) ) THEN
            vzf(ix,kz,jy) = vzf2d(ix,1,kz)
+           IF ( dbz2d(ix,1,kz) <= 0.0 ) THEN
+             vzf(ix,kz,jy) = 0.0
+           ELSEIF ( dbz2d(ix,1,kz) <= 15.0 ) THEN
+             refl = 10**(0.1*dbz2d(ix,1,kz))
+             vzf(ix,kz,jy) = Min( vzf2d(ix,1,kz), 2.6 * Max(0.0,refl)**0.107 * (1.2/dn1(ix,1,kz))**0.4 )
+           ENDIF
          ENDIF
           IF ( present( compdbz ) ) THEN
             compdbz(ix,jy) = Max( compdbz(ix,jy), dbz2d(ix,1,kz) )
@@ -2191,6 +2495,11 @@ SUBROUTINE nssl_2mom_driver(qv, qc, qr, qi, qs, qh, qhl, ccw, crw, cci, csw, chw
          IF ( present( cn ) .and. lccn > 1 .and. .not. flag_qndrop) THEN
            cn(ix,kz,jy) = an(ix,1,kz,lccn)
          ENDIF
+         IF ( lccna > 1 ) THEN
+           IF ( present( cna ) .and. f_cnatmp ) THEN
+              cna(ix,kz,jy) = an(ix,1,kz,lccna)
+           ENDIF
+         ENDIF
          IF ( ipconc >= 5 ) THEN
 
           ccw(ix,kz,jy) = an(ix,1,kz,lnc)
@@ -2203,6 +2512,77 @@ SUBROUTINE nssl_2mom_driver(qv, qc, qr, qi, qs, qh, qhl, ccw, crw, cci, csw, chw
 
 
 
+         IF ( present(scw) .and. ipelec > 0 .and. lscw > 1 ) THEN !{
+
+         sciona(ix,kz,jy) = (an(ix,1,kz,lscpi) - an(ix,1,kz,lscni))*ec/dn(ix,kz,jy)
+!         sciona(ix,kz,jy) = (scion2(ix,1,kz,1) - scion2(ix,1,kz,2))*ec/dn(ix,kz,jy)
+!         sciona(ix,kz,jy) = sciona(ix,kz,jy)/dn(ix,kz,jy)
+
+         scw(ix,kz,jy)  = an(ix,1,kz,lscw)
+         scr(ix,kz,jy)  = an(ix,1,kz,lscr)
+         sci(ix,kz,jy)  = an(ix,1,kz,lsci)
+         scs(ix,kz,jy)  = an(ix,1,kz,lscs)
+         sch(ix,kz,jy)  = an(ix,1,kz,lsch)
+         sctot(ix,kz,jy)  = dn(ix,kz,jy)*(scw(ix,kz,jy)+scr(ix,kz,jy)+sci(ix,kz,jy)+scs(ix,kz,jy) &
+      &                     + sch(ix,kz,jy)+sciona(ix,kz,jy) ) ! to get C/m3 for RHS calc later on
+         IF ( lhl > 1 ) THEN
+         schl(ix,kz,jy)  = an(ix,1,kz,lschl)
+         sctot(ix,kz,jy)  = sctot(ix,kz,jy)+dn(ix,kz,jy)*schl(ix,kz,jy)
+        
+         ENDIF
+
+         IF ( .not. ( noninduc(ix,kz,jy) > -1.e-3 .and. noninduc(ix,kz,jy) < 1.e-3 ) ) THEN
+           write(0,*) 'problem with noninduc! ix,jy,kz,noninduc = ',ix,jy,kz,noninduc(ix,kz,jy)
+           STOP
+         ENDIF
+
+         IF ( .not. ( induc(ix,kz,jy) > -1.e-3 .and. induc(ix,kz,jy) < 1.e-3 ) ) THEN
+           write(0,*) 'problem with induc! ix,jy,kz,induc = ',ix,jy,kz,induc(ix,kz,jy),t5(ix,1,kz)
+           STOP
+         ENDIF
+
+
+          tmp =  dn(ix,kz,jy)*(an(ix,1,kz,lscw)+an(ix,1,kz,lscr)+an(ix,1,kz,lsci)+ &
+     &                         an(ix,1,kz,lscs)+an(ix,1,kz,lsch)+an(ix,1,kz,lschl)+sciona(ix,kz,jy) )*dx*dy*dz(ix,kz,jy)
+          chgneg3 = chgneg3 + Min(0.0, tmp)
+          chgpos3 = chgpos3 + Max(0.0, tmp)
+          chgiona3 = chgiona3 + sciona(ix,kz,jy)*dn(ix,kz,jy)*dx*dy*dz(ix,kz,jy)
+
+         IF ( present(elec) .and. ipelec > 1) THEN
+
+         scion(ix,kz,jy,1)  = an(ix,1,kz,lscpi) ! scion2(ix,1,kz,1)
+         scion(ix,kz,jy,2)  = an(ix,1,kz,lscni) ! scion2(ix,1,kz,2)
+
+         ENDIF
+
+         
+         dv = dn(ix,kz,jy)*dx*dy*dz(ix,kz,jy)
+
+         IF ( present(elec) ) THEN
+           sctot3 = sctot3 + sctot(ix,kz,jy)*dx*dy*dz(ix,kz,jy)
+           scwtot  = scwtot + scw(ix,kz,jy)*dv
+           scrtot  = scrtot + scr(ix,kz,jy)*dv
+           scitot  = scitot + sci(ix,kz,jy)*dv
+           scstot  = scstot + scs(ix,kz,jy)*dv
+           schtot  = schtot + sch(ix,kz,jy)*dv
+           schltot = schltot + schl(ix,kz,jy)*dv
+           
+           scwmax = Max( scwmax, scw(ix,kz,jy) )
+           scrmax = Max( scrmax, scr(ix,kz,jy) )
+           scimax = Max( scimax, sci(ix,kz,jy) )
+           scsmax = Max( scsmax, scs(ix,kz,jy) )
+           schmax = Max( schmax, sch(ix,kz,jy) )
+           IF ( lhl > 1 ) schlmax= Max(schlmax, schl(ix,kz,jy) )
+
+           scwmin = Min( scwmin, scw(ix,kz,jy) )
+           scrmin = Min( scrmin, scr(ix,kz,jy) )
+           scimin = Min( scimin, sci(ix,kz,jy) )
+           scsmin = Min( scsmin, scs(ix,kz,jy) )
+           schmin = Min( schmin, sch(ix,kz,jy) )
+           IF ( lhl > 1 ) schlmin= Min(schlmin, schl(ix,kz,jy) )
+           
+         ENDIF
+         ENDIF !}
 
          IF ( lvh > 0 )  vhw(ix,kz,jy) = an(ix,1,kz,lvh)
          IF ( lvhl > 0 .and. present( vhl ) ) vhl(ix,kz,jy) = an(ix,1,kz,lvhl)
@@ -2230,6 +2610,101 @@ SUBROUTINE nssl_2mom_driver(qv, qc, qr, qi, qs, qh, qhl, ccw, crw, cci, csw, chw
 
 
 
+     IF ( present( scw ) ) THEN
+! #ifdef MPI
+#ifdef DM_PARALLEL
+       mpitotindp(1)  = chgpos1
+       mpitotindp(2)  = chgneg1
+       mpitotindp(3)  = chgpos2
+       mpitotindp(4)  = chgneg2
+       mpitotindp(5)  = chgpos3
+       mpitotindp(6)  = chgneg3
+       mpitotindp(7)  = chgiona1
+       mpitotindp(8)  = chgiona2
+       mpitotindp(9)  = chgiona3
+       mpitotindp(10)  = sctot3
+       mpitotindp(11)  = scwtot 
+       mpitotindp(12)  = scrtot 
+       mpitotindp(13)  = scitot 
+       mpitotindp(14)  = scstot 
+       mpitotindp(15)  = schtot 
+       mpitotindp(16)  = schltot
+
+
+
+
+
+      CALL MPI_Reduce(mpitotindp, mpitotoutdp, 16, MPI_DOUBLE_PRECISION, MPI_SUM, 0, local_communicator, mpi_error_code)
+
+       IF ( mytask == 0 ) THEN
+       chgpos1 = mpitotoutdp(1)  
+       chgneg1 = mpitotoutdp(2)  
+       chgpos2 = mpitotoutdp(3)  
+       chgneg2 = mpitotoutdp(4)  
+       chgpos3 = mpitotoutdp(5)  
+       chgneg3 = mpitotoutdp(6)  
+       chgiona1 = mpitotoutdp(7)  
+       chgiona2 = mpitotoutdp(8)  
+       chgiona3 = mpitotoutdp(9)  
+       sctot3   = mpitotoutdp(10)  
+       scwtot  = mpitotoutdp(11)  
+       scrtot  = mpitotoutdp(12)  
+       scitot  = mpitotoutdp(13)  
+       scstot  = mpitotoutdp(14)  
+       schtot  = mpitotoutdp(15)  
+       schltot = mpitotoutdp(16)  
+       ENDIF
+
+       mpitotindp(1)  = scwmax 
+       mpitotindp(2)  = scrmax 
+       mpitotindp(3)  = scimax 
+       mpitotindp(4)  = scsmax 
+       mpitotindp(5)  = schmax 
+       mpitotindp(6)  = schlmax
+       mpitotindp(7)  = -scwmin 
+       mpitotindp(8)  = -scrmin 
+       mpitotindp(9)  = -scimin 
+       mpitotindp(10) = -scsmin 
+       mpitotindp(11) = -schmin 
+       mpitotindp(12) = -schlmin
+
+      CALL MPI_Reduce(mpitotindp, mpitotoutdp, 16, MPI_DOUBLE_PRECISION, MPI_MAX, 0, local_communicator, mpi_error_code)
+
+       IF ( mytask == 0 ) THEN
+       scwmax  = mpitotoutdp(1)  
+       scrmax  = mpitotoutdp(2)  
+       scimax  = mpitotoutdp(3)  
+       scsmax  = mpitotoutdp(4)  
+       schmax  = mpitotoutdp(5)  
+       schlmax = mpitotoutdp(6)  
+       scwmin  = -mpitotoutdp(7)  
+       scrmin  = -mpitotoutdp(8)  
+       scimin  = -mpitotoutdp(9)  
+       scsmin  = -mpitotoutdp(10)  
+       schmin  = -mpitotoutdp(11)  
+       schlmin = -mpitotoutdp(12)  
+       ENDIF
+
+
+         IF ( present(scw) .and. ipelec > 0 .and. mytask == 0 ) THEN !{
+!#else
+#else
+         IF ( present(scw) .and. ipelec > 0 ) THEN !{
+! #endif
+#endif
+           write(0,*) 'pos/neg/tot 1 = ',chgpos1,chgneg1,chgpos1+chgneg1
+           write(0,*) 'pos/neg/tot 2 = ',chgpos2,chgneg2,chgpos2+chgneg2
+           write(0,*) 'pos/neg/tot 3 = ',chgpos3,chgneg3,chgpos3+chgneg3
+           write(0,*) 'chgiona1/2/3 = ',chgiona1,chgiona2,chgiona3
+           write(0,*) 'sctot3 = ',sctot3
+           write(0,*) 'scwtot,max,min  = ',scwtot, scwmax, scwmin 
+           write(0,*) 'scrtot,max,min  = ',scrtot, scrmax, scrmin 
+           write(0,*) 'scitot,max,min  = ',scitot, scimax, scimin 
+           write(0,*) 'scstot,max,min  = ',scstot, scsmax, scsmin 
+           write(0,*) 'schtot,max,min  = ',schtot, schmax, schmin 
+           write(0,*) 'schltot,max,min = ',schltot,schlmax,schlmin
+         ENDIF
+       ENDIF
 
 
   RETURN
@@ -2340,7 +2815,7 @@ double precision function GAMXINFDP(A1,X1)
 !       Input :  a   --- Parameter ( a < 170 )
 !                x   --- Argument 
 !       Output:  GIM --- Gamma(a,x) t=x,Infinity
-!       Routine called: GAMMA for computing Ahat(x)
+!       Routine called: GAMMA for computing gamma_dp(x)
 !       ===================================================
 
 !        IMPLICIT DOUBLE PRECISION (A-H,O-Z)
@@ -3077,6 +3552,14 @@ subroutine sediment1d(dtp,nx,ny,nz,an,na,nor,norz,xfall,dn,dz3d,dz3dinv, &
         ENDIF
       ENDIF
 
+! charge
+
+      IF ( ipelec > 0 ) THEN
+        IF ( lsc(il) .gt. 1 ) THEN
+         call fallout1d(nx,ny,nz,nor,na,dtptmp,dtfrac,jgs,xvt(1,1,1,il), &
+     &              an,db1,lsc(il),0,xfall,dtz1,ix)
+        ENDIF
+      ENDIF
 
       if (ndebug .gt. 0 ) write(0,*) 'dbg = 3d'
 
@@ -3617,6 +4100,156 @@ subroutine calcnfromz1d(nx,ny,nz,nor,na,a,t0,ixe,kze,    &
 
       END subroutine calcnfromz1d
 
+! #####################################################################
+! #####################################################################
+!
+! Subroutine for reattachment of floating ion charge
+!
+   SUBROUTINE SCIONATT    &
+     &  (nx,ny,nz,na,jyslab &
+     &  ,nor,norz &
+     &  ,dtp,dz3d &
+     &  ,an,dn,p2 &
+     &  ,pn,w &
+     &  ,tmp3d)
+
+   implicit none
+
+      integer :: nx,ny,nz,na
+      integer :: ng
+      integer :: nor,norz, jyslab ! ,nht,ngt,igsr
+      real    :: dtp  ! time step
+
+
+!
+! external temporary arrays
+!
+
+      real p2(-nor+1:nx+nor,-nor+1:ny+nor,-norz+1:nz+norz)  ! perturbation Pi
+      real pn(-nor+1:nx+nor,-nor+1:ny+nor,-norz+1:nz+norz)
+      real an(-nor+1:nx+nor,-nor+1:ny+nor,-norz+1:nz+norz,na)
+      real dn(-nor+1:nx+nor,-nor+1:ny+nor,-norz+1:nz+norz)
+
+      real w(-nor+1:nx+nor,-nor+1:ny+nor,-norz+1:nz+norz)
+!      real qv(-nor+1:nx+nor,-nor+1:ny+nor,-norz+1:nz+norz)
+
+
+      real dz3d(-nor+1:nx+nor,-nor+1:ny+nor,-norz+1:nz+norz)
+
+      real tmp3d(-nor+1:nx+nor,-nor+1:ny+nor,-norz+1:nz+norz)
+
+!      real scion2(-nor+1:nx+nor,-nor+1:ny+nor,-norz+1:nz+norz,2)
+
+    ! local
+
+      integer ix,jy,kz,i,n
+
+      double precision frachl
+      double precision frach
+      double precision fracr
+      double precision fracw
+      double precision fraci
+      double precision fracs
+      double precision fractot,frac
+      double precision dv, deninv, tmp, tmpion
+
+      real    :: rhos = 100.
+      real    :: rhog = 500. ! not correct, but for now
+      real    :: rhoh = 900.
+      real    :: rhor = 1000.
+      real    :: rhoi = 900.
+      real    :: rhow = 1000.
+      
+      logical, parameter :: dampicecharge = .false.    ! whether to apply charge damping to cloud ice and snow (WRF ONLY)
+      real, parameter    :: dampchargethresh = 0.09e-9 ! charge density magnitude at which damping stops
+      real, parameter    :: dampchargetimeconst = 3600. ! time constant for charge damping
+
+      IF ( lnh < 1 ) THEN ! not double-moment
+        RETURN
+      ENDIF
+
+      DO kz = 1,nz
+        DO jy = 1,1
+          DO ix = 1,nx
+           IF ( an(ix,jy,kz,lscpi) - an(ix,jy,kz,lscni) /= 0.0 ) THEN
+             fracs = 0.0
+             fraci = 0.0
+             frach = 0.0
+             fracw = 0.0
+             fracr = 0.0
+             frachl = 0.0
+             if (an(ix,jy,kz,lc) > qxmin(lc)) fracw=((an(ix,jy,kz,lc)/rhow)**(2./3.) ) * Max(an(ix,jy,kz,lnc), 0.0)**(1./3.)
+             if (an(ix,jy,kz,lr) > qxmin(lr)) fracr=((an(ix,jy,kz,lr)/rhor)**(2./3.) ) * Max(an(ix,jy,kz,lnr), 0.0)**(1./3.)
+             if (an(ix,jy,kz,li) > qxmin(li)) fraci=((an(ix,jy,kz,li)/rhoi)**(2./3.) ) * Max(an(ix,jy,kz,lni), 0.0)**(1./3.)
+             if (an(ix,jy,kz,ls) > qxmin(ls)) fracs=((an(ix,jy,kz,ls)/rhos)**(2./3.) ) * Max(an(ix,jy,kz,lns), 0.0)**(1./3.)
+             if (an(ix,jy,kz,lh) > qxmin(lh)) frach=((an(ix,jy,kz,lh)/rhog)**(2./3.) ) * Max(an(ix,jy,kz,lnh), 0.0)**(1./3.)
+             IF ( lhl > 1 ) THEN
+              if (an(ix,jy,kz,lhl) > qxmin(lhl)) frachl=((an(ix,jy,kz,lhl)/rhoh)**(2./3.) ) * Max(an(ix,jy,kz,lnhl), 0.0)**(1./3.)
+             ENDIF
+            
+            
+            fractot = fracw + fracr + fraci + fracs + frach + frachl
+       
+            IF ( fractot > 0.0 ) THEN
+              tmpion = (an(ix,jy,kz,lscpi) - an(ix,jy,kz,lscni))*ec
+
+             IF (fracw > 0) then
+               an(ix,jy,kz,lscw) = an(ix,jy,kz,lscw) + tmpion*(fracw/fractot)
+             ENDIF
+
+             IF (fracr > 0) then
+               an(ix,jy,kz,lscr) = an(ix,jy,kz,lscr) + tmpion*(fracr/fractot)
+             ENDIF
+
+             IF (fraci > 0) then
+               an(ix,jy,kz,lsci) = an(ix,jy,kz,lsci) + tmpion*(fraci/fractot)
+             ENDIF
+
+             IF (fracs > 0) then ! avoid division by zero IF fractot = 0 because qx=0
+               an(ix,jy,kz,lscs) = an(ix,jy,kz,lscs) + tmpion*(fracs/fractot)
+             ENDIF
+
+             IF (frach > 0) then
+               an(ix,jy,kz,lsch) = an(ix,jy,kz,lsch) + tmpion*(frach/fractot)
+             ENDIF
+   
+             IF (lnhl > 1 .and. frachl > 0 ) then
+               an(ix,jy,kz,lschl) = an(ix,jy,kz,lschl) + tmpion*(frachl/fractot)
+             ENDIF
+              
+              
+             an(ix,jy,kz,lscpi) = 0.0
+             an(ix,jy,kz,lscni) = 0.0
+             
+            ENDIF ! fractot
+             
+            
+            ENDIF ! non-zero ion charge
+            
+          ENDDO
+        ENDDO
+      ENDDO
+      
+      IF ( dampicecharge ) THEN
+      frac = Exp(-dtp/dampchargetimeconst)
+      DO kz = 1,nz
+        DO jy = 1,1
+          DO ix = 1,nx
+             IF ( Abs( an(ix,jy,kz,lsci) ) > dampchargethresh ) THEN
+               an(ix,jy,kz,lsci) = frac*an(ix,jy,kz,lsci)
+             ENDIF
+
+             IF ( Abs( an(ix,jy,kz,lscs) ) > dampchargethresh ) THEN 
+               an(ix,jy,kz,lscs) = frac*an(ix,jy,kz,lscs)
+             ENDIF
+            
+          ENDDO
+        ENDDO
+      ENDDO
+      ENDIF
+      
+      RETURN
+      END SUBROUTINE SCIONATT
 
 ! ##############################################################################
 ! ##############################################################################
@@ -4961,6 +5594,7 @@ SUBROUTINE setvtz(ngscnt,qx,qxmin,qxw,cx,rho0,rhovt,xdia,cno,cnostmp, &
         
         ! using functional form of  arx*(1 - Exp(-frx*diameter) ), with arx =       arx = 10.
         !  and frx = 516.575 ! raind fit parameters for arx*(1 - Exp(-fx*d)), where d is rain diameter in meters.
+        ! Similar form as in Atlas et al. (1973), who had 9.65 - 10.3*Exp[-600 * d]
 
         
           alp = alpha(mgs,lr)
@@ -5756,7 +6390,9 @@ subroutine ziegfall1d(nx,ny,nz,nor,norz,na,dtp,jgs,ixcol, &
         kgs(ngscnt) = kz
         if ( ngscnt .eq. ngs ) goto 1100
         end if
+!#ifndef MPI
         end do !!ix
+!#endif
         nxmpb = 1
        end do !! kz
 
@@ -6079,7 +6715,7 @@ subroutine radardd02(nx,ny,nz,nor,na,an,temk,         &
 !;
 !; 6/22/99 - Added function to compute height of max rf and 40 dbz echo top
 !;           Also added vilqr which is the model vertical integrated liquid only
-!;           using qr.  Will need to check...doesn't seem consistent with vilZ
+!;           using qr.  Will need to check...does not seem consistent with vilZ
 !;
 
 
@@ -6440,7 +7076,7 @@ subroutine radardd02(nx,ny,nz,nor,na,an,temk,         &
 !       xwdnsq/rwdnsq *0.224        ! Ferrier - for particle sizes in equiv. drop diam
 !       xwdnsq/rwdnsq *0.176/kw_sq  ! =0.189 in Smith - for particle sizes in equiv 
 !                       ice spheres
-!       xwdnsq/rwdnsq *0.208/kw_sq  ! Smith '84 - for particle sizes in equiv melted drop diameter
+!       xwdnsq/rwdnsq *0.208/kw_sq  ! Smith 1984 - for particle sizes in equiv melted drop diameter
 !~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
 
@@ -6509,7 +7145,7 @@ subroutine radardd02(nx,ny,nz,nor,na,an,temk,         &
 !    qh2d   = reform(data[*,*,k,11],[nx*ny])
 
 !~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-! Only use the following lines if running Straka's GEMS microphysics
+! Only use the following lines if running Straka GEMS microphysics
 !  (Sam 1-d version modified by L Wicker does not use this)
 !~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 !    ;xcnoh    = cnoh*exp(-0.025*(temp-tfr))
@@ -6528,7 +7164,7 @@ subroutine radardd02(nx,ny,nz,nor,na,an,temk,         &
 
 !~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 ! Use the following lines if Nos and Noh are constant
-!  (As in Svetla's version of Ferrier, GCE Tao, and SAM 1-d)
+!  (As in Svetla version of Ferrier, GCE Tao, and SAM 1-d)
 !~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         xcnoh    = cnoh
         xcnos    = cnos
@@ -7016,10053 +7652,14504 @@ subroutine radardd02(nx,ny,nz,nor,na,an,temk,         &
       RETURN
       END subroutine radardd02
       
+! #include "include/saund.02b.F90"
 
-! ##############################################################################
-! ##############################################################################
-
-
-! #####################################################################
-! #####################################################################
 !
-! Subroutine for explicit cloud condensation and droplet nucleation
+! 08.13.04: version 02b: added missing low-temp roll-off to "saund" (S91)
+!           scheme and changed all roll-offs to cut off at -40 
+!           instead of -43.
 !
-   SUBROUTINE NUCOND    &
-     &  (nx,ny,nz,na,jyslab & 
-     &  ,nor,norz,dtp,nxi & 
-     &  ,dz3d & 
-     &  ,t0,t9 & 
-     &  ,an,dn,p2 & 
-     &  ,pn,w & 
-     &  ,axtra,io_flag &
-     &  ,ssfilt,t00,t77,flag_qndrop  &
-     & )
-
-
-   implicit none
-
-      integer :: nx,ny,nz,na,nxi
-      integer :: nor,norz, jyslab ! ,nht,ngt,igsr
-      real    :: dtp  ! time step
-      logical :: flag_qndrop
-
-      integer, parameter :: ng1 = 1
-
-
+! 11.11.03: version 02a: Fixes to the S91 (saund) subroutine
 !
-! external temporary arrays
+! ####################################################################
+!                SUBROUTINE SAUNDX
+! ####################################################################
+      subroutine saundx(isaund,temcg,qcw,exw,vt,awdia,rho0,qsign,ftrar,     &
+     &                 qconkq,qconm,qconn,idelq,rarfac)
+      
+! ####################################################################
 !
-      real t00(-nor+1:nx+nor,-nor+1:ny+nor,-norz+1:nz+norz)
-      real t77(-nor+1:nx+nor,-nor+1:ny+nor,-norz+1:nz+norz)
+! 05.04.2004  Fixed another error in the S91 code (in region S8 of 
+!             Helsdon et al.)
+!             Added isaund = -2 option to replace anom. pos. zone with normal 
+!              negative charging
+!             Added isaund = -3 option to use same equations as Wojcik 1994
+!
+!  11/9/2001  Fixed a discrepancy between the crystal diameter used
+!             to calculate charge separation and the diameter used
+!             to find the size range.  Previously used awdia for finding
+!             the size range, but then used fac*awdia for calculating the
+!             charge separation.  (OK if fac = 1, but not for fac=3.67)
+!
+!
+!
+!  Purpose:
+!   Calls the appropriate version of the Saunders et al. scheme
+!
+!  -5 : Saunders etal 1991 (following Helsdon et al. 2001, but use normal charging instead of 'anomalous' zones)
+!  -4 : Saunders etal 1991 (following Helsdon et al. 2001, but remove positive 'anomalous' zone)
+!  -3 : Saunders etal 1991 (following Helsdon et al. 2001)
+!  -2 : Saunders etal 1991 (remove positive 'anomalous' zone)
+!  -1 : Saunders etal 1991 (unmodified 'anomalous' regions)
+!   0 : Saunders 1991 (modified as in Wojcik 1994)
+!   1 : RR scheme (with extra factor 3.67**qconm)
+!   2 : RR scheme ( no extra factor )
+!   3 : Saunders and Peck Scheme (with extra factor 3.67**qconm)
+!   4 : Saunders and Peck Scheme ( no extra factor )
+!   5 : Saunders and Peck Scheme (with extra factor 3.67**qconm, 0.5*rar)
+!   6 : Saunders and Peck Scheme (with extra factor 3.67**qconm, 0.75*rar)
+!   7 : Saunders and Peck Scheme ( no extra factor, 0.5*rar)
+!   8 : RR scheme ( no extra factor, , 0.5*rar )
+!   9 : Saunders and Peck Scheme ( no extra factor, cutoff at -32.47 as orig eq. from sp98 )
+!  10 : Brooks et al. RARcrit for T > -15 using saund2 (otherwise same as isaund=2) (set rarfac to negative in saund2)
+!  11 : Brooks et al. RARcrit for T > -15 using saund6 (otherwise same as isaund=4)
+!  12 : Brooks et al. RARcrit for T > -15 using saund6 (otherwise same as isaund=9)
+!  13 : Brooks et al. RARcrit for T > -15 using saund8 
+! ####################################################################
+      
+      implicit none
+      integer isaund  ! scheme choice
+      real temcg ! temperature
+      real qcw ! cloud water mixing ratio 
+      real exw ! cloud water collection efficiency
+      real vt ! terminal speed difference between x and cw 
+      real awdia ! crystal diameter
+      real rho0  ! air density
+      real qsign ! sign of charge acquired by rimer (not used by calling prog)
+      real ftrar ! charge factor based on temp and RAR 
+      real qconkq ! factor kq ( or 'B') 
+      real qconm  ! exponent on crystal diameter ('a')
+      real qconn  ! exponent on speed ('b')
+      integer idelq ! charge sign, not used by calling program
+      real awdia1
+      real rarfac
 
-      real t0(-nor+1:nx+nor,-nor+1:ny+nor,-norz+1:nz+norz)
-!      real t1(-nor+1:nx+nor,-nor+1:ny+nor,-norz+1:nz+norz)
-!      real t2(-nor+1:nx+nor,-nor+1:ny+nor,-norz+1:nz+norz)
-!      real t3(-nor+1:nx+nor,-nor+1:ny+nor,-norz+1:nz+norz)
-!      real t4(-nor+1:nx+nor,-nor+1:ny+nor,-norz+1:nz+norz)
-!      real t5(-nor+1:nx+nor,-nor+1:ny+nor,-norz+1:nz+norz)
-!      real t6(-nor+1:nx+nor,-nor+1:ny+nor,-norz+1:nz+norz)
-!      real t7(-nor+1:nx+nor,-nor+1:ny+nor,-norz+1:nz+norz)
-!      real t8(-nor+1:nx+nor,-nor+1:ny+nor,-norz+1:nz+norz)
-      real t9(-nor+1:nx+nor,-nor+1:ny+nor,-norz+1:nz+norz)
+! ####################################################################
       
+      idelq = 0
+      awdia1 = awdia
+      
+      IF ( isaund .eq. 1 ) THEN
+        awdia1 = 3.67*awdia
+        call saund2(temcg,qcw,exw,vt,awdia1,rho0,qsign,ftrar,     &
+     &                 qconkq,qconm,qconn,idelq,3.67,1.0)
+      ELSEIF ( isaund .eq. 2 ) THEN
+        call saund2(temcg,qcw,exw,vt,awdia,rho0,qsign,ftrar,     &
+     &                 qconkq,qconm,qconn,idelq,0.0,rarfac)
+      ELSEIF ( isaund .eq. 8 ) THEN
+        call saund2(temcg,qcw,exw,vt,awdia,rho0,qsign,ftrar,     &
+     &                 qconkq,qconm,qconn,idelq,0.0,0.5)
+      ELSEIF ( isaund .eq. 3 ) THEN
+        awdia1 = 3.67*awdia
+        call saund6(temcg,qcw,exw,vt,awdia1,rho0,qsign,ftrar,     &
+     &                 qconkq,qconm,qconn,idelq,3.67,1.0)
+      ELSEIF ( isaund .eq. 4 ) THEN
+        call saund6(temcg,qcw,exw,vt,awdia,rho0,qsign,ftrar,     &
+     &                 qconkq,qconm,qconn,idelq,0.0,rarfac)
+      ELSEIF ( isaund .eq. 5 ) THEN
+        awdia1 = 3.67*awdia
+        call saund6(temcg,qcw,exw,vt,awdia1,rho0,qsign,ftrar,     &
+     &                 qconkq,qconm,qconn,idelq,3.67,0.5)
+      ELSEIF ( isaund .eq. 6 ) THEN
+        awdia1 = 3.67*awdia
+        call saund6(temcg,qcw,exw,vt,awdia1,rho0,qsign,ftrar,     &
+     &                 qconkq,qconm,qconn,idelq,3.67,0.75)
+      ELSEIF ( isaund .eq. 7 ) THEN
+        call saund6(temcg,qcw,exw,vt,awdia,rho0,qsign,ftrar,     &
+     &                 qconkq,qconm,qconn,idelq,0.0,0.5)
+      ELSEIF ( isaund .eq. 9 ) THEN
+        idelq = 1
+        call saund6(temcg,qcw,exw,vt,awdia,rho0,qsign,ftrar,     &
+     &                 qconkq,qconm,qconn,idelq,0.0,rarfac)
+      ELSEIF ( isaund .eq. 10 ) THEN
+        call saund2(temcg,qcw,exw,vt,awdia,rho0,qsign,ftrar,     &
+     &                 qconkq,qconm,qconn,idelq,0.0,-rarfac)
+      ELSEIF ( isaund .eq. 11 ) THEN
+        call saund6(temcg,qcw,exw,vt,awdia,rho0,qsign,ftrar,     &
+     &                 qconkq,qconm,qconn,idelq,0.0,-rarfac)
+      ELSEIF ( isaund .eq. 12 ) THEN
+       idelq = 1
+        call saund6(temcg,qcw,exw,vt,awdia,rho0,qsign,ftrar,     &
+     &                 qconkq,qconm,qconn,idelq,0.0,-rarfac)
+      ELSEIF ( isaund .eq. 13 ) THEN
+        call saund8(temcg,qcw,exw,vt,awdia,rho0,qsign,ftrar,     &
+     &                 qconkq,qconm,qconn,idelq,0.0,-rarfac)
+      ELSEIF ( isaund .eq. 0 ) THEN
+        call saund(temcg,qcw,exw,awdia,rho0,qsign,ftrar,     &
+     &                 qconkq,qconm,qconn,idelq,0)
+      ELSEIF ( isaund .eq. -1 ) THEN
+        call saund(temcg,qcw,exw,awdia,rho0,qsign,ftrar,     &
+     &                 qconkq,qconm,qconn,idelq,1)
+      ELSEIF ( isaund .eq. -2 ) THEN
+        call saund(temcg,qcw,exw,awdia,rho0,qsign,ftrar,     &
+     &                 qconkq,qconm,qconn,idelq,2)
+      ELSEIF ( isaund .eq. -3 ) THEN
+        call saund(temcg,qcw,exw,awdia,rho0,qsign,ftrar,     &
+     &                 qconkq,qconm,qconn,idelq,3)
+      ELSEIF ( isaund .eq. -4 ) THEN
+        call saund(temcg,qcw,exw,awdia,rho0,qsign,ftrar,     &
+     &                 qconkq,qconm,qconn,idelq,4)
+      ELSEIF ( isaund .eq. -5 ) THEN
+        call saund(temcg,qcw,exw,awdia,rho0,qsign,ftrar,     &
+     &                 qconkq,qconm,qconn,idelq,5)
+      ELSE
+        write(6,*) 'STOP! unsupported value of isaund = ',isaund
+        STOP
+      ENDIF
+      RETURN
+      END subroutine saundx
 
-      real p2(-nor+1:nx+nor,-nor+1:ny+nor,-norz+1:nz+norz)  ! perturbation Pi
-      real pn(-nor+1:nx+nor,-nor+1:ny+nor,-norz+1:nz+norz)
-      real an(-nor+1:nx+nor,-nor+1:ny+nor,-norz+1:nz+norz,na)
-      real dn(-nor+1:nx+nor,-nor+1:ny+nor,-norz+1:nz+norz)
-
-      real w(-nor+1:nx+nor,-nor+1:ny+nor,-norz+1:nz+norz)
-!      real qv(-nor+1:nx+nor,-nor+1:ny+nor,-norz+1:nz+norz)
-
-      real ssfilt(-nor+1:nx+nor,-nor+1:ny+nor,-norz+1:nz+norz)
+! ####################################################################
+!                SUBROUTINE SAUNDY
+! ####################################################################
+      subroutine saundy(isaund,temcg,qcw,rar,vt,awdia,rho0,qsign,ftrar,     &
+     &                 qconkq,qconm,qconn,idelq)
       
-
-      real pb(-norz+ng1:nz+norz)
-      real pinit(-norz+ng1:nz+norz)
-
-      real dz3d(-nor+1:nx+nor,-nor+1:ny+nor,-norz+1:nz+norz)
-
+! ####################################################################
+!
+!  4.1.2002   altered version of saundx to take rar as input instead
+!             of exw.
+!
+!  11/9/2001  Fixed a discrepancy between the crystal diameter used
+!             to calculate charge separation and the diameter used
+!             to find the size range.  Previously used awdia for finding
+!             the size range, but then used fac*awdia for calculating the
+!             charge separation.  (OK if fac = 1, but not for fac=3.67)
+!
+!
+!
+!  Purpose:
+!   Calls the appropriate version of the Saunders et al. scheme
+!
+!   1 : RAR scheme (with extra factor 3.67**qconm)
+!   2 : RAR scheme ( no extra factor )
+!   3 : Saunders and Peck Scheme (with extra factor 3.67**qconm)
+!   4 : Saunders and Peck Scheme ( no extra factor )
+!   5 : Saunders and Peck Scheme (with extra factor 3.67**qconm, 0.5*rar)
+!   6 : Saunders and Peck Scheme (with extra factor 3.67**qconm, 0.75*rar)
+!
+!
+! ####################################################################
       
-    ! local
-
+      implicit none
+      integer isaund  ! scheme choice
+      real temcg ! temperature
+      real qcw ! cloud water mixing ratio 
+      real exw ! cloud water collection efficiency
+      real rar
+      real vt ! terminal speed difference between x and cw 
+      real awdia ! crystal diameter
+      real rho0  ! air density
+      real qsign ! sign of charge acquired by rimer (not used by calling prog)
+      real ftrar ! charge factor based on temp and RAR 
+      real qconkq ! factor kq ( or 'B') 
+      real qconm  ! exponent on crystal diameter ('a')
+      real qconn  ! exponent on speed ('b')
+      integer idelq ! charge sign, not used by calling program
+      real awdia1
 
-      real axtra(-nor+ng1:nx+nor,-nor+ng1:ny+nor,-norz+ng1:nz+norz,nxtra)
-      logical :: io_flag
+! ####################################################################
       
-      real :: dv
-
-! 
-!  declarations microphysics and for gather/scatter
-!
-      integer nxmpb,nzmpb,nxz
-      integer mgs,ngs,numgs,inumgs
-      parameter (ngs=500)
-      integer ngscnt,igs(ngs),kgs(ngs)
-      integer kgsp(ngs),kgsm(ngs)
-      integer nsvcnt
+      awdia1 = awdia
       
-      integer ix,kz,i,n, kp1, km1
-      integer :: jy, jgs
-      integer ixb,ixe,jyb,jye,kzb,kze
-    
-      integer itile,jtile,ktile
-      integer ixend,jyend,kzend,kzbeg
-      integer nxend,nyend,nzend,nzbeg
-
+      IF ( isaund .eq. 4 ) THEN
+        call saund7(temcg,qcw,rar,vt,awdia,rho0,qsign,ftrar,     &
+     &                 qconkq,qconm,qconn,idelq,0.0,1.0)
+      ENDIF
+      RETURN
+      END subroutine saundy
+! ####################################################################
+! ####################################################################
+!                SUBROUTINE TAKAX
+! ####################################################################
+      subroutine takax(isaund0,nt,nlc,lookup,temcg,qcw,vt,awdia,     &
+     &                 rho0,ftlwc,exw,qrw,rarfac)
+      
+! ####################################################################
 !
-! Variables for Ziegler warm rain microphysics
-!      
-
-
-      real ccnc(ngs), ccna(ngs), cnuc(ngs), cwnccn(ngs)
-      real sscb  ! 'cloud base' SS threshold
-      parameter ( sscb = 2.0 )
-      integer idecss  ! flag to turn on (=1) decay of ssmax when no cloud or ice crystals
-      parameter ( idecss = 1 )
-      integer iba ! flag to do condensation/nucleation in 1st or 2nd loop
-                  ! =0 to use ad to calculate SS
-                  ! =1 to use an at end of main jy loop to calculate SS
-      parameter (iba = 1)
-      integer ifilt   ! =1 to filter ssat, =0 to set ssfilt=ssat
-      parameter ( ifilt = 0 ) 
-      real temp1,temp2 ! ,ssold
-      real :: ssmax(ngs) = 0.0       ! maximum SS experienced by a parcel
-      real ssmx
-      real dnnet,dqnet
-!      real cnu,rnu,snu,cinu
-!      parameter ( cnu = 0.0, rnu = -0.8, snu = -0.8, cinu = 0.0 )
-      real ventrx(ngs)
-      real ventrxn(ngs)
-      real volb, t2s
-      real, parameter :: aa1 = 9.44e15, aa2 = 5.78e3  ! a1 in Ziegler
-
-      real ec0, ex1, ft, rhoinv(ngs)
+!  Purpose: For calling different versions of Takahashi charging 
+!           routine
+!  
+!
+! ####################################################################
       
-      real chw, g1, rd1
-
-      real ac1,bc, taus, c1,d1,e1,f1,p380,tmp,tmp2 ! , sstdy, super
-      real tmpmx, fw
-      real x,y,del,r,alpr
-      double precision :: vent1,vent2
-      real g1palp
-      real bs
-      real v1, v2
-      real d1r, d1i, d1s, e1i
-      integer nc ! condensation step
-      real dtcon,dtcon1,dtcon2 ! condensation time step (dtcon*nc = dtp)
-      real delta
-      integer ltemq1,ltemq1m ! ,ltemq1m2
-      real dqv,qv1,ss1,ss2,qvs1,dqvs,dtemp,dt1   ! temporaries for condensation
-
-      real ssi1, ssi2, dqvi, dqvis, dqvii,qis1
-      real dqvr, dqc, dqr, dqi, dqs
-      real qv1m,qvs1m,ss1m,ssi1m,qis1m
-      real cwmastmp 
-      real  dcloud,dcloud2 ! ,as, bs
-      real dcrit
-      real cn(ngs) 
-
-      integer ltemq
+      implicit none
       
-      integer il
+      integer isaund0,isaund,nt,nlc
+      real lookup(0:nt,0:nlc) 
+      real qcw, qrw, lwc
+      real rho0
+      real ftlwc
+      real temcg
+      real vt
+      real awdia,awdia1
+      real exw
+      real rarfac
+      
+      lwc = qcw
+      isaund = Abs(isaund0)
+      IF ( isaund0 .eq. -1 ) lwc = (qcw + qrw)
+      IF ( isaund0 .eq. -2 ) lwc = (qcw + qrw)*rarfac
+       
+!  BEGIN EXECUTABLE CODE
+      IF ( isaund .eq. 1 ) THEN ! taka size/vel. depend.
+        call taka(nt,nlc,lookup,temcg,lwc,vt,awdia,rho0,ftlwc)
+      ELSEIF ( isaund .eq. 2 ) THEN ! saunders size dependence
+        awdia1 = awdia !  3.67*awdia
+        call taka2(nt,nlc,lookup,temcg,lwc,vt,awdia1,rho0,ftlwc)
+      ELSEIF ( isaund .eq. 3 ) THEN ! no size or velocity dependence
+        call taka3(nt,nlc,lookup,temcg,lwc,vt,awdia,rho0,ftlwc)
+      ELSEIF ( isaund .eq. 4 ) THEN ! taka size/vel. depend. w/ D = 3.67/lambda
+        call taka4(nt,nlc,lookup,temcg,lwc,vt,awdia,rho0,ftlwc)
+      ELSEIF ( isaund .eq. 5 ) THEN ! taka size/vel. depend. and using RAR
+        call takarar(nt,nlc,lookup,temcg,lwc,vt,awdia,rho0,ftlwc,exw)
+      ELSE
+        call taka(nt,nlc,lookup,temcg,lwc,vt,awdia,rho0,ftlwc)
+      ENDIF
 
-      real  es(ngs) ! ss(ngs),
-!      real  eis(ngs)
-      real ssf(ngs),ssfkp1(ngs),ssfkm1(ngs),ssat0(ngs)
-      real, parameter :: ssfcut = 4.0
-      real ssfjp1(ngs),ssfjm1(ngs)
-      real ssfip1(ngs),ssfim1(ngs)
+      END subroutine takax
 
-      real supcb, supmx
-      parameter (supcb=0.5,supmx=238.0)
-      real r2dxm, r2dym, r2dzm
-      real dssdz, dssdy, dssdx
-!      real tqvcon
-      real epsi,d
-      parameter (epsi = 0.622, d = 0.266)
-      real r1,qevap ! ,slv
+! ####################################################################
+!                SUBROUTINE SAUND7
+! ####################################################################
+      subroutine saund7(temcg,qcw,rar,vt,awdia,rho0,qsign,ftrar,     &
+     &                 qconkq,qconm,qconn,idelq,qfac,rarfac)
       
-      real vr,nrx,qr,z1,z2,rdi,alp,xnutmp,xnuc
-      real ctmp, ccwtmp
-      real f5, qvs0  ! Kessler condensation factor
-      real    :: t0p1, t0p3
-      real qvex
+! ####################################################################
+!
+! 4.1.2002  New version that uses the model-calculated RAR (derived
+!           from the collection rate qxacw)
+!
+!cPurpose:
+!   Saunders charging scheme based on rime accretion rate (RAR)
+!   as in Brooks et al. (1997) and Saunders and Peck (1998)
+!
+! 7/27/2000 Try with original Saunders and Peck curve (1998) plus the 
+!           drop-off starting at -23.7
+!
+!
+! 7/24/99  new adjustment to RARcritical curve: make a cubic drop-off
+!          from -23.7 to -40 (and zero charging below -40)
+!
+! 12/8/99 temporary test of putting in a factor of (3.67)**qconm to
+!         approximate using the mass-weighted mean crystal diameter
+!
+! 12/17/99 for positive charging, just use ftrar = 6.74*( rar - rarc )
+!          for all temperatures (took out alternate eq. for T<-34)
+!
+! ####################################################################
       
-!      real, dimension(ngs) :: temp, tempc, elv, elf, els, pqs, theta, temg, temcg
-      real dqvcnd(ngs),dqwv(ngs),dqcw(ngs),dqci(ngs)
-      real temp(ngs),tempc(ngs)
-      real temg(ngs),temcg(ngs),theta(ngs),qvap(ngs) ! ,tembzg(ngs)
-      real temgx(ngs),temcgx(ngs)
-      real qvs(ngs),qis(ngs),qss(ngs),pqs(ngs)
-      real felv(ngs),felf(ngs),fels(ngs)
-      real felvcp(ngs),felvpi(ngs)
-      real gamw(ngs),gams(ngs)   !   qciavl(ngs),
-      real tsqr(ngs),ssi(ngs),ssw(ngs)
-      real cc3(ngs),cqv1(ngs),cqv2(ngs)
-      real qcwtmp(ngs),qtmp
-
-      real fvent(ngs) !,fraci(ngs),fracl(ngs)
-      real fwvdf(ngs),ftka(ngs),fthdf(ngs)
-      real fadvisc(ngs),fakvisc(ngs)
-      real fci(ngs),fcw(ngs)
-      real fschm(ngs),fpndl(ngs)
-
-      real pres(ngs),pipert(ngs)
-      real pk(ngs)
-      real rho0(ngs),pi0(ngs)
-      real rhovt(ngs)
-      real thetap(ngs),theta0(ngs),qwvp(ngs),qv0(ngs)
-      real thsave(ngs)
-      real qss0(ngs)
-      real fcqv1(ngs)
-      real wvel(ngs),wvelkm1(ngs)
+      implicit none
+      real temcg ! temperature
+      real qcw ! cloud water mixing ratio 
+!      real exw ! cloud water collection efficiency
+      real vt ! terminal speed difference between x and cw 
+      real awdia ! crystal diameter
+      real rho0  ! air density
+      real qsign ! sign of charge acquired by rimer (not used by calling prog)
+      real ftrar ! charge factor based on temp and RAR 
+      real qconkq ! factor kq ( or 'B') 
+      real qconm  ! exponent on crystal diameter ('a')
+      real qconn  ! exponent on speed ('b')
+      integer idelq ! charge sign, not used by calling program
+      real qfac
+      real rarfac  ! factor to reduce rar for purposes of charge calculation
+      
+      real rar ! rime accretion rate
+      real rarc ! critical RAR
+      real t,tc
+      parameter (tc = -23.7)
+      real delr,delri
+      parameter (delr=0.5, delri=1.0/delr)
+      real rar0  ! lower limit of RAR where charging goes to zero
+      parameter (rar0 = 0.1)
+      real q0
+      parameter (q0 = 6.48)
+      real tema,tmin
+      parameter (tema = -7.0 , tmin = -43.)
+      
+      real fac
+      
+! ####################################################################
+! Begin Executable code
+! ####################################################################
 
-      real wvdf(ngs),tka(ngs)
-      real advisc(ngs)
+      IF ( temcg .gt. -30 ) THEN
+        fac = 1.0
+      ELSEIF ( temcg .gt. -40.0 ) THEN
+        fac = 1.0 - ((temcg+30.0)/(40.0 - 30.0))**2
+      ELSE
+        fac = 0.0
+      END IF
+      
+      ftrar = 0.0
+      
+!      rar = exw*qcw*1.0e3*rho0*vt*rarfac
+      t = temcg
+
+      IF (t .gt. tc ) THEN
+      rarc = 1.0 + t*(7.9262e-2 + t*(4.4847e-2 +     &
+     &  t*(7.4754e-3 + t*(5.4686e-4 +     &
+     &  t*(1.6737e-5 + t*1.7613e-7)))))
+!      ELSE ! IF ( t .le. -23.0) THEN
+!       rarc = 3.27
+!      ELSE ! IF ( t .le. -30.0) THEN
+!       rarc = 1.795
+      ELSE ! IF ( t .le. tc) THEN
+       rarc = 3.39608*( 1.0 - Abs( ( (t - tc)/(tc + 40) )**3) )
+      END IF
+
+
+      
+! check for RAR below threshold:
+      IF ( rar .le. rar0 .or. temcg .le. tmin) THEN
+        qsign = 0.0
+        ftrar = 0.0
+        qconkq = 0.0
+        qconn = 1.0
+        qconm = 1.0
+        GOTO 999
+      END IF
+
+! for now, use charging values at -8.0 for warmer temps
+! and values at -23.0 for colder temps (Saunders and Peck, 1998)      
+      IF (temcg .gt. -8.0 ) THEN
+         t = -8.0
+      ELSEIF (temcg .lt. -23.0) THEN
+         t = -23.0
+      END IF
+      
+      qsign = -1.0
+      IF (rar .gt. rarc) qsign = 1.0
+      
+      IF (qsign .gt. 0.5) THEN
+        
+!        IF ( Abs(rar - rarc) .lt. delr) THEN
+!         ftrar = delri*Abs(rar - rarc)*
+!     :           (6.74*(rarc + delr) + 1.36*t + 10.5 )
+!        ELSE
+!         ftrar = 6.74*rar + 1.36*t + 10.5
+!        END IF
+!        ftrar = Max(0.0, ftrar)
 
-      real rwvent(ngs)
-      
+!        IF ( Abs(rar - rarc) .lt. delr .and. temcg .gt. tc) THEN
+!         ftrar = Max( 0.0, delri*Abs(rar - rarc)*
+!     :           (6.74*(rarc + delr) + 1.36*t + 10.5 ) )
+!        ELSE
+!         ftrar = Max( 0.0, 6.74*rar + 1.36*t + 10.5 )
+!        END IF
+        
+!        IF ( temcg .gt. -34.0 ) THEN
+          ftrar = 6.74*( rar - rarc )
+!        ELSE
+!          ftrar = Max ( 0.0, 6.74*( rar - 
+!     :     4*( 1.0 - Abs( ( (-34.0 + 25.0 )/(-25.0 - tmin) )**2) ) ) )
+!        END IF
+        
+        if ( awdia*1.e6.lt.155. ) then
+          qconkq = 4.9e13
+          qconm  = 3.76
+          qconn  = 2.5
+        end if
+        if ( awdia*1.e6.ge.155. .and. awdia*1.e6.le.452. ) then
+          qconkq = 4.0e6
+          qconm  = 1.9
+          qconn  = 2.5
+        end if
+        if ( awdia*1.e6.gt.452. ) then
+          qconkq = 52.8
+          qconm  = 0.44
+          qconn  = 2.5
+        end if
+        
+        IF ( qfac .gt. 1.0 ) THEN
+         ftrar = fac*ftrar*qfac**qconm
+        ELSE
+         ftrar = fac*ftrar
+        ENDIF
 
-      real :: qx(ngs,lv:lhab)
-      real :: cx(ngs,lc:lhab)
-      real :: xv(ngs,lc:lhab)
-      real :: xmas(ngs,lc:lhab)
-      real :: xdn(ngs,lc:lhab)
-      real :: xdia(ngs,lc:lhab,3)
-      real :: alpha(ngs,lc:lhab)
-      real :: zx(ngs,lr:lhab)
+      ELSEIF (qsign .lt. -0.5) THEN
 
+!        IF ( Abs(rar - rarc) .lt. delr) THEN
+!         ftrar = delri*Abs(rar - rarc)*
+!     :           (3.02 - 10.59*(rarc-delr) + 2.95*(rarc-delr)**2 )
+!        ELSEIF (rar .lt. 0.4) THEN
+!         ftrar = ((rar-0.1)/0.3)*(3.02 - 10.59*(0.4) + 2.95*(0.4)**2)
+!        ELSE
+!         ftrar = 3.02 - 10.59*rar + 2.95*rar**2
+!        END IF
 
-      logical zerocx(lc:lqmx)
-      
-      logical :: lprint
+        ftrar = Min(1.0, 0.6*Abs(rarc - rar0) )*(6.5)*(-1.0 +      &
+     &    4.0/(rarc - rar0)**2 * (rar - (rarc + rar0)/2.0 )**2  )
+        ftrar = Min( 0.0, ftrar )
+        
+        if ( awdia*1.e6.lt.253. ) then
+          qconkq = 5.24e8
+          qconm  = 2.54
+          qconn  = 2.8
+        end if
+        if ( awdia*1.e6.gt.253. ) then
+          qconkq = 24.0
+          qconm  = 0.50
+          qconn  = 2.8
+        end if
 
-      integer, parameter :: iunit = 0
+        IF ( qfac .gt. 1.0 ) THEN
+         ftrar = fac*ftrar*qfac**qconm
+        ELSE
+         ftrar = fac*ftrar
+        ENDIF
+        
+      END IF
       
-      real :: frac, hwdn, tmpg
       
-      real :: cvm,cpm,rmm
+ 999  CONTINUE      
+      RETURN
+      END subroutine saund7
 
-      real, parameter :: rovcp = rd/cp
-      real, parameter ::      cpv = 1885.0       ! specific heat of water vapor at constant pressure
+
+! ####################################################################
+!                SUBROUTINE TAKA2
+! ####################################################################
+      subroutine TAKA2(nt,nlc,lookup,temcg,qcw,vt,awdia,rho0,ftlwc)
       
-      integer :: kstag
+! ####################################################################
+!
+!  Purpose:
+!           Noninductive charging per Takahashi 1978 lab results.  
+!           Using lookup table from Wojcik (1994).  For temperatures
+!           lower than -30 C, the values at -30 C are used.
+!
+!  7/31/99 Now limit low-temp charging rates by a parabolic function
+!          with a value of zero at -30 C and goes to zero at -43 C.
+!         
+!  8/10/99 Fixed bug in the interpolation: was accidentally 
+!          _extrapolating_.   Oops.
+!
+!  10/26/99  Test using a Saunders et al. size dependence on the crystal size
+!
+! ####################################################################
       
-      integer :: count
+      implicit none
       
-
-! -------------------------------------------------------------------------------
-      itile = nxi
-      jtile = ny
-      ktile = nz
-      ixend = nxi
-      jyend = ny
-      kzend = nz
-      nxend = nxi + 1
-      nyend = ny + 1
-      nzend = nz
-      kzbeg = 1
-      nzbeg = 1
-
-      f5 = 237.3 * 17.27 * 2.5e6 / cp ! combined constants for rain condensation (Soong and Ogura 73)
-
-       jy = 1
-       kstag = 0
-       pb(:) = 0.0
-       pinit(:) = 0.0
+      integer nt,nlc
+      real lookup(0:nt,0:nlc) 
+      real qlwc
+      real qcw
+      real rho0
+      real ftlwc
+      real temt,temcg
+      integer item,ilwc
+      real fact,facl
+      real a1,a2,a3
+      real alf
+      real vt
+      real awdia
+      real d0
+      parameter(d0 = 100.0e-6)
+      real v0 
+      parameter(v0 = 8.0)
+      real fac
+      real qconkq, qconm, qconn
+      
+!  BEGIN EXECUTABLE CODE
+
+      IF ( temcg .gt. -30 ) THEN
+        fac = 1.0
+      ELSEIF ( temcg .gt. -40.0 ) THEN
+        fac = 1.0 - ((temcg+30.0)/(40.0 - 30.0))**2
+      ELSE
+        fac = 0.0
+      END IF
+      
+      
+      temt = Max (temcg, -30.0)
+      item = Int(-temt) + 1
+      qlwc = qcw*(1.e3)*rho0
+      
+      qlwc = Min ( qlwc, 30.0)
+      ilwc = 0
+      ftlwc = 0.0
+      
+      IF (qlwc .ge. 10.0) THEN
+        ilwc = Int( qlwc/10.0 + 1.0e-5) + 1 + 27
+        facl = (qlwc - lookup(0,ilwc) )*0.1
+      ELSEIF (qlwc .ge. 1.0) THEN
+        ilwc = Int( qlwc + 1.0e-5) + 1 + 18
+        facl = (qlwc - lookup(0,ilwc) )*1.0
+      ELSEIF (qlwc .ge. 0.1) THEN
+        ilwc = Int( qlwc*10.0 + 1.0e-5 ) + 1 + 9
+        facl = (qlwc - lookup(0,ilwc) )*10.0
+      ELSEIF (qlwc .ge. 0.01) THEN
+        ilwc = Int ( qlwc*100.0 + 1.0e-5) + 1
+        facl = (qlwc - lookup(0,ilwc) )*100.0
+      ELSE 
+         ilwc = 0
+         ftlwc = 0.0
+      END IF
+
+      IF (ilwc .gt. 0) THEN
+        fact = -temt - Float(item) + 1.0
+!        a1 = (1.0-fact)*lookup(item,ilwc) + fact*lookup(item+1,ilwc)
+!        a2 = (1.0-fact)*lookup(item,ilwc+1) + fact*lookup(item+1,ilwc+1)
+        a1 = (1.0-fact)*lookup(item,ilwc) +      &
+     &          fact*lookup(Min(nt,item+1),ilwc)
+        a2 = (1.0-fact)*lookup(item,ilwc+1) +      &
+     &          fact*lookup(Min(nt,item+1),ilwc+1)
+        ftlwc = fac*(a1 + facl*(a2-a1))
+        IF ( ftlwc .gt. 0.0 ) THEN
+        
+        if ( awdia*1.e6.lt.155. ) then
+          qconkq = 4.9e13
+          qconm  = 3.76
+          qconn  = 2.5
+        end if
+        if ( awdia*1.e6.ge.155. .and. awdia*1.e6.le.452. ) then
+          qconkq = 4.0e6
+          qconm  = 1.9
+          qconn  = 2.5
+        end if
+        if ( awdia*1.e6.gt.452. ) then
+          qconkq = 52.8
+          qconm  = 0.44
+          qconn  = 2.5
+        end if
+        
+        ELSEIF ( ftlwc .lt. 0.0 ) THEN
+        
+        if ( awdia*1.e6.lt.253. ) then
+          qconkq = 5.24e8
+          qconm  = 2.54
+          qconn  = 2.8
+        end if
+        if ( awdia*1.e6.gt.253. ) then
+          qconkq = 24.0
+          qconm  = 0.50
+          qconn  = 2.8
+        end if
+        
+        ENDIF
+        
+!        alf = Min(5.0*(awdia/d0)**2*Abs(vt)/v0,10.0)
+!        alf = qconkq*(3.67*awdia)**qconm*(0.333*Abs(vt))**qconn ! 11/9/01 erm
+!        alf = qconkq*(awdia)**qconm*(Abs(vt))**qconn        ! 11/9/01 erm
+! Need to figure out what to do with qconkq, if anything...
+        alf = (awdia/d0)**qconm*(Abs(vt)/v0)**qconn        ! 12/9/04 erm
+        ftlwc = 1.0e-15*alf*ftlwc
+      END IF
       
-      IF ( ipconc <= 1 .or. isedonly == 2 ) GOTO 2200
+      RETURN
+      END subroutine TAKA2
 
+! ####################################################################
+!                SUBROUTINE TAKARAR
+! ####################################################################
+      subroutine TAKARAR(nt,nlc,lookup,temcg,qcw,vt,awdia,rho0,ftlwc,     &
+     &                   exw)
+      
+! ####################################################################
 !
-!  Ziegler nucleation 
+!  Purpose:
+!           Noninductive charging per Takahashi 1978 lab results.  
+!           Using lookup table from Wojcik (1994).  For temperatures
+!           lower than -30 C, the values at -30 C are used.
 !
-
-!      ssfilt(:,:,:) = 0.0
-      ssmx = 0
-      count = 0
-
-      do kz = 1,nz-kstag
-        do ix = 1,nxi
-
-         temp1 = an(ix,jy,kz,lt)*t77(ix,jy,kz)
-          t0(ix,jy,kz) = temp1
-          ltemq = Int( (temp1-163.15)/fqsat+1.5 )
-         ltemq = Min( nqsat, Max(1,ltemq) )
-
-          c1 = t00(ix,jy,kz)*tabqvs(ltemq)
-
-          IF ( c1 > 0. ) THEN
-            ssfilt(ix,jy,kz) = 100.*(an(ix,jy,kz,lv)/c1 - 1.0)  ! from "new" values
-          ENDIF
-
-        ENDDO
-      ENDDO
-
-
+!  7/31/99 Now limit low-temp charging rates by a parabolic function
+!          with a value of zero at -30 C and goes to zero at -43 C.
+!         
+!  8/10/99 Fixed bug in the interpolation: was accidentally 
+!          _extrapolating_.   Oops.
 !
-!     jy = 1 ! working on a 2d slab
-!!  VERY IMPORTANT:  SET jgs = jy
-
-      jgs = jy
+! ####################################################################
+      
+      implicit none
+      
+      integer nt,nlc
+      real lookup(0:nt,0:nlc) 
+      real qlwc
+      real qcw
+      real rho0
+      real ftlwc
+      real exw
+      real temt,temcg
+      integer item,ilwc
+      real fact,facl
+      real a1,a2,a3
+      real alf
+      real vt
+      real awdia
+      real d0
+      parameter(d0 = 100.0e-6)
+      real v0 
+      parameter(v0 = 8.0)
+      real fac
+      real rar
+      
+!  BEGIN EXECUTABLE CODE
+
+      IF ( temcg .gt. -30 ) THEN
+        fac = 1.0
+      ELSEIF ( temcg .gt. -40.0 ) THEN
+        fac = 1.0 - ((temcg+30.0)/(40.0 - 30.0))**2
+      ELSE
+        fac = 0.0
+      END IF
+!
+! here, qlwc is scaled by vt/9.0, where 9.0m/s is the riming rod speed in Takahashi (1978)
+!
+      qlwc = exw*qcw*1.0e3*rho0*vt/9.0
+      
+      temt = Max (temcg, -30.0)
+      item = Int(-temt) + 1
+!      qlwc = qcw*(1.e3)*rho0
+      
+      qlwc = Min ( qlwc, 30.0)
+      ilwc = 0
+      ftlwc = 0.0
+      
+      IF (qlwc .ge. 10.0) THEN
+        ilwc = Int( qlwc/10.0 + 1.0e-5) + 1 + 27
+        facl = (qlwc - lookup(0,ilwc) )*0.1
+      ELSEIF (qlwc .ge. 1.0) THEN
+        ilwc = Int( qlwc + 1.0e-5) + 1 + 18
+        facl = (qlwc - lookup(0,ilwc) )*1.0
+      ELSEIF (qlwc .ge. 0.1) THEN
+        ilwc = Int( qlwc*10.0 + 1.0e-5 ) + 1 + 9
+        facl = (qlwc - lookup(0,ilwc) )*10.0
+      ELSEIF (qlwc .ge. 0.01) THEN
+        ilwc = Int ( qlwc*100.0 + 1.0e-5) + 1
+        facl = (qlwc - lookup(0,ilwc) )*100.0
+      ELSE 
+         ilwc = 0
+         ftlwc = 0.0
+      END IF
+      
+      IF ( ilwc .eq. nlc ) THEN
+       write(0,*) 'Warning: ilwc = nlc! setting to nlc-1'
+       ilwc = nlc - 1
+      ENDIF 
+      IF ( item .gt. nt ) THEN
+       write(0,*) 'Warning: item > nt! setting to nt'
+       item = nt
+      ENDIF 
+      IF ( ilwc .lt. 0 ) THEN
+       write(0,*) 'Warning: ilwc < 0! setting to 0'
+       ilwc = 0
+      ENDIF 
+      IF ( item .lt. 0 ) THEN
+       write(0,*) 'Warning: item < 0! setting to 0'
+       item = 0
+      ENDIF 
+
+      IF (ilwc .gt. 0) THEN
+        fact = -temt - Float(item) + 1.0
+        a1 = (1.0-fact)*lookup(item,ilwc) +      &
+     &          fact*lookup(Min(nt,item+1),ilwc)
+        a2 = (1.0-fact)*lookup(item,ilwc+1) +      &
+     &          fact*lookup(Min(nt,item+1),ilwc+1)
+        ftlwc = fac*(a1 + facl*(a2-a1))
+        
+        alf = Min(5.0*(awdia/d0)**2*Abs(vt)/v0,10.0)
+        ftlwc = 1.0e-15*alf*ftlwc
+      END IF
+      
+      RETURN
+      END subroutine takarar
+! ####################################################################
+!                SUBROUTINE TAKA
+! ####################################################################
+      subroutine TAKA(nt,nlc,lookup,temcg,qcw,vt,awdia,rho0,ftlwc)
+      
+! ####################################################################
+!
+!  Purpose:
+!           Noninductive charging per Takahashi 1978 lab results.  
+!           Using lookup table from Wojcik (1994).  For temperatures
+!           lower than -30 C, the values at -30 C are used.
+!
+!  7/31/99 Now limit low-temp charging rates by a parabolic function
+!          with a value of zero at -30 C and goes to zero at -43 C.
+!         
+!  8/10/99 Fixed bug in the interpolation: was accidentally 
+!          _extrapolating_.   Oops.
+!
+! ####################################################################
+      
+      implicit none
+      
+      integer nt,nlc
+      real lookup(0:nt,0:nlc) 
+      real qlwc
+      real qcw
+      real rho0
+      real ftlwc
+      real temt,temcg
+      integer item,ilwc
+      real fact,facl
+      real a1,a2,a3
+      real alf
+      real vt
+      real awdia
+      real d0
+      parameter(d0 = 100.0e-6)
+      real v0 
+      parameter(v0 = 8.0)
+      real fac
+      
+!  BEGIN EXECUTABLE CODE
+
+      IF ( temcg .gt. -30 ) THEN
+        fac = 1.0
+      ELSEIF ( temcg .gt. -40.0 ) THEN
+        fac = 1.0 - ((temcg+30.0)/(40.0 - 30.0))**2
+      ELSE
+        fac = 0.0
+      END IF
+      
+      
+      temt = Max (temcg, -30.0)
+      item = Int(-temt) + 1
+      qlwc = qcw*(1.e3)*rho0
+      
+      qlwc = Min ( qlwc, 30.0)
+      ilwc = 0
+      ftlwc = 0.0
+      
+      IF (qlwc .ge. 10.0) THEN
+        ilwc = Int( qlwc/10.0 + 1.0e-5) + 1 + 27
+        facl = (qlwc - lookup(0,ilwc) )*0.1
+      ELSEIF (qlwc .ge. 1.0) THEN
+        ilwc = Int( qlwc + 1.0e-5) + 1 + 18
+        facl = (qlwc - lookup(0,ilwc) )*1.0
+      ELSEIF (qlwc .ge. 0.1) THEN
+        ilwc = Int( qlwc*10.0 + 1.0e-5 ) + 1 + 9
+        facl = (qlwc - lookup(0,ilwc) )*10.0
+      ELSEIF (qlwc .ge. 0.01) THEN
+        ilwc = Int ( qlwc*100.0 + 1.0e-5) + 1
+        facl = (qlwc - lookup(0,ilwc) )*100.0
+      ELSE 
+         ilwc = 0
+         ftlwc = 0.0
+      END IF
+      
+      IF ( ilwc .eq. nlc ) THEN
+       write(0,*) 'Warning: ilwc = nlc! setting to nlc-1'
+       ilwc = nlc - 1
+      ENDIF 
+      IF ( item .gt. nt ) THEN
+       write(0,*) 'Warning: item > nt! setting to nt'
+       item = nt
+      ENDIF 
+      IF ( ilwc .lt. 0 ) THEN
+       write(0,*) 'Warning: ilwc < 0! setting to 0'
+       ilwc = 0
+      ENDIF 
+      IF ( item .lt. 0 ) THEN
+       write(0,*) 'Warning: item < 0! setting to 0'
+       item = 0
+      ENDIF 
+
+      IF (ilwc .gt. 0) THEN
+        fact = -temt - Float(item) + 1.0
+        a1 = (1.0-fact)*lookup(item,ilwc) +      &
+     &          fact*lookup(Min(nt,item+1),ilwc)
+        a2 = (1.0-fact)*lookup(item,ilwc+1) +      &
+     &          fact*lookup(Min(nt,item+1),ilwc+1)
+        ftlwc = fac*(a1 + facl*(a2-a1))
+        
+        alf = Min(5.0*(awdia/d0)**2*Abs(vt)/v0,10.0)
+        ftlwc = 1.0e-15*alf*ftlwc
+      END IF
+      
+      RETURN
+      END subroutine TAKA
 
+! ####################################################################
+!                SUBROUTINE TAKA3
+! ####################################################################
+      subroutine TAKA3(nt,nlc,lookup,temcg,qcw,vt,awdia,rho0,ftlwc)
+      
+! ####################################################################
 !
-!..Gather microphysics
+!  Purpose:
+!           Noninductive charging per Takahashi 1978 lab results.  
+!           Using lookup table from Wojcik (1994).  For temperatures
+!           lower than -30 C, the values at -30 C are used.
 !
-      if ( ndebug .gt. 0 ) write(0,*) 'ICEZVD_DR: Gather stage'
+!  7/31/99 Now limit low-temp charging rates by a parabolic function
+!          with a value of zero at -30 C and goes to zero at -43 C.
+!         
+!  8/10/99 Fixed bug in the interpolation: was accidentally 
+!          _extrapolating_.   Oops.
+!
+! ####################################################################
+      
+      implicit none
+      
+      integer nt,nlc
+      real lookup(0:nt,0:nlc) 
+      real qlwc
+      real qcw
+      real rho0
+      real ftlwc
+      real temt,temcg
+      integer item,ilwc
+      real fact,facl
+      real a1,a2,a3
+      real alf
+      real vt
+      real awdia
+      real d0
+      parameter(d0 = 100.0e-6)
+      real v0 
+      parameter(v0 = 8.0)
+      real fac
+      
+!  BEGIN EXECUTABLE CODE
+
+      IF ( temcg .gt. -30 ) THEN
+        fac = 1.0
+      ELSEIF ( temcg .gt. -40.0 ) THEN
+        fac = 1.0 - ((temcg+30.0)/(40.0 - 30.0))**2
+      ELSE
+        fac = 0.0
+      END IF
+      
+      
+      temt = Max (temcg, -30.0)
+      item = Int(-temt) + 1
+      qlwc = qcw*(1.e3)*rho0
+      
+      qlwc = Min ( qlwc, 30.0)
+      ilwc = 0
+      ftlwc = 0.0
+      
+      IF (qlwc .ge. 10.0) THEN
+        ilwc = Int( qlwc/10.0 + 1.0e-5) + 1 + 27
+        facl = (qlwc - lookup(0,ilwc) )*0.1
+      ELSEIF (qlwc .ge. 1.0) THEN
+        ilwc = Int( qlwc + 1.0e-5) + 1 + 18
+        facl = (qlwc - lookup(0,ilwc) )*1.0
+      ELSEIF (qlwc .ge. 0.1) THEN
+        ilwc = Int( qlwc*10.0 + 1.0e-5 ) + 1 + 9
+        facl = (qlwc - lookup(0,ilwc) )*10.0
+      ELSEIF (qlwc .ge. 0.01) THEN
+        ilwc = Int ( qlwc*100.0 + 1.0e-5) + 1
+        facl = (qlwc - lookup(0,ilwc) )*100.0
+      ELSE 
+         ilwc = 0
+         ftlwc = 0.0
+      END IF
+
+      IF (ilwc .gt. 0) THEN
+        fact = -temt - Float(item) + 1.0
+!        a1 = (1.0-fact)*lookup(item,ilwc) + fact*lookup(item+1,ilwc)
+!        a2 = (1.0-fact)*lookup(item,ilwc+1) + fact*lookup(item+1,ilwc+1)
+        a1 = (1.0-fact)*lookup(item,ilwc) +      &
+     &          fact*lookup(Min(nt,item+1),ilwc)
+        a2 = (1.0-fact)*lookup(item,ilwc+1) +      &
+     &          fact*lookup(Min(nt,item+1),ilwc+1)
+        ftlwc = fac*(a1 + facl*(a2-a1))
+        
+!        alf = Min(5.0*(awdia/d0)**2*Abs(vt)/v0,10.0)
+        ftlwc = 1.0e-15*ftlwc
+      END IF
+      
+      RETURN
+      END subroutine TAKA3
 
-      nxmpb = 1
-      nzmpb = 1
-      nxz = nxi*nz
-      numgs = nxz/ngs + 1
+! ####################################################################
+!                SUBROUTINE TAKA4
+! ####################################################################
+      subroutine TAKA4(nt,nlc,lookup,temcg,qcw,vt,awdia,rho0,ftlwc)
+      
+! ####################################################################
+!
+!  Purpose:
+!           Noninductive charging per Takahashi 1978 lab results.  
+!           Using lookup table from Wojcik (1994).  For temperatures
+!           lower than -30 C, the values at -30 C are used.
+!
+!  7/31/99 Now limit low-temp charging rates by a parabolic function
+!          with a value of zero at -30 C and goes to zero at -43 C.
+!         
+!  8/10/99 Fixed bug in the interpolation: was accidentally 
+!          _extrapolating_.   Oops.
+!
+! ####################################################################
+      
+      implicit none
+      
+      integer nt,nlc
+      real lookup(0:nt,0:nlc) 
+      real qlwc
+      real qcw
+      real rho0
+      real ftlwc
+      real temt,temcg
+      integer item,ilwc
+      real fact,facl
+      real a1,a2,a3
+      real alf
+      real vt
+      real awdia
+      real d0
+      parameter(d0 = 100.0e-6)
+      real v0 
+      parameter(v0 = 8.0)
+      real fac
+      
+!  BEGIN EXECUTABLE CODE
+
+      IF ( temcg .gt. -30 ) THEN
+        fac = 1.0
+      ELSEIF ( temcg .gt. -40.0 ) THEN
+        fac = 1.0 - ((temcg+30.0)/(40.0 - 30.0))**2
+      ELSE
+        fac = 0.0
+      END IF
+      
+      
+      temt = Max (temcg, -30.0)
+      item = Int(-temt) + 1
+      qlwc = qcw*(1.e3)*rho0
+      
+      qlwc = Min ( qlwc, 30.0)
+      ilwc = 0
+      ftlwc = 0.0
+      
+      IF (qlwc .ge. 10.0) THEN
+        ilwc = Int( qlwc/10.0 + 1.0e-5) + 1 + 27
+        facl = (qlwc - lookup(0,ilwc) )*0.1
+      ELSEIF (qlwc .ge. 1.0) THEN
+        ilwc = Int( qlwc + 1.0e-5) + 1 + 18
+        facl = (qlwc - lookup(0,ilwc) )*1.0
+      ELSEIF (qlwc .ge. 0.1) THEN
+        ilwc = Int( qlwc*10.0 + 1.0e-5 ) + 1 + 9
+        facl = (qlwc - lookup(0,ilwc) )*10.0
+      ELSEIF (qlwc .ge. 0.01) THEN
+        ilwc = Int ( qlwc*100.0 + 1.0e-5) + 1
+        facl = (qlwc - lookup(0,ilwc) )*100.0
+      ELSE 
+         ilwc = 0
+         ftlwc = 0.0
+      END IF
+
+      IF (ilwc .gt. 0) THEN
+        fact = -temt - Float(item) + 1.0
+!        a1 = (1.0-fact)*lookup(item,ilwc) + fact*lookup(item+1,ilwc)
+!        a2 = (1.0-fact)*lookup(item,ilwc+1) + fact*lookup(item+1,ilwc+1)
+        a1 = (1.0-fact)*lookup(item,ilwc) +      &
+     &          fact*lookup(Min(nt,item+1),ilwc)
+        a2 = (1.0-fact)*lookup(item,ilwc+1) +      &
+     &          fact*lookup(Min(nt,item+1),ilwc+1)
+        ftlwc = fac*(a1 + facl*(a2-a1))
+        
+        alf = Min(5.0*(3.67*awdia/d0)**2*Abs(vt)/v0,10.0)
+        ftlwc = 1.0e-15*alf*ftlwc
+      END IF
+      
+      RETURN
+      END subroutine TAKA4
 
+! ####################################################################
+!                SUBROUTINE SAUND6
+! ####################################################################
+      subroutine saund6(temcg,qcw,exw,vt,awdia,rho0,qsign,ftrar,     &
+     &                 qconkq,qconm,qconn,idelq,qfac,rarfac)
+      
+! ####################################################################
+!
+!  Purpose:
+!   Saunders charging scheme based on rime accretion rate (RAR)
+!   as in Brooks et al. (1997) and Saunders and Peck (1998)
+!
+! 10/12/2003:  Add line 'rarc = Max(rarc, 0.0)' to prevent negative
+!              values of rarc for -43 < T < -40
+!
+!
+! 7/27/2000 Try with original Saunders and Peck curve (1998) plus the 
+!           drop-off starting at -23.7
+!
+!
+! 7/24/99  new adjustment to RARcritical curve: make a cubic drop-off
+!          from -23.7 to -40 (and zero charging below -40) 
+!         (correction, 10/12/2003: charging was set zero below -43, not -40)
+!
+! 12/8/99 temporary test of putting in a factor of (3.67)**qconm to
+!         approximate using the mass-weighted mean crystal diameter
+!
+! 12/17/99 for positive charging, just use ftrar = 6.74*( rar - rarc )
+!          for all temperatures (took out alternate eq. for T<-34)
+!
+! ####################################################################
+      
+      implicit none
+      real temcg ! temperature
+      real qcw ! cloud water mixing ratio 
+      real exw ! cloud water collection efficiency
+      real vt ! terminal speed difference between x and cw 
+      real awdia ! crystal diameter
+      real rho0  ! air density
+      real qsign ! sign of charge acquired by rimer (not used by calling prog)
+      real ftrar ! charge factor based on temp and RAR 
+      real qconkq ! factor kq ( or 'B') 
+      real qconm  ! exponent on crystal diameter ('a')
+      real qconn  ! exponent on speed ('b')
+      integer idelq ! charge sign, not used by calling program
+      real qfac
+      real rarfac  ! factor to reduce rar for purposes of charge calculation
+      
+      real rar ! rime accretion rate
+      real rarc ! critical RAR
+      real t,tc
+      parameter (tc = -23.7)
+      real delr,delri
+      parameter (delr=0.5, delri=1.0/delr)
+      real rar0  ! lower limit of RAR where charging goes to zero
+      parameter (rar0 = 0.1)
+      real q0
+      parameter (q0 = 6.48)
+      real tema,tmin
+      parameter (tema = -7.0 , tmin = -37.0)
+      integer ibs
+      
+      real fac
+      
+! ####################################################################
+! Begin Executable code
+! ####################################################################
 
-      do 2000 inumgs = 1,numgs
+      IF ( temcg .gt. -30. ) THEN
+        fac = 1.0
+!      ELSEIF ( temcg .gt. -40.0 ) THEN
+!        fac = 1.0 - ((temcg+30.0)/(40.0 - 30.0))**2
+      ELSEIF ( temcg .gt. tmin ) THEN
+        fac = 1.0 - ((temcg+30.0)/(-tmin - 30.0))**2
+      ELSE
+        fac = 0.0
+      END IF
 
-      ngscnt = 0
+      IF ( rarfac .gt. 0.0 ) THEN
+        ibs = 0
+      ELSE
+        ibs = 1
+      ENDIF
+      
+      ftrar = 0.0
+      
+      rar = exw*qcw*1.0e3*rho0*vt*Abs(rarfac)
+      t = temcg
 
+      IF ( ibs .eq. 1 .and. t .gt. -15.0 ) THEN
+       rarc = Max( 0.0, Min( 3.29, -1.47 - 0.2*t ) )
+      ELSE
+        IF (t .gt. tc ) THEN
+        rarc = 1.0 + t*(7.9262e-2 + t*(4.4847e-2 +     &
+     &    t*(7.4754e-3 + t*(5.4686e-4 +     &
+     &    t*(1.6737e-5 + t*1.7613e-7)))))
+!      ELSE ! IF ( t .le. -23.0) THEN
+!       rarc = 3.27
+!      ELSE ! IF ( t .le. -30.0) THEN
+!       rarc = 1.795
+        ELSE ! IF ( t .le. tc) THEN
+         rarc = 3.39608*( 1.0 - Abs( ( (t - tc)/(tc - tmin) )**3) )
+        ENDIF
+      ENDIF
+      
+       rarc = Max(rarc, rar0)  ! ERM 10/12/2003; changed 0 to rar0 5/8/2004
 
-      kzb = nzmpb
-      kze = nz-kstag
- !     if (kzbeg .le. nzmpb .and. kzend .gt. nzmpb) kzb = nzmpb
+!
+! New option (2/9/2005) to use original SP98 equation and cut off charging where
+!  it hits zero
+!
+      IF ( idelq .eq. 1 ) THEN  
+      
+        IF ( t .le. tc) THEN
+        rarc = Max(0.0, 1.0 + t*(7.9262e-2 + t*(4.4847e-2 +     &
+     &    t*(7.4754e-3 + t*(5.4686e-4 +     &
+     &    t*(1.6737e-5 + t*1.7613e-7))))) )
+        END IF
+        
+        IF ( t .lt. -33. ) rarc = rar0
+      
+        IF ( temcg .gt. -25.0 ) THEN
+          fac = 1.0
+        ELSEIF ( temcg .gt. -32.47 ) THEN
+          fac = 1.0 + ((temcg+25.0)/(32.47 - 25.00))
+        ELSE
+          fac = 0.0
+          qsign = 0.0
+          ftrar = 0.0
+          qconkq = 0.0
+          qconn = 1.0
+          qconm = 1.0
+          GOTO 999
+        END IF
+      
+      ENDIF
 
-      ixb = nxmpb
-      ixe = itile
+      
+! check for RAR below threshold:
+      IF ( rar .le. rar0 .or. temcg .le. tmin) THEN
+        qsign = 0.0
+        ftrar = 0.0
+        qconkq = 0.0
+        qconn = 1.0
+        qconm = 1.0
+        GOTO 999
+      END IF
+
+! for now, use charging values at -8.0 for warmer temps
+! and values at -23.0 for colder temps (Saunders and Peck, 1998)      
+      IF (temcg .gt. -8.0 ) THEN
+         t = -8.0
+      ELSEIF (temcg .lt. -23.0) THEN
+         t = -23.0
+      END IF
+      
+      qsign = -1.0
+      IF (rar .gt. rarc) qsign = 1.0
+      
+      IF (qsign .gt. 0.5) THEN
+        
+          ftrar = 6.74*( rar - rarc )
+        
+        if ( awdia*1.e6.lt.155. ) then
+          qconkq = 4.9e13
+          qconm  = 3.76
+          qconn  = 2.5
+        end if
+        if ( awdia*1.e6.ge.155. .and. awdia*1.e6.le.452. ) then
+          qconkq = 4.0e6
+          qconm  = 1.9
+          qconn  = 2.5
+        end if
+        if ( awdia*1.e6.gt.452. ) then
+          qconkq = 52.8
+          qconm  = 0.44
+          qconn  = 2.5
+        end if
+        
+        IF ( qfac .gt. 1.0 ) THEN
+         ftrar = fac*ftrar*qfac**qconm
+        ELSE
+         ftrar = fac*ftrar
+        ENDIF
 
-      do kz = kzb,kze
-      do ix = nxmpb,nxi
+      ELSEIF (qsign .lt. -0.5) THEN
 
-      pqs(1) = 380.0/(pn(ix,jy,kz) + pb(kz))
-      theta(1) = an(ix,jy,kz,lt)
-      temg(1) = t0(ix,jy,kz)
 
-      temcg(1) = temg(1) - tfr
-      ltemq = (temg(1)-163.15)/fqsat+1.5
-      ltemq = Min( nqsat, Max(1,ltemq) )
-      qvs(1) = pqs(1)*tabqvs(ltemq)
-      qis(1) = pqs(1)*tabqis(ltemq)
+        ftrar = Min(1.0, 0.6*Abs(rarc - rar0) )*(6.5)*(-1.0 +      &
+     &    4.0/(rarc - rar0)**2 * (rar - (rarc + rar0)/2.0 )**2  )
+        ftrar = Min( 0.0, ftrar )
+        
+        if ( awdia*1.e6.lt.253. ) then
+          qconkq = 5.24e8
+          qconm  = 2.54
+          qconn  = 2.8
+        end if
+        if ( awdia*1.e6.gt.253. ) then
+          qconkq = 24.0
+          qconm  = 0.50
+          qconn  = 2.8
+        end if
 
-      qss(1) = qvs(1)
+        IF ( qfac .gt. 1.0 ) THEN
+         ftrar = fac*ftrar*qfac**qconm
+        ELSE
+         ftrar = fac*ftrar
+        ENDIF
+        
+      END IF
+      
+      
+ 999  CONTINUE      
+      RETURN
+      END subroutine saund6
 
 
-      if ( temg(1) .lt. tfr ) then
-      end if
+! ####################################################################
+!                SUBROUTINE SAUND8
+! ####################################################################
+      subroutine saund8(temcg,qcw,exw,vt,awdia,rho0,qsign,ftrar,     &
+     &                 qconkq,qconm,qconn,idelq,qfac,rarfac)
+      
+! ####################################################################
 !
-      if ( (temg(1) .gt. tfrh ) .and.  &
-     &   ( an(ix,jy,kz,lv)  .gt. qss(1) .or. &
-     &     an(ix,jy,kz,lc)  .gt. qxmin(lc)   .or.  &
-     &     ( an(ix,jy,kz,lr)  .gt. qxmin(lr) .and. rcond == 2 )  &
-     &     )) then
-      ngscnt = ngscnt + 1
-      igs(ngscnt) = ix
-      kgs(ngscnt) = kz
-      if ( ngscnt .eq. ngs ) goto 2100
-      end if
-
-      end do  !ix
-
-      nxmpb = 1
-      end do  !kz
-!      if ( jy .eq. (ny-jstag) ) iend = 1
- 2100 continue
-
-      if ( ngscnt .eq. 0 ) go to 29998
-
-      if (ndebug .gt. 0 ) write(0,*) 'ICEZVD_DR: dbg = 8'
+!  Purpose:
+!   Saunders charging scheme based on rime accretion rate (RAR)
+!   as in Brooks et al. (1997) and Saunders and Peck (1998)
+!
+! 10/12/2003:  Add line 'rarc = Max(rarc, 0.0)' to prevent negative
+!              values of rarc for -43 < T < -40
+!
+!
+! 7/27/2000 Try with original Saunders and Peck curve (1998) plus the 
+!           drop-off starting at -23.7
+!
+!
+! 7/24/99  new adjustment to RARcritical curve: make a cubic drop-off
+!          from -23.7 to -40 (and zero charging below -40) 
+!         (correction, 10/12/2003: charging was set zero below -43, not -40)
+!
+! 12/8/99 temporary test of putting in a factor of (3.67)**qconm to
+!         approximate using the mass-weighted mean crystal diameter
+!
+! 12/17/99 for positive charging, just use ftrar = 6.74*( rar - rarc )
+!          for all temperatures (took out alternate eq. for T<-34)
+!
+! ####################################################################
       
-!      write(0,*) 'NUCOND: dbg = 8, ngscnt,ssmx = ',ngscnt,ssmx
-
+      implicit none
+      real temcg ! temperature
+      real qcw ! cloud water mixing ratio 
+      real exw ! cloud water collection efficiency
+      real vt ! terminal speed difference between x and cw 
+      real awdia ! crystal diameter
+      real rho0  ! air density
+      real qsign ! sign of charge acquired by rimer (not used by calling prog)
+      real ftrar ! charge factor based on temp and RAR 
+      real qconkq ! factor kq ( or 'B') 
+      real qconm  ! exponent on crystal diameter ('a')
+      real qconn  ! exponent on speed ('b')
+      integer idelq ! charge sign, not used by calling program
+      real qfac
+      real rarfac  ! factor to reduce rar for purposes of charge calculation
+      
+      real rar ! rime accretion rate
+      real rarc ! critical RAR
+      real t,tc
+!      parameter (tc = -23.7)
+      parameter (tc = -24.5)
+      real delr,delri
+      parameter (delr=0.5, delri=1.0/delr)
+      real rar0  ! lower limit of RAR where charging goes to zero
+      parameter (rar0 = 0.1)
+      real q0
+      parameter (q0 = 6.48)
+      real tema,tmin,tcc
+      parameter (tema = -7.0 , tmin = -37.0)
+      real :: tmincutoff
+      integer ibs
+      real, parameter :: pi = 3.141592654
+      
+      real fac
       
-      qx(:,:) = 0.0
-      cx(:,:) = 0.0
+! ####################################################################
+! Begin Executable code
+! ####################################################################
 
-      xv(:,:) = 0.0
-      xmas(:,:) = 0.0
+      tcc = -30.
+      tmincutoff = -37.
+      IF ( temcg .gt. tcc ) THEN
+        fac = 1.0
+!      ELSEIF ( temcg .gt. -40.0 ) THEN
+!        fac = 1.0 - ((temcg+30.0)/(40.0 - 30.0))**2
+      ELSEIF ( temcg .gt. tmincutoff ) THEN
+!        fac = 1.0 - ((temcg+30.0)/(-tmin - 30.0))**2
+! Cosine funtion roll-off
+         fac = 0.5 *(1. + Cos(pi *(((temcg - tcc)/(-tmincutoff + tcc)))))
+      ELSE
+        fac = 0.0
+      END IF
 
-      IF ( imurain == 1 ) THEN
-        alpha(:,lr) = alphar
-      ELSEIF ( imurain == 3 ) THEN
-        alpha(:,lr) = xnu(lr)
+      IF ( rarfac .gt. 0.0 ) THEN
+        ibs = 0
+      ELSE
+        ibs = 1
       ENDIF
+      
+      ftrar = 0.0
+      
+      rar = exw*qcw*1.0e3*rho0*vt*Abs(rarfac)
+      t = temcg
 
-!
-!  define temporaries for state variables to be used in calculations
-!
-      DO mgs = 1,ngscnt
-      qx(mgs,lv) = an(igs(mgs),jy,kgs(mgs),lv)
-       DO il = lc,lhab
-        qx(mgs,il) = max(an(igs(mgs),jy,kgs(mgs),il), 0.0)
-       ENDDO
-
-       qcwtmp(mgs) = qx(mgs,lc)
-
-
-      theta0(mgs) = an(igs(mgs),jy,kgs(mgs),lt) !
-      thetap(mgs) = 0.0
-      theta(mgs) = an(igs(mgs),jy,kgs(mgs),lt)
-      qv0(mgs) =  qx(mgs,lv)
-      qwvp(mgs) = qx(mgs,lv) - qv0(mgs)
+      IF ( ibs .eq. 1 .and. t .gt. -15.0 ) THEN
+       rarc = Max( 0.0, Min( 3.29, -1.47 - 0.2*t ) )
+      ELSE
+        IF (t .gt. tc ) THEN
+        rarc = 1.0 + t*(7.9262e-2 + t*(4.4847e-2 +     &
+     &    t*(7.4754e-3 + t*(5.4686e-4 +     &
+     &    t*(1.6737e-5 + t*1.7613e-7)))))
+!      ELSE ! IF ( t .le. -23.0) THEN
+!       rarc = 3.27
+!      ELSE ! IF ( t .le. -30.0) THEN
+!       rarc = 1.795
+        ELSEIF ( t > tmin) THEN
+!         rarc = 3.39608*( 1.0 - Abs( ( (t - tc)/(tc - tmin) )**3) )
+         rarc = 3.42533* 0.5 *(1. + Cos(pi *(((t - tc)/(-tmin + tc))))) ! 3.42533 is the value on the curve at T = -24.5284
+        ELSE
+          rarc = 0
+        ENDIF
+      ENDIF
+      
+       rarc = Max(rarc, rar0)  ! ERM 10/12/2003; changed 0 to rar0 5/8/2004
 
-       pres(mgs) = pn(igs(mgs),jy,kgs(mgs)) + pb(kgs(mgs))
-       pipert(mgs) = p2(igs(mgs),jy,kgs(mgs))
-       rho0(mgs) = dn(igs(mgs),jy,kgs(mgs))
-       rhoinv(mgs) = 1.0/rho0(mgs)
-       rhovt(mgs) = Sqrt(rho00/rho0(mgs))
-       pi0(mgs) = p2(igs(mgs),jy,kgs(mgs)) + pinit(kgs(mgs))
-       temg(mgs) = t0(igs(mgs),jy,kgs(mgs))
-!       pk(mgs) = t77(igs(mgs),jy,kgs(mgs)) ! ( pres(mgs) / poo ) ** cap
-       pk(mgs)   = p2(igs(mgs),jy,kgs(mgs)) + pinit(kgs(mgs)) ! t77(igs(mgs),jy,kgs(mgs))
-       temcg(mgs) = temg(mgs) - tfr
-       qss0(mgs) = (380.0)/(pres(mgs))
-       pqs(mgs) = (380.0)/(pres(mgs))
-       ltemq = (temg(mgs)-163.15)/fqsat+1.5
-       ltemq = Min( nqsat, Max(1,ltemq) )
-       qvs(mgs) = pqs(mgs)*tabqvs(ltemq)
-       qis(mgs) = pqs(mgs)*tabqis(ltemq)
 !
-        qvap(mgs) = max( (qwvp(mgs) + qv0(mgs)), 0.0 )
-        es(mgs) = 6.1078e2*tabqvs(ltemq)
-        qss(mgs) = qvs(mgs)
-
-
-        temgx(mgs) = min(temg(mgs),313.15)
-        temgx(mgs) = max(temgx(mgs),233.15)
-        felv(mgs) = 2500837.367 * (273.15/temgx(mgs))**((0.167)+(3.67e-4)*temgx(mgs))
+! New option (2/9/2005) to use original SP98 equation and cut off charging where
+!  it hits zero
 !
-        IF ( eqtset <= 1 ) THEN
-          felvcp(mgs) = felv(mgs)*cpi
-        ELSE ! equation set 2 in cm1
-          tmp = qx(mgs,li)+qx(mgs,ls)+qx(mgs,lh)
-          IF ( lhl > 1 ) tmp = tmp + qx(mgs,lhl)
-          cvm = cv+cvv*qx(mgs,lv)+cpl*(qx(mgs,lc)+qx(mgs,lr))   &
-                                  +cpigb*(tmp)
-          cpm = cp+cpv*qx(mgs,lv)+cpl*(qx(mgs,lc)+qx(mgs,lr))   &
-                                  +cpigb*(tmp)
-          rmm=rd+rw*qx(mgs,lv)
-          
-          IF ( eqtset == 2 ) THEN
-
-           felvcp(mgs) = (felv(mgs)-rw*temg(mgs))/cvm
-
-          ELSE
-            felvcp(mgs) = (felv(mgs)*cv/(cp) - rw*temg(mgs)*(1.0-rovcp*cpm/rmm))/cvm
-            felvpi(mgs) = pi0(mgs)*rovcp*(felv(mgs)/(temg(mgs)) - rw*cpm/rmm)/cvm
-          ENDIF
+      IF ( idelq .eq. 1 ) THEN  
+      
+        IF ( t .le. tc) THEN
+        rarc = Max(0.0, 1.0 + t*(7.9262e-2 + t*(4.4847e-2 +     &
+     &    t*(7.4754e-3 + t*(5.4686e-4 +     &
+     &    t*(1.6737e-5 + t*1.7613e-7))))) )
+        END IF
+        
+        IF ( t .lt. -33. ) rarc = rar0
+      
+        IF ( temcg .gt. -25.0 ) THEN
+          fac = 1.0
+        ELSEIF ( temcg .gt. -32.47 ) THEN
+          fac = 1.0 + ((temcg+25.0)/(32.47 - 25.00))
+        ELSE
+          fac = 0.0
+          qsign = 0.0
+          ftrar = 0.0
+          qconkq = 0.0
+          qconn = 1.0
+          qconm = 1.0
+          GOTO 999
+        END IF
+      
+      ENDIF
 
+      
+! check for RAR below threshold:
+      IF ( rar .le. rar0 .or. temcg .le. tmin) THEN
+        qsign = 0.0
+        ftrar = 0.0
+        qconkq = 0.0
+        qconn = 1.0
+        qconm = 1.0
+        GOTO 999
+      END IF
+
+! for now, use charging values at -8.0 for warmer temps
+! and values at -23.0 for colder temps (Saunders and Peck, 1998)      
+      IF (temcg .gt. -8.0 ) THEN
+         t = -8.0
+      ELSEIF (temcg .lt. -23.0) THEN
+         t = -23.0
+      END IF
+      
+      qsign = -1.0
+      IF (rar .gt. rarc) qsign = 1.0
+      
+      IF (qsign .gt. 0.5) THEN
+        
+          ftrar = 6.74*( rar - rarc )
+        
+        if ( awdia*1.e6.lt.155. ) then
+          qconkq = 4.9e13
+          qconm  = 3.76
+          qconn  = 2.5
+        end if
+        if ( awdia*1.e6.ge.155. .and. awdia*1.e6.le.452. ) then
+          qconkq = 4.0e6
+          qconm  = 1.9
+          qconn  = 2.5
+        end if
+        if ( awdia*1.e6.gt.452. ) then
+          qconkq = 52.8
+          qconm  = 0.44
+          qconn  = 2.5
+        end if
+        
+        IF ( qfac .gt. 1.0 ) THEN
+         ftrar = fac*ftrar*qfac**qconm
+        ELSE
+         ftrar = fac*ftrar
         ENDIF
 
-        temcgx(mgs) = min(temg(mgs),273.15)
-        temcgx(mgs) = max(temcgx(mgs),223.15)
-        temcgx(mgs) = temcgx(mgs)-273.15
-        felf(mgs) = 333690.6098 + (2030.61425)*temcgx(mgs) - (10.46708312)*temcgx(mgs)**2
-!
-        fels(mgs) = felv(mgs) + felf(mgs)
-        fcqv1(mgs) = 4098.0258*felv(mgs)*cpi
-
-      wvdf(mgs) = (2.11e-05)*((temg(mgs)/tfr)**1.94)* &
-     &  (101325.0/(pb(kgs(mgs)) + pn(igs(mgs),jgs,kgs(mgs))))                            ! diffusivity of water vapor, Hall and Pruppacher (76)
-      advisc(mgs) = advisc0*(416.16/(temg(mgs)+120.0))* &
-     &  (temg(mgs)/296.0)**(1.5)                         ! dynamic viscosity (SMT; see Beard & Pruppacher 71)
-      tka(mgs) = tka0*advisc(mgs)/advisc1                 ! thermal conductivity
-
+      ELSEIF (qsign .lt. -0.5) THEN
 
-      ENDDO
 
+        ftrar = Min(1.0, 0.6*Abs(rarc - rar0) )*(6.5)*(-1.0 +      &
+     &    4.0/(rarc - rar0)**2 * (rar - (rarc + rar0)/2.0 )**2  )
+        ftrar = Min( 0.0, ftrar )
+        
+        if ( awdia*1.e6.lt.253. ) then
+          qconkq = 5.24e8
+          qconm  = 2.54
+          qconn  = 2.8
+        end if
+        if ( awdia*1.e6.gt.253. ) then
+          qconkq = 24.0
+          qconm  = 0.50
+          qconn  = 2.8
+        end if
 
+        IF ( qfac .gt. 1.0 ) THEN
+         ftrar = fac*ftrar*qfac**qconm
+        ELSE
+         ftrar = fac*ftrar
+        ENDIF
+        
+      END IF
+      
+      
+ 999  CONTINUE      
+      RETURN
+      END subroutine saund8
 
+! ####################################################################
+!                SUBROUTINE SAUND2
+! ####################################################################
+      subroutine saund2(temcg,qcw,exw,vt,awdia,rho0,qsign,ftrar,     &
+     &                 qconkq,qconm,qconn,idelq,qfac,rarfac)
+      
+! ####################################################################
 !
-! load concentrations
+!  Purpose:
+!   Saunders charging scheme based on rime accretion rate (RAR)
+!   as in Brooks et al. (1997) and Saunders and Peck (1998)
 !
-      if ( ipconc .ge. 1 ) then
-       do mgs = 1,ngscnt
-        cx(mgs,li) = Max(an(igs(mgs),jy,kgs(mgs),lni), 0.0)
-       end do
-      end if
-      if ( ipconc .ge. 2 ) then
-       do mgs = 1,ngscnt
-        cx(mgs,lc) = Max(an(igs(mgs),jy,kgs(mgs),lnc), 0.0)
-        cwnccn(mgs) = cwccn*rho0(mgs)/rho00
-        cn(mgs) = 0.0
-        IF ( lss > 1 ) ssmax(mgs) = an(igs(mgs),jy,kgs(mgs),lss)
-        IF ( lccn .gt. 1 ) THEN
-          ccnc(mgs) = an(igs(mgs),jy,kgs(mgs),lccn)
-        ELSE
-          ccnc(mgs) = cwnccn(mgs)
-        ENDIF
-        IF ( lccna > 1 ) THEN
-          ccna(mgs) = an(igs(mgs),jy,kgs(mgs),lccna)
-        ELSE
-          IF ( lccn > 1 ) THEN
-            ccna(mgs) = cwnccn(mgs) - ccnc(mgs)
-          ELSE
-            ccna(mgs) = cx(mgs,lc) ! approximation of number of activated ccn
-          ENDIF
+! 8.27.2002 added rarfac input
+!
+! 7/24/99  new adjustment to RARcritical curve: make a cubic drop-off
+!          from -23.7 to -40 (and zero charging below -40)
+!  version for small droplet curve (Saunders, ICAE 1999)
+! 8/15/99 use higher RARcrit at low temp and keep small droplet
+!
+! 12/8/99 temporary test of putting in a factor of (3.67)**qconm to
+!         approximate using the mass-weighted mean crystal diameter
+!
+! 12/17/99 for positive charging, just use ftrar = 6.74*( rar - rarc )
+!          for all temperatures (took out alternate eq. for T<-34)
+!
+! ####################################################################
+      
+      implicit none
+      real temcg ! temperature
+      real qcw ! cloud water mixing ratio 
+      real exw ! cloud water collection efficiency
+      real vt ! terminal speed difference between x and cw 
+      real awdia ! crystal diameter
+      real rho0  ! air density
+      real qsign ! sign of charge acquired by rimer (not used by calling prog)
+      real ftrar ! charge factor based on temp and RAR 
+      real qconkq ! factor kq ( or 'B') 
+      real qconm  ! exponent on crystal diameter ('a')
+      real qconn  ! exponent on speed ('b')
+      integer idelq ! charge sign, not used by calling program
+      real qfac
+      
+      real rar ! rime accretion rate
+      real rarc ! critical RAR
+      real t,tc
+      parameter (tc = -23.7)
+      real delr,delri
+      parameter (delr=0.5, delri=1.0/delr)
+      real rar0  ! lower limit of RAR where charging goes to zero
+      parameter (rar0 = 0.1)
+      real q0
+      parameter (q0 = 6.48)
+      real tema,tmin
+      parameter (tema = -7.0 , tmin = -43.)
+      integer ibs
+      
+      real fac,rarfac
+      
+! ####################################################################
+! Begin Executable code
+! ####################################################################
+
+      IF ( temcg .gt. -30 ) THEN
+        fac = 1.0
+      ELSEIF ( temcg .gt. -40.0 ) THEN
+        fac = 1.0 - ((temcg+30.0)/(40.0 - 30.0))**2
+      ELSE
+        fac = 0.0
+      END IF
+      
+      IF ( rarfac .gt. 0.0 ) THEN
+        ibs = 0
+      ELSE
+        ibs = 1
+      ENDIF
+      
+      ftrar = 0.0
+      
+      rar = exw*qcw*1.0e3*rho0*vt*Abs(rarfac)
+      t = temcg
+      IF ( ibs .eq. 1 .and. t .gt. -15.0 ) THEN
+       rarc = Max( rar0, Min( 3.29, -1.47 - 0.2*t ) )
+      ELSE
+        IF (t .gt. -7.0 ) THEN
+         rarc = 1.0 + t*(7.9262e-2 + t*(4.4847e-2 +     &
+     &    t*(7.4754e-3 + t*(5.4686e-4 +     &
+     &    t*(1.6737e-5 + t*1.7613e-7)))))
+        ELSEIF ( t .gt. -16.0 ) THEN
+         rarc =  8.0*Abs((tema-t)/(10.0+tema))*     &
+     &      Exp(- Abs((tema-t)/(10.0+tema))) +     &
+     &     1.0 + t*(7.9262e-2 + t*(4.4847e-2 +     &
+     &    t*(7.4754e-3 + t*(5.4686e-4 +     &
+     &    t*(1.6737e-5 + t*1.7613e-7)))))
+        ELSEIF ( t .gt. -21.7 ) THEN
+          rarc = 4*( 1.0 - Abs( ( (t + 25.0 )/(-25.0 - tmin) )**2) )
+        ELSE 
+          rarc = 4*( 1.0 - Abs( ( (-21.7 + 25.0 )/(-25.0 - tmin) )**2) )
         ENDIF
-       end do
-      end if
-      if ( ipconc .ge. 3 ) then
-       do mgs = 1,ngscnt
-        cx(mgs,lr) = Max(an(igs(mgs),jy,kgs(mgs),lnr), 0.0)
-       end do
-      end if
+      ENDIF ! ibs .eq. 1
+      
+! check for RAR below threshold:
+      IF ( rar .le. rar0 .or. temcg .le. tmin) THEN
+        qsign = 0.0
+        ftrar = 0.0
+        qconkq = 0.0
+        qconn = 1.0
+        qconm = 1.0
+        GOTO 999
+      END IF
+
+! for now, use charging values at -8.0 for warmer temps
+! and values at -23.0 for colder temps (Saunder and Peck, 1998)      
+      IF (temcg .gt. -8.0 ) THEN
+         t = -8.0
+      ELSEIF (temcg .lt. -23.0) THEN
+         t = -23.0
+      END IF
+      
+      qsign = -1.0
+      IF (rar .gt. rarc) qsign = 1.0
+      
+      IF (qsign .gt. 0.5) THEN
+        
+!        IF ( Abs(rar - rarc) .lt. delr) THEN
+!         ftrar = delri*Abs(rar - rarc)*
+!     :           (6.74*(rarc + delr) + 1.36*t + 10.5 )
+!        ELSE
+!         ftrar = 6.74*rar + 1.36*t + 10.5
+!        END IF
+!        ftrar = Max(0.0, ftrar)
 
-!        cnuc(1:ngscnt) = cwccn*rho0(mgs)/rho00*(1. - renucfrac) + ccnc(1:ngscnt)*renucfrac
-       DO mgs = 1,ngscnt
-        IF ( irenuc /= 6 ) THEN
-        cnuc(mgs) = Max(ccnc(mgs),cwnccn(mgs))*(1. - renucfrac) + ccnc(mgs)*renucfrac
+!        IF ( Abs(rar - rarc) .lt. delr .and. temcg .gt. tc) THEN
+!         ftrar = Max( 0.0, delri*Abs(rar - rarc)*
+!     :           (6.74*(rarc + delr) + 1.36*t + 10.5 ) )
+!        ELSE
+!         ftrar = Max( 0.0, 6.74*rar + 1.36*t + 10.5 )
+!        END IF
+        
+!        IF ( temcg .gt. -34.0 ) THEN
+          ftrar = 6.74*( rar - rarc )
+!        ELSE
+!          ftrar = Max ( 0.0, 6.74*( rar - 
+!     :     4*( 1.0 - Abs( ( (-34.0 + 25.0 )/(-25.0 - tmin) )**2) ) ) )
+!        END IF
+        
+        if ( awdia*1.e6.lt.155. ) then
+          qconkq = 4.9e13
+          qconm  = 3.76
+          qconn  = 2.5
+        end if
+        if ( awdia*1.e6.ge.155. .and. awdia*1.e6.le.452. ) then
+          qconkq = 4.0e6
+          qconm  = 1.9
+          qconn  = 2.5
+        end if
+        if ( awdia*1.e6.gt.452. ) then
+          qconkq = 52.8
+          qconm  = 0.44
+          qconn  = 2.5
+        end if
+        
+        IF ( qfac .gt. 1.0 ) THEN
+         ftrar = fac*ftrar*qfac**qconm
         ELSE
-        cnuc(mgs) = Max(ccnc(mgs),cwnccn(mgs))*(1. - renucfrac) + Max(0.0,ccnc(mgs) - ccna(mgs))*renucfrac
-        ENDIF
-        IF ( renucfrac >= 0.999 ) THEN
-          IF ( temg(mgs) < 265. ) THEN
-            IF ( qx(mgs,lc) > 10.*qxmin(lc) .and. w(igs(mgs),jgs,kgs(mgs)) > 2.0 ) THEN
-             cnuc(mgs) = 0.0 !  Min(cnuc(mgs), 0.5*cx(mgs,lc) ) ! Hack to reduce nucleation at low temp in updraft when ccn are not predicted
-            ELSE
-             cnuc(mgs) = 0.1*cnuc(mgs)
-            ENDIF
-          ENDIF
+         ftrar = fac*ftrar
         ENDIF
-       ENDDO
 
-!  Set density
-!
-      if (ndebug .gt. 0 ) write(0,*) 'ICEZVD_DR: Set density'
-
-      do mgs = 1,ngscnt
-        xdn(mgs,lc) = xdn0(lc)
-        xdn(mgs,lr) = xdn0(lr)
-      end do
+      ELSEIF (qsign .lt. -0.5) THEN
 
-      ventrx(:) = ventr
-      ventrxn(:) = ventrn
-      
+!        IF ( Abs(rar - rarc) .lt. delr) THEN
+!         ftrar = delri*Abs(rar - rarc)*
+!     :           (3.02 - 10.59*(rarc-delr) + 2.95*(rarc-delr)**2 )
+!        ELSEIF (rar .lt. 0.4) THEN
+!         ftrar = ((rar-0.1)/0.3)*(3.02 - 10.59*(0.4) + 2.95*(0.4)**2)
+!        ELSE
+!         ftrar = 3.02 - 10.59*rar + 2.95*rar**2
+!        END IF
 
+        ftrar = Min(1.0, 0.6*Abs(rarc - rar0) )*(6.5)*(-1.0 +      &
+     &    4.0/(rarc - rar0)**2 * (rar - (rarc + rar0)/2.0 )**2  )
+        ftrar = Min( 0.0, ftrar )
+        
+        if ( awdia*1.e6.lt.253. ) then
+          qconkq = 5.24e8
+          qconm  = 2.54
+          qconn  = 2.8
+        end if
+        if ( awdia*1.e6.gt.253. ) then
+          qconkq = 24.0
+          qconm  = 0.50
+          qconn  = 2.8
+        end if
 
-!       write(0,*) 'NUCOND: Set ssf variables, ssmxinit =',ssmxinit
-      ssmx = 0.0
-      DO mgs = 1,ngscnt
+        IF ( qfac .gt. 1.0 ) THEN
+         ftrar = fac*ftrar*qfac**qconm
+        ELSE
+         ftrar = fac*ftrar
+        ENDIF
+        
+      END IF
       
-      kp1 = Min(nz, kgs(mgs)+1 )
-      wvel(mgs) = (0.5)*(w(igs(mgs),jgs,kp1) & 
-     &                  +w(igs(mgs),jgs,kgs(mgs)))
-      wvelkm1(mgs) = (0.5)*(w(igs(mgs),jgs,kgs(mgs)) & 
-     &                  +w(igs(mgs),jgs,Max(1,kgs(mgs)-1)))
+      
+ 999  CONTINUE      
+      RETURN
+      END subroutine saund2
 
-      ssat0(mgs)  = ssfilt(igs(mgs),jgs,kgs(mgs))
-      ssf(mgs)    = ssfilt(igs(mgs),jgs,kgs(mgs))
-!      ssmx = Max( ssmx, ssf(mgs) )
 
+! ####################################################################
+!                SUBROUTINE SAUND5
+! ####################################################################
+      subroutine saund5(temcg,qcw,exw,vt,awdia,rho0,qsign,ftrar,     &
+     &                 qconkq,qconm,qconn,idelq)
       
-      ssfkp1(mgs) = ssfilt(igs(mgs),jgs,Min(nz-1,kgs(mgs)+1))
-      ssfkm1(mgs) = ssfilt(igs(mgs),jgs,Max(1,kgs(mgs)-1))
+! ####################################################################
+!
+!  Purpose:
+!   Saunders charging scheme based on rime accretion rate (RAR)
+!   as in Brooks et al. (1997) and Saunders and Peck (1998)
+!
+! 7/24/99  new adjustment to RARcritical curve: make a cubic drop-off
+!          from -23.7 to -40 (and zero charging below -40)
+!  version for small droplet curve (Saunders, ICAE 1999)
+! ####################################################################
+      
+      implicit none
+      real temcg ! temperature
+      real qcw ! cloud water mixing ratio 
+      real exw ! cloud water collection efficiency
+      real vt ! terminal speed difference between x and cw 
+      real awdia ! crystal diameter
+      real rho0  ! air density
+      real qsign ! sign of charge acquired by rimer (not used by calling prog)
+      real ftrar ! charge factor based on temp and RAR 
+      real qconkq ! factor kq ( or 'B') 
+      real qconm  ! exponent on crystal diameter ('a')
+      real qconn  ! exponent on speed ('b')
+      integer idelq ! charge sign, not used by calling program
+      
+      real rar ! rime accretion rate
+      real rarc ! critical RAR
+      real t,tc
+      parameter (tc = -23.7)
+      real delr,delri
+      parameter (delr=0.5, delri=1.0/delr)
+      real rar0  ! lower limit of RAR where charging goes to zero
+      parameter (rar0 = 0.1)
+      real q0
+      parameter (q0 = 6.48)
+      real tema,tmin
+      parameter (tema = -7.0 , tmin = -43.)
+      
+! ####################################################################
+! Begin Executable code
+! ####################################################################
+      
+      ftrar = 0.0
+      
+      rar = exw*qcw*1.0e3*rho0*vt
+      t = temcg
+      IF (t .gt. -7.0 ) THEN
+      rarc = 1.0 + t*(7.9262e-2 + t*(4.4847e-2 +     &
+     &  t*(7.4754e-3 + t*(5.4686e-4 +     &
+     &  t*(1.6737e-5 + t*1.7613e-7)))))
+      ELSEIF ( t .gt. -16.0 ) THEN
+       rarc =  8.0*Abs((tema-t)/(10.0+tema))*     &
+     &      Exp(- Abs((tema-t)/(10.0+tema))) +     &
+     &     1.0 + t*(7.9262e-2 + t*(4.4847e-2 +     &
+     &  t*(7.4754e-3 + t*(5.4686e-4 +     &
+     &  t*(1.6737e-5 + t*1.7613e-7)))))
+      ELSE
+       rarc = 4*( 1.0 - Abs( ( (t + 25.0 )/(-25.0 - tmin) )**2) )
+      END IF
+      
+! check for RAR below threshold:
+      IF ( rar .le. rar0 .or. temcg .le. tmin) THEN
+        qsign = 0.0
+        ftrar = 0.0
+        qconkq = 0.0
+        qconn = 1.0
+        qconm = 1.0
+        GOTO 999
+      END IF
+
+! for now, use charging values at -8.0 for warmer temps
+! and values at -23.0 for colder temps (Saunder and Peck, 1998)      
+      IF (temcg .gt. -8.0 ) THEN
+         t = -8.0
+      ELSEIF (temcg .lt. -23.0) THEN
+         t = -23.0
+      END IF
+      
+      qsign = -1.0
+      IF (rar .gt. rarc) qsign = 1.0
+      
+      IF (qsign .gt. 0.5) THEN
+        
+!        IF ( Abs(rar - rarc) .lt. delr) THEN
+!         ftrar = delri*Abs(rar - rarc)*
+!     :           (6.74*(rarc + delr) + 1.36*t + 10.5 )
+!        ELSE
+!         ftrar = 6.74*rar + 1.36*t + 10.5
+!        END IF
+!        ftrar = Max(0.0, ftrar)
 
+!        IF ( Abs(rar - rarc) .lt. delr .and. temcg .gt. tc) THEN
+!         ftrar = Max( 0.0, delri*Abs(rar - rarc)*
+!     :           (6.74*(rarc + delr) + 1.36*t + 10.5 ) )
+!        ELSE
+!         ftrar = Max( 0.0, 6.74*rar + 1.36*t + 10.5 )
+!        END IF
+        
+        IF ( temcg .gt. -34.0 ) THEN
+          ftrar = 6.74*( rar - rarc )
+        ELSE
+          ftrar = Max ( 0.0, 6.74*( rar -      &
+     &     4*( 1.0 - Abs( ( (-34.0 + 25.0 )/(-25.0 - tmin) )**2) ) ) )
+        END IF
+        
+        if ( awdia*1.e6.lt.155. ) then
+          qconkq = 4.9e13
+          qconm  = 3.76
+          qconn  = 2.5
+        end if
+        if ( awdia*1.e6.ge.155. .and. awdia*1.e6.le.452. ) then
+          qconkq = 4.0e6
+          qconm  = 1.9
+          qconn  = 2.5
+        end if
+        if ( awdia*1.e6.gt.452. ) then
+          qconkq = 52.8
+          qconm  = 0.44
+          qconn  = 2.5
+        end if
 
-      ENDDO
+      ELSEIF (qsign .lt. -0.5) THEN
 
+!        IF ( Abs(rar - rarc) .lt. delr) THEN
+!         ftrar = delri*Abs(rar - rarc)*
+!     :           (3.02 - 10.59*(rarc-delr) + 2.95*(rarc-delr)**2 )
+!        ELSEIF (rar .lt. 0.4) THEN
+!         ftrar = ((rar-0.1)/0.3)*(3.02 - 10.59*(0.4) + 2.95*(0.4)**2)
+!        ELSE
+!         ftrar = 3.02 - 10.59*rar + 2.95*rar**2
+!        END IF
 
+        ftrar = Min(1.0, 0.6*Abs(rarc - rar0) )*(6.5)*(-1.0 +      &
+     &    4.0/(rarc - rar0)**2 * (rar - (rarc + rar0)/2.0 )**2  )
+        ftrar = Min( 0.0, ftrar )
+        
+        if ( awdia*1.e6.lt.253. ) then
+          qconkq = 5.24e8
+          qconm  = 2.54
+          qconn  = 2.8
+        end if
+        if ( awdia*1.e6.gt.253. ) then
+          qconkq = 24.0
+          qconm  = 0.50
+          qconn  = 2.8
+        end if
+      END IF
+      
+      
+ 999  CONTINUE      
+      RETURN
+      END subroutine saund5
 
+! ####################################################################
+!                SUBROUTINE SAUND4
+! ####################################################################
+      subroutine saund4(temcg,qcw,exw,vt,awdia,rho0,qsign,ftrar,     &
+     &                 qconkq,qconm,qconn,idelq)
+      
+! ####################################################################
 !
-!  cloud water variables
+!  Purpose:
+!   Saunders charging scheme based on rime accretion rate (RAR)
+!   as in Brooks et al. (1997) and Saunders and Peck (1998)
 !
-
-      if ( ndebug .gt. 0 )write(0,*) 'ICEZVD_DR: Set cloud water variables'
-
-      do mgs = 1,ngscnt
-      xv(mgs,lc) = 0.0
-      IF ( ipconc .ge. 2 .and. cx(mgs,lc) .gt. 1.0e6 ) THEN
-        xmas(mgs,lc) = &
-     &    min( max(qx(mgs,lc)*rho0(mgs)/cx(mgs,lc),cwmasn),cwmasx )
-        xv(mgs,lc) = xmas(mgs,lc)/xdn(mgs,lc)
-      ELSE
-       IF ( qx(mgs,lc) .gt. qxmin(lc) .and. cx(mgs,lc) .gt. 0.01 ) THEN
-        xmas(mgs,lc) = &
-     &     min( max(qx(mgs,lc)*rho0(mgs)/cx(mgs,lc),xdn(mgs,lc)*xvmn(lc)), &
-     &      xdn(mgs,lc)*xvmx(lc) )
-
-        cx(mgs,lc) = qx(mgs,lc)*rho0(mgs)/xmas(mgs,lc)
-
-       ELSEIF ( qx(mgs,lc) .gt. qxmin(lc) .and. cx(mgs,lc) .le. 0.01 ) THEN
-        xmas(mgs,lc) = xdn(mgs,lc)*4.*pi/3.*(5.0e-6)**3
-        cx(mgs,lc) = rho0(mgs)*qx(mgs,lc)/xmas(mgs,lc)
-
-       ELSE
-        xmas(mgs,lc) = cwmasn
-       ENDIF
-      ENDIF
-      xdia(mgs,lc,1) = (xmas(mgs,lc)*cwc1)**c1f3
-
-
-      end do
+! 10/12/2003:  Add line 'rarc = Max(rarc, 0.0)' to prevent negative
+!              rarc for -43 < T < -40
 !
-! rain
 !
-      do mgs = 1,ngscnt
-      if ( qx(mgs,lr) .gt. qxmin(lr) ) then
-
-      if ( ipconc .ge. 3 ) then
-        xv(mgs,lr) = rho0(mgs)*qx(mgs,lr)/(xdn(mgs,lr)*Max(1.0e-9,cx(mgs,lr)))
-!      parameter( xvmn(lr)=2.8866e-13, xvmx(lr)=4.1887e-9 )  ! mks
-        IF ( xv(mgs,lr) .gt. xvmx(lr) ) THEN
-          xv(mgs,lr) = xvmx(lr)
-          cx(mgs,lr) = rho0(mgs)*qx(mgs,lr)/(xvmx(lr)*xdn(mgs,lr))
-        ELSEIF ( xv(mgs,lr) .lt. xvmn(lr) ) THEN
-          xv(mgs,lr) = xvmn(lr)
-          cx(mgs,lr) = rho0(mgs)*qx(mgs,lr)/(xvmn(lr)*xdn(mgs,lr))
-        ENDIF
-
-        xmas(mgs,lr) = xv(mgs,lr)*xdn(mgs,lr)
-        xdia(mgs,lr,3) = (xmas(mgs,lr)*cwc1)**(1./3.) ! xdia(mgs,lr,1)
-        IF ( imurain == 3 ) THEN
-!          xdia(mgs,lr,1) = (6.*pii*xv(mgs,lr)/(alpha(mgs,lr)+1.))**(1./3.)
-          xdia(mgs,lr,1) = xdia(mgs,lr,3) ! formulae for Ziegler (1985) use mean volume diameter, not lambda**(-1)
-        ELSE ! imurain == 1, Characteristic diameter (1/lambda)
-          xdia(mgs,lr,1) = (6.*piinv*xv(mgs,lr)/((alpha(mgs,lr)+3.)*(alpha(mgs,lr)+2.)*(alpha(mgs,lr)+1.)))**(1./3.)
-        ENDIF
-!        rwrad(mgs) = 0.5*xdia(mgs,lr,1)
+! 7/24/99  new adjustment to RARcritical curve: make a cubic drop-off
+!          from -23.7 to -40 (and zero charging below -40)
+!
+! ####################################################################
+      
+      implicit none
+      real temcg ! temperature
+      real qcw ! cloud water mixing ratio 
+      real exw ! cloud water collection efficiency
+      real vt ! terminal speed difference between x and cw 
+      real awdia ! crystal diameter
+      real rho0  ! air density
+      real qsign ! sign of charge acquired by rimer (not used by calling prog)
+      real ftrar ! charge factor based on temp and RAR 
+      real qconkq ! factor kq ( or 'B') 
+      real qconm  ! exponent on crystal diameter ('a')
+      real qconn  ! exponent on speed ('b')
+      integer idelq ! charge sign, not used by calling program
+      
+      real rar ! rime accretion rate
+      real rarc ! critical RAR
+      real t,tc
+      parameter (tc = -23.7)
+      real delr,delri
+      parameter (delr=0.5, delri=1.0/delr)
+      real rar0  ! lower limit of RAR where charging goes to zero
+      parameter (rar0 = 0.1)
+      real q0
+      parameter (q0 = 6.48)
+      
+! ####################################################################
+! Begin Executable code
+! ####################################################################
+      
+      ftrar = 0.0
+      
+      rar = exw*qcw*1.0e3*rho0*vt
+      t = temcg
+!      IF (t .gt. -23.0 ) THEN
+!      IF (t .gt. -30.0 ) THEN
+      IF (t .gt. tc ) THEN
+      rarc = 1.0 + t*(7.9262e-2 + t*(4.4847e-2 +     &
+     &  t*(7.4754e-3 + t*(5.4686e-4 +     &
+     &  t*(1.6737e-5 + t*1.7613e-7)))))
+!      ELSE ! IF ( t .le. -23.0) THEN
+!       rarc = 3.27
+!      ELSE ! IF ( t .le. -30.0) THEN
+!       rarc = 1.795
+      ELSE ! IF ( t .le. tc) THEN
+       rarc = 3.39608*( 1.0 - Abs( ( (t - tc)/(tc + 40) )**3) )
+      END IF
+
+      
+      rarc = Max(rarc, 0.0)
+
+      
+! check for RAR below threshold:
+      IF ( rar .le. rar0 .or. temcg .le. -40.0) THEN
+        qsign = 0.0
+        ftrar = 0.0
+        qconkq = 0.0
+        qconn = 1.0
+        qconm = 1.0
+        GOTO 999
+      END IF
+
+! for now, use charging values at -8.0 for warmer temps
+! and values at -23.0 for colder temps (Saunder and Peck, 1998)      
+      IF (temcg .gt. -8.0 ) THEN
+         t = -8.0
+      ELSEIF (temcg .lt. -23.0) THEN
+         t = -23.0
+      END IF
+      
+      qsign = -1.0
+      IF (rar .gt. rarc) qsign = 1.0
+      
+      IF (qsign .gt. 0.5) THEN
+        
+!        IF ( Abs(rar - rarc) .lt. delr) THEN
+!         ftrar = delri*Abs(rar - rarc)*
+!     :           (6.74*(rarc + delr) + 1.36*t + 10.5 )
+!        ELSE
+!         ftrar = 6.74*rar + 1.36*t + 10.5
+!        END IF
+!        ftrar = Max(0.0, ftrar)
 
-! Inverse exponential version:
-!        xdia(mgs,lr,1) =
-!     >  (qx(mgs,lr)*rho0(mgs)
-!     > /(pi*xdn(mgs,lr)*cx(mgs,lr)))**(0.333333)
-      ELSE
-        xdia(mgs,lr,1) = &
-     &  (qx(mgs,lr)*rho0(mgs)/(pi*xdn(mgs,lr)*cno(lr)))**(0.25)
-      end if
-      else
-        xdia(mgs,lr,1) = 1.e-9
-!        rwrad(mgs) = 0.5*xdia(mgs,lr,1)
-      end if
+        IF ( Abs(rar - rarc) .lt. delr .and. temcg .gt. tc) THEN
+         ftrar = Max( 0.0, delri*Abs(rar - rarc)*     &
+     &           (6.74*(rarc + delr) + 1.36*t + 10.5 ) )
+        ELSE
+         ftrar = Max( 0.0, 6.74*rar + 1.36*t + 10.5 )
+        END IF
+        
+        if ( awdia*1.e6.lt.155. ) then
+          qconkq = 4.9e13
+          qconm  = 3.76
+          qconn  = 2.5
+        end if
+        if ( awdia*1.e6.ge.155. .and. awdia*1.e6.le.452. ) then
+          qconkq = 4.0e6
+          qconm  = 1.9
+          qconn  = 2.5
+        end if
+        if ( awdia*1.e6.gt.452. ) then
+          qconkq = 52.8
+          qconm  = 0.44
+          qconn  = 2.5
+        end if
 
-      end do
+      ELSEIF (qsign .lt. -0.5) THEN
 
+!        IF ( Abs(rar - rarc) .lt. delr) THEN
+!         ftrar = delri*Abs(rar - rarc)*
+!     :           (3.02 - 10.59*(rarc-delr) + 2.95*(rarc-delr)**2 )
+!        ELSEIF (rar .lt. 0.4) THEN
+!         ftrar = ((rar-0.1)/0.3)*(3.02 - 10.59*(0.4) + 2.95*(0.4)**2)
+!        ELSE
+!         ftrar = 3.02 - 10.59*rar + 2.95*rar**2
+!        END IF
 
+        ftrar = Min(1.0, 0.6*Abs(rarc - rar0) )*(7.0)*(-1.0 +      &
+     &    4.0/(rarc - rar0)**2 * (rar - (rarc + rar0)/2.0 )**2  )
+        ftrar = Min( 0.0, ftrar )
+        
+        if ( awdia*1.e6.lt.253. ) then
+          qconkq = 5.24e8
+          qconm  = 2.54
+          qconn  = 2.8
+        end if
+        if ( awdia*1.e6.gt.253. ) then
+          qconkq = 24.0
+          qconm  = 0.50
+          qconn  = 2.8
+        end if
+      END IF
+      
+      
+ 999  CONTINUE      
+      RETURN
+      END subroutine saund4
+      
+! ####################################################################
+!                SUBROUTINE SAUND3
+! ####################################################################
+      subroutine saund3(temcg,qcw,exw,vt,awdia,rho0,qsign,ftrar,     &
+     &                 qconkq,qconm,qconn,idelq)
+      
+! ####################################################################
 !
-!  Ventilation coefficients
+!  Purpose:
+!   Saunders charging scheme based on rime accretion rate (RAR)
+!   as in Brooks et al. (1997) and Saunders and Peck (1998)
+!
+!  8/2/99  Put in quadratic drop-off in transferred charge 
+!          starting at -30 (fac=1.0) down to -43 (fac=0.0)
+!
+! ####################################################################
+      
+      implicit none
+      real temcg ! temperature
+      real qcw ! cloud water mixing ratio 
+      real exw ! cloud water collection efficiency
+      real vt ! terminal speed difference between x and cw 
+      real awdia ! crystal diameter
+      real rho0  ! air density
+      real qsign ! sign of charge acquired by rimer (not used by calling prog)
+      real ftrar ! charge factor based on temp and RAR 
+      real qconkq ! factor kq ( or 'B') 
+      real qconm  ! exponent on crystal diameter ('a')
+      real qconn  ! exponent on speed ('b')
+      integer idelq ! charge sign, not used by calling program
+      
+      real rar ! rime accretion rate
+      real rarc ! critical RAR
+      real t
+      real delr,delri
+      parameter (delr=0.5, delri=1.0/delr)
+      real rar0  ! lower limit of RAR where charging goes to zero
+      parameter (rar0 = 0.1)
+      real q0
+      parameter (q0 = 6.48)
+      real fac
+      
+! ####################################################################
+! Begin Executable code
+! ####################################################################
+      
+      ftrar = 0.0
 
-      do mgs = 1,ngscnt
+      IF ( temcg .gt. -30 ) THEN
+        fac = 1.0
+      ELSEIF ( temcg .gt. -40.0 ) THEN
+        fac = 1.0 - ((temcg+30.0)/(40.0 - 30.0))**2
+      ELSE
+        fac = 0.0
+      END IF
+      
+      rar = exw*qcw*1.0e3*rho0*vt
+      t = temcg
+      IF (t .gt. -23.0 ) THEN
+!      IF (t .gt. -30.0 ) THEN
+      rarc = 1.0 + t*(7.9262e-2 + t*(4.4847e-2 +     &
+     &  t*(7.4754e-3 + t*(5.4686e-4 +     &
+     &  t*(1.6737e-5 + t*1.7613e-7)))))
+      ELSE ! IF ( t .le. -23.0) THEN
+       rarc = 3.27
+!      ELSE ! IF ( t .le. -30.0) THEN
+!       rarc = 1.795
+      END IF
+      
+      
+! check for RAR below threshold:
+      IF ( rar .le. rar0 ) THEN
+        qsign = 0.0
+        ftrar = 0.0
+        qconkq = 0.0
+        qconn = 1.0
+        qconm = 1.0
+        GOTO 999
+      END IF
+
+! for now, use charging values at -8.0 for warmer temps
+! and values at -23.0 for colder temps (Saunder and Peck, 1998)      
+      IF (temcg .gt. -8.0 ) THEN
+         t = -8.0
+      ELSEIF (temcg .lt. -23.0) THEN
+         t = -23.0
+      END IF
+      
+      qsign = -1.0
+      IF (rar .gt. rarc) qsign = 1.0
+      
+      IF (qsign .gt. 0.5) THEN
+        
+!        IF ( Abs(rar - rarc) .lt. delr) THEN
+!         ftrar = delri*Abs(rar - rarc)*
+!     :           (6.74*(rarc + delr) + 1.36*t + 10.5 )
+!        ELSE
+!         ftrar = 6.74*rar + 1.36*t + 10.5
+!        END IF
+!        ftrar = Max(0.0, ftrar)
 
+         ftrar = fac*Max( 0.0, 6.74*rar + 1.36*t + 10.5 )
+        
+        if ( awdia*1.e6.lt.155. ) then
+          qconkq = 4.9e13
+          qconm  = 3.76
+          qconn  = 2.5
+        end if
+        if ( awdia*1.e6.ge.155. .and. awdia*1.e6.le.452. ) then
+          qconkq = 4.0e6
+          qconm  = 1.9
+          qconn  = 2.5
+        end if
+        if ( awdia*1.e6.gt.452. ) then
+          qconkq = 52.8
+          qconm  = 0.44
+          qconn  = 2.5
+        end if
 
-      fadvisc(mgs) = advisc0*(416.16/(temg(mgs)+120.0))* & 
-     &  (temg(mgs)/296.0)**(1.5)
+      ELSEIF (qsign .lt. -0.5) THEN
 
-      fakvisc(mgs) = fadvisc(mgs)*rhoinv(mgs)
+!        IF ( Abs(rar - rarc) .lt. delr) THEN
+!         ftrar = delri*Abs(rar - rarc)*
+!     :           (3.02 - 10.59*(rarc-delr) + 2.95*(rarc-delr)**2 )
+!        ELSEIF (rar .lt. 0.4) THEN
+!         ftrar = ((rar-0.1)/0.3)*(3.02 - 10.59*(0.4) + 2.95*(0.4)**2)
+!        ELSE
+!         ftrar = 3.02 - 10.59*rar + 2.95*rar**2
+!        END IF
 
-      fwvdf(mgs) = (2.11e-05)*((temg(mgs)/tfr)**1.94)* & 
-     &  (101325.0/(pres(mgs)))
+        ftrar = fac*q0*(-1.0 +      &
+     &    4.0/(rarc - rar0)**2 * (rar - (rarc + rar0)/2.0 )**2  )
+        
+        if ( awdia*1.e6.lt.253. ) then
+          qconkq = 5.24e8
+          qconm  = 2.54
+          qconn  = 2.8
+        end if
+        if ( awdia*1.e6.gt.253. ) then
+          qconkq = 24.0
+          qconm  = 0.50
+          qconn  = 2.8
+        end if
+      END IF
       
-      fschm(mgs) = (fakvisc(mgs)/fwvdf(mgs))
-
-      fvent(mgs) = (fschm(mgs)**(1./3.)) * (fakvisc(mgs)**(-0.5))
+      
+ 999  CONTINUE      
+      RETURN
+      END subroutine saund3
+      
+!
+! 6/21/99 
+!         Also put in a linear drop-off for -7.4 < T < 0
+!       try setting elwc = 0.5*lwc
+!
+!  11.11.03  ERM fixed some bugs that allowed charging at EW below
+!            threshold for T < -20.  Also corrected charging at low EW
+!            at -16 > T > -20.
+!
+! ####################################################################
+!                SUBROUTINE SAUND
+! ####################################################################
+      subroutine saund(temcg,qcw,exw,awdia,rho0,qsign,ftelwc,     &
+     &                 qconkq,qconm,qconn,idelq,ianom)
+     
+      implicit none
+      
+      integer ianom  ! =0 to reduce 'anomalous' regions
+                     ! =1 to keep 'anonmalous' regions unchanged
+                     ! =2 to reduce neg. anom. zone and
+                     !     remove the pos. anom. zone (use normal neg. instead)
+                     ! =3 to run same as Helsdon et al. 2001
+                     ! =4 to run Helsdon et al. 2001 without pos. anom. zone
+                     ! =5 to run Helsdon et al. 2001 without pos. or neg. anom. zones (use normal instead)
+                     ! =(anything else) to remove the anomalous zones altogether
+      real anom
+      integer ieq, iseq
+
+      real temcg ! temperature
+      real qcw ! cloud water mixing ratio 
+      real exw ! cloud water collection efficiency
+!      real vt ! terminal speed difference between x and cw 
+      real awdia ! crystal diameter
+      real rho0  ! air density
+      real qsign ! sign of charge acquired by rimer (not used by calling prog)
+      real ftrar ! charge factor based on temp and RAR 
+      real qconkq ! factor kq ( or 'B') 
+      real qconm  ! exponent on crystal diameter ('a')
+      real qconn  ! exponent on speed ('b')
+      integer idelq ! charge sign, not used by calling program
+      real ftelwc, fac
+      
+      real elwc, trevsau, qlwc, pi, cew
+!
+! ####################################################
+!
+
+      IF ( temcg .gt. -30 ) THEN
+        fac = 1.0
+      ELSEIF ( temcg .gt. -40.0 ) THEN
+        fac = 1.0 - ((temcg+30.0)/(40.0 - 30.0))**2
+      ELSE
+        fac = 0.0
+      END IF
 
-      end do
+      ieq = 0
+      pi    = 4.*atan(1.0)
 !
+      qlwc = qcw*(1.e3)*rho0
+      elwc = qlwc*Min(1.0,exw)
+!      elwc = qlwc*0.5
 !
-!  Ziegler nucleation 
 !
+!   Saunders et al. 1991 non-inductive parameterizations
 !
-! cloud evaporation, condensation, and nucleation
-!  sqsat -> qss(mgs)
-
-      DO mgs=1,ngscnt
-        dcloud = 0.0
-        IF ( temg(mgs) .le. tfrh ) THEN
-         CYCLE
-        ENDIF
+!
+      idelq = 0
+      ftelwc = 0.0
+      qsign = 0.0
+      qconkq = 0.0
+      qconm = 1.0
+      qconn = 1.0
 
-      IF( ssat0(mgs) .GT. 0. .OR. ssf(mgs) .GT. 0. ) GO TO 620
-!6/4      IF( qvap(mgs) .EQ. qss(mgs) ) GO TO 631
+      IF ( ( temcg .lt. -20.0 .and. elwc .le. 0.061 ) .or.     &
+     &     (  elwc .le. 0.026 ) ) THEN
+       RETURN
+      ENDIF
 !
-!.... EVAPORATION. QV IS LESS THAN qss(mgs).
-!.... EVAPORATE CLOUD FIRST
+!   case I  (positive anomalous zone)
 !
-      IF ( qx(mgs,lc) .LE. 0. ) GO TO 631
-!.... CLOUD EVAPORATION.
-! convert input 'cp' to cgs
-      R1=1./(1. + caw*(273.15 - cbw)*qss(mgs)*felv(mgs)/ &
-     &            (cp*(temg(mgs) - cbw)**2))
-      QEVAP= Min( qx(mgs,lc), R1*(qss(mgs)-qvap(mgs)) )
-
-
-      IF ( qx(mgs,lc) .LT. QEVAP ) THEN ! GO TO 63
-        qwvp(mgs) = qwvp(mgs) + qx(mgs,lc)
-        thetap(mgs) = thetap(mgs) - felv(mgs)*qx(mgs,lc)/(cp*pi0(mgs))
-        IF ( io_flag .and. nxtra > 1 ) THEN
-           axtra(igs(mgs),jy,kgs(mgs),1) = -qx(mgs,lc)/dtp
-        ENDIF
-        qx(mgs,lc) = 0.
-        cx(mgs,lc) = 0.
+      IF ( ( temcg.lt.(-20.0) .or.      &
+     &    ( temcg.lt.(-18.0) .and. ianom .ne. 3 ) )     &
+     &      .and. elwc.lt.(0.1596) .and. ianom .ne. 2      &
+     &       .and. ianom .ne. 4 .and. ianom .ne. 5 ) then
+!
+      ieq = 1
+      idelq = 1
+!
+!  sign
+!
+      qsign = 1.0
+!
+!  f(t,lwc)
+!
+      ftelwc = 0.0
+      
+      if (elwc.lt.(0.12).and.elwc.gt.(0.061)) then
+      ftelwc = ( (2041.76)*elwc-(128.70) )
+      end if
+      if (elwc.lt.(0.1596).and.elwc.ge.(0.12)) then
+      ftelwc = ( (-2900.22)*elwc+(462.91) )
+      end if
+      
+      IF ( temcg .gt. -20.0 ) THEN
+       ftelwc = ftelwc*( -temcg - 18.0 )*0.5
+      ENDIF
+!
+! f(awdia)
+!
+      
+      IF ( ianom .eq. 0 .or. ianom .eq. 3 ) THEN
+         anom = 0.1
+      ELSEIF ( ianom .eq. 1 ) THEN
+         anom = 1.0
       ELSE
-        qwvp(mgs) = qwvp(mgs) + QEVAP
-        qx(mgs,lc) = qx(mgs,lc) - QEVAP
-        IF ( qx(mgs,lc) .le. 0. ) cx(mgs,lc) = 0.
-        thetap(mgs) = thetap(mgs) - felv(mgs)*QEVAP/(CP*pi0(mgs))
-        IF ( io_flag .and. nxtra > 1 ) THEN
-           axtra(igs(mgs),jy,kgs(mgs),1) = -QEVAP/dtp
-        ENDIF
-
+         anom = 0.0
       ENDIF
+      
+      if ( awdia*1.e6.lt.155. ) then
+      qconkq = anom*4.9e13
+      qconm  = 3.76
+      qconn  = 2.5
+      end if
+      if ( awdia*1.e6.ge.155. .and.      &
+     &     awdia*1.e6.le.452. ) then
+      qconkq = anom*4.9e6
+      qconm  = 1.9
+      qconn  = 2.5
+      end if
+      if ( awdia*1.e6.gt.452. ) then
+      qconkq = anom*52.8
+      qconm  = 0.44
+      qconn  = 2.5
+      end if
+!
+!  end case I
+!
+      end if
+!
+!
+!   case II  (zero charging at low EW)
+!
+      if ( ( (temcg.ge.(-20.0) .or. (ianom.eq.2) ) .and.      &
+     &      temcg.lt.(-16.0)) .and.      &
+     &     elwc.lt.(0.06) ) then
+!
+      ieq = 2
+      idelq = 1
+!
+!  sign
+!
+      qsign = 0.0
+!
+!  f(t,lwc)
+!
+      ftelwc = 0.0
+!
+! f(awdia)
+!
+      qconkq = 0.0
+      qconm  = 1.0
+      qconn  = 1.0
+!
+!  end case II
+!
+      end if
+!
+!   case III  (negative anomalous zone)
+!
+      if ( ( temcg.ge.(-16.0) .or.      &
+     &      ( temcg.ge.(-18.0) .and. ianom .ne. 3 .and. ianom .ne. 4) )     &
+     &        .and. elwc.lt.(0.22) .and. ianom .ne. 5 ) then
+!
+      ieq = 3
+      idelq = 1
+!
+!  sign
+!
+      qsign = -1.
+!
+!  f(t,lwc)
+!
+!  If elwc.lt.0.03:
+      ftelwc = 0.0                                  ! ERM bug fix 11.11.2003
 
-      GO TO 631
-
-
-  620 CONTINUE
-
-!.... CLOUD CONDENSATION
+      if (elwc.lt.(0.14).and.elwc.gt.(0.026)) then
+       ftelwc = ( (-314.40)*elwc+(7.92) ) !iseq=2
+      end if
+      if (elwc.lt.(0.22).and.elwc.ge.(0.14)) then
+       ftelwc = ( (419.4)*elwc-(92.64) ) !iseq=3
+      end if
 
-        IF ( qx(mgs,lc) .GT. qxmin(lc) .and. cx(mgs,lc) .ge. 1. ) THEN
+      ftelwc = Min ( 0.0, ftelwc ) 
+      
+      IF ( temcg .lt. -16.0 ) THEN
+        ftelwc = ftelwc*( temcg + 18.0 )*0.5 
+      ENDIF
+      
+      IF ( temcg .gt. -7.38 ) ftelwc = ftelwc*Abs(temcg/7.38)
+!
+! f(awdia)
+!
+      
+      IF ( ianom .eq. 0 .or. (ianom .ge. 2 .and. ianom .le. 4) ) THEN
+         anom = 0.2
+      ELSEIF ( ianom .eq. 1 ) THEN
+         anom = 1.0
+      ELSE
+         anom = 0.0
+      ENDIF
 
+      if ( awdia*1.e6.lt.253. ) then
+      qconkq = anom*5.24e8
+      qconm  = 2.54
+      qconn  = 2.8
+      end if
+      if ( awdia*1.e6.gt.253. ) then
+      qconkq = anom*24.0
+      qconm  = 0.50
+      qconn  = 2.8
+      end if
+!
+!  end case III
+!
+      end if
+!
+!  ASSIGN NORMAL CHARGING ZONES
+!
+      trevsau = -15.06*elwc-7.38
+      
+      iseq = 7 ! set default for [something]
+      IF ( temcg .gt. -10.69 .and. elwc .gt. 0.22 ) THEN
+        cew = 0.22
+        iseq = 1
+      ELSEIF (temcg .lt. -24. .and. elwc .gt. 1.1 ) THEN
+        cew = 1.1
+        iseq = 8
+      ELSEIF (temcg .lt. -24.0 .and. elwc .le. 1.1 ) THEN
+        cew = 1.1
+        iseq = 7
+      ELSEIF ( temcg .le. -10.69 .and. temcg .ge. -24.0 ) THEN
+         cew = -0.49 - (6.64e-2)*temcg
+         IF ( elwc .gt. cew ) THEN
+           iseq = 4
+         ELSE
+           iseq = 7
+         ENDIF
+      ENDIF
+ 
+      IF ( temcg .le. -7.38 .and. temcg .ge. -24.0 .and. ianom .eq. 5 ) THEN
+         cew = -0.49 - (6.64e-2)*temcg
+         IF ( elwc .gt. cew ) THEN
+           iseq = 4
+         ELSE
+           iseq = 7
+         ENDIF
+      ENDIF
 
 
-!       ac1 =  xdn(mgs,lc)*elv(kgs(mgs))**2*epsi/
-!     :        (tka(kgs(mgs))*rw*temg(mgs)**2)
-! took out xdn factor because it cancels later...
-       ac1 =  felv(mgs)**2/(tka(mgs)*rw*temg(mgs)**2)
+!
+!   case IV (normal positive zone, above the critical line)
+!
 
+      IF ( iseq .eq. 1 .or. iseq .eq. 8 .or. iseq .eq. 4 ) THEN
+!
+      ieq = 4
+      idelq = 1
+!
+!  sign
+!
+      qsign = 1.0
+!
+!  f(t,lwc)
+!
+      IF ( iseq .eq. 4 ) THEN
+        ftelwc = (20.22)*elwc+(1.36)*temcg+(10.05)
+      ELSEIF ( iseq .eq. 1 .and. ianom /= 5 ) THEN
+        ftelwc = 20.22*elwc - 4.4484 ! value of T set to -10.69
+!cccc      ENDIF
+      ELSEIF ( iseq .eq. 1 .and. ianom == 5 ) THEN
+        ftelwc = 20.22*(elwc - cew)
+      ELSEIF ( iseq .eq. 8 ) THEN
+        IF ( ianom .eq. 3 .or. ianom .eq. 4 ) THEN 
+          ftelwc = Max(0.0, (20.22)*elwc - 22.24 )
+        ELSE  ! create region of zero charging
+          ftelwc = Max(0.0, (20.22)*elwc+(1.36)*temcg+(10.05))
+        ENDIF
+      ENDIF
+      IF ( temcg .gt. -7.38 )     &
+     &   ftelwc = Abs(temcg/7.38)*     &
+     &            ((20.22)*elwc + (1.36)*(-7.38) + 10.05)
 
-!       bc = xdn(mgs,lc)*rw*temg(mgs)/
-!     :       (epsi*wvdf(kgs(mgs))*es(mgs))
-! took out xdn factor because it cancels later...
-       bc =   rw*temg(mgs)/(wvdf(mgs)*es(mgs))
-
-!       bs = rho0(mgs)*((rd*temg(mgs)/(epsi*es(mgs)))+
-!     :             (epsi*elv(kgs(mgs))**2/(pres(mgs)*temg(mgs)*cp)))
-
-!       taus = Min(dtp, xdn(mgs,lc)*rho0(mgs)*(ac1+bc)/
-!     :        (4*pi*0.89298*BS*0.5*xdia(mgs,lc,1)*cx(mgs,lc)*xdn(mgs,lc)))
-
+!      IF ( ftelwc .lt. 0 ) ftelwc = 0.0
+      ftelwc = Max ( 0.0 , ftelwc )
 !
-      IF ( ssf(mgs) .gt. 0.0 .or. ssat0(mgs) .gt. 0.0 ) THEN
-       IF ( ny .le. 2 ) THEN
-!        write(0,*)  'undershoot: ',ssf(mgs),
-!     :   ( (qx(mgs,lv) - dcloud)/c1 - 1.0)*100.
-       ENDIF
+! f(awdia)
+!
+      if ( awdia*1.e6.lt.155. ) then
+      qconkq = 4.9e13
+      qconm  = 3.76
+      qconn  = 2.5
+      end if
+      if ( awdia*1.e6.ge.155. .and.      &
+     &     awdia*1.e6.le.452. ) then
+      qconkq = 4.9e6
+      qconm  = 1.9
+      qconn  = 2.5
+      end if
+      if ( awdia*1.e6.gt.452. ) then
+      qconkq = 52.8
+      qconm  = 0.44
+      qconn  = 2.5
+      end if
+!
+!  end case IV
+!
+      END IF
+!
+!
+!   case V (normal negative zone, below the critical line)
+!
+!      if ( temcg.le.(trevsau) .and. 
+!     >     elwc.lt.(1.1) .and. 
+!     >     idelq .eq. 0 ) then
+        IF ( idelq .eq. 0 .and. iseq .eq. 7 ) THEN
+!
+      ieq = 7
+      idelq = 1
+!
+!  sign
+!
+      qsign = -1.
+!
+!  f(t,lwc)
+!
+      ftelwc = Min( 0.0, (3.02)-(31.76)*elwc+(26.53)*elwc**2 )
+!
+! f(awdia)
+!
+      if ( awdia*1.e6.lt.253. ) then
+      qconkq = 5.24e8
+      qconm  = 2.54
+      qconn  = 2.8
+      end if
+      if ( awdia*1.e6.gt.253. ) then
+      qconkq = 24.0
+      qconm  = 0.50
+      qconn  = 2.8
+      end if
+!
+!  end case V
+!
+      end if
+      
+      ftelwc = fac*ftelwc
+!
+!     print*,'qsign',qsign
+!     print*,'ftelwc',ftelwc
+!     print*,'qconkq',qconkq
+!     print*,'qconm',qconm
+!     print*,'qconn',qconn
+!     print*,'idelq',idelq
+!     print*,'awdia',awdia
+!     print*,'temcg',temcg
+!     print*,'qcw',qcw
+!
+      return
+      end subroutine saund
+!
+!
+! ####################################################################
+!                SUBROUTINE SAUNDMST
+! ####################################################################
+      subroutine saundmst(temcg,ssi,vt,awdia,rho0,     &
+     &                 qsign,ftrar,qcw,exw,     &
+     &                 qconkq,qconm,qconn,idelq,rarfac)
+      
+! ####################################################################
+!
+!  Purpose:
+!    Charge separation based on having just ice supersaturation but little
+!    or no riming. (Mitzeva, Saunders, and Tsenova, 2006, Atmos. Res.)
+!
+!  NOTE: 'q' here does nothing -- ftrar is really set in the calling subroutine
+!     using qsign for polarity.
+!
+!
+! ####################################################################
+      
+      implicit none
+      real temcg ! temperature
+      real ssi ! ice supersaturation
+      real qcw !  cloud liquid water mixing ratio
+      real exw ! cloud water collection efficiency
+      real vt ! terminal speed difference between x and cw 
+      real awdia ! crystal diameter
+      real rho0  ! air density
+      real qsign ! sign of charge acquired by rimer (not used by calling prog)
+      real ftrar ! charge factor based on temp and RAR 
+      real qconkq ! factor kq ( or 'B') 
+      real qconm  ! exponent on crystal diameter ('a')
+      real qconn  ! exponent on speed ('b')
+      integer idelq ! charge sign, not used by calling program
+!      real qfac
+      real rarfac  ! factor to reduce rar for purposes of charge calculation
+      
+      real rar ! rime accretion rate
+      real rarc ! critical RAR
+      real t,tc
+      parameter (tc = -23.7)
+      real delr,delri
+      parameter (delr=0.5, delri=1.0/delr)
+      real rar0  ! lower limit of RAR where charging goes to zero
+      parameter (rar0 = 0.1)
+      real q0
+      parameter (q0 = 6.48)
+      real tema,tmin
+      parameter (tema = -7.0 , tmin = -37.0)
+      integer ibs
+      
+      real fac
+      real q
+      
+! ####################################################################
+! Begin Executable code
+! ####################################################################
 
 
+      fac = 1.0
+      q = 1.
+      
+      rar = exw*qcw*1.0e3*rho0*vt*Abs(rarfac)
+      t = temcg
 
-       IF ( qx(mgs,lc) .gt. qxmin(lc) ) THEN
+      IF ( rar .gt. rar0 ) THEN ! should not be here if there is riming
+          fac = 0.0
+          qsign = 0.0
+          ftrar = 0.0
+          qconkq = 0.0
+          qconn = 1.0
+          qconm = 1.0
+          GOTO 999
+        
+      ENDIF
+      
+      
+      IF ( ssi .ge. 1.0 ) THEN
+        qsign = -1.0
+      ELSE
+        qsign =  1.0
+      ENDIF
+      
+      IF (qsign .gt. 0.5) THEN
+        
+        
+        if ( awdia*1.e6.lt.155. ) then
+          qconkq = 4.9e13
+          qconm  = 3.76
+          qconn  = 2.5
+        end if
+        if ( awdia*1.e6.ge.155. .and. awdia*1.e6.le.452. ) then
+          qconkq = 4.0e6
+          qconm  = 1.9
+          qconn  = 2.5
+        end if
+        if ( awdia*1.e6.gt.452. ) then
+          qconkq = 52.8
+          qconm  = 0.44
+          qconn  = 2.5
+        end if
+        
+         ftrar = q
 
-         IF ( xdia(mgs,lc,1) .le. 0.0 ) THEN
-          xmas(mgs,lc) = cwmasn
-          xdia(mgs,lc,1) = (xmas(mgs,lc)*cwc1)**c1f3
-         ENDIF
-        d1 = (1./(ac1 + bc))*4.0*pi*ventc &
-     &        *0.5*xdia(mgs,lc,1)*cx(mgs,lc)*rhoinv(mgs)
+      ELSEIF (qsign .lt. -0.5) THEN
 
-       ELSE
-         d1 = 0.0
-       ENDIF
 
-       IF ( rcond .eq. 2 .and. qx(mgs,lr) .gt. qxmin(lr) .and. cx(mgs,lr) > 1.e-9 ) THEN
-          IF ( imurain == 3 ) THEN
-           IF ( izwisventr == 1 ) THEN
-            rwvent(mgs) = ventrx(mgs)*(1.6 + 124.9*(1.e-3*rho0(mgs)*qx(mgs,lr))**.2046)
-           ELSE ! izwisventr = 2
-!  Following Wisner et al. (1972) but using gamma of volume. Note that Ferrier's rain fall speed does not integrate with gamma of volume, so using Vr = ar*d^br
-          rwvent(mgs) =   &
-     &  (0.78*ventrx(mgs) + 0.308*ventrxn(mgs)*fvent(mgs)   &
-     &   *Sqrt((ar*rhovt(mgs)))   &
-     &    *(xdia(mgs,lr,1)**((1.0+br)/2.0)) )
-           ENDIF
+        
+        if ( awdia*1.e6.lt.253. ) then
+          qconkq = 5.24e8
+          qconm  = 2.54
+          qconn  = 2.8
+        end if
+        if ( awdia*1.e6.gt.253. ) then
+          qconkq = 24.0
+          qconm  = 0.50
+          qconn  = 2.8
+        end if
 
-          ELSE ! imurain == 1
+         ftrar = -q
+        
+      END IF
+      
+      
+ 999  CONTINUE      
+      RETURN
+      END subroutine saundmst
+      
 
-           IF ( iferwisventr == 1 ) THEN
-             alpr = Min(alpharmax,alpha(mgs,lr) )
-!             alpr = alpha(mgs,lr)
-             x =  1. + alpr
+! ##############################################################################
+! ##############################################################################
 
-              tmp = 1 + alpr
-              i = Int(dgami*(tmp))
-              del = tmp - dgam*i
-              g1palp = gmoi(i) + (gmoi(i+1) - gmoi(i))*del*dgami
 
-              tmp = 2.5 + alpr + 0.5*bx(lr)
-              i = Int(dgami*(tmp))
-              del = tmp - dgam*i
-              y = (gmoi(i) + (gmoi(i+1) - gmoi(i))*del*dgami)/g1palp ! ratio of gamma functions
+! #include "include/nucond.F90"
+! #include "include/nssl_2mom_gs.F90"
+! #####################################################################
+! #####################################################################
+!
+! Subroutine for explicit cloud condensation and droplet nucleation
+!
+   SUBROUTINE NUCOND    &
+     &  (nx,ny,nz,na,jyslab & 
+     &  ,nor,norz,dtp,nxi & 
+     &  ,dz3d & 
+     &  ,t0,t9 & 
+     &  ,an,dn,p2 & 
+     &  ,pn,w & 
+     &  ,axtra,io_flag &
+     &  ,ssfilt,t00,t77,flag_qndrop  &
+     & )
 
-!         vent1 = dble(xdia(mgs,lr,1))**(-2. - alpr) ! Actually OK
-!         vent2 = dble(1./xdia(mgs,lr,1) + 0.5*fx(lr))**dble(2.5+alpr+0.5*bx(lr))  ! Actually OK
-         vent1 = dble(xdia(mgs,lr,1))**(0.5 + 0.5*bx(lr)) ! 2016.2.26 Changed for consistency with derivation (recast formula)
-         vent2 = dble(1. + 0.5*fx(lr)*xdia(mgs,lr,1))**dble(2.5+alpr+0.5*bx(lr))
-        
-        
-        rwvent(mgs) =    &
-     &    0.78*x +    &
-     &    0.308*fvent(mgs)*y*   &
-     &            Sqrt(ax(lr)*rhovt(mgs))*(vent1/vent2)
 
-           ELSEIF ( iferwisventr == 2 ) THEN
-          
-!  Following Wisner et al. (1972) but using gamma of volume. Note that Ferrier's rain fall speed does not integrate with gamma of volume, so using Vr = ar*d^br
-            x =  1. + alpha(mgs,lr)
+   implicit none
 
-            rwvent(mgs) =   &
-     &        (0.78*x + 0.308*ventrxn(mgs)*fvent(mgs)   &
-     &         *Sqrt((ar*rhovt(mgs)))   &
-     &         *(xdia(mgs,lr,1)**((1.0+br)/2.0)) )
+      integer :: nx,ny,nz,na,nxi
+      integer :: nor,norz, jyslab ! ,nht,ngt,igsr
+      real    :: dtp  ! time step
+      logical :: flag_qndrop
 
-          
-          ENDIF ! iferwisventr
-          
-       ENDIF ! imurain
+      integer, parameter :: ng1 = 1
 
-       d1r = (1./(ac1 + bc))*4.0*pi*rwvent(mgs) & 
-     &        *0.5*xdia(mgs,lr,1)*cx(mgs,lr)*rhoinv(mgs)
-       ELSE
-       d1r = 0.0
-       ENDIF
-       
-       
-       e1  = felvcp(mgs)/(pi0(mgs))
-       f1 = pk(mgs) ! (pres(mgs)/poo)**cap
 
 !
-!  fifth trial to see what happens:
+! external temporary arrays
 !
-       ltemq = (temg(mgs)-163.15)/fqsat+1.5
-       ltemq = Min( nqsat, Max(1,ltemq) )
-       ltemq1 = ltemq
-       temp1 = temg(mgs)
-       p380 = 380.0/pres(mgs)
+      real t00(-nor+1:nx+nor,-nor+1:ny+nor,-norz+1:nz+norz)
+      real t77(-nor+1:nx+nor,-nor+1:ny+nor,-norz+1:nz+norz)
 
-!       taus = Max( 0.05*dtp, Min(taus, 0.25*dtp ) )
-!       nc = NInt(dtp/Min(1.0,0.5*taus))
-!       dtcon = dtp/float(nc)
-       ss1 = qx(mgs,lv)/qvs(mgs)
-       ss2 = ss1
-       temp2 = temp1
-       qv1 = qx(mgs,lv)
-       qvs1 = qvs(mgs)
-       qis1 = qis(mgs)
-       dt1 = 0.0
+      real t0(-nor+1:nx+nor,-nor+1:ny+nor,-norz+1:nz+norz)
+!      real t1(-nor+1:nx+nor,-nor+1:ny+nor,-norz+1:nz+norz)
+!      real t2(-nor+1:nx+nor,-nor+1:ny+nor,-norz+1:nz+norz)
+!      real t3(-nor+1:nx+nor,-nor+1:ny+nor,-norz+1:nz+norz)
+!      real t4(-nor+1:nx+nor,-nor+1:ny+nor,-norz+1:nz+norz)
+!      real t5(-nor+1:nx+nor,-nor+1:ny+nor,-norz+1:nz+norz)
+!      real t6(-nor+1:nx+nor,-nor+1:ny+nor,-norz+1:nz+norz)
+!      real t7(-nor+1:nx+nor,-nor+1:ny+nor,-norz+1:nz+norz)
+!      real t8(-nor+1:nx+nor,-nor+1:ny+nor,-norz+1:nz+norz)
+      real t9(-nor+1:nx+nor,-nor+1:ny+nor,-norz+1:nz+norz)
+      
 
+      real p2(-nor+1:nx+nor,-nor+1:ny+nor,-norz+1:nz+norz)  ! perturbation Pi
+      real pn(-nor+1:nx+nor,-nor+1:ny+nor,-norz+1:nz+norz)
+      real an(-nor+1:nx+nor,-nor+1:ny+nor,-norz+1:nz+norz,na)
+      real dn(-nor+1:nx+nor,-nor+1:ny+nor,-norz+1:nz+norz)
 
-!          dtcon = Max(dtcon,0.2)
-!          nc = Nint(dtp/dtcon)
+      real w(-nor+1:nx+nor,-nor+1:ny+nor,-norz+1:nz+norz)
+!      real qv(-nor+1:nx+nor,-nor+1:ny+nor,-norz+1:nz+norz)
 
-       ltemq1 = ltemq
-! want to start out with a small time step to handle the steep slope
-! and fast changes, then can switch to a larger step (dtcon2) for the
-! rest of the big time step.
-! base the initial time step (dtcon1) on the slope (delta)
-       IF ( Abs(ss1 - 1.0) .gt. 1.e-5 ) THEN
-         delta = 0.5*(qv1-qvs1)/(d1*(ss1 - 1.0))
-       ELSE
-         delta = 0.1*dtp
-       ENDIF
-! delta is the extrapolated time to get halfway from qv1 to qvs1
-! want at least 5 time steps to the halfway point, so multiply by 0.2
-! for the initial time step
-       dtcon1 = Min(0.05,0.2*delta)
-       nc = Max(5,2*NInt( (dtp-4.0*dtcon1)/delta))
-       dtcon2 = (dtp-4.0*dtcon1)/nc
+      real ssfilt(-nor+1:nx+nor,-nor+1:ny+nor,-norz+1:nz+norz)
+      
 
-       n = 1
-       dt1 = 0.0
-       nc = 0
-       dqc = 0.0
-       dqr = 0.0
-       dqi = 0.0
-       dqs = 0.0
-       dqvii = 0.0
-       dqvis = 0.0
+      real pb(-norz+ng1:nz+norz)
+      real pinit(-norz+ng1:nz+norz)
 
-       RK2c: DO WHILE ( dt1 .lt. dtp )
-          nc = 0
-          IF ( n .le. 4 ) THEN
-            dtcon = dtcon1
-          ELSE
-            dtcon = dtcon2
-          ENDIF
- 609       dqv  = -(ss1 - 1.)*d1*dtcon
-           dqvr = -(ss1 - 1.)*d1r*dtcon
-            dtemp = -0.5*e1*f1*(dqv + dqvr)
-!          write(0,*) 'RK2c dqv1 = ',dqv
-! calculate midpoint values:
-     !      ltemq1m = ltemq1 + Nint(dtemp*fqsat + 0.5)
+      real dz3d(-nor+1:nx+nor,-nor+1:ny+nor,-norz+1:nz+norz)
 
-         ! 7.6.2016: Test full calc of ltemq
-           ltemq1m = (temp1+dtemp-163.15)*fqsati+1.5
-           ltemq1m = Min( nqsat, Max(1,ltemq1m) )
+      
+    ! local
 
-           IF ( ltemq1m .lt. 1 .or. ltemq1m .gt. nqsat ) THEN
-             write(0,*) 'STOP in nucond line 1192 '
-             write(0,*) ' ltemq1m,icond = ',ltemq1m,icond
-             write(0,*) ' dtemp,e1,f1,dqv,dqvr = ', dtemp,e1,f1,dqv,dqvr
-             write(0,*) ' d1,d1r,dtcon,ss1 = ',d1,d1r,dtcon,ss1
-             write(0,*) ' dqc, dqr = ',dqc,dqr
-             write(0,*) ' qv,qc,qr = ',qx(mgs,lv)*1000.,qx(mgs,lc)*1000.,qx(mgs,lr)*1000.
-             write(0,*) ' i, j, k = ',igs(mgs),jy,kgs(mgs)
-             write(0,*) ' dtcon1,dtcon2,delta = ',dtcon1,dtcon2,delta
-             write(0,*) ' nc,dtp = ',nc,dtp
-             write(0,*) ' rwvent,xdia,crw,ccw = ', rwvent(mgs),xdia(mgs,lr,1),cx(mgs,lr),cx(mgs,lc)
-             write(0,*) ' fvent,alphar = ',fvent(mgs),alpha(mgs,lr)
-             write(0,*) ' xvr,xmasr,xdnr,cwc1 = ',xv(mgs,lr),xmas(mgs,lr),xdn(mgs,lr),cwc1
-           ENDIF
-            dqvs = dtemp*p380*dtabqvs(ltemq1m)
-            qv1m = qv1 + dqv + dqvr
-!          qv1mr = qv1r + dqvr
 
-            qvs1m = qvs1 + dqvs
-            ss1m = qv1m/qvs1m
+      real axtra(-nor+ng1:nx+nor,-nor+ng1:ny+nor,-norz+ng1:nz+norz,nxtra)
+      logical :: io_flag
+      
+      real :: dv
 
-    ! check for undersaturation when no ice is present, if so, then reduce time step
-          IF ( ss1m .lt. 1.  .and. (dqvii + dqvis) .eq. 0.0 ) THEN
-            dtcon = (0.5*dtcon)
-            IF ( dtcon .ge. dtcon1 ) THEN
-             GOTO 609
-            ELSE
-             EXIT
-            ENDIF
-          ENDIF
-! calculate full step:
-          dqv  = -(ss1m - 1.)*d1*dtcon
-          dqvr = -(ss1m - 1.)*d1r*dtcon
+! 
+!  declarations microphysics and for gather/scatter
+!
+      integer nxmpb,nzmpb,nxz
+      integer mgs,ngs,numgs,inumgs
+      parameter (ngs=500)
+      integer ngscnt,igs(ngs),kgs(ngs)
+      integer kgsp(ngs),kgsm(ngs)
+      integer nsvcnt
+      
+      integer ix,kz,i,n, kp1, km1
+      integer :: jy, jgs
+      integer ixb,ixe,jyb,jye,kzb,kze
+    
+      integer itile,jtile,ktile
+      integer ixend,jyend,kzend,kzbeg
+      integer nxend,nyend,nzend,nzbeg
 
+!
+! Variables for Ziegler warm rain microphysics
+!      
 
-!          write(0,*) 'RK2a dqv1m = ',dqv
-          dtemp = -e1*f1*(dqv + dqvr)
-          
-         ! ltemq1 = ltemq1 + Nint(dtemp*fqsat + 0.5)
 
-         ! 7.6.2016: Test full calc of ltemq
-           ltemq1 = (temp1+dtemp-163.15)*fqsati+1.5
-           ltemq1 = Min( nqsat, Max(1,ltemq1) )
+      real ccnc(ngs), ccna(ngs), cnuc(ngs), cwnccn(ngs)
+      real sscb  ! 'cloud base' SS threshold
+      parameter ( sscb = 2.0 )
+      integer idecss  ! flag to turn on (=1) decay of ssmax when no cloud or ice crystals
+      parameter ( idecss = 1 )
+      integer iba ! flag to do condensation/nucleation in 1st or 2nd loop
+                  ! =0 to use ad to calculate SS
+                  ! =1 to use an at end of main jy loop to calculate SS
+      parameter (iba = 1)
+      integer ifilt   ! =1 to filter ssat, =0 to set ssfilt=ssat
+      parameter ( ifilt = 0 ) 
+      real temp1,temp2 ! ,ssold
+      real :: ssmax(ngs) = 0.0       ! maximum SS experienced by a parcel
+      real ssmx
+      real dnnet,dqnet
+!      real cnu,rnu,snu,cinu
+!      parameter ( cnu = 0.0, rnu = -0.8, snu = -0.8, cinu = 0.0 )
+      real ventrx(ngs)
+      real ventrxn(ngs)
+      real volb, t2s
+      real, parameter :: aa1 = 9.44e15, aa2 = 5.78e3  ! a1 in Ziegler
 
-           IF ( ltemq1 .lt. 1 .or. ltemq1 .gt. nqsat ) THEN
-             write(0,*) 'STOP in nucond line 1230 '
-             write(0,*) ' ltemq1m,icond = ',ltemq1m,icond
-             write(0,*) ' dtemp,e1,dqv,dqvr = ', dtemp,e1,dqv,dqvr
-           ENDIF
-          dqvs = dtemp*p380*dtabqvs(ltemq1)
+      real ec0, ex1, ft, rhoinv(ngs)
+      
+      real chw, g1, rd1
 
-          qv1 = qv1 + dqv + dqvr
+      real ac1,bc, taus, c1,d1,e1,f1,p380,tmp,tmp2 ! , sstdy, super
+      real tmpmx, fw
+      real x,y,del,r,alpr
+      double precision :: vent1,vent2
+      real g1palp
+      real bs
+      real v1, v2
+      real d1r, d1i, d1s, e1i
+      integer nc ! condensation step
+      real dtcon,dtcon1,dtcon2 ! condensation time step (dtcon*nc = dtp)
+      real delta
+      integer ltemq1,ltemq1m ! ,ltemq1m2
+      real dqv,qv1,ss1,ss2,qvs1,dqvs,dtemp,dt1   ! temporaries for condensation
 
-          dqc = dqc - dqv
-          dqr = dqr - dqvr
+      real ssi1, ssi2, dqvi, dqvis, dqvii,qis1
+      real dqvr, dqc, dqr, dqi, dqs
+      real qv1m,qvs1m,ss1m,ssi1m,qis1m
+      real cwmastmp 
+      real  dcloud,dcloud2 ! ,as, bs
+      real dcrit
+      real cn(ngs) 
 
-          qvs1 = qvs1 + dqvs
-          ss1 = qv1/qvs1
-          temp1 = temp1 + dtemp
-          IF ( temp2 .eq. temp1 .or. ss2 .eq. ss1 .or.  &
-     &           ss1 .eq. 1.00 .or.  &
-     &      ( n .gt. 10 .and. ss1 .lt. 1.0005 ) ) THEN
-!           write(0,*) 'RK2c break'
-           EXIT
-          ELSE
-           ss2 = ss1
-           temp2 = temp1
-           dt1 = dt1 + dtcon
-           n = n + 1
-          ENDIF
-       ENDDO RK2c
+      integer ltemq
+      
+      integer il
 
+      real  es(ngs) ! ss(ngs),
+!      real  eis(ngs)
+      real ssf(ngs),ssfkp1(ngs),ssfkm1(ngs),ssat0(ngs)
+      real, parameter :: ssfcut = 4.0
+      real ssfjp1(ngs),ssfjm1(ngs)
+      real ssfip1(ngs),ssfim1(ngs)
 
-        dcloud = dqc ! qx(mgs,lv) - qv1
-        thetap(mgs) = thetap(mgs) + e1*(DCLOUD + dqr)
+      real supcb, supmx
+      parameter (supcb=0.5,supmx=238.0)
+      real r2dxm, r2dym, r2dzm
+      real dssdz, dssdy, dssdx
+!      real tqvcon
+      real epsi,d
+      parameter (epsi = 0.622, d = 0.266)
+      real r1,qevap ! ,slv
+      
+      real vr,nrx,qr,z1,z2,rdi,alp,xnutmp,xnuc
+      real ctmp, ccwtmp
+      real f5, qvs0  ! Kessler condensation factor
+      real    :: t0p1, t0p3
+      real qvex
+      
+!      real, dimension(ngs) :: temp, tempc, elv, elf, els, pqs, theta, temg, temcg
+      real dqvcnd(ngs),dqwv(ngs),dqcw(ngs),dqci(ngs)
+      real temp(ngs),tempc(ngs)
+      real temg(ngs),temcg(ngs),theta(ngs),qvap(ngs) ! ,tembzg(ngs)
+      real temgx(ngs),temcgx(ngs)
+      real qvs(ngs),qis(ngs),qss(ngs),pqs(ngs)
+      real felv(ngs),felf(ngs),fels(ngs)
+      real felvcp(ngs),felvpi(ngs)
+      real gamw(ngs),gams(ngs)   !   qciavl(ngs),
+      real tsqr(ngs),ssi(ngs),ssw(ngs)
+      real cc3(ngs),cqv1(ngs),cqv2(ngs)
+      real qcwtmp(ngs),qtmp
 
+      real fvent(ngs) !,fraci(ngs),fracl(ngs)
+      real fwvdf(ngs),ftka(ngs),fthdf(ngs)
+      real fadvisc(ngs),fakvisc(ngs)
+      real fci(ngs),fcw(ngs)
+      real fschm(ngs),fpndl(ngs)
 
-        IF ( eqtset > 2 ) THEN
-           pipert(mgs) = pipert(mgs) + felvpi(mgs)*(DCLOUD + dqr)
-        ENDIF
-        IF ( io_flag .and. nxtra > 1 ) THEN
-           axtra(igs(mgs),jy,kgs(mgs),1) = DCLOUD/dtp
-           axtra(igs(mgs),jy,kgs(mgs),2) = axtra(igs(mgs),jy,kgs(mgs),2) + dqr/dtp
-        ENDIF
-        qwvp(mgs) = qwvp(mgs) - (DCLOUD + dqr)
-        qx(mgs,lc) = qx(mgs,lc) + DCLOUD
-        qx(mgs,lr) = qx(mgs,lr) + dqr
-!        t9(igs(mgs),jy,kgs(mgs)) = t9(igs(mgs),jy,kgs(mgs)) + (DCLOUD + dqr)/dtp*felv(mgs)/(cp*pi0(mgs)) !* &
-!!     &                 dx*dy*dz3d(igs(mgs),jy,kgs(mgs))
+      real pres(ngs),pipert(ngs)
+      real pk(ngs)
+      real rho0(ngs),pi0(ngs)
+      real rhovt(ngs)
+      real thetap(ngs),theta0(ngs),qwvp(ngs),qv0(ngs)
+      real thsave(ngs)
+      real qss0(ngs)
+      real fcqv1(ngs)
+      real wvel(ngs),wvelkm1(ngs)
 
+      real wvdf(ngs),tka(ngs)
+      real advisc(ngs)
 
-        theta(mgs) = thetap(mgs) + theta0(mgs)
-        temg(mgs) = theta(mgs)*f1
-        ltemq = (temg(mgs)-163.15)/fqsat+1.5
-        ltemq = Min( nqsat, Max(1,ltemq) )
-        qvs(mgs) = pqs(mgs)*tabqvs(ltemq)
-!        es(mgs) = 6.1078e2*tabqvs(ltemq)
+      real rwvent(ngs)
+      
 
-!
+      real :: qx(ngs,lv:lhab)
+      real :: cx(ngs,lc:lhab)
+      real :: xv(ngs,lc:lhab)
+      real :: xmas(ngs,lc:lhab)
+      real :: xdn(ngs,lc:lhab)
+      real :: xdia(ngs,lc:lhab,3)
+      real :: alpha(ngs,lc:lhab)
+      real :: zx(ngs,lr:lhab)
 
-      ENDIF  ! dcloud .gt. 0.
 
+      logical zerocx(lc:lqmx)
+      
+      logical :: lprint
 
-      ELSE  ! qc .le. qxmin(lc)
+      integer, parameter :: iunit = 0
+      
+      real :: frac, hwdn, tmpg
+      
+      real :: cvm,cpm,rmm
 
-!        IF ( ssf(mgs) .gt. 0.0 .and. .not. flag_qndrop ) THEN ! flag_qndrop turns off primary nucleation when using wrf-chem with progn=1
-        IF ( ssf(mgs) .gt. 0.0 ) THEN ! .and.  ssmax(mgs) .lt. sscb ) THEN ! except that wrf-chem does not seem to initialize qc for activated aerosols, so keep this, after all
+      real, parameter :: rovcp = rd/cp
+      real, parameter ::      cpv = 1885.0       ! specific heat of water vapor at constant pressure
+      
+      integer :: kstag
+      
+      integer :: count
+      
 
-          IF ( iqcinit == 1 ) THEN
+! -------------------------------------------------------------------------------
+      itile = nxi
+      jtile = ny
+      ktile = nz
+      ixend = nxi
+      jyend = ny
+      kzend = nz
+      nxend = nxi + 1
+      nyend = ny + 1
+      nzend = nz
+      kzbeg = 1
+      nzbeg = 1
 
-         qvs0   = 380.*exp(17.27*(temg(mgs)-273.)/(temg(mgs)- 36.))/pk(mgs)
+      f5 = 237.3 * 17.27 * 2.5e6 / cp ! combined constants for rain condensation (Soong and Ogura 73)
 
-         dcloud = Max(0.0, (qx(mgs,lv)-qvs0) / (1.+qvs0*f5/(temg(mgs)-36.)**2) )
+       jy = 1
+       kstag = 0
+       pb(:) = 0.0
+       pinit(:) = 0.0
+      
+      IF ( ipconc <= 1 .or. isedonly == 2 ) GOTO 2200
 
-          ELSEIF ( iqcinit == 3 ) THEN
-              R1=1./(1. + caw*(273.15 - cbw)*qss(mgs)*felvcp(mgs)/ & 
-     &             ((temg(mgs) - cbw)**2))
-            DCLOUD=R1*(qvap(mgs) - qvs(mgs))  ! KW model adjustment; 
-                              ! this will put mass into qc if qv > sqsat exists
-          
-          ELSEIF ( iqcinit == 2 ) THEN
-!              R1=1./(1. + caw*(273.15 - cbw)*qss(mgs)*felv(mgs)/
-!     :             (cp*(temg(mgs) - cbw)**2))
-!            DCLOUD=R1*(qvap(mgs) - qvs(mgs))  ! KW model adjustment; 
-                              ! this will put mass into qc if qv > sqsat exists
-         ssmx = ssmxinit
-
-          IF ( ssf(mgs) > ssmx ) THEN
-           CALL QVEXCESS(ngs,mgs,qwvp,qv0,qx(1,lc),pres,thetap,theta0,dcloud, & 
-     &      pi0,tabqvs,nqsat,fqsat,cbw,fcqv1,felvcp,ssmx,pk,ngscnt)
-          ELSE
-            dcloud = 0.0
-          ENDIF
-         ENDIF
-        ELSE
-            dcloud = 0.0
-        ENDIF
-
-        thetap(mgs) = thetap(mgs) + felvcp(mgs)*DCLOUD/(pi0(mgs))
-        qwvp(mgs) = qwvp(mgs) - DCLOUD
-        qx(mgs,lc) = qx(mgs,lc) + DCLOUD
-        IF ( io_flag .and. nxtra > 1 ) THEN
-           axtra(igs(mgs),jy,kgs(mgs),1) = DCLOUD/dtp
-        ENDIF
-        theta(mgs) = thetap(mgs) + theta0(mgs)
-        temg(mgs) = theta(mgs)*pk(mgs) !( pres(mgs) / poo ) ** cap
-!        temg(mgs) = theta2temp( theta(mgs), pres(mgs) )
-        ltemq = (temg(mgs)-163.15)/fqsat+1.5
-        ltemq = Min( nqsat, Max(1,ltemq) )
-        qvs(mgs) = pqs(mgs)*tabqvs(ltemq)
-!        es(mgs) = 6.1078e2*tabqvs(ltemq)
+!
+!  Ziegler nucleation 
+!
 
-!.... S. TWOMEY (1959)
-! Note: get here if there is no previous cloud water and w > 0.
-      cn(mgs) = 0.0
-      
-      IF ( ncdebug .ge. 1 ) THEN
-        write(iunit,*) 'at 613: ',qx(mgs,lc),cx(mgs,lc),wvel(mgs),ssmax(mgs),kgs(mgs)
-      ENDIF
-      
-      IF (  .not. flag_qndrop ) THEN ! { only calculate mass change when using wrf-chem
+!      ssfilt(:,:,:) = 0.0
+      ssmx = 0
+      count = 0
 
-      
-!      IF ( ssmax(mgs) .lt. sscb .and. qx(mgs,lc) .gt. qxmin(lc)) THEN
-      IF ( dcloud .gt. qxmin(lc) .and. wvel(mgs) > 0.0) THEN
-!       CN(mgs) =   CCNE*wvel(mgs)**cnexp ! *Min(1.0,1./dtp) ! 0.3465
-       CN(mgs) =   CCNE0*cnuc(mgs)**(2./(2.+cck))*wvel(mgs)**cnexp ! *Min(1.0,1./dtp) ! 0.3465
-        IF ( ny .le. 2 .and. cn(mgs) .gt. 0.0    &
-     &                    .and. ncdebug .ge. 1 ) THEN 
-          write(iunit,*) 'CN: ',cn(mgs)*1.e-6, cx(mgs,lc)*1.e-6, qx(mgs,lc)*1.e3,   &
-     &       wvel(mgs), dcloud*1.e3
-          IF ( cn(mgs) .gt. 1.0 ) write(iunit,*) 'cwrad = ',   &
-     &       1.e6*(rho0(mgs)*qx(mgs,lc)/cn(mgs)*cwc1)**c1f3,   &
-     &   igs(mgs),kgs(mgs),temcg(mgs),    &
-     &   1.e3*an(igs(mgs),jgs,kgs(mgs)-1,lc)
-        ENDIF
-        IF ( iccwflg .eq. 1 ) THEN
-          cn(mgs) = Min(cwccn*rho0(mgs)/rho00, Max(cn(mgs),   &
-     &       rho0(mgs)*qx(mgs,lc)/(xdn(mgs,lc)*(4.*pi/3.)*(4.e-6)**3)))
-        ENDIF
-      ELSE
-       cn(mgs) = 0.0
-       dcloud = 0.0
-!          cn(mgs) = Min(cwccn,    &
-!     &       rho0(mgs)*dcloud/(xdn(mgs,lc)*(4.*pi/3.)*(4.e-6)**3) )
-      ENDIF
+      do kz = 1,nz-kstag
+        do ix = 1,nxi
 
-      IF ( cn(mgs) .gt. 0.0 ) THEN
-       IF ( cn(mgs) .gt. ccnc(mgs) ) THEN
-         cn(mgs) = ccnc(mgs)
-!         ccnc(mgs) = 0.0
-       ENDIF
-!      cx(mgs,lc) = cx(mgs,lc) + cn(mgs)
-      IF ( irenuc <= 2 ) ccnc(mgs) = Max(0.0, ccnc(mgs) - cn(mgs))
-      ccna(mgs) = ccna(mgs) + cn(mgs)
-      ENDIF
+         temp1 = an(ix,jy,kz,lt)*t77(ix,jy,kz)
+          t0(ix,jy,kz) = temp1
+          ltemq = Int( (temp1-163.15)/fqsat+1.5 )
+         ltemq = Min( nqsat, Max(1,ltemq) )
 
-!       write(91,*) 'nuc1: cn, ix, kz = ',cn(mgs),igs(mgs),kgs(mgs),wvel(mgs),cnexp,ccnc(mgs)
+          c1 = t00(ix,jy,kz)*tabqvs(ltemq)
 
-      IF( CN(mgs) .GT. cx(mgs,lc) ) cx(mgs,lc) = CN(mgs)
-      IF( cx(mgs,lc) .GT. 0. .AND. qx(mgs,lc) .le. qxmin(lc) ) THEN
-        cx(mgs,lc) = 0.
-      ELSE
-        cx(mgs,lc) = Min(cx(mgs,lc),rho0(mgs)*Max(0.0,qx(mgs,lc))/cwmasn)
-      ENDIF
-      
-      ENDIF ! }.not. flag_qndrop
+          IF ( c1 > 0. ) THEN
+            ssfilt(ix,jy,kz) = 100.*(an(ix,jy,kz,lv)/c1 - 1.0)  ! from "new" values
+          ENDIF
 
-        GOTO 613
-        
-        END IF ! qc .gt. 0.
+        ENDDO
+      ENDDO
 
-!        ES=EES(PIB(K)*PT)
-!        SQSAT=EPSI*ES/(PB(K)*1000.-ES)
 
-!.... CLOUD NUCLEATION
-!      T=PIB(K)*PT
-!      ES=1.E3*PB(K)*QV/EPSI
+!
+!     jy = 1 ! working on a 2d slab
+!!  VERY IMPORTANT:  SET jgs = jy
 
-      IF ( wvel(mgs) .le. 0. ) GO TO 616
-      IF ( cx(mgs,lc) .le. 0. )  GO TO 613                             !TWOMEY (1959) Nucleation
-      IF ( kzbeg-1+kgs(mgs) .GT. 1 .and. qx(mgs,lc) .le. qxmin(lc)) GO TO 613  !TWOMEY (1959) Nucleation
-      IF ( kzbeg-1+kgs(mgs) .eq. 1 .and. wvel(mgs) .gt. 0. ) GO TO 613         !TWOMEY (1959) Nucleation
-!.... ATTEMPT ZIEGLER CLOUD NUCLEATION IN CLOUD INTERIOR UNLESS...
-  616 IF ( ssf(mgs) .LE. SUPCB .AND. wvel(mgs) .GT. 0. ) GO TO 631 !... weakly saturated updraft
-      IF ( kzbeg-1+kgs(mgs) .GT. 1 .AND. kzbeg-1+kgs(mgs) .LT. nzend-1 .AND.  &
-     &    (ssfkp1(mgs) .GE. SUPMX .OR. &
-     &     ssf(mgs)    .GE. SUPMX .OR. &
-     &     ssfkm1(mgs) .GE. SUPMX)) GO TO 631                      !... too much vapour
-      IF (ssf(mgs) .LT. 1.E-10 .OR. ssf(mgs) .GE. SUPMX) GO TO 631 !... at the extremes for ss
+      jgs = jy
 
 !
-! get here if ( qc > 0 and ss > supcb) or (w < 0)
+!..Gather microphysics
 !
+      if ( ndebug .gt. 0 ) write(0,*) 'ICEZVD_DR: Gather stage'
 
-      if (ndebug .gt. 0) write(0,*) "ICEZVD_DR: Entered Ziegler Cloud Nucleation" !mpidebug
-
-      DSSDZ=0.
-      r2dzm=0.50/dz3d(igs(mgs),jy,kgs(mgs))
-      IF ( irenuc >= 0 .and. .not. flag_qndrop) THEN ! turn off nucleation when flag_qndrop (using WRF-CHEM for activation)
+      nxmpb = 1
+      nzmpb = 1
+      nxz = nxi*nz
+      numgs = nxz/ngs + 1
 
-      IF ( irenuc < 2 ) THEN !{
 
-        IF ( kzend == nzend ) THEN
-          t0p3 = t0(igs(mgs),jgs,Min(kze,kgs(mgs)+3))
-          t0p1 = t0(igs(mgs),jgs,Min(kze,kgs(mgs)+1))
-        ELSE
-          t0p3 = t0(igs(mgs),jgs,kgs(mgs)+3)
-          t0p1 = t0(igs(mgs),jgs,kgs(mgs)+1)
-        ENDIF
+      do 2000 inumgs = 1,numgs
 
-      IF ( ( ssf(mgs) .gt. ssmax(mgs) .or.  irenuc .eq. 1 ) &
-     &   .and.  ( ( lccn .lt. 1 .and.  &
-     &            cx(mgs,lc) .lt. cwccn*(Min(1.0,rho0(mgs)))) .or. &
-     &    ( lccn .gt. 1 .and. ccnc(mgs) .gt. 0. )   ) &
-     &    ) THEN
-      IF( kzbeg-1+kgs(mgs) .GT. 1 .AND. kzbeg-1+kgs(mgs) .LT. nzend-1 &
-     &  .and. ssf(mgs) .gt. 0.0 &
-     &  .and. ssfkp1(mgs) .LT. SUPMX .and. ssfkp1(mgs) .ge. 0.0  &
-     &  .AND. ssfkm1(mgs) .LT. SUPMX .AND. ssfkm1(mgs) .ge. 0.0  &
-     &  .AND. ssfkp1(mgs) .gt. ssfkm1(mgs)  &
-     &  .and. t0p3 .gt. 233.2) THEN
-          DSSDZ = (ssfkp1(mgs) - ssfkm1(mgs))*R2DZM
-!
-! otherwise check for cloud base condition with updraft:
-!
-        ELSEIF( kzbeg-1+kgs(mgs) .GT. 1 .AND. kzbeg-1+kgs(mgs) .LT. nzend-1 &
-!        IF( kgs(mgs) .GT. 1 .AND. kgs(mgs) .LT. NZ-1 & !)
-     &  .and. ssf(mgs) .gt. 0.0  .and. wvel(mgs) .gt. 0.0 &
-     &  .and. ssfkp1(mgs) .gt. 0.0   &
-     &  .AND. ssfkm1(mgs) .le. 0.0 .and. wvelkm1(mgs) .gt. 0.0 &
-     &  .AND. ssf(mgs) .gt. ssfkm1(mgs)  &
-     &  .and. t0p1 .gt. 233.2) THEN
-         DSSDZ = 2.*(ssf(mgs) - ssfkm1(mgs))*R2DZM  ! 1-sided difference
-        ENDIF
+      ngscnt = 0
 
-       ENDIF
-!
-!CLZ  IF(wijk.LE.0.) CN=CCN*ssfilt(ix,jy,kz)**CCK
-! note: CCN -> cwccn, DELT -> dtp
-      c1 = Max(0.0, rho0(mgs)*(qx(mgs,lv) - qss(mgs))/ &
-     &        (xdn(mgs,lc)*(4.*pi/3.)*(4.e-6)**3))
-      IF ( lccn .lt. 1 ) THEN
-       CN(mgs) = cwccn*rho0(mgs)/rho00*CCK*ssf(mgs)**CCKM*dtp*   &
-     & Max(0.0,    &
-     &         (wvel(mgs)*DSSDZ) )      ! probably the vertical gradient dominates
-      ELSE
-      CN(mgs) =  &
-     &    Min(ccnc(mgs), cnuc(mgs)*CCK*ssf(mgs)**CCKM*dtp*   &
-     & Max(0.0,    &
-     &         ( wvel(mgs)*DSSDZ) )  )
-!      IF ( cn(mgs) .gt. 0 ) ccnc(mgs) = ccnc(mgs) - cn(mgs)
-      ENDIF
 
-      IF ( cn(mgs) .gt. 0.0 ) THEN
-       IF ( ccnc(mgs) .lt. 5.e7 .and. cn(mgs) .ge. 5.e7 ) THEN
-          cn(mgs) = 5.e7
-          ccnc(mgs) = 0.0
-       ELSEIF ( cn(mgs) .gt. ccnc(mgs) ) THEN
-         cn(mgs) = ccnc(mgs)
-         ccnc(mgs) = 0.0
-       ENDIF
-      cx(mgs,lc) = cx(mgs,lc) + cn(mgs)
-      ccnc(mgs) = Max(0.0, ccnc(mgs) - cn(mgs))
-      ENDIF
+      kzb = nzmpb
+      kze = nz-kstag
+ !     if (kzbeg .le. nzmpb .and. kzend .gt. nzmpb) kzb = nzmpb
 
-      ELSEIF ( irenuc == 2 ) THEN !} { 
-      ! simple Twomey scheme
-!      if (ndebug .gt. 0) write(0,*) 'ICEZVD_DR:  Cloud reNucleation, wvel = ',wvel(mgs)
-       CN(mgs) =   CCNE0*cnuc(mgs)**(2./(2.+cck))*Max(0.0,wvel(mgs))**cnexp ! *Min(1.0,1./dtp) ! 0.3465
-!      ccne = ccnefac*1.e6*(1.e-6*Abs(cwccn))**(2./(2.+cck))
-!!!       CN(mgs) = Max( 0.0, CN(mgs) - ccna(mgs) ) ! this was from
-               ! Philips, Donner et al. 2007, but results in too much limitation of
-               ! nucleation
-       CN(mgs) = Min(cn(mgs), ccnc(mgs))
-       cn(mgs) = Min(cn(mgs), 0.5*dqc/cwmasn) ! limit the nucleation mass to half of the condensation mass
-       
-       cx(mgs,lc) = cx(mgs,lc) + cn(mgs)
-       
-       ccnc(mgs) = Max(0.0, ccnc(mgs) - cn(mgs))
+      ixb = nxmpb
+      ixe = itile
 
-      ELSEIF ( irenuc == 7 ) THEN !} { 
+      do kz = kzb,kze
+      do ix = nxmpb,nxi
 
-      ! simple Twomey scheme but limit activation to try to do most activation near cloud base, but keep some CCN available for renuclation
-!      if (ndebug .gt. 0) write(0,*) 'ICEZVD_DR:  Cloud reNucleation, wvel = ',wvel(mgs)
-       cn(mgs) = 0.0
-!       IF ( ccna(mgs) < 0.7*cnuc(mgs) .and. ccnc(mgs) > 0.69*cnuc(mgs) - ccna(mgs)) THEN ! here, assume we are near cloud base and use Twomey formulation
-       IF ( ccna(mgs) < 0.9*cnuc(mgs) ) THEN ! { here, assume we are near cloud base and use Twomey formulation
-         CN(mgs) =  Min( 0.91*cnuc(mgs), CCNE0*cnuc(mgs)**(2./(2.+cck))*Max(0.0,wvel(mgs))**cnexp )! *Min(1.0,1./dtp) ! 0.3465
-!         IF ( cn(mgs) + ccna(mgs) > 0.71*cnuc ) THEN
-         ! prevent this branch from activating more than 70% of CCN
-           CN(mgs) = Min( CN(mgs), Max(0.0, (0.9*cnuc(mgs) - ccna(mgs) )) )
-!           CN(mgs) = Min( CN(mgs), Max(0.0, 0.71*ccnc(mgs) - ccna(mgs) ) )
-           
-       ELSE ! }{
-        ! if a large fraction of CCN have been activated, then assume we are in the cloud interior and use local SSw as in Phillips et al. 2007.
+      pqs(1) = 380.0/(pn(ix,jy,kz) + pb(kz))
+      theta(1) = an(ix,jy,kz,lt)
+      temg(1) = t0(ix,jy,kz)
 
-         temp1 = (theta0(mgs)+thetap(mgs))*pk(mgs) ! t77(ix,jy,kz)
-!          t0(ix,jy,kz) = temp1
-          ltemq = Int( (temp1-163.15)/fqsat+1.5 )
-         ltemq = Min( nqsat, Max(1,ltemq) )
+      temcg(1) = temg(1) - tfr
+      ltemq = (temg(1)-163.15)/fqsat+1.5
+      ltemq = Min( nqsat, Max(1,ltemq) )
+      qvs(1) = pqs(1)*tabqvs(ltemq)
+      qis(1) = pqs(1)*tabqis(ltemq)
 
-        !  c1 = t00(igs(mgs),jy,kgs(mgs))*tabqvs(ltemq)
-          c1= pqs(mgs)*tabqvs(ltemq)
+      qss(1) = qvs(1)
 
-          ssf(mgs) = 0.0
-          IF ( c1 > 0. ) THEN
-            ssf(mgs) = 100.*(qx(mgs,lv)/c1 - 1.0)  ! from "new" values
-          ENDIF
 
-!          IF ( ssf(mgs) <= 1.0 .or. cnuc(mgs) > ccna(mgs) ) THEN
-          IF ( ssf(mgs) <= 1.0 ) THEN
-          CN(mgs) =   cnuc(mgs)*Min(1.0, Max(0.0,ssf(mgs))**cck ) ! 
-          ELSE
-          CN(mgs) =   cnuc(mgs)*Min(2.0, Max(0.0,0.03*(ssf(mgs)-1.0)+1.)**cck ) !           
-!          write(0,*) 'iren7: ssf,ssmx = ',ssf(mgs),ssmax(mgs),cn(mgs),ccna(mgs),cnuc(mgs)
-!          write(0,*) 'c1,qv = ',c1,qx(mgs,lv),temp1,ltemq
-          ENDIF
-          
-
-!        CN(mgs) = Min( Min(0.1,ssf(mgs)-1.)*cnuc(mgs), Max( 0.0, CN(mgs) - ccna(mgs) ) ) ! this was from
-!        CN(mgs) = Min( Min(0.5*cx(mgs,lc), Min(0.1,ssf(mgs)/100.)*cnuc(mgs)), Max( 0.0, CN(mgs) - ccna(mgs) ) ) ! this was from
-        CN(mgs) = Min(0.01*cnuc(mgs), Max( 0.0, CN(mgs) - ccna(mgs) ) ) ! this was from
+      if ( temg(1) .lt. tfr ) then
+      end if
+!
+      if ( (temg(1) .gt. tfrh ) .and.  &
+     &   ( an(ix,jy,kz,lv)  .gt. qss(1) .or. &
+     &     an(ix,jy,kz,lc)  .gt. qxmin(lc)   .or.  &
+     &     ( an(ix,jy,kz,lr)  .gt. qxmin(lr) .and. rcond == 2 )  &
+     &     )) then
+      ngscnt = ngscnt + 1
+      igs(ngscnt) = ix
+      kgs(ngscnt) = kz
+      if ( ngscnt .eq. ngs ) goto 2100
+      end if
 
-       ENDIF ! }
-!      ccne = ccnefac*1.e6*(1.e-6*Abs(cwccn))**(2./(2.+cck))
-!!!       CN(mgs) = Max( 0.0, CN(mgs) - ccna(mgs) ) ! this was from
-               ! Philips, Donner et al. 2007, but results in too much limitation of
-               ! nucleation
-!       CN(mgs) = Min(cn(mgs), ccnc(mgs))
-!       cn(mgs) = Min(cn(mgs), 0.5*dqc/cwmasn) ! limit the nucleation mass to half of the condensation mass
-       
-       IF ( cn(mgs) > 0.0 ) THEN
-       cx(mgs,lc) = cx(mgs,lc) + cn(mgs)
-       
-       ! create some small droplets at minimum size (CP 2000), although it adds very little liquid
-       
-       dcrit = 2.0*2.5e-7
-       
-       dcloud = 1000.*dcrit**3*Pi/6.*cn(mgs)
-        qx(mgs,lc) = qx(mgs,lc) + DCLOUD
-        thetap(mgs) = thetap(mgs) + felvcp(mgs)*DCLOUD/(pi0(mgs))
-        qwvp(mgs) = qwvp(mgs) - DCLOUD
-  !      ccnc(mgs) = Max(0.0, ccnc(mgs) - cn(mgs))
-        ENDIF
+      end do  !ix
 
-      ELSEIF ( irenuc == 8 ) THEN !} { 
-      ! simple Twomey scheme
-!      if (ndebug .gt. 0) write(0,*) 'ICEZVD_DR:  Cloud reNucleation, wvel = ',wvel(mgs)
-       
-       cn(mgs) = 0.0
-       
-       IF ( ccnc(mgs) > 0. ) THEN
-       CN(mgs) =   CCNE0*ccnc(mgs)**(2./(2.+cck))*Max(0.0,wvel(mgs))**cnexp ! *Min(1.0,1./dtp) ! 0.3465
-!      ccne = ccnefac*1.e6*(1.e-6*Abs(cwccn))**(2./(2.+cck))
-!!!       CN(mgs) = Max( 0.0, CN(mgs) - ccna(mgs) ) ! this was from
-               ! Philips, Donner et al. 2007, but results in too much limitation of
-               ! nucleation
-       CN(mgs) = Min(cn(mgs), ccnc(mgs))
-       
-       ELSEIF ( cx(mgs,lc) < 0.01e9 ) THEN
+      nxmpb = 1
+      end do  !kz
+!      if ( jy .eq. (ny-jstag) ) iend = 1
+ 2100 continue
 
-        ! if a large fraction of CCN have been activated, then assume we are in the cloud interior and use local SSw as in Phillips et al. 2007.
+      if ( ngscnt .eq. 0 ) go to 29998
 
-         temp1 = (theta0(mgs)+thetap(mgs))*pk(mgs) ! t77(ix,jy,kz)
-!          t0(ix,jy,kz) = temp1
-          ltemq = Int( (temp1-163.15)/fqsat+1.5 )
-         ltemq = Min( nqsat, Max(1,ltemq) )
+      if (ndebug .gt. 0 ) write(0,*) 'ICEZVD_DR: dbg = 8'
+      
+!      write(0,*) 'NUCOND: dbg = 8, ngscnt,ssmx = ',ngscnt,ssmx
 
-        !  c1 = t00(igs(mgs),jy,kgs(mgs))*tabqvs(ltemq)
-          c1= pqs(mgs)*tabqvs(ltemq)
+      
+      qx(:,:) = 0.0
+      cx(:,:) = 0.0
 
-          ssf(mgs) = 0.0
-          IF ( c1 > 0. ) THEN
-            ssf(mgs) = 100.*(qx(mgs,lv)/c1 - 1.0)  ! from "new" values
-          ENDIF
+      xv(:,:) = 0.0
+      xmas(:,:) = 0.0
 
-!          IF ( ssf(mgs) <= 1.0 .or. cnuc(mgs) > ccna(mgs) ) THEN
-          IF ( ssf(mgs) <= 1.0 ) THEN
-          CN(mgs) = 0.0
-          ELSE
-!          CN(mgs) = 0.01e9*rho0(mgs)/rho00*Min(2.0, Max(0.0,0.03*(ssf(mgs)-1.0)+1.)**cck ) - cx(mgs,lc)
-           CN(mgs) = 0.01e9*Min(2.0, Max(0.0,0.03*(ssf(mgs)-1.0)+1.)**cck ) - cx(mgs,lc)
-          ENDIF
-       
-       ENDIF
+      IF ( imurain == 1 ) THEN
+        alpha(:,lr) = alphar
+      ELSEIF ( imurain == 3 ) THEN
+        alpha(:,lr) = xnu(lr)
+      ENDIF
 
-       IF ( cn(mgs) > 0.0 ) THEN
-       cx(mgs,lc) = cx(mgs,lc) + cn(mgs)
-       
-       ccnc(mgs) = Max(0.0, ccnc(mgs) - cn(mgs))
-       
-       ! create some small droplets at minimum size (CP 2000), although it adds very little liquid
-       
-       dcrit = 2.0*2.5e-7
-       
-       dcloud = 1000.*dcrit**3*Pi/6.*cn(mgs)
-        qx(mgs,lc) = qx(mgs,lc) + DCLOUD
-        thetap(mgs) = thetap(mgs) + felvcp(mgs)*DCLOUD/(pi0(mgs))
-        qwvp(mgs) = qwvp(mgs) - DCLOUD
-  !      ccnc(mgs) = Max(0.0, ccnc(mgs) - cn(mgs))
-        ENDIF
-       
+!
+!  define temporaries for state variables to be used in calculations
+!
+      DO mgs = 1,ngscnt
+      qx(mgs,lv) = an(igs(mgs),jy,kgs(mgs),lv)
+       DO il = lc,lhab
+        qx(mgs,il) = max(an(igs(mgs),jy,kgs(mgs),il), 0.0)
+       ENDDO
 
+       qcwtmp(mgs) = qx(mgs,lc)
 
-      ENDIF ! }
 
-      ccna(mgs) = ccna(mgs) + cn(mgs)
+      theta0(mgs) = an(igs(mgs),jy,kgs(mgs),lt) !
+      thetap(mgs) = 0.0
+      theta(mgs) = an(igs(mgs),jy,kgs(mgs),lt)
+      qv0(mgs) =  qx(mgs,lv)
+      qwvp(mgs) = qx(mgs,lv) - qv0(mgs)
 
+       pres(mgs) = pn(igs(mgs),jy,kgs(mgs)) + pb(kgs(mgs))
+       pipert(mgs) = p2(igs(mgs),jy,kgs(mgs))
+       rho0(mgs) = dn(igs(mgs),jy,kgs(mgs))
+       rhoinv(mgs) = 1.0/rho0(mgs)
+       rhovt(mgs) = Sqrt(rho00/rho0(mgs))
+       pi0(mgs) = p2(igs(mgs),jy,kgs(mgs)) + pinit(kgs(mgs))
+       temg(mgs) = t0(igs(mgs),jy,kgs(mgs))
+!       pk(mgs) = t77(igs(mgs),jy,kgs(mgs)) ! ( pres(mgs) / poo ) ** cap
+       pk(mgs)   = p2(igs(mgs),jy,kgs(mgs)) + pinit(kgs(mgs)) ! t77(igs(mgs),jy,kgs(mgs))
+       temcg(mgs) = temg(mgs) - tfr
+       qss0(mgs) = (380.0)/(pres(mgs))
+       pqs(mgs) = (380.0)/(pres(mgs))
+       ltemq = (temg(mgs)-163.15)/fqsat+1.5
+       ltemq = Min( nqsat, Max(1,ltemq) )
+       qvs(mgs) = pqs(mgs)*tabqvs(ltemq)
+       qis(mgs) = pqs(mgs)*tabqis(ltemq)
+!
+        qvap(mgs) = max( (qwvp(mgs) + qv0(mgs)), 0.0 )
+        es(mgs) = 6.1078e2*tabqvs(ltemq)
+        qss(mgs) = qvs(mgs)
 
 
-      ENDIF ! irenuc >= 0 .and. .not. flag_qndrop
+        temgx(mgs) = min(temg(mgs),313.15)
+        temgx(mgs) = max(temgx(mgs),233.15)
+        felv(mgs) = 2500837.367 * (273.15/temgx(mgs))**((0.167)+(3.67e-4)*temgx(mgs))
+!
+        IF ( eqtset <= 1 ) THEN
+          felvcp(mgs) = felv(mgs)*cpi
+        ELSE ! equation set 2 in cm1
+          tmp = qx(mgs,li)+qx(mgs,ls)+qx(mgs,lh)
+          IF ( lhl > 1 ) tmp = tmp + qx(mgs,lhl)
+          cvm = cv+cvv*qx(mgs,lv)+cpl*(qx(mgs,lc)+qx(mgs,lr))   &
+                                  +cpigb*(tmp)
+          cpm = cp+cpv*qx(mgs,lv)+cpl*(qx(mgs,lc)+qx(mgs,lr))   &
+                                  +cpigb*(tmp)
+          rmm=rd+rw*qx(mgs,lv)
+          
+          IF ( eqtset == 2 ) THEN
 
-      IF( cx(mgs,lc) .GT. 0. .AND. qx(mgs,lc) .LE. qxmin(lc)) cx(mgs,lc)=0.
-      GO TO 631
-!.... NUCLEATION ON CLOUD INFLOW BOUNDARY POINT
+           felvcp(mgs) = (felv(mgs)-rw*temg(mgs))/cvm
 
-  613 CONTINUE
+          ELSE
+            felvcp(mgs) = (felv(mgs)*cv/(cp) - rw*temg(mgs)*(1.0-rovcp*cpm/rmm))/cvm
+            felvpi(mgs) = pi0(mgs)*rovcp*(felv(mgs)/(temg(mgs)) - rw*cpm/rmm)/cvm
+          ENDIF
 
-  631  CONTINUE
+        ENDIF
 
+        temcgx(mgs) = min(temg(mgs),273.15)
+        temcgx(mgs) = max(temcgx(mgs),223.15)
+        temcgx(mgs) = temcgx(mgs)-273.15
+        felf(mgs) = 333690.6098 + (2030.61425)*temcgx(mgs) - (10.46708312)*temcgx(mgs)**2
 !
-! Check for supersaturation greater than ssmx and adjust down
-!
-       ssmx = 1.9
-       qv1 = qv0(mgs) + qwvp(mgs)
-       qvs1 = qvs(mgs)
-       
-!       IF ( flag_qndrop .and. do_satadj_for_wrfchem ) ssmx = 1.04 ! set lower threshold for progn=1 when using WRF-CHEM
+        fels(mgs) = felv(mgs) + felf(mgs)
+        fcqv1(mgs) = 4098.0258*felv(mgs)*cpi
 
-       IF ( qv1 .gt. (ssmx*qvs1) ) THEN
-! use line below to disable saturation adjustment when flag_qndrop is true
-!       IF ( qv1 .gt. (ssmx*qvs1) .and. .not. flag_qndrop ) THEN
-        
-         ss1 = qv1/qvs1
+      wvdf(mgs) = (2.11e-05)*((temg(mgs)/tfr)**1.94)* &
+     &  (101325.0/(pb(kgs(mgs)) + pn(igs(mgs),jgs,kgs(mgs))))                            ! diffusivity of water vapor, Hall and Pruppacher (76)
+      advisc(mgs) = advisc0*(416.16/(temg(mgs)+120.0))* &
+     &  (temg(mgs)/296.0)**(1.5)                         ! dynamic viscosity (SMT; see Beard & Pruppacher 71)
+      tka(mgs) = tka0*advisc(mgs)/advisc1                 ! thermal conductivity
 
-        ssmx = 100.*(ssmx - 1.0)
-        
-        qvex = 0.0
 
-        CALL QVEXCESS(ngs,mgs,qwvp,qv0,qx(1,lc),pres,thetap,theta0,qvex,   &
-     &    pi0,tabqvs,nqsat,fqsat,cbw,fcqv1,felvcp,ssmx,pk,ngscnt)
+      ENDDO
 
 
 
-        IF ( qvex .gt. 0.0 ) THEN
-        thetap(mgs) = thetap(mgs) + felvcp(mgs)*qvex/(pi0(mgs))
-        IF ( io_flag .and. nxtra > 1 ) THEN
-           axtra(igs(mgs),jy,kgs(mgs),1) = axtra(igs(mgs),jy,kgs(mgs),1) + qvex/dtp
+!
+! load concentrations
+!
+      if ( ipconc .ge. 1 ) then
+       do mgs = 1,ngscnt
+        cx(mgs,li) = Max(an(igs(mgs),jy,kgs(mgs),lni), 0.0)
+       end do
+      end if
+      if ( ipconc .ge. 2 ) then
+       do mgs = 1,ngscnt
+        cx(mgs,lc) = Max(an(igs(mgs),jy,kgs(mgs),lnc), 0.0)
+        cwnccn(mgs) = cwccn*rho0(mgs)/rho00
+        cn(mgs) = 0.0
+        IF ( lss > 1 ) ssmax(mgs) = an(igs(mgs),jy,kgs(mgs),lss)
+        IF ( lccn .gt. 1 ) THEN
+          ccnc(mgs) = an(igs(mgs),jy,kgs(mgs),lccn)
+        ELSE
+          ccnc(mgs) = cwnccn(mgs)
         ENDIF
-        qwvp(mgs) = qwvp(mgs) - qvex
-        qx(mgs,lc) = qx(mgs,lc) + qvex
-        IF ( .not. flag_qndrop) THEN
-        cn(mgs) = Min( Max(ccnc(mgs),cwnccn(mgs)), rho0(mgs)*qvex/Max( cwmasn5, xmas(mgs,lc) )  )
-        ccnc(mgs) = Max( 0.0, ccnc(mgs) - cn(mgs) )
-        cx(mgs,lc) = cx(mgs,lc) + cn(mgs)
+        IF ( lccna > 1 ) THEN
+          ccna(mgs) = an(igs(mgs),jy,kgs(mgs),lccna)
+        ELSE
+          IF ( lccn > 1 ) THEN
+            ccna(mgs) = cwnccn(mgs) - ccnc(mgs)
+          ELSE
+            ccna(mgs) = cx(mgs,lc) ! approximation of number of activated ccn
+          ENDIF
         ENDIF
-        
-!        write(iunit,*) 'theta = ',theta0(mgs) + thetap(mgs)
-
-!        temg(mgs) = theta(mgs)*( pres(mgs) / poo ) ** cap
+       end do
+      end if
+      if ( ipconc .ge. 3 ) then
+       do mgs = 1,ngscnt
+        cx(mgs,lr) = Max(an(igs(mgs),jy,kgs(mgs),lnr), 0.0)
+       end do
+      end if
 
+!        cnuc(1:ngscnt) = cwccn*rho0(mgs)/rho00*(1. - renucfrac) + ccnc(1:ngscnt)*renucfrac
+       DO mgs = 1,ngscnt
+        IF ( irenuc /= 6 ) THEN
+        cnuc(mgs) = Max(ccnc(mgs),cwnccn(mgs))*(1. - renucfrac) + ccnc(mgs)*renucfrac
+        ELSE
+        cnuc(mgs) = Max(ccnc(mgs),cwnccn(mgs))*(1. - renucfrac) + Max(0.0,ccnc(mgs) - ccna(mgs))*renucfrac
         ENDIF
+        IF ( renucfrac >= 0.999 ) THEN
+          IF ( temg(mgs) < 265. ) THEN
+            IF ( qx(mgs,lc) > 10.*qxmin(lc) .and. w(igs(mgs),jgs,kgs(mgs)) > 2.0 ) THEN
+             cnuc(mgs) = 0.0 !  Min(cnuc(mgs), 0.5*cx(mgs,lc) ) ! Hack to reduce nucleation at low temp in updraft when ccn are not predicted
+            ELSE
+             cnuc(mgs) = 0.1*cnuc(mgs)
+            ENDIF
+          ENDIF
+        ENDIF
+       ENDDO
 
-       
-       ENDIF
-
+!  Set density
 !
-! Calculate droplet volume and check if it is within bounds.
-!  Adjust if necessary
-!  
-!      if (ndebug .gt. 0) write(0,*) "ICEZVD_DR: check droplet volume" 
-
+      if (ndebug .gt. 0 ) write(0,*) 'ICEZVD_DR: Set density'
 
-!      cx(mgs,lc) = Min( cwnccn(mgs), cx(mgs,lc) )
-      IF( cx(mgs,lc) > cxmin .AND. qx(mgs,lc) .GT. qxmin(lc)) THEN
-!        SVC(mgs) = rho0(mgs)*qx(mgs,lc)/(cx(mgs,lc)*xdn(mgs,lc))
-        xmas(mgs,lc) = rho0(mgs)*qx(mgs,lc)/(cx(mgs,lc))
-        
-       IF (  xmas(mgs,lc) < cwmasn .or.  xmas(mgs,lc) > cwmasx ) THEN
-        xmas(mgs,lc) = Min( xmas(mgs,lc), cwmasx )
-        xmas(mgs,lc) = Max( xmas(mgs,lc), cwmasn )
-        cx(mgs,lc) = rho0(mgs)*qx(mgs,lc)/xmas(mgs,lc)
-       ENDIF
-      ENDIF
+      do mgs = 1,ngscnt
+        xdn(mgs,lc) = xdn0(lc)
+        xdn(mgs,lr) = xdn0(lr)
+      end do
 
+      ventrx(:) = ventr
+      ventrxn(:) = ventrn
+      
 
-!      IF( cx(mgs,lc) .GT. 10.e6 .AND. qx(mgs,lc) .GT. qxmin(lc) ) GO TO 681
-!        ccwtmp = cx(mgs,lc)
-!        cwmastmp = xmas(mgs,lc)
-!       xmas(mgs,lc) = Max(xmas(mgs,lc), cwmasn)
-!       IF (qx(mgs,lc) .GT. qxmin(lc) .AND. cx(mgs,lc) .le. 0.) THEN
-!          cx(mgs,lc) = Min(0.5*cwccn,rho0(mgs)*qx(mgs,lc)/xmas(mgs,lc))
-!          xmas(mgs,lc) = rho0(mgs)*qx(mgs,lc)/cx(mgs,lc)
-!       ENDIF
-!      IF (cx(mgs,lc) .GT. 0. .AND. qx(mgs,lc) .GT. qxmin(lc))    &
-!     &        xmas(mgs,lc) = rho0(mgs)*qx(mgs,lc)/cx(mgs,lc)
-!      IF (qx(mgs,lc) .GT. qxmin(lc) .AND. xmas(mgs,lc) .LT. cwmasn)    &
-!     &          xmas(mgs,lc) = cwmasn
-!      IF (qx(mgs,lc) .GT. qxmin(lc) .AND. xmas(mgs,lc) .GT. cwmasx)    &
-!     &    xmas(mgs,lc) = cwmasx
-!      IF ( qx(mgs,lc) .gt. qxmin(lc) ) THEN
-!        cx(mgs,lc) = rho0(mgs)*qx(mgs,lc)/Max(cwmasn,xmas(mgs,lc))
-!      ENDIF
-!        
-!
-! 681  CONTINUE
 
-        
-      IF ( ipconc .ge. 3 .and. rcond == 2 ) THEN
+!       write(0,*) 'NUCOND: Set ssf variables, ssmxinit =',ssmxinit
+      ssmx = 0.0
+      DO mgs = 1,ngscnt
+      
+      kp1 = Min(nz, kgs(mgs)+1 )
+      wvel(mgs) = (0.5)*(w(igs(mgs),jgs,kp1) & 
+     &                  +w(igs(mgs),jgs,kgs(mgs)))
+      wvelkm1(mgs) = (0.5)*(w(igs(mgs),jgs,kgs(mgs)) & 
+     &                  +w(igs(mgs),jgs,Max(1,kgs(mgs)-1)))
 
-        
-        IF (cx(mgs,lr) .GT. 0. .AND. qx(mgs,lr) .GT. qxmin(lr))    &
-     &       xv(mgs,lr)=rho0(mgs)*qx(mgs,lr)/(xdn(mgs,lr)*cx(mgs,lr))
-        IF (xv(mgs,lr) .GT. xvmx(lr)) xv(mgs,lr) = xvmx(lr)
-        IF (xv(mgs,lr) .LT. xvmn(lr)) xv(mgs,lr) = xvmn(lr)
+      ssat0(mgs)  = ssfilt(igs(mgs),jgs,kgs(mgs))
+      ssf(mgs)    = ssfilt(igs(mgs),jgs,kgs(mgs))
+!      ssmx = Max( ssmx, ssf(mgs) )
 
-      ENDIF
+      
+      ssfkp1(mgs) = ssfilt(igs(mgs),jgs,Min(nz-1,kgs(mgs)+1))
+      ssfkm1(mgs) = ssfilt(igs(mgs),jgs,Max(1,kgs(mgs)-1))
 
 
+      ENDDO
 
-      ENDDO ! mgs
 
 
-! ################################################################
-      DO mgs=1,ngscnt
-      IF ( ssf(mgs) .gt. ssmax(mgs)    &
-     &  .and. ( idecss .eq. 0 .or. qx(mgs,lc) .gt. qxmin(lc)) ) THEN
-        ssmax(mgs) = ssf(mgs)
-      ENDIF
-      ENDDO
 !
-
-      do mgs = 1,ngscnt
-      an(igs(mgs),jy,kgs(mgs),lt) = theta0(mgs) + thetap(mgs)
-      an(igs(mgs),jy,kgs(mgs),lv) =  qv0(mgs) + qwvp(mgs)
-!      tmp3d(igs(mgs),jy,kgs(mgs)) = tmp3d(igs(mgs),jy,kgs(mgs)) + t9(igs(mgs),jy,kgs(mgs)) !  pi0(mgs) ! wvdf(mgs) ! ssf(mgs) ! cn(mgs)
+!  cloud water variables
 !
-      IF ( eqtset > 2 ) THEN
-        p2(igs(mgs),jy,kgs(mgs)) = pipert(mgs)
-      ENDIF
 
-       if ( ido(lc) .eq. 1 )  then
-        an(igs(mgs),jy,kgs(mgs),lc) = qx(mgs,lc) +    &
-     &    min( an(igs(mgs),jy,kgs(mgs),lc), 0.0 )
-!        qx(mgs,lc) = an(igs(mgs),jy,kgs(mgs),lc)
-       end if
-!
+      if ( ndebug .gt. 0 )write(0,*) 'ICEZVD_DR: Set cloud water variables'
 
-       if ( ido(lr) .eq. 1 .and. rcond == 2 )  then
-        an(igs(mgs),jy,kgs(mgs),lr) = qx(mgs,lr) +    &
-     &    min( an(igs(mgs),jy,kgs(mgs),lr), 0.0 )
-!        qx(mgs,lr) = an(igs(mgs),jy,kgs(mgs),lr)
-       end if
+      do mgs = 1,ngscnt
+      xv(mgs,lc) = 0.0
+      IF ( ipconc .ge. 2 .and. cx(mgs,lc) .gt. 1.0e6 ) THEN
+        xmas(mgs,lc) = &
+     &    min( max(qx(mgs,lc)*rho0(mgs)/cx(mgs,lc),cwmasn),cwmasx )
+        xv(mgs,lc) = xmas(mgs,lc)/xdn(mgs,lc)
+      ELSE
+       IF ( qx(mgs,lc) .gt. qxmin(lc) .and. cx(mgs,lc) .gt. 0.01 ) THEN
+        xmas(mgs,lc) = &
+     &     min( max(qx(mgs,lc)*rho0(mgs)/cx(mgs,lc),xdn(mgs,lc)*xvmn(lc)), &
+     &      xdn(mgs,lc)*xvmx(lc) )
 
+        cx(mgs,lc) = qx(mgs,lc)*rho0(mgs)/xmas(mgs,lc)
 
+       ELSEIF ( qx(mgs,lc) .gt. qxmin(lc) .and. cx(mgs,lc) .le. 0.01 ) THEN
+        xmas(mgs,lc) = xdn(mgs,lc)*4.*pi/3.*(5.0e-6)**3
+        cx(mgs,lc) = rho0(mgs)*qx(mgs,lc)/xmas(mgs,lc)
 
-       IF (  ipconc .ge. 2 ) THEN
-        an(igs(mgs),jy,kgs(mgs),lnc) = Max(cx(mgs,lc) , 0.0)
-        IF ( lss > 1 ) an(igs(mgs),jy,kgs(mgs),lss) = Max( 0.0, ssmax(mgs) )
-        IF ( lccn .gt. 1 ) THEN
-          an(igs(mgs),jy,kgs(mgs),lccn) = Max(0.0,  ccnc(mgs) )
-        ENDIF
-        IF ( lccna .gt. 1 ) THEN
-          an(igs(mgs),jy,kgs(mgs),lccna) = Max(0.0, ccna(mgs) )
-        ENDIF
-       ENDIF
-       IF (  ipconc .ge. 3 .and. rcond == 2 ) THEN
-        an(igs(mgs),jy,kgs(mgs),lnr) = Max(cx(mgs,lr) , 0.0)
+       ELSE
+        xmas(mgs,lc) = cwmasn
        ENDIF
-      end do
+      ENDIF
+      xdia(mgs,lc,1) = (xmas(mgs,lc)*cwc1)**c1f3
 
 
-29998 continue
+      end do
+!
+! rain
+!
+      do mgs = 1,ngscnt
+      if ( qx(mgs,lr) .gt. qxmin(lr) ) then
 
+      if ( ipconc .ge. 3 ) then
+        xv(mgs,lr) = rho0(mgs)*qx(mgs,lr)/(xdn(mgs,lr)*Max(1.0e-9,cx(mgs,lr)))
+!      parameter( xvmn(lr)=2.8866e-13, xvmx(lr)=4.1887e-9 )  ! mks
+        IF ( xv(mgs,lr) .gt. xvmx(lr) ) THEN
+          xv(mgs,lr) = xvmx(lr)
+          cx(mgs,lr) = rho0(mgs)*qx(mgs,lr)/(xvmx(lr)*xdn(mgs,lr))
+        ELSEIF ( xv(mgs,lr) .lt. xvmn(lr) ) THEN
+          xv(mgs,lr) = xvmn(lr)
+          cx(mgs,lr) = rho0(mgs)*qx(mgs,lr)/(xvmn(lr)*xdn(mgs,lr))
+        ENDIF
 
-      if ( kz .gt. nz-1 .and. ix .ge. nxi) then
-        if ( ix .ge. nxi ) then
-         go to 2200 ! exit gather scatter
-        else
-         nzmpb = kz
-        endif
-      else
-        nzmpb = kz
-      end if
+        xmas(mgs,lr) = xv(mgs,lr)*xdn(mgs,lr)
+        xdia(mgs,lr,3) = (xmas(mgs,lr)*cwc1)**(1./3.) ! xdia(mgs,lr,1)
+        IF ( imurain == 3 ) THEN
+!          xdia(mgs,lr,1) = (6.*pii*xv(mgs,lr)/(alpha(mgs,lr)+1.))**(1./3.)
+          xdia(mgs,lr,1) = xdia(mgs,lr,3) ! formulae for Ziegler (1985) use mean volume diameter, not lambda**(-1)
+        ELSE ! imurain == 1, Characteristic diameter (1/lambda)
+          xdia(mgs,lr,1) = (6.*piinv*xv(mgs,lr)/((alpha(mgs,lr)+3.)*(alpha(mgs,lr)+2.)*(alpha(mgs,lr)+1.)))**(1./3.)
+        ENDIF
+!        rwrad(mgs) = 0.5*xdia(mgs,lr,1)
 
-      if ( ix .ge. nxi ) then
-        nxmpb = 1
-        nzmpb = kz+1
+! Inverse exponential version:
+!        xdia(mgs,lr,1) =
+!     >  (qx(mgs,lr)*rho0(mgs)
+!     > /(pi*xdn(mgs,lr)*cx(mgs,lr)))**(0.333333)
+      ELSE
+        xdia(mgs,lr,1) = &
+     &  (qx(mgs,lr)*rho0(mgs)/(pi*xdn(mgs,lr)*cno(lr)))**(0.25)
+      end if
       else
-       nxmpb = ix+1
+        xdia(mgs,lr,1) = 1.e-9
+!        rwrad(mgs) = 0.5*xdia(mgs,lr,1)
       end if
 
- 2000 continue ! inumgs
- 2200 continue
+      end do
+
+
 !
-!  end of gather scatter (for this jy slice)
+!  Ventilation coefficients
 
+      do mgs = 1,ngscnt
 
-!#ifdef COMMAS
-!    GOTO 9999
-!#endif
 
-! Redistribute inappreciable cloud particles and charge
-!
-! Redistribution everywhere in the domain...
-!
-      frac = 1.0 ! 0.25 ! 1.0 ! 0.2
-!
-!  alternate test version for ipconc .ge. 3
-!  just vaporize stuff to prevent noise in the number concentrations
+      fadvisc(mgs) = advisc0*(416.16/(temg(mgs)+120.0))* & 
+     &  (temg(mgs)/296.0)**(1.5)
 
+      fakvisc(mgs) = fadvisc(mgs)*rhoinv(mgs)
 
-      do kz = 1,nz
-!      do jy = 1,1
-      do ix = 1,nxi
-      
-      t0(ix,jy,kz) = an(ix,jy,kz,lt)*t77(ix,jy,kz)
+      fwvdf(mgs) = (2.11e-05)*((temg(mgs)/tfr)**1.94)* & 
+     &  (101325.0/(pres(mgs)))
       
-      zerocx(:) = .false.
-      DO il = lc,lhab
-       IF ( iresetmoments == 1 .or. iresetmoments == il ) THEN
-        IF ( ln(il) > 1 ) zerocx(il) = ( an(ix,jy,kz,ln(il)) < cxmin )
-        IF ( lz(il) > 1 ) zerocx(il) = ( zerocx(il) .or. an(ix,jy,kz,lz(il)) < zxmin )
-       ELSE
-        IF ( il == lc ) THEN
-          IF ( ln(il) > 1 ) zerocx(il) = ( an(ix,jy,kz,ln(il)) <= 0 ) .and. .not. flag_qndrop ! don't reset if progn=1 (WRF-CHEM)
-        ELSE
-         IF ( ln(il) > 1 ) zerocx(il) = ( an(ix,jy,kz,ln(il)) <= 0 )
-        ENDIF
-       ENDIF
-      ENDDO
+      fschm(mgs) = (fakvisc(mgs)/fwvdf(mgs))
 
-      IF ( lhl .gt. 1 ) THEN
-      
-      
-      if ( an(ix,jy,kz,lhl) .lt. frac*qxmin(lhl) .or. zerocx(lhl) ) then
+      fvent(mgs) = (fschm(mgs)**(1./3.)) * (fakvisc(mgs)**(-0.5))
 
-!        IF ( an(ix,jy,kz,lhl) .gt. 0 ) THEN
-          an(ix,jy,kz,lv) = an(ix,jy,kz,lv) + an(ix,jy,kz,lhl)
-          an(ix,jy,kz,lhl) = 0.0
-!        ENDIF
+      end do
+!
+!
+!  Ziegler nucleation 
+!
+!
+! cloud evaporation, condensation, and nucleation
+!  sqsat -> qss(mgs)
 
-        IF ( ipconc .ge. 5 ) THEN ! .and. an(ix,jy,kz,lnh) .gt. 0.0 ) THEN
-          an(ix,jy,kz,lnhl) = 0.0
+      DO mgs=1,ngscnt
+        dcloud = 0.0
+        IF ( temg(mgs) .le. tfrh ) THEN
+         CYCLE
         ENDIF
 
-        IF ( lvhl .gt. 1 ) THEN
-           an(ix,jy,kz,lvhl) = 0.0
-        ENDIF
+      IF( ssat0(mgs) .GT. 0. .OR. ssf(mgs) .GT. 0. ) GO TO 620
+!6/4      IF( qvap(mgs) .EQ. qss(mgs) ) GO TO 631
+!
+!.... EVAPORATION. QV IS LESS THAN qss(mgs).
+!.... EVAPORATE CLOUD FIRST
+!
+      IF ( qx(mgs,lc) .LE. 0. ) GO TO 631
+!.... CLOUD EVAPORATION.
+! convert input 'cp' to cgs
+      R1=1./(1. + caw*(273.15 - cbw)*qss(mgs)*felv(mgs)/ &
+     &            (cp*(temg(mgs) - cbw)**2))
+      QEVAP= Min( qx(mgs,lc), R1*(qss(mgs)-qvap(mgs)) )
 
-        IF ( lhlw .gt. 1 ) THEN
-           an(ix,jy,kz,lhlw) = 0.0
-        ENDIF
-      
-        IF ( lzhl .gt. 1 ) THEN
-           an(ix,jy,kz,lzhl) = 0.0
-        ENDIF
 
-      ELSE
-       IF ( lvol(lhl) .gt. 1 ) THEN  ! check density
-        IF ( an(ix,jy,kz,lvhl) .gt. 0.0 ) THEN
-         tmp = dn(ix,jy,kz)*an(ix,jy,kz,lhl)/an(ix,jy,kz,lvhl)
-        ELSE ! in case volume is zero but mass is above threshold (should not happen, of course)
-          tmp = rho_qhl
-          an(ix,jy,kz,lvhl) = dn(ix,jy,kz)*an(ix,jy,kz,lhl)/tmp
+      IF ( qx(mgs,lc) .LT. QEVAP ) THEN ! GO TO 63
+        qwvp(mgs) = qwvp(mgs) + qx(mgs,lc)
+        thetap(mgs) = thetap(mgs) - felv(mgs)*qx(mgs,lc)/(cp*pi0(mgs))
+        IF ( io_flag .and. nxtra > 1 ) THEN
+           axtra(igs(mgs),jy,kgs(mgs),1) = -qx(mgs,lc)/dtp
         ENDIF
-
-        IF (  tmp .lt. xdnmn(lhl) ) THEN
-          tmp = Max( xdnmn(lhl), tmp )
-          an(ix,jy,kz,lvhl) = dn(ix,jy,kz)*an(ix,jy,kz,lhl)/tmp
+        qx(mgs,lc) = 0.
+        cx(mgs,lc) = 0.
+      ELSE
+        qwvp(mgs) = qwvp(mgs) + QEVAP
+        qx(mgs,lc) = qx(mgs,lc) - QEVAP
+        IF ( qx(mgs,lc) .le. 0. ) cx(mgs,lc) = 0.
+        thetap(mgs) = thetap(mgs) - felv(mgs)*QEVAP/(CP*pi0(mgs))
+        IF ( io_flag .and. nxtra > 1 ) THEN
+           axtra(igs(mgs),jy,kgs(mgs),1) = -QEVAP/dtp
         ENDIF
 
-        IF ( tmp .gt. xdnmx(lhl) .and. lhlw .le. 0 ) THEN ! no liquid allowed on hail
-          tmp = Min( xdnmx(lhl), tmp )
-          an(ix,jy,kz,lvhl) = dn(ix,jy,kz)*an(ix,jy,kz,lhl)/tmp
-        ELSEIF ( tmp .gt. xdnmx(lhl) .and. lhlw .gt. 1 ) THEN  ! allow for liquid on hail
-          fw = an(ix,jy,kz,lhlw)/an(ix,jy,kz,lhl)
-!          tmpmx = xdnmx(lhl) + fw*(xdnmx(lr) - xdnmx(lhl)) ! maximum possible average density
-                                                           ! it is not exactly linear, but approx. is close enough for this
-!          tmpmx = 1./( (1. - fw)/900. + fw/1000. ) is exact max, where 900 is xdnmx
-
-          tmpmx = xdnmx(lhl)/( 1. - fw*(1. - xdnmx(lhl)/xdnmx(lr) )) 
-
-          IF ( tmp .gt. tmpmx  ) THEN
-            an(ix,jy,kz,lvhl) = dn(ix,jy,kz)*an(ix,jy,kz,lhl)/tmpmx
-          ENDIF
+      ENDIF
 
-!          IF ( tmp .gt. xdnmx(lhl) .and. an(ix,jy,kz,lhlw) .lt. qxmin(lhl) ) THEN
-!            tmp = Min( xdnmx(lhl), tmp )
-!            an(ix,jy,kz,lvhl) = dn(ix,jy,kz)*an(ix,jy,kz,lhl)/tmp
-!          ELSEIF ( tmp .gt. xdnmx(lr) ) THEN
-!            tmp =  xdnmx(lr)
-!            an(ix,jy,kz,lvhl) = dn(ix,jy,kz)*an(ix,jy,kz,lhl)/tmp
-!          ENDIF
-        ENDIF
+      GO TO 631
 
-        IF ( lhlw .gt. 1 ) THEN ! check if basically pure water
-          IF ( an(ix,jy,kz,lhlw) .gt. 0.98*an(ix,jy,kz,lhl) ) THEN
-           tmp = xdnmx(lr)
-           an(ix,jy,kz,lvhl) = dn(ix,jy,kz)*an(ix,jy,kz,lhl)/tmp
-          ENDIF
-        ENDIF
-        
-       ENDIF
-       
-       
-!  CHECK INTERCEPT
-       IF ( ipconc == 5 .and.  an(ix,jy,kz,lhl) .gt. qxmin(lhl) .and.  alphahl .le. 0.1 .and. lnhl .gt. 1 .and. lzhl == 0 ) THEN
-       
-         IF ( lvhl .gt. 1 ) THEN
-           hwdn = dn(ix,jy,kz)*an(ix,jy,kz,lhl)/an(ix,jy,kz,lvhl)
-         ELSE
-           hwdn = xdn0(lhl)
-         ENDIF
-           tmp = (hwdn*an(ix,jy,kz,lnhl))/(dn(ix,jy,kz)*an(ix,jy,kz,lhl))
-           tmpg = an(ix,jy,kz,lnhl)*(tmp*(3.14159))**(1./3.)
-           IF ( tmpg .lt. cnohlmn ) THEN
-             tmp = ( (hwdn)/(dn(ix,jy,kz)*an(ix,jy,kz,lhl))*(3.14159))**(1./3.)
-              an(ix,jy,kz,lnhl) = (cnohlmn/tmp)**(3./4.)
-           ENDIF
-       
-       ENDIF
-!      ELSE  ! check mean size here?
 
-      end if
+  620 CONTINUE
 
+!.... CLOUD CONDENSATION
 
+        IF ( qx(mgs,lc) .GT. qxmin(lc) .and. cx(mgs,lc) .ge. 1. ) THEN
 
-      ENDIF !lhl
 
 
-      if ( an(ix,jy,kz,lh) .lt. frac*qxmin(lh) .or. zerocx(lh) ) then
+!       ac1 =  xdn(mgs,lc)*elv(kgs(mgs))**2*epsi/
+!     :        (tka(kgs(mgs))*rw*temg(mgs)**2)
+! took out xdn factor because it cancels later...
+       ac1 =  felv(mgs)**2/(tka(mgs)*rw*temg(mgs)**2)
 
-!        IF ( an(ix,jy,kz,lh) .gt. 0 ) THEN
-          an(ix,jy,kz,lv) = an(ix,jy,kz,lv) + an(ix,jy,kz,lh)
-          an(ix,jy,kz,lh) = 0.0
-!        ENDIF
 
-        IF ( ipconc .ge. 5 ) THEN ! .and. an(ix,jy,kz,lnh) .gt. 0.0 ) THEN
-          an(ix,jy,kz,lnh) = 0.0
-        ENDIF
+!       bc = xdn(mgs,lc)*rw*temg(mgs)/
+!     :       (epsi*wvdf(kgs(mgs))*es(mgs))
+! took out xdn factor because it cancels later...
+       bc =   rw*temg(mgs)/(wvdf(mgs)*es(mgs))
 
-        IF ( lvh .gt. 1 ) THEN
-           an(ix,jy,kz,lvh) = 0.0
-        ENDIF
-      
-        IF ( lhw .gt. 1 ) THEN
-           an(ix,jy,kz,lhw) = 0.0
-        ENDIF
-      
-        IF ( lzh .gt. 1 ) THEN
-           an(ix,jy,kz,lzh) = 0.0
-        ENDIF
+!       bs = rho0(mgs)*((rd*temg(mgs)/(epsi*es(mgs)))+
+!     :             (epsi*elv(kgs(mgs))**2/(pres(mgs)*temg(mgs)*cp)))
 
-      ELSE
-       IF ( lvol(lh) .gt. 1 ) THEN  ! check density
-        IF ( an(ix,jy,kz,lvh) .gt. 0.0 ) THEN
-         tmp = dn(ix,jy,kz)*an(ix,jy,kz,lh)/an(ix,jy,kz,lvh)
-        ELSE
-         tmp = rho_qh
-          an(ix,jy,kz,lvh) = dn(ix,jy,kz)*an(ix,jy,kz,lh)/tmp
-        ENDIF
+!       taus = Min(dtp, xdn(mgs,lc)*rho0(mgs)*(ac1+bc)/
+!     :        (4*pi*0.89298*BS*0.5*xdia(mgs,lc,1)*cx(mgs,lc)*xdn(mgs,lc)))
 
-        IF (  tmp .lt. xdnmn(lh) ) THEN
-          tmp = Max( xdnmn(lh), tmp )
-          an(ix,jy,kz,lvh) = dn(ix,jy,kz)*an(ix,jy,kz,lh)/tmp
-        ENDIF
+!
+      IF ( ssf(mgs) .gt. 0.0 .or. ssat0(mgs) .gt. 0.0 ) THEN
+       IF ( ny .le. 2 ) THEN
+!        write(0,*)  'undershoot: ',ssf(mgs),
+!     :   ( (qx(mgs,lv) - dcloud)/c1 - 1.0)*100.
+       ENDIF
 
-        IF ( tmp .gt. xdnmx(lh) .and. lhw .le. 0 ) THEN ! no liquid allowed on graupel
-          tmp = Min( xdnmx(lh), tmp )
-          an(ix,jy,kz,lvh) = dn(ix,jy,kz)*an(ix,jy,kz,lh)/tmp
-        ELSEIF ( tmp .gt. xdnmx(lh) .and. lhw .gt. 1 ) THEN  ! allow for liquid on graupel
-          fw = an(ix,jy,kz,lhw)/an(ix,jy,kz,lh)
-!          tmpmx = xdnmx(lh) + fw*(xdnmx(lr) - xdnmx(lh)) ! maximum possible average density
-                                                           ! it is not exactly linear, but approx. is close enough for this
-!          tmpmx = 1./( (1. - fw)/900. + fw/1000. ) is exact max, where 900 is xdnmx
-          tmpmx = xdnmx(lh)/( 1. - fw*(1. - xdnmx(lh)/xdnmx(lr) )) 
 
-          IF ( tmp .gt. tmpmx  ) THEN
-            an(ix,jy,kz,lvh) = dn(ix,jy,kz)*an(ix,jy,kz,lh)/tmpmx
-          ENDIF
 
-!          IF ( tmp .gt. xdnmx(lh) .and. an(ix,jy,kz,lhw) .lt. qxmin(lh) ) THEN
-!            tmp = Min( xdnmx(lh), tmp )
-!            an(ix,jy,kz,lvh) = dn(ix,jy,kz)*an(ix,jy,kz,lh)/tmp
-!          ELSEIF ( tmp .gt. xdnmx(lr) ) THEN
-!            tmp =  xdnmx(lr)
-!            an(ix,jy,kz,lvh) = dn(ix,jy,kz)*an(ix,jy,kz,lh)/tmp
-!          ENDIF
+       IF ( qx(mgs,lc) .gt. qxmin(lc) ) THEN
 
-        ENDIF
+         IF ( xdia(mgs,lc,1) .le. 0.0 ) THEN
+          xmas(mgs,lc) = cwmasn
+          xdia(mgs,lc,1) = (xmas(mgs,lc)*cwc1)**c1f3
+         ENDIF
+        d1 = (1./(ac1 + bc))*4.0*pi*ventc &
+     &        *0.5*xdia(mgs,lc,1)*cx(mgs,lc)*rhoinv(mgs)
 
-        IF ( lhw .gt. 1 ) THEN ! check if basically pure water
-          IF ( an(ix,jy,kz,lhw) .gt. 0.98*an(ix,jy,kz,lh) ) THEN
-           tmp = xdnmx(lr)
-           an(ix,jy,kz,lvh) = dn(ix,jy,kz)*an(ix,jy,kz,lh)/tmp
-          ENDIF
-        ENDIF
-        
+       ELSE
+         d1 = 0.0
        ENDIF
 
-!  CHECK INTERCEPT
-       IF ( ipconc == 5 .and.  an(ix,jy,kz,lh) .gt. qxmin(lh) .and.  alphah .le. 0.1 .and. lnh .gt. 1 .and. lzh == 0 ) THEN
-       
-         IF ( lvh .gt. 1 ) THEN
-           IF ( an(ix,jy,kz,lvh) .gt. 0.0 ) THEN
-             hwdn = dn(ix,jy,kz)*an(ix,jy,kz,lh)/an(ix,jy,kz,lvh)
-           ELSE
-             hwdn = xdn0(lh)
-           ENDIF
-           hwdn = Max( xdnmn(lh), hwdn )
-         ELSE
-           hwdn = xdn0(lh)
-         ENDIF
-           tmp = (hwdn*an(ix,jy,kz,lnh))/(dn(ix,jy,kz)*an(ix,jy,kz,lh))
-           tmpg = an(ix,jy,kz,lnh)*(tmp*(3.14159))**(1./3.)
-           IF ( tmpg .lt. cnohmn ) THEN
-!           tmpg = an(ix,jy,kz,lnh)*( (hwdn*an(ix,jy,kz,lnh))/(dn(ix,jy,kz)*an(ix,jy,kz,lh))*(3.14159))**(1./3.)
-!           tmpg = an(ix,jy,kz,lnh)**(4./3.)*( (hwdn)/(dn(ix,jy,kz)*an(ix,jy,kz,lh))*(3.14159))**(1./3.)
-             tmp = ( (hwdn)/(dn(ix,jy,kz)*an(ix,jy,kz,lh))*(3.14159))**(1./3.)
-              an(ix,jy,kz,lnh) = (cnohmn/tmp)**(3./4.)
+       IF ( rcond .eq. 2 .and. qx(mgs,lr) .gt. qxmin(lr) .and. cx(mgs,lr) > 1.e-9 ) THEN
+          IF ( imurain == 3 ) THEN
+           IF ( izwisventr == 1 ) THEN
+            rwvent(mgs) = ventrx(mgs)*(1.6 + 124.9*(1.e-3*rho0(mgs)*qx(mgs,lr))**.2046)
+           ELSE ! izwisventr = 2
+!  Following Wisner et al. (1972) but using gamma of volume. Note that Ferrier rain fall speed does not integrate with gamma of volume, so using Vr = ar*d^br
+          rwvent(mgs) =   &
+     &  (0.78*ventrx(mgs) + 0.308*ventrxn(mgs)*fvent(mgs)   &
+     &   *Sqrt((ar*rhovt(mgs)))   &
+     &    *(xdia(mgs,lr,1)**((1.0+br)/2.0)) )
            ENDIF
-       
-       ENDIF
-        
-      end if
 
+          ELSE ! imurain == 1
 
-      if ( an(ix,jy,kz,ls) .lt.  frac*qxmin(ls)  .or. zerocx(ls)  & ! .or.  an(ix,jy,kz,lns) .lt. 0.1 ! .and.
-     &         ) then
-      IF ( t0(ix,jy,kz) .lt. 273.15 ) THEN
-!        IF ( an(ix,jy,kz,ls) .gt. 0 ) THEN
-          an(ix,jy,kz,lv) = an(ix,jy,kz,lv) + an(ix,jy,kz,ls)
-          an(ix,jy,kz,ls) = 0.0
-!        ENDIF
-      
-        IF ( ipconc .ge. 4 ) THEN ! .and. an(ix,jy,kz,lns) .gt. 0.0  ) THEN ! 
-!          an(ix,jy,kz,lni) = an(ix,jy,kz,lni) + an(ix,jy,kz,lns)
-          an(ix,jy,kz,lns) = 0.0
-        ENDIF
-        
-        IF ( lvs .gt. 1 ) THEN
-           an(ix,jy,kz,lvs) = 0.0
-        ENDIF
-
-        IF ( lsw .gt. 1 ) THEN
-           an(ix,jy,kz,lsw) = 0.0
-        ENDIF
+           IF ( iferwisventr == 1 ) THEN
+             alpr = Min(alpharmax,alpha(mgs,lr) )
+!             alpr = alpha(mgs,lr)
+             x =  1. + alpr
 
-      ELSE
-!        IF ( an(ix,jy,kz,ls) .gt. 0 ) THEN
-          an(ix,jy,kz,lv) = an(ix,jy,kz,lv) + an(ix,jy,kz,ls)
-          an(ix,jy,kz,ls) = 0.0
-!        ENDIF
+              tmp = 1 + alpr
+              i = Int(dgami*(tmp))
+              del = tmp - dgam*i
+              g1palp = gmoi(i) + (gmoi(i+1) - gmoi(i))*del*dgami
 
-        IF ( lvs .gt. 1 ) THEN
-           an(ix,jy,kz,lvs) = 0.0
-        ENDIF
+              tmp = 2.5 + alpr + 0.5*bx(lr)
+              i = Int(dgami*(tmp))
+              del = tmp - dgam*i
+              y = (gmoi(i) + (gmoi(i+1) - gmoi(i))*del*dgami)/g1palp ! ratio of gamma functions
 
-        IF ( lsw .gt. 1 ) THEN
-           an(ix,jy,kz,lsw) = 0.0
-        ENDIF
+!         vent1 = dble(xdia(mgs,lr,1))**(-2. - alpr) ! Actually OK
+!         vent2 = dble(1./xdia(mgs,lr,1) + 0.5*fx(lr))**dble(2.5+alpr+0.5*bx(lr))  ! Actually OK
+         vent1 = dble(xdia(mgs,lr,1))**(0.5 + 0.5*bx(lr)) ! 2016.2.26 Changed for consistency with derivation (recast formula)
+         vent2 = dble(1. + 0.5*fx(lr)*xdia(mgs,lr,1))**dble(2.5+alpr+0.5*bx(lr))
+        
+        
+        rwvent(mgs) =    &
+     &    0.78*x +    &
+     &    0.308*fvent(mgs)*y*   &
+     &            Sqrt(ax(lr)*rhovt(mgs))*(vent1/vent2)
 
-        IF ( ipconc .ge. 4 ) THEN ! .and. an(ix,jy,kz,lns) .gt. 0.0  ) THEN ! 
-!          an(ix,jy,kz,lnr) = an(ix,jy,kz,lnr) + an(ix,jy,kz,lns)
-          an(ix,jy,kz,lns) = 0.0
-        ENDIF
+           ELSEIF ( iferwisventr == 2 ) THEN
+          
+!  Following Wisner et al. (1972) but using gamma of volume. Note that Ferrier rain fall speed does not integrate with gamma of volume, so using Vr = ar*d^br
+            x =  1. + alpha(mgs,lr)
 
-      ENDIF
-      
+            rwvent(mgs) =   &
+     &        (0.78*x + 0.308*ventrxn(mgs)*fvent(mgs)   &
+     &         *Sqrt((ar*rhovt(mgs)))   &
+     &         *(xdia(mgs,lr,1)**((1.0+br)/2.0)) )
 
-      ELSEIF ( lvol(ls) .gt. 1 ) THEN  ! check density
-        IF ( an(ix,jy,kz,lvs) .gt. 0.0 ) THEN
-          tmp = dn(ix,jy,kz)*an(ix,jy,kz,ls)/an(ix,jy,kz,lvs)
-          IF ( tmp .gt. xdnmx(ls) .or. tmp .lt. xdnmn(ls) ) THEN
-            tmp = Min( xdnmx(ls), Max( xdnmn(ls), tmp ) )
-            an(ix,jy,kz,lvs) = dn(ix,jy,kz)*an(ix,jy,kz,ls)/tmp
-          ENDIF
-        ELSE
-          tmp = rho_qs
-          an(ix,jy,kz,lvs) = dn(ix,jy,kz)*an(ix,jy,kz,ls)/tmp
-        ENDIF
+          
+          ENDIF ! iferwisventr
+          
+       ENDIF ! imurain
 
+       d1r = (1./(ac1 + bc))*4.0*pi*rwvent(mgs) & 
+     &        *0.5*xdia(mgs,lr,1)*cx(mgs,lr)*rhoinv(mgs)
+       ELSE
+       d1r = 0.0
+       ENDIF
+       
+       
+       e1  = felvcp(mgs)/(pi0(mgs))
+       f1 = pk(mgs) ! (pres(mgs)/poo)**cap
 
-      end if
+!
+!  fifth trial to see what happens:
+!
+       ltemq = (temg(mgs)-163.15)/fqsat+1.5
+       ltemq = Min( nqsat, Max(1,ltemq) )
+       ltemq1 = ltemq
+       temp1 = temg(mgs)
+       p380 = 380.0/pres(mgs)
 
+!       taus = Max( 0.05*dtp, Min(taus, 0.25*dtp ) )
+!       nc = NInt(dtp/Min(1.0,0.5*taus))
+!       dtcon = dtp/float(nc)
+       ss1 = qx(mgs,lv)/qvs(mgs)
+       ss2 = ss1
+       temp2 = temp1
+       qv1 = qx(mgs,lv)
+       qvs1 = qvs(mgs)
+       qis1 = qis(mgs)
+       dt1 = 0.0
 
-      if ( an(ix,jy,kz,lr) .lt. frac*qxmin(lr)  .or. zerocx(lr)  &
-     &  ) then
-        an(ix,jy,kz,lv) = an(ix,jy,kz,lv) + an(ix,jy,kz,lr)
-        an(ix,jy,kz,lr) = 0.0
-        IF ( ipconc .ge. 3 ) THEN
-!          an(ix,jy,kz,lnc) = an(ix,jy,kz,lnc) + an(ix,jy,kz,lnr)
-          an(ix,jy,kz,lnr) = 0.0
-        ENDIF
-        
-      end if
 
-!
-!  for qci
-!
-      IF ( an(ix,jy,kz,li) .le. frac*qxmin(li) .or. zerocx(li)   & ! .or.  an(ix,jy,kz,lni) .lt. 0.1
-     &    ) THEN
-      an(ix,jy,kz,lv) = an(ix,jy,kz,lv) + an(ix,jy,kz,li)
-      an(ix,jy,kz,li)= 0.0
-       IF ( ipconc .ge. 1 ) THEN
-         an(ix,jy,kz,lni) = 0.0
-       ENDIF
-      ENDIF
+!          dtcon = Max(dtcon,0.2)
+!          nc = Nint(dtp/dtcon)
 
-!
-!  for qis
-!
-      IF ( lis > 1 ) THEN ! {
-      IF ( an(ix,jy,kz,lis) .le. frac*qxmin(lis) .or. zerocx(lis)   & ! .or.  an(ix,jy,kz,lni) .lt. 0.1
-     &    ) THEN ! { {
-      an(ix,jy,kz,lv) = an(ix,jy,kz,lv) + an(ix,jy,kz,lis)
-      an(ix,jy,kz,lis)= 0.0
-       IF ( ipconc .ge. 1 ) THEN
-         an(ix,jy,kz,lnis) = 0.0
-       ENDIF
-      
-      ELSEIF ( icespheres >= 2 ) THEN ! } {
-       km1 = Max(1, kz-1)
-       IF ( 0.5*( w(ix,jy,kz) + w(ix,jy,kz+1)) < -1.0 .or.    &
-     &      (icespheres == 3 .and. ( t0(ix,jy,kz) < 232.15 .or. an(ix,jy,kz,lc) < qxmin(lc) ) ) .or. &
-     &      (icespheres == 5 .and. ( t0(ix,jy,kz) < 232.15 .or. ( an(ix,jy,kz,lc) < qxmin(lc) .and. an(ix,jy,km1,lc) < qxmin(lc)  )) ) .or. &
-     &      (icespheres == 4 .and. ( t0(ix,jy,kz) < 235.15 )) ) THEN ! transfer to regular ice crystals in downdraft or at low temp
-         an(ix,jy,kz,li) = an(ix,jy,kz,li) + an(ix,jy,kz,lis)
-         an(ix,jy,kz,lni) = an(ix,jy,kz,lni) + an(ix,jy,kz,lnis)
-         an(ix,jy,kz,lis)= 0.0
-         an(ix,jy,kz,lnis)= 0.0
-         
+       ltemq1 = ltemq
+! want to start out with a small time step to handle the steep slope
+! and fast changes, then can switch to a larger step (dtcon2) for the
+! rest of the big time step.
+! base the initial time step (dtcon1) on the slope (delta)
+       IF ( Abs(ss1 - 1.0) .gt. 1.e-5 ) THEN
+         delta = 0.5*(qv1-qvs1)/(d1*(ss1 - 1.0))
+       ELSE
+         delta = 0.1*dtp
        ENDIF
-       
-      ENDIF ! } }
-      ENDIF ! }
+! delta is the extrapolated time to get halfway from qv1 to qvs1
+! want at least 5 time steps to the halfway point, so multiply by 0.2
+! for the initial time step
+       dtcon1 = Min(0.05,0.2*delta)
+       nc = Max(5,2*NInt( (dtp-4.0*dtcon1)/delta))
+       dtcon2 = (dtp-4.0*dtcon1)/nc
 
-!
-!  for qcw
-!
+       n = 1
+       dt1 = 0.0
+       nc = 0
+       dqc = 0.0
+       dqr = 0.0
+       dqi = 0.0
+       dqs = 0.0
+       dqvii = 0.0
+       dqvis = 0.0
 
-      IF ( an(ix,jy,kz,lc) .le. frac*qxmin(lc) .or. zerocx(lc)   &
-     &       ) THEN
-      an(ix,jy,kz,lv) = an(ix,jy,kz,lv) + an(ix,jy,kz,lc)
-      an(ix,jy,kz,lc)= 0.0
-       IF ( ipconc .ge. 2 ) THEN
-        IF ( lccn .gt. 1 ) THEN
-         an(ix,jy,kz,lccn) =     &
-     &       an(ix,jy,kz,lccn) + Max(0.0,an(ix,jy,kz,lnc))
-        ENDIF
-         an(ix,jy,kz,lnc) = 0.0
-         
-         IF ( lccna > 0  ) THEN ! apply exponential decay to activated CCN to restore to environmental value
-           tmp = an(ix,jy,kz,li) + an(ix,jy,kz,ls)  
-           
-           IF ( an(ix,jy,kz,lccna) > 1. .and. tmp < qxmin(li) ) an(ix,jy,kz,lccna) = an(ix,jy,kz,lccna)*Exp(-dtp/ccntimeconst)
+       RK2c: DO WHILE ( dt1 .lt. dtp )
+          nc = 0
+          IF ( n .le. 4 ) THEN
+            dtcon = dtcon1
+          ELSE
+            dtcon = dtcon2
+          ENDIF
+ 609       dqv  = -(ss1 - 1.)*d1*dtcon
+           dqvr = -(ss1 - 1.)*d1r*dtcon
+            dtemp = -0.5*e1*f1*(dqv + dqvr)
+!          write(0,*) 'RK2c dqv1 = ',dqv
+! calculate midpoint values:
+     !      ltemq1m = ltemq1 + Nint(dtemp*fqsat + 0.5)
 
-         ELSEIF ( lccn > 1 .and. restoreccn ) THEN
-           ! in this case, we are treating the ccn field as ccna
-           tmp = an(ix,jy,kz,li) + an(ix,jy,kz,ls)  
-           
-           IF ( an(ix,jy,kz,lccn) > 1. .and. tmp < qxmin(li) ) an(ix,jy,kz,lccn) =  &
-                    dn(ix,jy,kz)*qccn - Max(0.0 , dn(ix,jy,kz)*qccn - an(ix,jy,kz,lccn))*Exp(-dtp/ccntimeconst)
-         
-         ENDIF
+         ! 7.6.2016: Test full calc of ltemq
+           ltemq1m = (temp1+dtemp-163.15)*fqsati+1.5
+           ltemq1m = Min( nqsat, Max(1,ltemq1m) )
 
-       ENDIF
+           IF ( ltemq1m .lt. 1 .or. ltemq1m .gt. nqsat ) THEN
+             write(0,*) 'STOP in nucond line 1192 '
+             write(0,*) ' ltemq1m,icond = ',ltemq1m,icond
+             write(0,*) ' dtemp,e1,f1,dqv,dqvr = ', dtemp,e1,f1,dqv,dqvr
+             write(0,*) ' d1,d1r,dtcon,ss1 = ',d1,d1r,dtcon,ss1
+             write(0,*) ' dqc, dqr = ',dqc,dqr
+             write(0,*) ' qv,qc,qr = ',qx(mgs,lv)*1000.,qx(mgs,lc)*1000.,qx(mgs,lr)*1000.
+             write(0,*) ' i, j, k = ',igs(mgs),jy,kgs(mgs)
+             write(0,*) ' dtcon1,dtcon2,delta = ',dtcon1,dtcon2,delta
+             write(0,*) ' nc,dtp = ',nc,dtp
+             write(0,*) ' rwvent,xdia,crw,ccw = ', rwvent(mgs),xdia(mgs,lr,1),cx(mgs,lr),cx(mgs,lc)
+             write(0,*) ' fvent,alphar = ',fvent(mgs),alpha(mgs,lr)
+             write(0,*) ' xvr,xmasr,xdnr,cwc1 = ',xv(mgs,lr),xmas(mgs,lr),xdn(mgs,lr),cwc1
+           ENDIF
+            dqvs = dtemp*p380*dtabqvs(ltemq1m)
+            qv1m = qv1 + dqv + dqvr
+!          qv1mr = qv1r + dqvr
 
-      ENDIF
+            qvs1m = qvs1 + dqvs
+            ss1m = qv1m/qvs1m
 
-      end do
-!      end do
-      end do
-      
-      
-      IF ( ndebug .ge. 1 ) write(6,*) 'END OF ICEZVD_DR'
-!
-!
-   
-   
-   9999 RETURN
-   
-   END SUBROUTINE NUCOND
+    ! check for undersaturation when no ice is present, if so, then reduce time step
+          IF ( ss1m .lt. 1.  .and. (dqvii + dqvis) .eq. 0.0 ) THEN
+            dtcon = (0.5*dtcon)
+            IF ( dtcon .ge. dtcon1 ) THEN
+             GOTO 609
+            ELSE
+             EXIT
+            ENDIF
+          ENDIF
+! calculate full step:
+          dqv  = -(ss1m - 1.)*d1*dtcon
+          dqvr = -(ss1m - 1.)*d1r*dtcon
 
 
-! #####################################################################
-! #####################################################################
+!          write(0,*) 'RK2a dqv1m = ',dqv
+          dtemp = -e1*f1*(dqv + dqvr)
+          
+         ! ltemq1 = ltemq1 + Nint(dtemp*fqsat + 0.5)
 
+         ! 7.6.2016: Test full calc of ltemq
+           ltemq1 = (temp1+dtemp-163.15)*fqsati+1.5
+           ltemq1 = Min( nqsat, Max(1,ltemq1) )
 
+           IF ( ltemq1 .lt. 1 .or. ltemq1 .gt. nqsat ) THEN
+             write(0,*) 'STOP in nucond line 1230 '
+             write(0,*) ' ltemq1m,icond = ',ltemq1m,icond
+             write(0,*) ' dtemp,e1,dqv,dqvr = ', dtemp,e1,dqv,dqvr
+           ENDIF
+          dqvs = dtemp*p380*dtabqvs(ltemq1)
 
-!c--------------------------------------------------------------------------
-!
-!
-!--------------------------------------------------------------------------
-!
+          qv1 = qv1 + dqv + dqvr
 
-      subroutine nssl_2mom_gs   &
-     &  (nx,ny,nz,na,jyslab  &
-     &  ,nor,norz          &
-     &  ,dtp,gz       &
-     &  ,t0,t1,t2,t3,t4,t5,t6,t7,t8,t9      &
-     &  ,an,dn,p2                  &
-     &  ,pn,w,iunit                   &
-     &  ,t00,t77,                             &
-     &   ventr,ventc,c1sw,jgs,ido,    &
-     &   xdnmx,xdnmn,               &
-!     &   ln,ipc,lvol,lz,lliq,   &
-     &   cdx,                              &
-     &   xdn0,tmp3d,tkediss  &
-     & ,timevtcalc,axtra,io_flag  &
-     & ,rainprod2d, evapprod2d &
-     & ,elec,its,ids,ide,jds,jde &
-     & )
+          dqc = dqc - dqv
+          dqr = dqr - dqvr
 
+          qvs1 = qvs1 + dqvs
+          ss1 = qv1/qvs1
+          temp1 = temp1 + dtemp
+          IF ( temp2 .eq. temp1 .or. ss2 .eq. ss1 .or.  &
+     &           ss1 .eq. 1.00 .or.  &
+     &      ( n .gt. 10 .and. ss1 .lt. 1.0005 ) ) THEN
+!           write(0,*) 'RK2c break'
+           EXIT
+          ELSE
+           ss2 = ss1
+           temp2 = temp1
+           dt1 = dt1 + dtcon
+           n = n + 1
+          ENDIF
+       ENDDO RK2c
 
-!
-!--------------------------------------------------------------------------
-!                                
-!     Ziegler 1985 parameterized microphysics (also Zrnic et al. 1993)
-!     1)  cloud water
-!     2)  rain
-!     3)  column ice 
-!     6)  snow
-!     11) graupel/hail
-!
-!--------------------------------------------------------------------------
-!
-! Notes:
-!
-!  4/27/2009: allows for liquid water to be advected on snow and graupel particles using flag "mixedphase"
-!
-!  3/14/2007: (APS) added qproc temp to make microphysic process timeseries
-!
-!  10/17/2006: added flag (iehw) to select how to calculate ehw
-!
-!  10/5/2006: switched chacr to integrated version rather than assuming that average rain
-!             drop mass does not change.  This acts to reduce rain size somewhat via graupel
-!             collection.
-!             Use Mason data for ehw, with scaling toward ehw=1 as air density decreases.
-!
-!  10/3/2006: Turned off Meyers nucleation for T > -5 (can turn on with imeyers5 flag)
-!             Turned off contact nucleation in updrafts
-!
-!  7/24/2006:  Turned on Meyers nucleation for -5 < T < 0
-!
-!  5/12/2006:  Converted qsacw/csacw and qsaci/csaci to Z93
-!
-!  5/12/2006:  Put a threshold on Bigg rain freezing.  If the frozen drops
-!              have an average volume less than xvhmn, then the drops are put
-!              into snow instead of graupel/hail.
-!
-!              Fixed bug when vapor deposition was limited.
-!
-!  5/13/2006:  Note that qhacr has a large effect, but Z85 did not include it.
-!              Turned off qsacr (set to zero).
-!
-!  9/14/2007: erm: recalculate vx(lh) after setting xdn(lh) in case xdn was out of allowed range.
-!             added parameter rimc3 for minimum rime density.  Default value set at 170. kg/m**3
-!             instead of previous use of 100.  (Farley, 1987)
-!
-!--------------------------------------------------------------------------
-!
-!  general declarations
-!
-!--------------------------------------------------------------------------
-!
-!
-!
+
+        dcloud = dqc ! qx(mgs,lv) - qv1
+        thetap(mgs) = thetap(mgs) + e1*(DCLOUD + dqr)
 
 
-      implicit none
+        IF ( eqtset > 2 ) THEN
+           pipert(mgs) = pipert(mgs) + felvpi(mgs)*(DCLOUD + dqr)
+        ENDIF
+        IF ( io_flag .and. nxtra > 1 ) THEN
+           axtra(igs(mgs),jy,kgs(mgs),1) = DCLOUD/dtp
+           axtra(igs(mgs),jy,kgs(mgs),2) = axtra(igs(mgs),jy,kgs(mgs),2) + dqr/dtp
+        ENDIF
+        qwvp(mgs) = qwvp(mgs) - (DCLOUD + dqr)
+        qx(mgs,lc) = qx(mgs,lc) + DCLOUD
+        qx(mgs,lr) = qx(mgs,lr) + dqr
+!        t9(igs(mgs),jy,kgs(mgs)) = t9(igs(mgs),jy,kgs(mgs)) + (DCLOUD + dqr)/dtp*felv(mgs)/(cp*pi0(mgs)) !* &
+!!     &                 dx*dy*dz3d(igs(mgs),jy,kgs(mgs))
+
+
+        theta(mgs) = thetap(mgs) + theta0(mgs)
+        temg(mgs) = theta(mgs)*f1
+        ltemq = (temg(mgs)-163.15)/fqsat+1.5
+        ltemq = Min( nqsat, Max(1,ltemq) )
+        qvs(mgs) = pqs(mgs)*tabqvs(ltemq)
+!        es(mgs) = 6.1078e2*tabqvs(ltemq)
+
 !
-!      integer icond 
-!      parameter ( icond = 2 )
 
-      integer, parameter :: ng1 = 1
+      ENDIF  ! dcloud .gt. 0.
 
-      integer nx,ny,nz,na,nba,nv
-      integer nor,norz,istag,jstag,kstag ! ,nht,ngt,igsr
-      integer iwrite
-      real dtp,dx,dy,dz
 
-      logical, intent(in) :: io_flag
+      ELSE  ! qc .le. qxmin(lc)
 
-      integer itile,jtile,ktile
-      integer ixbeg,jybeg
-      integer ixend,jyend,kzend,kzbeg
-      integer nxend,nyend,nzend,nzbeg
-      integer :: my_rank = 0
-      integer, parameter :: myprock = 1, nprock = 1
-      real rainprod2d(-nor+1:nx+nor,-norz+ng1:nz+norz)
-      real evapprod2d(-nor+1:nx+nor,-norz+ng1:nz+norz)
+!        IF ( ssf(mgs) .gt. 0.0 .and. .not. flag_qndrop ) THEN ! flag_qndrop turns off primary nucleation when using wrf-chem with progn=1
+        IF ( ssf(mgs) .gt. 0.0 ) THEN ! .and.  ssmax(mgs) .lt. sscb ) THEN ! except that wrf-chem does not seem to initialize qc for activated aerosols, so keep this, after all
 
+          IF ( iqcinit == 1 ) THEN
 
-      real tkediss(-nor+1:nx+nor,-norz+ng1:nz+norz)
-      real axtra(-nor+ng1:nx+nor,-nor+ng1:ny+nor,-norz+ng1:nz+norz,nxtra)
+         qvs0   = 380.*exp(17.27*(temg(mgs)-273.)/(temg(mgs)- 36.))/pk(mgs)
 
-      real :: galpharaut
-      real :: xvbarmax
-      
-      integer jyslab,its,ids,ide,jds,jde ! domain boundaries
-      integer, intent(in) :: iunit !,iunit0
-      real qvex
-      integer iraincv, icgxconv
-      parameter ( iraincv = 1, icgxconv = 1)
-      real ffrz
+         dcloud = Max(0.0, (qx(mgs,lv)-qvs0) / (1.+qvs0*f5/(temg(mgs)-36.)**2) )
 
-      real qcitmp,cirdiatmp ! ,qiptmp,qirtmp
-      real ccwtmp,ccitmp ! ,ciptmp,cirtmp
-      real cpqc,cpci ! ,cpip,cpir
-      real cpqc0,cpci0 ! ,cpip0,cpir0
-      real scfac ! ,cpip1
-      
-      double precision dp1
-      
-      double precision frac, frach, xvfrz
-      
-      double precision :: timevtcalc
-      double precision :: dpt1,dpt2
-            
-      
-      logical, parameter :: usegamxinf = .false.
-      logical, parameter :: usegamxinf2 = .false.
-      logical, parameter :: usegamxinf3 = .false.
-!      real rar  ! rime accretion rate as calculated from qxacw
+          ELSEIF ( iqcinit == 3 ) THEN
+              R1=1./(1. + caw*(273.15 - cbw)*qss(mgs)*felvcp(mgs)/ & 
+     &             ((temg(mgs) - cbw)**2))
+            DCLOUD=R1*(qvap(mgs) - qvs(mgs))  ! KW model adjustment; 
+                              ! this will put mass into qc if qv > sqsat exists
+          
+          ELSEIF ( iqcinit == 2 ) THEN
+!              R1=1./(1. + caw*(273.15 - cbw)*qss(mgs)*felv(mgs)/
+!     :             (cp*(temg(mgs) - cbw)**2))
+!            DCLOUD=R1*(qvap(mgs) - qvs(mgs))  ! KW model adjustment; 
+                              ! this will put mass into qc if qv > sqsat exists
+         ssmx = ssmxinit
 
+          IF ( ssf(mgs) > ssmx ) THEN
+           CALL QVEXCESS(ngs,mgs,qwvp,qv0,qx(1,lc),pres,thetap,theta0,dcloud, & 
+     &      pi0,tabqvs,nqsat,fqsat,cbw,fcqv1,felvcp,ssmx,pk,ngscnt)
+          ELSE
+            dcloud = 0.0
+          ENDIF
+         ENDIF
+        ELSE
+            dcloud = 0.0
+        ENDIF
 
-! a few vars for time-split fallout      
-      real vtmax
-      integer n,ndfall
+        thetap(mgs) = thetap(mgs) + felvcp(mgs)*DCLOUD/(pi0(mgs))
+        qwvp(mgs) = qwvp(mgs) - DCLOUD
+        qx(mgs,lc) = qx(mgs,lc) + DCLOUD
+        IF ( io_flag .and. nxtra > 1 ) THEN
+           axtra(igs(mgs),jy,kgs(mgs),1) = DCLOUD/dtp
+        ENDIF
+        theta(mgs) = thetap(mgs) + theta0(mgs)
+        temg(mgs) = theta(mgs)*pk(mgs) !( pres(mgs) / poo ) ** cap
+!        temg(mgs) = theta2temp( theta(mgs), pres(mgs) )
+        ltemq = (temg(mgs)-163.15)/fqsat+1.5
+        ltemq = Min( nqsat, Max(1,ltemq) )
+        qvs(mgs) = pqs(mgs)*tabqvs(ltemq)
+!        es(mgs) = 6.1078e2*tabqvs(ltemq)
+
+!.... S. TWOMEY (1959)
+! Note: get here if there is no previous cloud water and w > 0.
+      cn(mgs) = 0.0
       
-      double precision chgneg,chgpos,sctot
+      IF ( ncdebug .ge. 1 ) THEN
+        write(iunit,*) 'at 613: ',qx(mgs,lc),cx(mgs,lc),wvel(mgs),ssmax(mgs),kgs(mgs)
+      ENDIF
       
-      real temgtmp
-
-      real pb(-norz+ng1:nz+norz)
-      real pinit(-norz+ng1:nz+norz)
+      IF (  .not. flag_qndrop ) THEN ! { only calculate mass change when using wrf-chem
 
-      real gz(-nor+ng1:nx+nor,-nor+ng1:ny+nor,-norz+ng1:nz+norz) ! dz
       
-      real qimax,xni0,roqi0
+!      IF ( ssmax(mgs) .lt. sscb .and. qx(mgs,lc) .gt. qxmin(lc)) THEN
+      IF ( dcloud .gt. qxmin(lc) .and. wvel(mgs) > 0.0) THEN
+!       CN(mgs) =   CCNE*wvel(mgs)**cnexp ! *Min(1.0,1./dtp) ! 0.3465
+       CN(mgs) =   CCNE0*cnuc(mgs)**(2./(2.+cck))*wvel(mgs)**cnexp ! *Min(1.0,1./dtp) ! 0.3465
+        IF ( ny .le. 2 .and. cn(mgs) .gt. 0.0    &
+     &                    .and. ncdebug .ge. 1 ) THEN 
+          write(iunit,*) 'CN: ',cn(mgs)*1.e-6, cx(mgs,lc)*1.e-6, qx(mgs,lc)*1.e3,   &
+     &       wvel(mgs), dcloud*1.e3
+          IF ( cn(mgs) .gt. 1.0 ) write(iunit,*) 'cwrad = ',   &
+     &       1.e6*(rho0(mgs)*qx(mgs,lc)/cn(mgs)*cwc1)**c1f3,   &
+     &   igs(mgs),kgs(mgs),temcg(mgs),    &
+     &   1.e3*an(igs(mgs),jgs,kgs(mgs)-1,lc)
+        ENDIF
+        IF ( iccwflg .eq. 1 ) THEN
+          cn(mgs) = Min(cwccn*rho0(mgs)/rho00, Max(cn(mgs),   &
+     &       rho0(mgs)*qx(mgs,lc)/(xdn(mgs,lc)*(4.*pi/3.)*(4.e-6)**3)))
+        ENDIF
+      ELSE
+       cn(mgs) = 0.0
+       dcloud = 0.0
+!          cn(mgs) = Min(cwccn,    &
+!     &       rho0(mgs)*dcloud/(xdn(mgs,lc)*(4.*pi/3.)*(4.e-6)**3) )
+      ENDIF
 
+      IF ( cn(mgs) .gt. 0.0 ) THEN
+       IF ( cn(mgs) .gt. ccnc(mgs) ) THEN
+         cn(mgs) = ccnc(mgs)
+!         ccnc(mgs) = 0.0
+       ENDIF
+!      cx(mgs,lc) = cx(mgs,lc) + cn(mgs)
+      IF ( irenuc <= 2 ) ccnc(mgs) = Max(0.0, ccnc(mgs) - cn(mgs))
+      ccna(mgs) = ccna(mgs) + cn(mgs)
+      ENDIF
 
-      real dv
+!       write(91,*) 'nuc1: cn, ix, kz = ',cn(mgs),igs(mgs),kgs(mgs),wvel(mgs),cnexp,ccnc(mgs)
 
-      real dtptmp
-      integer itest,nidx,id1,jd1,kd1
-      parameter (itest=1)
-      parameter (nidx=10)
-      parameter (id1=1,jd1=1,kd1=1)
-      integer ierr
-      integer iend
-
-      integer ix,kz, il, ic, ir, icp1, irp1, ip1,jp1,kp1
-      integer :: jy
-      integer i,j,k,i1
-      integer kzb,kze
-      real slope1, slope2
-      real x1, x2, x3
-      real eps,eps2
-      parameter (eps=1.e-20,eps2=1.e-5)
-!
-!  Other elec. vars
-!
-      real  temele
-      real  trev
+      IF( CN(mgs) .GT. cx(mgs,lc) ) cx(mgs,lc) = CN(mgs)
+      IF( cx(mgs,lc) .GT. 0. .AND. qx(mgs,lc) .le. qxmin(lc) ) THEN
+        cx(mgs,lc) = 0.
+      ELSE
+        cx(mgs,lc) = Min(cx(mgs,lc),rho0(mgs)*Max(0.0,qx(mgs,lc))/cwmasn)
+      ENDIF
       
-      logical ldovol, ishail, ltest
-!
-!
-!  wind indicies
-!
-      integer mu,mv,mw
-      parameter (mu=1,mv=2,mw=3)
-!
-!  conversion parameters
-!
-      integer mqcw,mqxw,mtem,mrho,mtim
-      parameter (mqcw=21,mqxw=21,mtem=21,mrho=5,mtim=6)
+      ENDIF ! }.not. flag_qndrop
 
-      real xftim,xftimi,yftim, xftem,yftem, xfqcw,yfqcw, xfqxw,yfqxw
-      parameter (xftim=0.05,xftimi = 1./xftim,yftim=1.)
-      parameter (xftem=0.5,yftem=1.)
-      parameter (xfqcw=2000.,yfqcw=1.)
-      parameter (xfqxw=2000.,yfqxw=1.)
-      real dtfac
-      parameter ( dtfac = 1.0 )
-      integer ido(lc:lqmx)
+        GOTO 613
+        
+        END IF ! qc .gt. 0.
 
-!      integer iexy(lc:lqmx,lc:lqmx)
-!      integer ieswi, ieswir, ieswip, ieswc, ieswr
-!      integer ieglsw, iegli, ieglir, ieglip, ieglc, ieglr
-!      integer iegmsw, iegmi, iegmir, iegmip, iegmc, iegmr
-!      integer ieghsw, ieghi, ieghir, ieghip, ieghc, ieghr
-!      integer iefwsw, iefwi, iefwir, iefwip, iefwc, iefwr
-!      integer iehwsw, iehwi, iehwir, iehwip, iehwc, iehwr
-!      integer iehlsw, iehli, iehlir, iehlip, iehlc, iehlr
-!      real delqnsa, delqxsa, delqnsb, delqxsb, delqnia, delqxia
-!      real delqnra, delqxra
+!        ES=EES(PIB(K)*PT)
+!        SQSAT=EPSI*ES/(PB(K)*1000.-ES)
+
+!.... CLOUD NUCLEATION
+!      T=PIB(K)*PT
+!      ES=1.E3*PB(K)*QV/EPSI
+
+      IF ( wvel(mgs) .le. 0. ) GO TO 616
+      IF ( cx(mgs,lc) .le. 0. )  GO TO 613                             !TWOMEY (1959) Nucleation
+      IF ( kzbeg-1+kgs(mgs) .GT. 1 .and. qx(mgs,lc) .le. qxmin(lc)) GO TO 613  !TWOMEY (1959) Nucleation
+      IF ( kzbeg-1+kgs(mgs) .eq. 1 .and. wvel(mgs) .gt. 0. ) GO TO 613         !TWOMEY (1959) Nucleation
+!.... ATTEMPT ZIEGLER CLOUD NUCLEATION IN CLOUD INTERIOR UNLESS...
+  616 IF ( ssf(mgs) .LE. SUPCB .AND. wvel(mgs) .GT. 0. ) GO TO 631 !... weakly saturated updraft
+      IF ( kzbeg-1+kgs(mgs) .GT. 1 .AND. kzbeg-1+kgs(mgs) .LT. nzend-1 .AND.  &
+     &    (ssfkp1(mgs) .GE. SUPMX .OR. &
+     &     ssf(mgs)    .GE. SUPMX .OR. &
+     &     ssfkm1(mgs) .GE. SUPMX)) GO TO 631                      !... too much vapour
+      IF (ssf(mgs) .LT. 1.E-10 .OR. ssf(mgs) .GE. SUPMX) GO TO 631 !... at the extremes for ss
 
-       real delqnxa(lc:lqmx)
-       real delqxxa(lc:lqmx)
 !
-! external temporary arrays
+! get here if ( qc > 0 and ss > supcb) or (w < 0)
 !
-      real t00(-nor+ng1:nx+nor,-nor+ng1:ny+nor,-norz+ng1:nz+norz)
-      real t77(-nor+ng1:nx+nor,-nor+ng1:ny+nor,-norz+ng1:nz+norz)
 
-      real t0(-nor+ng1:nx+nor,-nor+ng1:ny+nor,-norz+ng1:nz+norz)
-      real t1(-nor+ng1:nx+nor,-nor+ng1:ny+nor,-norz+ng1:nz+norz)
-      real t2(-nor+ng1:nx+nor,-nor+ng1:ny+nor,-norz+ng1:nz+norz)
-      real t3(-nor+ng1:nx+nor,-nor+ng1:ny+nor,-norz+ng1:nz+norz)
-      real t4(-nor+ng1:nx+nor,-nor+ng1:ny+nor,-norz+ng1:nz+norz)
-      real t5(-nor+ng1:nx+nor,-nor+ng1:ny+nor,-norz+ng1:nz+norz)
-      real t6(-nor+ng1:nx+nor,-nor+ng1:ny+nor,-norz+ng1:nz+norz)
-      real t7(-nor+ng1:nx+nor,-nor+ng1:ny+nor,-norz+ng1:nz+norz)
-      real t8(-nor+ng1:nx+nor,-nor+ng1:ny+nor,-norz+ng1:nz+norz)
-      real t9(-nor+ng1:nx+nor,-nor+ng1:ny+nor,-norz+ng1:nz+norz)
+      if (ndebug .gt. 0) write(0,*) "ICEZVD_DR: Entered Ziegler Cloud Nucleation" !mpidebug
 
-      real p2(-nor+1:nx+nor,-nor+1:ny+nor,-norz+ng1:nz+norz)  ! perturbation Pi
-      real pn(-nor+1:nx+nor,-nor+1:ny+nor,-norz+ng1:nz+norz)
-      real an(-nor+ng1:nx+nor,-nor+ng1:ny+nor,-norz+ng1:nz+norz,na)
-      real dn(-nor+1:nx+nor,-nor+1:ny+nor,-norz+ng1:nz+norz)
-      real w(-nor+1:nx+nor,-nor+1:ny+nor,-norz+ng1:nz+norz)
+      DSSDZ=0.
+      r2dzm=0.50/dz3d(igs(mgs),jy,kgs(mgs))
+      IF ( irenuc >= 0 .and. .not. flag_qndrop) THEN ! turn off nucleation when flag_qndrop (using WRF-CHEM for activation)
 
-      real tmp3d(-nor+ng1:nx+nor,-nor+ng1:ny+nor,-norz+ng1:nz+norz)
+      IF ( irenuc < 2 ) THEN !{
 
-! 
-!  declarations microphyscs and for gather/scatter
-!
-      integer nxmpb,nzmpb,nxz
-      integer jgs,mgs,ngs,numgs
-      parameter (ngs=500) !500)
-      integer, parameter :: ngsz = 500
-      integer ntt
-      parameter (ntt=300)
+        IF ( kzend == nzend ) THEN
+          t0p3 = t0(igs(mgs),jgs,Min(kze,kgs(mgs)+3))
+          t0p1 = t0(igs(mgs),jgs,Min(kze,kgs(mgs)+1))
+        ELSE
+          t0p3 = t0(igs(mgs),jgs,kgs(mgs)+3)
+          t0p1 = t0(igs(mgs),jgs,kgs(mgs)+1)
+        ENDIF
 
-      real dvmgs(ngs)
-      
-      integer ngscnt,igs(ngs),kgs(ngs)
-      integer kgsp(ngs),kgsm(ngs),kgsm2(ngs)
-      integer ncuse
-      parameter (ncuse=0)
-      integer il0(ngs),il5(ngs),il2(ngs),il3(ngs)
-!      integer il1m(ngs),il2m(ngs),il3m(ngs),il4m(ngs),il5m(ngs)
-!
-      real tdtol,temsav,tfrcbw,tfrcbi
-      real, parameter :: thnuc = 235.15
-!
-!  Ice Multiplication Arrays.
+      IF ( ( ssf(mgs) .gt. ssmax(mgs) .or.  irenuc .eq. 1 ) &
+     &   .and.  ( ( lccn .lt. 1 .and.  &
+     &            cx(mgs,lc) .lt. cwccn*(Min(1.0,rho0(mgs)))) .or. &
+     &    ( lccn .gt. 1 .and. ccnc(mgs) .gt. 0. )   ) &
+     &    ) THEN
+      IF( kzbeg-1+kgs(mgs) .GT. 1 .AND. kzbeg-1+kgs(mgs) .LT. nzend-1 &
+     &  .and. ssf(mgs) .gt. 0.0 &
+     &  .and. ssfkp1(mgs) .LT. SUPMX .and. ssfkp1(mgs) .ge. 0.0  &
+     &  .AND. ssfkm1(mgs) .LT. SUPMX .AND. ssfkm1(mgs) .ge. 0.0  &
+     &  .AND. ssfkp1(mgs) .gt. ssfkm1(mgs)  &
+     &  .and. t0p3 .gt. 233.2) THEN
+          DSSDZ = (ssfkp1(mgs) - ssfkm1(mgs))*R2DZM
 !
-      real  fimt1(ngs),fimta(ngs),fimt2(ngs) !,qmul1(ngs),qmul2(ngs)
-      real xcwmas
+! otherwise check for cloud base condition with updraft:
 !
+        ELSEIF( kzbeg-1+kgs(mgs) .GT. 1 .AND. kzbeg-1+kgs(mgs) .LT. nzend-1 &
+!        IF( kgs(mgs) .GT. 1 .AND. kgs(mgs) .LT. NZ-1 & !)
+     &  .and. ssf(mgs) .gt. 0.0  .and. wvel(mgs) .gt. 0.0 &
+     &  .and. ssfkp1(mgs) .gt. 0.0   &
+     &  .AND. ssfkm1(mgs) .le. 0.0 .and. wvelkm1(mgs) .gt. 0.0 &
+     &  .AND. ssf(mgs) .gt. ssfkm1(mgs)  &
+     &  .and. t0p1 .gt. 233.2) THEN
+         DSSDZ = 2.*(ssf(mgs) - ssfkm1(mgs))*R2DZM  ! 1-sided difference
+        ENDIF
+
+       ENDIF
 !
-! Variables for Ziegler warm rain microphysics
-!      
+!CLZ  IF(wijk.LE.0.) CN=CCN*ssfilt(ix,jy,kz)**CCK
+! note: CCN -> cwccn, DELT -> dtp
+      c1 = Max(0.0, rho0(mgs)*(qx(mgs,lv) - qss(mgs))/ &
+     &        (xdn(mgs,lc)*(4.*pi/3.)*(4.e-6)**3))
+      IF ( lccn .lt. 1 ) THEN
+       CN(mgs) = cwccn*rho0(mgs)/rho00*CCK*ssf(mgs)**CCKM*dtp*   &
+     & Max(0.0,    &
+     &         (wvel(mgs)*DSSDZ) )      ! probably the vertical gradient dominates
+      ELSE
+      CN(mgs) =  &
+     &    Min(ccnc(mgs), cnuc(mgs)*CCK*ssf(mgs)**CCKM*dtp*   &
+     & Max(0.0,    &
+     &         ( wvel(mgs)*DSSDZ) )  )
+!      IF ( cn(mgs) .gt. 0 ) ccnc(mgs) = ccnc(mgs) - cn(mgs)
+      ENDIF
 
+      IF ( cn(mgs) .gt. 0.0 ) THEN
+       IF ( ccnc(mgs) .lt. 5.e7 .and. cn(mgs) .ge. 5.e7 ) THEN
+          cn(mgs) = 5.e7
+          ccnc(mgs) = 0.0
+       ELSEIF ( cn(mgs) .gt. ccnc(mgs) ) THEN
+         cn(mgs) = ccnc(mgs)
+         ccnc(mgs) = 0.0
+       ENDIF
+      cx(mgs,lc) = cx(mgs,lc) + cn(mgs)
+      ccnc(mgs) = Max(0.0, ccnc(mgs) - cn(mgs))
+      ENDIF
 
-      real ccnc(ngs),ccin(ngs),cina(ngs),ccna(ngs)
-      real cwnccn(ngs)
-      real sscb  ! 'cloud base' SS threshold
-      parameter ( sscb = 2.0 )
-      integer idecss  ! flag to turn on (=1) decay of ssmax when no cloud or ice crystals
-      parameter ( idecss = 1 )
-      integer iba ! flag to do condensation/nucleation in 1st or 2nd loop
-                  ! =0 to use ad to calculate SS
-                  ! =1 to use an at end of main jy loop to calculate SS
-      parameter (iba = 1)
-      integer ifilt   ! =1 to filter ssat, =0 to set ssfilt=ssat
-      parameter ( ifilt = 0 ) 
-      real temp1,temp2 ! ,ssold
-      real :: mwat, mice, dice, mwshed, fwmax, fw, mwcrit, massfactor, tmpdiam
-      real, parameter :: shedalp = 3.  ! set 3 for maximum mass diameter (same as area-weighted diameter), 4 for mass-weighted diameter
-      real ssmax(ngs)       ! maximum SS experienced by a parcel
-      real ssmx
-      real dnnet,dqnet
-!      real cnu,rnu,snu,cinu
-!      parameter ( cnu = 0.0, rnu = -0.8, snu = -0.8, cinu = 0.0 )
-      real bfnu, bfnu0, bfnu1
-      parameter ( bfnu0 = (rnu + 2.0)/(rnu + 1.0)  )
-      real ventr, ventc
-      real volb, aa1, aa2
-      double precision t2s, xdp
-      double precision xl2p(ngs),rb(ngs)
-      parameter ( aa1 = 9.44e15, aa2 = 5.78e3 ) ! a1 in Ziegler
-! snow parameters:
-      real cexs, cecs
-      parameter ( cexs = 0.1, cecs = 0.5 )
-      real rvt      ! ratio of collection kernels (Zrnic et al, 1993)
-      parameter ( rvt = 0.104 )
-      real kfrag    ! rate coefficent for collisional splintering (Schuur & Rutledge 00b)
-      parameter ( kfrag = 1.0e-6 )
-      real mfrag    ! assumed ice fragment mass for collisional splintering (Schuur & Rutledge 00b)
-      parameter ( mfrag = 1.0e-10)
-      double precision cautn(ngs), rh(ngs), nh(ngs)
-      real ex1, ft, rhoinv(ngs)
-      double precision ec0(ngs)
-      
-      real ac1,bc, taus, c1,d1,e1,f1,p380,tmp,tmp1,tmp2,tmp3,tmp4,tmp5 ! , sstdy, super
-      real ratio, delx, dely
-      real dbigg,volt
-      real chgtmp,fac,mixedphasefac
-      real x,y,y2,del,r,rtmp,alpr
-      double precision :: vent1,vent2
-      real g1palp,g4palp
-      real fqt !charge separation as fn of temperature from Dong and Hallett 1992
-      real bs
-      real v1, v2
-      real d1r, d1i, d1s, e1i
-      real c1sw   ! integration factor for snow melting with snu = -0.8
-      real, parameter :: vr1mm = 5.23599e-10 ! volume of 1mm diameter sphere (m**3)
-      real, parameter :: vr3mm = 5.23599e-10*(3.0/1.)**3   ! volume of a 3 mm diameter sphere (m**3) (Rasmussen et al. 1984b, JAS)
-      real, parameter :: vr4p5mm = 5.23599e-10*(4.5/1.)**3 ! volume of 4.5mm diameter sphere (m**3) (Rasmussen et al. 1984b, JAS)
-      real vmlt,vshd, vshdgs(ngs,lh:lhab), maxmassfac(lc:lhab)
-      real rhosm
-      parameter ( rhosm = 500. )
-      integer nc ! condensation step
-      real dtcon,dtcon1,dtcon2 ! condensation time step (dtcon*nc = dtp)
-      real delta
-      integer ltemq1,ltemq1m ! ,ltemq1m2
-      real dqv,qv1,ss1,ss2,qvs1,dqvs,dtemp,dt1   ! temporaries for condensation
-      real ssi1, ssi2, dqvi, dqvis, dqvii,qis1
-      real dqvr, dqc, dqr, dqi, dqs
-      real qv1m,qvs1m,ss1m,ssi1m,qis1m
-      real cwmastmp
-      real  dcloud,dcloud2 ! ,as, bs
-      real cn(ngs)
-      double precision xvc, xvr
-      real mwfac
-!      real  es(ngs) ! ss(ngs),
-!      real  eis(ngs)
+      ELSEIF ( irenuc == 2 ) THEN !} { 
+      ! simple Twomey scheme
+!      if (ndebug .gt. 0) write(0,*) 'ICEZVD_DR:  Cloud reNucleation, wvel = ',wvel(mgs)
+       CN(mgs) =   CCNE0*cnuc(mgs)**(2./(2.+cck))*Max(0.0,wvel(mgs))**cnexp ! *Min(1.0,1./dtp) ! 0.3465
+!      ccne = ccnefac*1.e6*(1.e-6*Abs(cwccn))**(2./(2.+cck))
+!!!       CN(mgs) = Max( 0.0, CN(mgs) - ccna(mgs) ) ! this was from
+               ! Philips, Donner et al. 2007, but results in too much limitation of
+               ! nucleation
+       CN(mgs) = Min(cn(mgs), ccnc(mgs))
+       cn(mgs) = Min(cn(mgs), 0.5*dqc/cwmasn) ! limit the nucleation mass to half of the condensation mass
+       
+       cx(mgs,lc) = cx(mgs,lc) + cn(mgs)
+       
+       ccnc(mgs) = Max(0.0, ccnc(mgs) - cn(mgs))
 
-      real rwmasn,rwmasx
+      ELSEIF ( irenuc == 7 ) THEN !} { 
 
-      real vgra,vfrz
-      parameter ( vgra = 0.523599*(1.0e-3)**3 )
-     
-      real epsi,d
-      parameter (epsi = 0.622, d = 0.266)
-      real r1,qevap ! ,slv
-      
-      real vr,nrx,chw,g1,qr,z,z1,rdi,alp,xnutmp,xnuc,g1r,rd1,rdia
-      
-      real, parameter :: rhofrz = 900.   ! density of graupel from newly-frozen rain
-      real, parameter :: rimedens = 500. ! default rime density
+      ! simple Twomey scheme but limit activation to try to do most activation near cloud base, but keep some CCN available for renuclation
+!      if (ndebug .gt. 0) write(0,*) 'ICEZVD_DR:  Cloud reNucleation, wvel = ',wvel(mgs)
+       cn(mgs) = 0.0
+!       IF ( ccna(mgs) < 0.7*cnuc(mgs) .and. ccnc(mgs) > 0.69*cnuc(mgs) - ccna(mgs)) THEN ! here, assume we are near cloud base and use Twomey formulation
+       IF ( ccna(mgs) < 0.9*cnuc(mgs) ) THEN ! { here, assume we are near cloud base and use Twomey formulation
+         CN(mgs) =  Min( 0.91*cnuc(mgs), CCNE0*cnuc(mgs)**(2./(2.+cck))*Max(0.0,wvel(mgs))**cnexp )! *Min(1.0,1./dtp) ! 0.3465
+!         IF ( cn(mgs) + ccna(mgs) > 0.71*cnuc ) THEN
+         ! prevent this branch from activating more than 70% of CCN
+           CN(mgs) = Min( CN(mgs), Max(0.0, (0.9*cnuc(mgs) - ccna(mgs) )) )
+!           CN(mgs) = Min( CN(mgs), Max(0.0, 0.71*ccnc(mgs) - ccna(mgs) ) )
+           
+       ELSE ! }{
+        ! if a large fraction of CCN have been activated, then assume we are in the cloud interior and use local SSw as in Phillips et al. 2007.
 
-!      real svc(ngs)  !  droplet volume
-!
-!  contact freezing nucleation
-!
-      real raero,kaero !assumd aerosol radius, thermal conductivity
-      parameter ( raero = 3.e-7, kaero = 5.39e-3 )
-      real kb   ! Boltzman constant  J K-1
-      parameter (kb = 1.3807e-23)
-      
-      real knud(ngs),knuda(ngs) !knudsen number and correction factor
-      real gtp(ngs)  !G(T,p) = 1/(a' + b')  Cotton 72b
-      real dfar(ngs) !aerosol diffusivity
-      real fn1(ngs),fn2(ngs),fnft(ngs)
-      
-      real ccia(ngs)
-      real ctfzbd(ngs),ctfzth(ngs),ctfzdi(ngs)
-!
-!  misc
-!
-      real ni,nis,nr,d0
-      real dqvcnd(ngs),dqwv(ngs),dqcw(ngs),dqci(ngs)
-      real tempc(ngs)
-      real temg(ngs),temcg(ngs),theta(ngs),qvap(ngs) 
-      real temgkm1(ngs), temgkm2(ngs)
-      real temgx(ngs),temcgx(ngs)
-      real qvs(ngs),qis(ngs),qss(ngs),pqs(ngs)
-      real elv(ngs),elf(ngs),els(ngs)
-      real tsqr(ngs),ssi(ngs),ssw(ngs)
-      real qcwtmp(ngs),qtmp,qtot(ngs) 
-      real qcond(ngs)
-      real ctmp, sctmp
-      real cimasn,cimasx,ccimx
-      real pid4
-      real cs,ds,gf7,gf6,gf5,gf4,gf3,gf2,gf1
-      real gcnup1,gcnup2
-      real gf73rds, gf83rds
-      real gamice73fac, gamsnow73fac
-      real gf43rds, gf53rds
-      real aradcw,bradcw,cradcw,dradcw,cwrad,rwrad,rwradmn
-      parameter ( rwradmn = 50.e-6 )
-      real dh0
-      
-      real clionpmx,clionnmx
-      parameter (clionpmx=1.e9,clionnmx=1.e9) ! Takahashi 84
-!
-!  other arrays
+         temp1 = (theta0(mgs)+thetap(mgs))*pk(mgs) ! t77(ix,jy,kz)
+!          t0(ix,jy,kz) = temp1
+          ltemq = Int( (temp1-163.15)/fqsat+1.5 )
+         ltemq = Min( nqsat, Max(1,ltemq) )
 
-      real fwet1(ngs),fwet2(ngs)   
-      real fmlt1(ngs),fmlt2(ngs)  
-      real fvds(ngs),fvce(ngs),fiinit(ngs) 
-      real fvent(ngs),fraci(ngs),fracl(ngs)
-!
-      real fai(ngs),fav(ngs),fbi(ngs),fbv(ngs)
-      real felv(ngs),fels(ngs),felf(ngs)
-      real felvcp(ngs),felscp(ngs),felfcp(ngs)
-      real felvpi(ngs),felspi(ngs),felfpi(ngs)
-      real felvs(ngs),felss(ngs)      !   ,felfs(ngs)
-      real fwvdf(ngs),ftka(ngs),fthdf(ngs)
-      real fadvisc(ngs),fakvisc(ngs)
-      real fci(ngs),fcw(ngs)
-      real fschm(ngs),fpndl(ngs)
-      real fgamw(ngs),fgams(ngs)
-      real fcqv1(ngs),fcqv2(ngs),fcc3(ngs) 
-      
-      real cvm,cpm,rmm
+        !  c1 = t00(igs(mgs),jy,kgs(mgs))*tabqvs(ltemq)
+          c1= pqs(mgs)*tabqvs(ltemq)
 
-      real, parameter :: rovcp = rd/cp
-      real, parameter ::      cpv = 1885.0       ! specific heat of water vapor at constant pressure
-!
-      real fcci(ngs), fcip(ngs)
-!
-      real :: sfm1(ngs),sfm2(ngs)
-      real :: gfm1(ngs),gfm2(ngs)
-      real :: hfm1(ngs),hfm2(ngs)
+          ssf(mgs) = 0.0
+          IF ( c1 > 0. ) THEN
+            ssf(mgs) = 100.*(qx(mgs,lv)/c1 - 1.0)  ! from "new" values
+          ENDIF
 
-      logical :: wetsfc(ngs),wetsfchl(ngs)
-      logical :: wetgrowth(ngs), wetgrowthhl(ngs)
+!          IF ( ssf(mgs) <= 1.0 .or. cnuc(mgs) > ccna(mgs) ) THEN
+          IF ( ssf(mgs) <= 1.0 ) THEN
+          CN(mgs) =   cnuc(mgs)*Min(1.0, Max(0.0,ssf(mgs))**cck ) ! 
+          ELSE
+          CN(mgs) =   cnuc(mgs)*Min(2.0, Max(0.0,0.03*(ssf(mgs)-1.0)+1.)**cck ) !           
+!          write(0,*) 'iren7: ssf,ssmx = ',ssf(mgs),ssmax(mgs),cn(mgs),ccna(mgs),cnuc(mgs)
+!          write(0,*) 'c1,qv = ',c1,qx(mgs,lv),temp1,ltemq
+          ENDIF
+          
 
-       real qitmp(ngs),qistmp(ngs)
+!        CN(mgs) = Min( Min(0.1,ssf(mgs)-1.)*cnuc(mgs), Max( 0.0, CN(mgs) - ccna(mgs) ) ) ! this was from
+!        CN(mgs) = Min( Min(0.5*cx(mgs,lc), Min(0.1,ssf(mgs)/100.)*cnuc(mgs)), Max( 0.0, CN(mgs) - ccna(mgs) ) ) ! this was from
+        CN(mgs) = Min(0.01*cnuc(mgs), Max( 0.0, CN(mgs) - ccna(mgs) ) ) ! this was from
+
+       ENDIF ! }
+!      ccne = ccnefac*1.e6*(1.e-6*Abs(cwccn))**(2./(2.+cck))
+!!!       CN(mgs) = Max( 0.0, CN(mgs) - ccna(mgs) ) ! this was from
+               ! Philips, Donner et al. 2007, but results in too much limitation of
+               ! nucleation
+!       CN(mgs) = Min(cn(mgs), ccnc(mgs))
+!       cn(mgs) = Min(cn(mgs), 0.5*dqc/cwmasn) ! limit the nucleation mass to half of the condensation mass
        
-      real rzxh(ngs), rzxhl(ngs), rzxhlh(ngs)
-      real rzxs(ngs)
-      real axh(ngs),bxh(ngs),axhl(ngs),bxhl(ngs)
-      real vt2ave(ngs)
+       IF ( cn(mgs) > 0.0 ) THEN
+       cx(mgs,lc) = cx(mgs,lc) + cn(mgs)
+       
+       ! create some small droplets at minimum size (CP 2000), although it adds very little liquid
+       
+       dcrit = 2.0*2.5e-7
+       
+       dcloud = 1000.*dcrit**3*Pi/6.*cn(mgs)
+        qx(mgs,lc) = qx(mgs,lc) + DCLOUD
+        thetap(mgs) = thetap(mgs) + felvcp(mgs)*DCLOUD/(pi0(mgs))
+        qwvp(mgs) = qwvp(mgs) - DCLOUD
+  !      ccnc(mgs) = Max(0.0, ccnc(mgs) - cn(mgs))
+        ENDIF
 
-      real ::  qx(ngs,lv:lhab)
-      real ::  qxw(ngs,ls:lhab)
-      real ::  cx(ngs,lc:lhab)
-      real ::  cxmxd(ngs,lc:lhab)
-      real ::  qxmxd(ngs,lv:lhab)
-      real ::  scx(ngs,lc:lhab)
-      real ::  xv(ngs,lc:lhab)
-      real ::  vtxbar(ngs,lc:lhab,3)
-      real ::  xmas(ngs,lc:lhab)
-      real ::  xdn(ngs,lc:lhab)
-      real ::  xdia(ngs,lc:lhab,3)
-      real ::  rarx(ngs,ls:lhab)
-      real ::  vx(ngs,li:lhab)
-      real ::  rimdn(ngs,li:lhab)
-      real ::  raindn(ngs,li:lhab)
-      real ::  alpha(ngs,lc:lhab)
-      real ::  dab0lh(ngs,lc:lhab,lr:lhab)
-      real ::  dab1lh(ngs,lc:lhab,lr:lhab)
-      
-      real :: galphrout
-      
-      real ventrx(ngs)
-      real ventrxn(ngs)
-      real g1shr, alphashr
-      real g1mlr, alphamlr
-      real massfacshr, massfacmlr
-      
-      real :: qhgt8mm ! ice mass greater than 8mm
-      real :: qhwgt8mm ! ice + max water mass greater than 8mm
-      real :: qhgt10mm ! mass greater than 10mm
-      real :: qhgt20mm ! mass greater than 20mm
-      real :: fwmhtmp
-      real, parameter :: fwmhtmptem = -15. ! temperature at which fwmhtmp fully switches to liquid water only being on large particles
-      real, parameter :: d1t = (6.0 * 0.268e-3/(917.* pi))**(1./3.) ! d1t is the diameter of the ice sphere with the mass of an 8mm spherical drop
-      real, parameter :: srasheym = 0.1389 ! slope fraction from Rasmussen and Heymsfield 
-!
-      real swvent(ngs),hwvent(ngs),rwvent(ngs),hlvent(ngs),hwventy(ngs),hlventy(ngs),rwventz(ngs)
-      integer, parameter :: ndiam = 10
-      integer :: numdiam
-      real hwvent0(ndiam+3),hlvent0 ! 0 to d1
-      real hwvent1,hlvent1 ! d1 to infinity
-      real hwvent2,hlvent2 ! d2 to infinity
-      real gama0,gamb0
-      real gama1,gamb1
-      real gama2,gamb2
-      real, parameter :: mltdiam1 = 9.0e-3, mltdiam2 = 19.0e-3, mltdiam3 = 200.0e-3, mltdiam05 = 4.5e-3
-      real :: mltdiam(ndiam+3)
-      real mltmass1inv,mltmass2inv, mltmass1cgs, mltmass2cgs
-      real qhmlr0, qhmlr05, qhmlr1, qhmlr2, qhmlr12
-      real qhlmlr0, qhlmlr05, qhlmlr1, qhlmlr2, qhlmlr12
-      real qxd1, cxd1 ! mass and number up to mltdiam1
-      real qxd05, cxd05 ! mass and number up to mltdiam1/2
-      
-      real :: qxd(ndiam+3), cxd(ndiam+3), qhml(ndiam+3), qhml0(ndiam+3)
-      real :: dqxd(ndiam+3), dcxd(ndiam+3), dqhml(ndiam+3)
-      
-      
-      real civent(ngs)
-      real isvent(ngs)
-!
-      real xmascw(ngs)
-      real xdnmx(lc:lhab), xdnmn(lc:lhab)
-      real dnmx
-      real :: xdiamxmas(ngs,lc:lhab)
-!
-      real cilen(ngs) ! ,ciplen(ngs)
-!
-!
-      real rwcap(ngs),swcap(ngs)
-      real hwcap(ngs)
-      real hlcap(ngs)
-      real cicap(ngs)
-      real iscap(ngs)
+      ELSEIF ( irenuc == 8 ) THEN !} { 
+      ! simple Twomey scheme
+!      if (ndebug .gt. 0) write(0,*) 'ICEZVD_DR:  Cloud reNucleation, wvel = ',wvel(mgs)
+       
+       cn(mgs) = 0.0
+       
+       IF ( ccnc(mgs) > 0. ) THEN
+       CN(mgs) =   CCNE0*ccnc(mgs)**(2./(2.+cck))*Max(0.0,wvel(mgs))**cnexp ! *Min(1.0,1./dtp) ! 0.3465
+!      ccne = ccnefac*1.e6*(1.e-6*Abs(cwccn))**(2./(2.+cck))
+!!!       CN(mgs) = Max( 0.0, CN(mgs) - ccna(mgs) ) ! this was from
+               ! Philips, Donner et al. 2007, but results in too much limitation of
+               ! nucleation
+       CN(mgs) = Min(cn(mgs), ccnc(mgs))
+       
+       ELSEIF ( cx(mgs,lc) < 0.01e9 ) THEN
 
-      real qvimxd(ngs)
-      real qimxd(ngs),qismxd(ngs),qcmxd(ngs),qrmxd(ngs),qsmxd(ngs),qhmxd(ngs),qhlmxd(ngs)
-      real cimxd(ngs),ccmxd(ngs),crmxd(ngs),csmxd(ngs),chmxd(ngs)
-      real cionpmxd(ngs),cionnmxd(ngs)
-      real clionpmxd(ngs),clionnmxd(ngs)
+        ! if a large fraction of CCN have been activated, then assume we are in the cloud interior and use local SSw as in Phillips et al. 2007.
 
+         temp1 = (theta0(mgs)+thetap(mgs))*pk(mgs) ! t77(ix,jy,kz)
+!          t0(ix,jy,kz) = temp1
+          ltemq = Int( (temp1-163.15)/fqsat+1.5 )
+         ltemq = Min( nqsat, Max(1,ltemq) )
 
-      real elec(-nor+ng1:nx+nor,-nor+ng1:ny+nor,-norz+ng1:nz+norz) ! Ez (elecsave)
+        !  c1 = t00(igs(mgs),jy,kgs(mgs))*tabqvs(ltemq)
+          c1= pqs(mgs)*tabqvs(ltemq)
 
-!
-!
-      ! Hallett-Mossop arrays
-      real chmul1(ngs),chlmul1(ngs),csmul1(ngs),csmul(ngs)
-      real qhmul1(ngs),qhlmul1(ngs),qsmul1(ngs),qsmul(ngs)
-      
-      ! splinters from drop freezing
-      real csplinter(ngs),qsplinter(ngs)
-      real csplinter2(ngs),qsplinter2(ngs)
-!
-!
-!  concentration arrays...
-!
-      real :: chlcnh(ngs), vhlcnh(ngs), vhlcnhl(ngs)
-      real cracif(ngs), ciacrf(ngs)
-      real cracr(ngs)
+          ssf(mgs) = 0.0
+          IF ( c1 > 0. ) THEN
+            ssf(mgs) = 100.*(qx(mgs,lv)/c1 - 1.0)  ! from "new" values
+          ENDIF
 
-!
-      real ciint(ngs), crfrz(ngs), crfrzf(ngs), crfrzs(ngs)
-      real cicint(ngs)
-      real cipint(ngs)
-      real ciacw(ngs), cwacii(ngs) 
-      real ciacr(ngs), craci(ngs)
-      real csacw(ngs)
-      real csacr(ngs)
-      real csaci(ngs),   csacs(ngs)
-      real cracw(ngs) 
-      real chacw(ngs), chacr(ngs)
-      real :: chlacw(ngs) ! = 0.0
-      real chaci(ngs), chacs(ngs)
-!
-      real :: chlacr(ngs)
-      real :: chlaci(ngs), chlacs(ngs)
-      real crcnw(ngs) 
-      real cidpv(ngs),cisbv(ngs)
-      real cisdpv(ngs),cissbv(ngs)
-      real cimlr(ngs),cismlr(ngs)
+!          IF ( ssf(mgs) <= 1.0 .or. cnuc(mgs) > ccna(mgs) ) THEN
+          IF ( ssf(mgs) <= 1.0 ) THEN
+          CN(mgs) = 0.0
+          ELSE
+!           CN(mgs) = 0.01e9*rho0(mgs)/rho00*Min(2.0, Max(0.0,0.03*(ssf(mgs)-1.0)+1.)**cck ) - cx(mgs,lc) !           
+           CN(mgs) = 0.01e9*Min(2.0, Max(0.0,0.03*(ssf(mgs)-1.0)+1.)**cck ) - cx(mgs,lc) !           
+          ENDIF
+       
+       ENDIF
 
-      real chlsbv(ngs), chldpv(ngs)
-      real chlmlr(ngs), chlmlrr(ngs) 
-      real chlshr(ngs), chlshrr(ngs)
+       IF ( cn(mgs) > 0.0 ) THEN
+       cx(mgs,lc) = cx(mgs,lc) + cn(mgs)
+       
+       ccnc(mgs) = Max(0.0, ccnc(mgs) - cn(mgs))
+       
+       ! create some small droplets at minimum size (CP 2000), although it adds very little liquid
+       
+       dcrit = 2.0*2.5e-7
+       
+       dcloud = 1000.*dcrit**3*Pi/6.*cn(mgs)
+        qx(mgs,lc) = qx(mgs,lc) + DCLOUD
+        thetap(mgs) = thetap(mgs) + felvcp(mgs)*DCLOUD/(pi0(mgs))
+        qwvp(mgs) = qwvp(mgs) - DCLOUD
+  !      ccnc(mgs) = Max(0.0, ccnc(mgs) - cn(mgs))
+        ENDIF
+       
 
-      real chdpv(ngs),chsbv(ngs)
-      real chmlr(ngs),chcev(ngs)
-      real chmlrr(ngs)
-      real chshr(ngs), chshrr(ngs)
 
-      real csdpv(ngs),cssbv(ngs)
-      real csmlr(ngs),cscev(ngs)
-      real csshr(ngs)
+      ENDIF ! }
 
-      real crcev(ngs)
-      real crshr(ngs)
-!
-!
-! arrays for w-ac-x ;  x-ac-w
-!
-!
-!
-      real qrcnw(ngs), qwcnr(ngs)
-      real zrcnw(ngs),zracr(ngs),zracw(ngs),zrcev(ngs)
+      ccna(mgs) = ccna(mgs) + cn(mgs)
 
 
-      real qracw(ngs) ! qwacr(ngs),
-      real qiacw(ngs) !, qwaci(ngs)
 
-      real qsacw(ngs) ! ,qwacs(ngs),
-      real qhacw(ngs) ! qwach(ngs),
-      real :: qhlacw(ngs) ! = 0.0
-      real vhacw(ngs), vsacw(ngs), vhlacw(ngs), vhlacr(ngs)
+      ENDIF ! irenuc >= 0 .and. .not. flag_qndrop
 
-!
-      real qsacws(ngs)
+      IF( cx(mgs,lc) .GT. 0. .AND. qx(mgs,lc) .LE. qxmin(lc)) cx(mgs,lc)=0.
+      GO TO 631
+!.... NUCLEATION ON CLOUD INFLOW BOUNDARY POINT
 
-!
-!  arrays for x-ac-r and r-ac-x; 
-!
-      real qsacr(ngs),qracs(ngs)
-      real qhacr(ngs),qhacrmlr(ngs) ! ,qrach(ngs)
-      real vhacr(ngs), zhacr(ngs), zhacrf(ngs), zrach(ngs), zrachl(ngs)
-      real qiacr(ngs),qraci(ngs)
-      
-      real ziacr(ngs)
+  613 CONTINUE
 
-      real qracif(ngs),qiacrf(ngs),qiacrs(ngs),ciacrs(ngs)
+  631  CONTINUE
 
-      real :: qhlacr(ngs),qhlacrmlr(ngs) ! = 0.0
-      real qsacrs(ngs) !,qracss(ngs)
 !
-!  ice - ice interactions
+! Check for supersaturation greater than ssmx and adjust down
 !
-      real qsaci(ngs)
-      real qsacis(ngs)
-      real qhaci(ngs)
-      real qhacs(ngs)
+       ssmx = maxsupersat
+       qv1 = qv0(mgs) + qwvp(mgs)
+       qvs1 = qvs(mgs)
+       
+!       IF ( flag_qndrop .and. do_satadj_for_wrfchem ) ssmx = 1.04 ! set lower threshold for progn=1 when using WRF-CHEM
 
-      real :: qhacis(ngs) = 0.0
-      real :: chacis(ngs) = 0.0
-      real :: chacis0(ngs) = 0.0
+       IF ( qv1 .gt. (ssmx*qvs1) ) THEN
+! use line below to disable saturation adjustment when flag_qndrop is true
+!       IF ( qv1 .gt. (ssmx*qvs1) .and. .not. flag_qndrop ) THEN
+        
+         ss1 = qv1/qvs1
 
-      real :: csaci0(ngs) ! collision rate only
-      real :: chaci0(ngs) ! collision rate only
-      real :: chacs0(ngs) ! collision rate only
-      real :: chlaci0(ngs) ! = 0.0
-      real :: chlacis(ngs) = 0.0
-      real :: chlacis0(ngs) = 0.0
-      real :: chlacs0(ngs) ! = 0.0
+        ssmx = 100.*(ssmx - 1.0)
+        
+        qvex = 0.0
 
-      real :: qsaci0(ngs) ! collision rate only
-      real :: qsacis0(ngs) ! collision rate only
-      real :: qhaci0(ngs) ! collision rate only
-      real :: qhacis0(ngs) ! collision rate only
-      real :: qhacs0(ngs) ! collision rate only
-      real :: qhlaci0(ngs) ! = 0.0
-      real :: qhlacis0(ngs) ! = 0.0
-      real :: qhlacs0(ngs) ! = 0.0
+        CALL QVEXCESS(ngs,mgs,qwvp,qv0,qx(1,lc),pres,thetap,theta0,qvex,   &
+     &    pi0,tabqvs,nqsat,fqsat,cbw,fcqv1,felvcp,ssmx,pk,ngscnt)
 
-      real :: qhlaci(ngs) ! = 0.0
-      real :: qhlacis(ngs) ! = 0.0
-      real :: qhlacs(ngs) ! = 0.0
-!
-!  conversions
-!
-      real qrfrz(ngs) ! , qirirhr(ngs)
-      real zrfrz(ngs), zrfrzf(ngs), zrfrzs(ngs)
-      real ziacrf(ngs), zhcnsh(ngs), zhcnih(ngs)
-      real zhacw(ngs), zhacs(ngs), zhaci(ngs)
-      real zhmlr(ngs), zhdsv(ngs), zhsbv(ngs), zhlcnh(ngs), zhshr(ngs)
-      real zhmlrtmp,zhmlr0inf,zhlmlr0inf
-      real zhmlrr(ngs),zhlmlrr(ngs),zhshrr(ngs),zhlshrr(ngs)
-      real zsmlr(ngs), zsmlrr(ngs), zsshr(ngs)
-      real zhcns(ngs), zhcni(ngs)
-      real zhwdn(ngs) ! change in Z due to density changes
-      real zhldn(ngs) ! change in Z due to density changes
 
-      real zhlacw(ngs), zhlacs(ngs), zhlacr(ngs)
-      real zhlmlr(ngs), zhldsv(ngs), zhlsbv(ngs), zhlshr(ngs)
 
-      
-      real vrfrzf(ngs), viacrf(ngs)
-      real qrfrzs(ngs), qrfrzf(ngs)
-      real qwfrz(ngs), qwctfz(ngs)
-      real cwfrz(ngs), cwctfz(ngs)
-      real qwfrzis(ngs), qwctfzis(ngs) ! droplet freezing to ice spheres
-      real cwfrzis(ngs), cwctfzis(ngs)
-      real qwfrzc(ngs), qwctfzc(ngs) ! droplet freezing to columns
-      real cwfrzc(ngs), cwctfzc(ngs)
-      real qwfrzp(ngs), qwctfzp(ngs) ! droplet freezing to plates
-      real cwfrzp(ngs), cwctfzp(ngs)
-      real xcolmn(ngs), xplate(ngs)
-      real ciihr(ngs), qiihr(ngs)
-      real cicichr(ngs), qicichr(ngs)
-      real cipiphr(ngs), qipiphr(ngs)
-      real qscni(ngs), cscni(ngs), cscnis(ngs)
-      real qscnvi(ngs), cscnvi(ngs), cscnvis(ngs)
-      real qhcns(ngs), chcns(ngs), chcnsh(ngs), vhcns(ngs)
-      real qscnh(ngs), cscnh(ngs), vscnh(ngs)
-      real qhcni(ngs), chcni(ngs), chcnih(ngs), vhcni(ngs)
-      real qiint(ngs),qipipnt(ngs),qicicnt(ngs)
-      real cninm(ngs),cnina(ngs),cninp(ngs),wvel(ngs),wvelkm1(ngs)
-      real tke(ngs)
-      real uvel(ngs),vvel(ngs)
-!
-      real qidpv(ngs),qisbv(ngs) ! qicnv(ngs),qievv(ngs),
-      real qimlr(ngs),qidsv(ngs),qisdsv(ngs),qidsvp(ngs) ! ,qicev(ngs)
-      real qismlr(ngs)
+        IF ( qvex .gt. 0.0 ) THEN
+        thetap(mgs) = thetap(mgs) + felvcp(mgs)*qvex/(pi0(mgs))
+        IF ( io_flag .and. nxtra > 1 ) THEN
+           axtra(igs(mgs),jy,kgs(mgs),1) = axtra(igs(mgs),jy,kgs(mgs),1) + qvex/dtp
+        ENDIF
+        qwvp(mgs) = qwvp(mgs) - qvex
+        qx(mgs,lc) = qx(mgs,lc) + qvex
+        IF ( .not. flag_qndrop) THEN
+        cn(mgs) = Min( Max(ccnc(mgs),cwnccn(mgs)), rho0(mgs)*qvex/Max( cwmasn5, xmas(mgs,lc) )  )
+        ccnc(mgs) = Max( 0.0, ccnc(mgs) - cn(mgs) )
+        cx(mgs,lc) = cx(mgs,lc) + cn(mgs)
+        ENDIF
+        
+!        write(iunit,*) 'theta = ',theta0(mgs) + thetap(mgs)
 
-!
-      real qfdpv(ngs),qfsbv(ngs) ! qfcnv(ngs),qfevv(ngs),
-      real qfmlr(ngs),qfdsv(ngs) ! ,qfcev(ngs)
-      real qfwet(ngs),qfdry(ngs),qfshr(ngs)
-      real qfshrp(ngs)
-!
-      real :: qhldpv(ngs), qhlsbv(ngs) ! qhlcnv(ngs),qhlevv(ngs),
-      real :: qhlmlr(ngs), qhldsv(ngs) 
-      real :: qhlwet(ngs), qhldry(ngs), qhlshr(ngs) 
-!
-      real :: qrfz(ngs),qsfz(ngs),qhfz(ngs),qhlfz(ngs)
-!
-      real qhdpv(ngs),qhsbv(ngs) ! qhcnv(ngs),qhevv(ngs),
-      real qhmlr(ngs),qhdsv(ngs),qhcev(ngs),qhcndv(ngs),qhevv(ngs)
-      real qhmlrlg(ngs),qhlmlrlg(ngs) ! melting from the larger diameters
-      real qhlcev(ngs), chlcev(ngs)
-      real qhwet(ngs),qhdry(ngs),qhshr(ngs)
-      real qhshrp(ngs)
-      real qhshh(ngs) !accreted water that remains on graupel
-      real qhmlh(ngs) !melt water that remains on graupel
-      real qhfzh(ngs) !water that freezes on mixed-phase graupel
-      real qhlfzhl(ngs) !water that freezes on mixed-phase hail
+!        temg(mgs) = theta(mgs)*( pres(mgs) / poo ) ** cap
 
-      real vhfzh(ngs) ! change in volume from water that freezes on mixed-phase graupel
-      real vhlfzhl(ngs) !  change in volume from water that freezes on mixed-phase hail
+        ENDIF
+
+       
+       ENDIF
 
-      real vhshdr(ngs) !accreted water that leaves on graupel (mixedphase)
-      real vhlshdr(ngs) !accreted water that leaves on hail (mixedphase)
-      real vhmlr(ngs) !melt water that leaves graupel (single phase)
-      real vhlmlr(ngs) !melt water that leaves hail (single phase)
-      real vhsoak(ngs) !  aquired water that seeps into graupel.
-      real vhlsoak(ngs) !  aquired water that seeps into hail.
-!
-      real qsdpv(ngs),qssbv(ngs) ! qscnv(ngs),qsevv(ngs),
-      real qsmlr(ngs),qsdsv(ngs),qscev(ngs),qscndv(ngs),qsevv(ngs)
-      real qswet(ngs),qsdry(ngs),qsshr(ngs)
-      real qsshrp(ngs)
-      real qsfzs(ngs)
 !
+! Calculate droplet volume and check if it is within bounds.
+!  Adjust if necessary
+!  
+!      if (ndebug .gt. 0) write(0,*) "ICEZVD_DR: check droplet volume" 
+
+
+!      cx(mgs,lc) = Min( cwnccn(mgs), cx(mgs,lc) )
+      IF( cx(mgs,lc) > cxmin .AND. qx(mgs,lc) .GT. qxmin(lc)) THEN
+!        SVC(mgs) = rho0(mgs)*qx(mgs,lc)/(cx(mgs,lc)*xdn(mgs,lc))
+        xmas(mgs,lc) = rho0(mgs)*qx(mgs,lc)/(cx(mgs,lc))
+        
+       IF (  xmas(mgs,lc) < cwmasn .or.  xmas(mgs,lc) > cwmasx ) THEN
+        xmas(mgs,lc) = Min( xmas(mgs,lc), cwmasx )
+        xmas(mgs,lc) = Max( xmas(mgs,lc), cwmasn )
+        cx(mgs,lc) = rho0(mgs)*qx(mgs,lc)/xmas(mgs,lc)
+       ENDIF
+      ENDIF
+
+
+!      IF( cx(mgs,lc) .GT. 10.e6 .AND. qx(mgs,lc) .GT. qxmin(lc) ) GO TO 681
+!        ccwtmp = cx(mgs,lc)
+!        cwmastmp = xmas(mgs,lc)
+!       xmas(mgs,lc) = Max(xmas(mgs,lc), cwmasn)
+!       IF (qx(mgs,lc) .GT. qxmin(lc) .AND. cx(mgs,lc) .le. 0.) THEN
+!          cx(mgs,lc) = Min(0.5*cwccn,rho0(mgs)*qx(mgs,lc)/xmas(mgs,lc))
+!          xmas(mgs,lc) = rho0(mgs)*qx(mgs,lc)/cx(mgs,lc)
+!       ENDIF
+!      IF (cx(mgs,lc) .GT. 0. .AND. qx(mgs,lc) .GT. qxmin(lc))    &
+!     &        xmas(mgs,lc) = rho0(mgs)*qx(mgs,lc)/cx(mgs,lc)
+!      IF (qx(mgs,lc) .GT. qxmin(lc) .AND. xmas(mgs,lc) .LT. cwmasn)    &
+!     &          xmas(mgs,lc) = cwmasn
+!      IF (qx(mgs,lc) .GT. qxmin(lc) .AND. xmas(mgs,lc) .GT. cwmasx)    &
+!     &    xmas(mgs,lc) = cwmasx
+!      IF ( qx(mgs,lc) .gt. qxmin(lc) ) THEN
+!        cx(mgs,lc) = rho0(mgs)*qx(mgs,lc)/Max(cwmasn,xmas(mgs,lc))
+!      ENDIF
+!        
 !
-      real qipdpv(ngs),qipsbv(ngs)
-      real qipmlr(ngs),qipdsv(ngs)
-!
-      real qirdpv(ngs),qirsbv(ngs)
-      real qirmlr(ngs),qirdsv(ngs),qirmlw(ngs)
-!
-      real qgldpv(ngs),qglsbv(ngs)
-      real qglmlr(ngs),qgldsv(ngs)
-      real qglwet(ngs),qgldry(ngs),qglshr(ngs)
-      real qglshrp(ngs)
-!
-      real qgmdpv(ngs),qgmsbv(ngs)
-      real qgmmlr(ngs),qgmdsv(ngs)
-      real qgmwet(ngs),qgmdry(ngs),qgmshr(ngs)
-      real qgmshrp(ngs)
-      real qghdpv(ngs),qghsbv(ngs)
-      real qghmlr(ngs),qghdsv(ngs) 
-      real qghwet(ngs),qghdry(ngs),qghshr(ngs)
-      real qghshrp(ngs)
-!
-      real qrztot(ngs),qrzmax(ngs),qrzfac(ngs)
-      real qrcev(ngs)
-      real qrshr(ngs)
-      real fsw(ngs),fhw(ngs),fhlw(ngs) !liquid water fractions
-      real qhcnf(ngs) 
-      real :: qhlcnh(ngs) ! = 0.0
-      real qhcngh(ngs),qhcngm(ngs),qhcngl(ngs)
-      
-      real :: qhcnhl(ngs), chcnhl(ngs), zhcnhl(ngs), vhcnhl(ngs) ! conversion of low-density hail back to graupel
+! 681  CONTINUE
 
-      real eiw(ngs),eii(ngs),eiri(ngs),eipir(ngs),eisw(ngs)
-      real erw(ngs),esw(ngs),eglw(ngs),eghw(ngs),efw(ngs)
-      real ehxw(ngs),ehlw(ngs),egmw(ngs),ehw(ngs)
-      real err(ngs),esr(ngs),eglr(ngs),eghr(ngs),efr(ngs)
-      real ehxr(ngs),ehlr(ngs),egmr(ngs) 
-      real eri(ngs),esi(ngs),egli(ngs),eghi(ngs),efi(ngs)
-      real ehxi(ngs),ehli(ngs),egmi(ngs),ehi(ngs),ehis(ngs),ehlis(ngs)
-      real ers(ngs),ess(ngs),egls(ngs),eghs(ngs),efs(ngs),ehs(ngs)
-      real ehscnv(ngs)
-      real ehxs(ngs),ehls(ngs),egms(ngs),egmip(ngs) 
+        
+      IF ( ipconc .ge. 3 .and. rcond == 2 ) THEN
 
-      real ehsclsn(ngs),ehiclsn(ngs),ehisclsn(ngs)
-      real ehlsclsn(ngs),ehliclsn(ngs),ehlisclsn(ngs)
-      real esiclsn(ngs)
+        
+        IF (cx(mgs,lr) .GT. 0. .AND. qx(mgs,lr) .GT. qxmin(lr))    &
+     &       xv(mgs,lr)=rho0(mgs)*qx(mgs,lr)/(xdn(mgs,lr)*cx(mgs,lr))
+        IF (xv(mgs,lr) .GT. xvmx(lr)) xv(mgs,lr) = xvmx(lr)
+        IF (xv(mgs,lr) .LT. xvmn(lr)) xv(mgs,lr) = xvmn(lr)
 
-      real :: ehs_collsn = 0.5, ehi_collsn = 1.0
-      real :: ehls_collsn = 1.0, ehli_collsn = 1.0
-      real :: esi_collsn = 1.0
-      
-      real ew(8,6)
-      real cwr(8,2)  ! radius and inverse of interval
-      data cwr / 2.0, 3.0, 4.0, 6.0,  8.0,  10.0, 15.0,  20.0 , & ! radius
-     &           1.0, 1.0, 0.5, 0.5,  0.5,   0.2,  0.2,  1.  /   ! inverse of interval
-      integer icwr(ngs), igwr(ngs), irwr(ngs), ihlr(ngs)
-      real grad(6,2) ! graupel radius and inverse of interval
-      data grad / 100., 200., 300., 400., 600., 1000.,   &
-     &            1.e-2,1.e-2,1.e-2,5.e-3,2.5e-3, 1.    /
-!droplet radius: 2     3     4     6     8    10    15    20
-      data ew /0.03, 0.07, 0.17, 0.41, 0.58, 0.69, 0.82, 0.88,  & ! 100
-!     :         0.07, 0.13, 0.27, 0.48, 0.65, 0.73, 0.84, 0.91,  ! 150
-     &         0.10, 0.20, 0.34, 0.58, 0.70, 0.78, 0.88, 0.92,  & ! 200
-     &         0.15, 0.31, 0.44, 0.65, 0.75, 0.83, 0.96, 0.91,  & ! 300
-     &         0.17, 0.37, 0.50, 0.70, 0.81, 0.87, 0.93, 0.96,  & ! 400
-     &         0.17, 0.40, 0.54, 0.71, 0.83, 0.88, 0.94, 0.98,  & ! 600
-     &         0.15, 0.37, 0.52, 0.74, 0.82, 0.88, 0.94, 0.98 / ! 1000
-!     :         0.11, 0.34, 0.49, 0.71, 0.83, 0.88, 0.94, 0.95 / ! 1400
+      ENDIF
 
 
-      real da0lr(ngs)
-      real da0lh(ngs)
-      real da0lhl(ngs)
-      
-      real va0 (lc:lqmx)          ! collection coefficients from Seifert 2005
-      real vab0(lc:lqmx,lc:lqmx)  ! collection coefficients from Seifert 2005
-      real vab1(lc:lqmx,lc:lqmx)  ! collection coefficients from Seifert 2005
-      real va1 (lc:lqmx)          ! collection coefficients from Seifert 2005
-      real ehip(ngs),ehlip(ngs),ehlir(ngs)
-      real erir(ngs),esir(ngs),eglir(ngs),egmir(ngs),eghir(ngs)
-      real efir(ngs),ehir(ngs),eirw(ngs),eirir(ngs),ehr(ngs)
-      real erip(ngs),esip(ngs),eglip(ngs),eghip(ngs)
-      real efip(ngs),eipi(ngs),eipw(ngs),eipip(ngs)
-!
-!  arrays for production terms
-!
-      real ptotal(ngs) ! , pqtot(ngs)
+
+      ENDDO ! mgs
+
+
+! ################################################################
+      DO mgs=1,ngscnt
+      IF ( ssf(mgs) .gt. ssmax(mgs)    &
+     &  .and. ( idecss .eq. 0 .or. qx(mgs,lc) .gt. qxmin(lc)) ) THEN
+        ssmax(mgs) = ssf(mgs)
+      ENDIF
+      ENDDO
 !
-      real pqcwi(ngs),pqcii(ngs),pqrwi(ngs),pqisi(ngs)
-      real pqswi(ngs),pqhwi(ngs),pqwvi(ngs)
-      real pqgli(ngs),pqghi(ngs),pqfwi(ngs)
-      real pqgmi(ngs),pqhli(ngs) ! ,pqhxi(ngs)
-      real pqiri(ngs),pqipi(ngs) ! pqwai(ngs),
-      real pqlwsi(ngs),pqlwhi(ngs),pqlwhli(ngs)
-      
-      real pvhwi(ngs), pvhwd(ngs)
-      real pvhli(ngs), pvhld(ngs)
-      real pvswi(ngs), pvswd(ngs)
+
+      do mgs = 1,ngscnt
+      an(igs(mgs),jy,kgs(mgs),lt) = theta0(mgs) + thetap(mgs)
+      an(igs(mgs),jy,kgs(mgs),lv) =  qv0(mgs) + qwvp(mgs)
+!      tmp3d(igs(mgs),jy,kgs(mgs)) = tmp3d(igs(mgs),jy,kgs(mgs)) + t9(igs(mgs),jy,kgs(mgs)) !  pi0(mgs) ! wvdf(mgs) ! ssf(mgs) ! cn(mgs)
 !
-      real pqcwd(ngs),pqcid(ngs),pqrwd(ngs),pqisd(ngs)
-      real pqswd(ngs),pqhwd(ngs),pqwvd(ngs)
-      real pqgld(ngs),pqghd(ngs),pqfwd(ngs)
-      real pqgmd(ngs),pqhld(ngs) ! ,pqhxd(ngs)
-      real pqird(ngs),pqipd(ngs) ! pqwad(ngs),
-      real pqlwsd(ngs),pqlwhd(ngs),pqlwhld(ngs)
+      IF ( eqtset > 2 ) THEN
+        p2(igs(mgs),jy,kgs(mgs)) = pipert(mgs)
+      ENDIF
+
+       if ( ido(lc) .eq. 1 )  then
+        an(igs(mgs),jy,kgs(mgs),lc) = qx(mgs,lc) +    &
+     &    min( an(igs(mgs),jy,kgs(mgs),lc), 0.0 )
+!        qx(mgs,lc) = an(igs(mgs),jy,kgs(mgs),lc)
+       end if
 !
-!      real pqxii(ngs,nhab),pqxid(ngs,nhab)
+
+       if ( ido(lr) .eq. 1 .and. rcond == 2 )  then
+        an(igs(mgs),jy,kgs(mgs),lr) = qx(mgs,lr) +    &
+     &    min( an(igs(mgs),jy,kgs(mgs),lr), 0.0 )
+!        qx(mgs,lr) = an(igs(mgs),jy,kgs(mgs),lr)
+       end if
+
+
+
+       IF (  ipconc .ge. 2 ) THEN
+        an(igs(mgs),jy,kgs(mgs),lnc) = Max(cx(mgs,lc) , 0.0)
+        IF ( lss > 1 ) an(igs(mgs),jy,kgs(mgs),lss) = Max( 0.0, ssmax(mgs) )
+        IF ( lccn .gt. 1 ) THEN
+          an(igs(mgs),jy,kgs(mgs),lccn) = Max(0.0,  ccnc(mgs) )
+        ENDIF
+        IF ( lccna .gt. 1 ) THEN
+          an(igs(mgs),jy,kgs(mgs),lccna) = Max(0.0, ccna(mgs) )
+        ENDIF
+       ENDIF
+       IF (  ipconc .ge. 3 .and. rcond == 2 ) THEN
+        an(igs(mgs),jy,kgs(mgs),lnr) = Max(cx(mgs,lr) , 0.0)
+       ENDIF
+      end do
+
+
+29998 continue
+
+
+      if ( kz .gt. nz-1 .and. ix .ge. nxi) then
+        if ( ix .ge. nxi ) then
+         go to 2200 ! exit gather scatter
+        else
+         nzmpb = kz
+        endif
+      else
+        nzmpb = kz
+      end if
+
+      if ( ix .ge. nxi ) then
+        nxmpb = 1
+        nzmpb = kz+1
+      else
+       nxmpb = ix+1
+      end if
+
+ 2000 continue ! inumgs
+ 2200 continue
 !
-      real  pctot(ngs)
-      real  pcipi(ngs), pcipd(ngs)
-      real  pciri(ngs), pcird(ngs)
-      real  pccwi(ngs), pccwd(ngs)
-      real  pccii(ngs), pccid(ngs)
-      real  pcisi(ngs), pcisd(ngs)
-      real  pccin(ngs)
-      real  pcrwi(ngs), pcrwd(ngs)
-      real  pcswi(ngs), pcswd(ngs)
-      real  pchwi(ngs), pchwd(ngs)
-      real  pchli(ngs), pchld(ngs)
-      real  pcfwi(ngs), pcfwd(ngs)
-      real  pcgli(ngs), pcgld(ngs)
-      real  pcgmi(ngs), pcgmd(ngs)
-      real  pcghi(ngs), pcghd(ngs)
+!  end of gather scatter (for this jy slice)
 
-      real  pzrwi(ngs), pzrwd(ngs)
-      real  pzhwi(ngs), pzhwd(ngs)
-      real  pzhli(ngs), pzhld(ngs)
-      real  pzswi(ngs), pzswd(ngs)
 
+!#ifdef COMMAS
+!    GOTO 9999
+!#endif
+
+! Redistribute inappreciable cloud particles and charge
 !
-!  other arrays
+! Redistribution everywhere in the domain...
 !
-      real dqisdt(ngs) !,advisc(ngs) !dqwsdt(ngs), ,schm(ngs),pndl(ngs)
+      frac = 1.0 ! 0.25 ! 1.0 ! 0.2
+!
+!  alternate test version for ipconc .ge. 3
+!  just vaporize stuff to prevent noise in the number concentrations
 
-      real qss0(ngs)
 
-      real qsacip(ngs)
-      real pres(ngs),pipert(ngs)
-      real pk(ngs)
-      real rho0(ngs),pi0(ngs)
-      real rhovt(ngs),sqrtrhovt
-      real thetap(ngs),theta0(ngs),qwvp(ngs),qv0(ngs)
-      real thsave(ngs)
-      real ptwfzi(ngs),ptimlw(ngs)
-      real psub(ngs),pvap(ngs),pfrz(ngs),ptem(ngs),pmlt(ngs),pevap(ngs),pdep(ngs)
-      
-      real cnostmp(ngs)   ! for diagnosed snow intercept
-!
-!  iholef = 1 to do hole filling technique version 1
-!  which uses all hydrometerors to do hole filling of all hydrometeors
-!  iholef = 2 to do hole filling technique version 2
-!  which uses an individual hydrometeror species to do hole
-!  filling of a species of a hydrometeor
-!
-!  iholen = interval that hole filling is done
-!
-      integer  iholef
-      integer  iholen
-      parameter (iholef = 1)
-      parameter (iholen = 1)
-      real  cqtotn,cqtotn1
-      real  cctotn
-      real  citotn
-      real  crtotn
-      real  cstotn
-      real  cvtotn
-      real  cftotn
-      real  cgltotn
-      real  cghtotn
-      real  chtotn
-      real  cqtotp,cqtotp1
-      real  cctotp
-      real  citotp
-      real  ciptotp
-      real  crtotp
-      real  cstotp
-      real  cvtotp
-      real  cftotp
-      real  chltotp
-      real  cgltotp
-      real  cgmtotp
-      real  cghtotp
-      real  chtotp
-      real  cqfac
-      real  ccfac
-      real  cifac
-      real  cipfac
-      real  crfac
-      real  csfac
-      real  cvfac
-      real  cffac
-      real  cglfac
-      real  cghfac
-      real  chfac
+      do kz = 1,nz
+!      do jy = 1,1
+      do ix = 1,nxi
       
-      real ssifac, qvapor
-!
-!   Miscellaneous variables
-!
-      integer ireadqf,lrho,lqsw,lqgl,lqgm ,lqgh 
-      integer lqrw
-      real vt
-      real arg  ! gamma is a function
-      real erbnd1, fdgt1, costhe1
-      real qeps
-      real dyi2,dzi2,cp608,bta1,cnit,dragh,dnz00,pii
-      real qccrit,gf4br,gf4ds,gf4p5, gf3ds, gf1ds,gr
-      real gf1palp(ngs) ! for storing Gamma[1.0 + alphar]
+      t0(ix,jy,kz) = an(ix,jy,kz,lt)*t77(ix,jy,kz)
+      
+      zerocx(:) = .false.
+      DO il = lc,lhab
+       IF ( iresetmoments == 1 .or. iresetmoments == il ) THEN
+        IF ( ln(il) > 1 ) zerocx(il) = ( an(ix,jy,kz,ln(il)) < cxmin )
+        IF ( lz(il) > 1 ) zerocx(il) = ( zerocx(il) .or. an(ix,jy,kz,lz(il)) < zxmin )
+       ELSE
+        IF ( il == lc ) THEN
+          IF ( ln(il) > 1 ) zerocx(il) = ( an(ix,jy,kz,ln(il)) <= 0 ) .and. .not. flag_qndrop ! do not reset if progn=1 (WRF-CHEM)
+        ELSE
+         IF ( ln(il) > 1 ) zerocx(il) = ( an(ix,jy,kz,ln(il)) <= 0 )
+        ENDIF
+       ENDIF
+      ENDDO
 
+      IF ( lhl .gt. 1 ) THEN
       
-      real xdn0(lc:lhab)
-      real xdn_new,drhodt
       
-      integer l ,ltemq,inumgs, idelq
+      if ( an(ix,jy,kz,lhl) .lt. frac*qxmin(lhl) .or. zerocx(lhl) ) then
 
-      real brz,arz,temq
+!        IF ( an(ix,jy,kz,lhl) .gt. 0 ) THEN
+          an(ix,jy,kz,lv) = an(ix,jy,kz,lv) + an(ix,jy,kz,lhl)
+          an(ix,jy,kz,lhl) = 0.0
+!        ENDIF
 
-      real ssival,tqvcon
-      real cdx(lc:lhab)
-      real cnox
-      real cval,aval,eval,fval,gval ,qsign,ftelwc,qconkq
-      real qconm,qconn,cfce15,gf8,gf4i,gf3p5,gf1a,gf1p5,qdiff,argrcnw
-      real c4,bradp,bl2,bt2,dtrh,hrifac, hdia0,hdia1,civenta,civentb
-      real civentc,civentd,civente,civentf,civentg,cireyn,xcivent
-      real cipventa,cipventb,cipventc,cipventd,cipreyn,cirventa
-      real cirventb
-      integer igmrwa,igmrwb,igmswa, igmswb,igmfwa,igmfwb,igmhwa,igmhwb
-      real rwventa ,rwventb,swventa,swventb,fwventa,fwventb,fwventc
-      real hwventa,hwventb
-      real    hwventc, hlventa, hlventb,  hlventc
-      real  glventa, glventb, glventc
-      real   gmventa, gmventb,  gmventc, ghventa, ghventb, ghventc
-      real  dzfacp,  dzfacm,  cmassin,  cwdiar 
-      real  rimmas, rhobar
-      real   argtim, argqcw, argqxw, argtem
-      real   frcswsw, frcswgl, frcswgm, frcswgh, frcswfw, frcswsw1
-      real   frcglgl, frcglgm, frcglgh,  frcglfw, frcglgl1
-      real   frcgmgl, frcgmgm, frcgmgh,  frcgmfw, frcgmgm1
-      real   frcghgl, frcghgm, frcghgh,  frcghfw,  frcghgh1
-      real   frcfwgl, frcfwgm, frcfwgh, frcfwfw,  frcfwfw1
-      real   frcswrsw, frcswrgl,  frcswrgm,  frcswrgh, frcswrfw
-      real   frcswrsw1
-      real   frcrswsw, frcrswgl, frcrswgm, frcrswgh, frcrswfw
-      real  frcrswsw1
-      real  frcglrgl, frcglrgm, frcglrgh,  frcglrfw, frcglrgl1
-      real  frcrglgl
-      real  frcrglgm,  frcrglgh, frcrglfw, frcrglgl1
-      real  frcgmrgl, frcgmrgm, frcgmrgh, frcgmrfw,  frcgmrgm1
-      real  frcrgmgl, frcrgmgm,  frcrgmgh, frcrgmfw, frcrgmgm1
-      real  sum,  qweps,  gf2a, gf4a, dqldt, dqidt, dqdt
-      real frcghrgl, frcghrgm, frcghrgh, frcghrfw, frcghrgh1, frcrghgl
-      real frcrghgm, frcrghgh,  frcrghfw, frcrghgh1
-      real    a1,a2,a3,a4,a5,a6
-      real   gamss
-      real cdw, cdi, denom1, denom2, delqci1, delqip1
-      real cirtotn,  ciptotn, cgmtotn, chltotn,  cirtotp
-      real  cgmfac, chlfac,  cirfac
-      integer igmhla, igmhlb, igmgla, igmglb, igmgma,  igmgmb
-      integer igmgha, igmghb
-      integer idqis, item, itim0 
-      integer  iqgl, iqgm, iqgh, iqrw, iqsw 
-      integer  itertd, ia
-      
-      integer :: infdo
-      
-      real tau, ewtmp
-      
-      integer cntnic_noliq
-      real     q_noliqmn, q_noliqmx
-      real     scsacimn, scsacimx
-      
-      real :: dtpinv
+        IF ( ipconc .ge. 5 ) THEN ! .and. an(ix,jy,kz,lnh) .gt. 0.0 ) THEN
+          an(ix,jy,kz,lnhl) = 0.0
+        ENDIF
+
+        IF ( lvhl .gt. 1 ) THEN
+           an(ix,jy,kz,lvhl) = 0.0
+        ENDIF
+
+        IF ( lhlw .gt. 1 ) THEN
+           an(ix,jy,kz,lhlw) = 0.0
+        ENDIF
       
-!   arrays for temporary bin space
+        IF ( lzhl .gt. 1 ) THEN
+           an(ix,jy,kz,lzhl) = 0.0
+        ENDIF
+        IF ( ipelec > 0 .and. lschl .gt. 1 ) THEN
+          IF ( an(ix,jy,kz,lschl) .gt. 0.0 ) THEN
+            an(ix,jy,kz,lscpi) = an(ix,jy,kz,lscpi) + an(ix,jy,kz,lschl)*eci
+          ELSE
+            an(ix,jy,kz,lscni) = an(ix,jy,kz,lscni) - an(ix,jy,kz,lschl)*eci
+          ENDIF
+          
+           an(ix,jy,kz,lschl) = 0.0
+        ENDIF
 
-      real :: qhmlrtmp,qhmlrtmp2, chmlrtmp, chmlrtmpd1inf, chlmlrtmp, zhlmlrtmp, zhlmlrrtmp, qvs0,tmpcmlt
+      ELSE
+       IF ( lvol(lhl) .gt. 1 ) THEN  ! check density
+        IF ( an(ix,jy,kz,lvhl) .gt. 0.0 ) THEN
+         tmp = dn(ix,jy,kz)*an(ix,jy,kz,lhl)/an(ix,jy,kz,lvhl)
+        ELSE ! in case volume is zero but mass is above threshold (should not happen, of course)
+          tmp = rho_qhl
+          an(ix,jy,kz,lvhl) = dn(ix,jy,kz)*an(ix,jy,kz,lhl)/tmp
+        ENDIF
 
-      real :: term1,term2,term3,term4
-      real :: qaacw ! combined qsacw-qhacw for WSM6 variation
+        IF (  tmp .lt. xdnmn(lhl) ) THEN
+          tmp = Max( xdnmn(lhl), tmp )
+          an(ix,jy,kz,lvhl) = dn(ix,jy,kz)*an(ix,jy,kz,lhl)/tmp
+        ENDIF
 
+        IF ( tmp .gt. xdnmx(lhl) .and. lhlw .le. 0 ) THEN ! no liquid allowed on hail
+          tmp = Min( xdnmx(lhl), tmp )
+          an(ix,jy,kz,lvhl) = dn(ix,jy,kz)*an(ix,jy,kz,lhl)/tmp
+        ELSEIF ( tmp .gt. xdnmx(lhl) .and. lhlw .gt. 1 ) THEN  ! allow for liquid on hail
+          fw = an(ix,jy,kz,lhlw)/an(ix,jy,kz,lhl)
+!          tmpmx = xdnmx(lhl) + fw*(xdnmx(lr) - xdnmx(lhl)) ! maximum possible average density
+                                                           ! it is not exactly linear, but approx. is close enough for this
+!          tmpmx = 1./( (1. - fw)/900. + fw/1000. ) is exact max, where 900 is xdnmx
 
+          tmpmx = xdnmx(lhl)/( 1. - fw*(1. - xdnmx(lhl)/xdnmx(lr) )) 
 
-!
-! ####################################################################
-!
-!  Start routine
-!
-! ####################################################################
+          IF ( tmp .gt. tmpmx  ) THEN
+            an(ix,jy,kz,lvhl) = dn(ix,jy,kz)*an(ix,jy,kz,lhl)/tmpmx
+          ENDIF
 
+!          IF ( tmp .gt. xdnmx(lhl) .and. an(ix,jy,kz,lhlw) .lt. qxmin(lhl) ) THEN
+!            tmp = Min( xdnmx(lhl), tmp )
+!            an(ix,jy,kz,lvhl) = dn(ix,jy,kz)*an(ix,jy,kz,lhl)/tmp
+!          ELSEIF ( tmp .gt. xdnmx(lr) ) THEN
+!            tmp =  xdnmx(lr)
+!            an(ix,jy,kz,lvhl) = dn(ix,jy,kz)*an(ix,jy,kz,lhl)/tmp
+!          ENDIF
+        ENDIF
 
+        IF ( lhlw .gt. 1 ) THEN ! check if basically pure water
+          IF ( an(ix,jy,kz,lhlw) .gt. 0.98*an(ix,jy,kz,lhl) ) THEN
+           tmp = xdnmx(lr)
+           an(ix,jy,kz,lvhl) = dn(ix,jy,kz)*an(ix,jy,kz,lhl)/tmp
+          ENDIF
+        ENDIF
+        
+       ENDIF
+       
+       
+!  CHECK INTERCEPT
+       IF ( ipconc == 5 .and.  an(ix,jy,kz,lhl) .gt. qxmin(lhl) .and.  alphahl .le. 0.1 .and. lnhl .gt. 1 .and. lzhl == 0 ) THEN
+       
+         IF ( lvhl .gt. 1 ) THEN
+           hwdn = dn(ix,jy,kz)*an(ix,jy,kz,lhl)/an(ix,jy,kz,lvhl)
+         ELSE
+           hwdn = xdn0(lhl)
+         ENDIF
+           tmp = (hwdn*an(ix,jy,kz,lnhl))/(dn(ix,jy,kz)*an(ix,jy,kz,lhl))
+           tmpg = an(ix,jy,kz,lnhl)*(tmp*(3.14159))**(1./3.)
+           IF ( tmpg .lt. cnohlmn ) THEN
+             tmp = ( (hwdn)/(dn(ix,jy,kz)*an(ix,jy,kz,lhl))*(3.14159))**(1./3.)
+              an(ix,jy,kz,lnhl) = (cnohlmn/tmp)**(3./4.)
+           ENDIF
+       
+       ENDIF
+!      ELSE  ! check mean size here?
 
-!
+      end if
 
-       pb(:) = 0.0
-       pinit(:) = 0.0
-      itile = nx
-      jtile = ny
-      ktile = nz
-      ixend = nx
-      jyend = ny
-      kzend = nz
-      nxend = nx + 1
-      nyend = ny + 1
-      nzend = nz
-      kzbeg = 1
-      nzbeg = 1
 
-      istag = 0
-      jstag = 0
-      kstag = 1
 
+      ENDIF !lhl
 
-!
-!  slope intercepts
-!
 
-      IF ( ngs .lt. nz ) THEN
-!       write(0,*) 'Error in ICEZVD: Must have ngs .ge. nz!'
-!       STOP
-      ENDIF
+      if ( an(ix,jy,kz,lh) .lt. frac*qxmin(lh) .or. zerocx(lh) ) then
 
-      cntnic_noliq = 0
-      q_noliqmn = 0.0
-      q_noliqmx = 0.0
-      scsacimn = 0.0
-      scsacimx = 0.0
-
-      ldovol = .false.
-
-      DO il = lc,lhab
-        ldovol = ldovol .or. ( lvol(il) .gt. 1 )
-      ENDDO
+!        IF ( an(ix,jy,kz,lh) .gt. 0 ) THEN
+          an(ix,jy,kz,lv) = an(ix,jy,kz,lv) + an(ix,jy,kz,lh)
+          an(ix,jy,kz,lh) = 0.0
+!        ENDIF
 
+        IF ( ipconc .ge. 5 ) THEN ! .and. an(ix,jy,kz,lnh) .gt. 0.0 ) THEN
+          an(ix,jy,kz,lnh) = 0.0
+        ENDIF
 
-!      DO il = lc,lhab
-!        write(iunit,*) 'delqnxa(',il,') = ',delqnxa(il)
-!      ENDDO
+        IF ( lvh .gt. 1 ) THEN
+           an(ix,jy,kz,lvh) = 0.0
+        ENDIF
       
-!
-!  density maximums and minimums
-!
-
-!
-!  Set terminal velocities...
-!    also set drag coefficients
-!
+        IF ( lhw .gt. 1 ) THEN
+           an(ix,jy,kz,lhw) = 0.0
+        ENDIF
+      
+        IF ( lzh .gt. 1 ) THEN
+           an(ix,jy,kz,lzh) = 0.0
+        ENDIF
+        IF ( ipelec > 0 .and. lsch .gt. 1 ) THEN
+          IF ( an(ix,jy,kz,lsch) .gt. 0.0 ) THEN
+            an(ix,jy,kz,lscpi) = an(ix,jy,kz,lscpi) + an(ix,jy,kz,lsch)*eci
+          ELSE
+            an(ix,jy,kz,lscni) = an(ix,jy,kz,lscni) - an(ix,jy,kz,lsch)*eci
+          ENDIF
+           an(ix,jy,kz,lsch) = 0.0
+        ENDIF
 
-      dtpinv = 1.d0/dtp
+      ELSE
+       IF ( lvol(lh) .gt. 1 ) THEN  ! check density
+        IF ( an(ix,jy,kz,lvh) .gt. 0.0 ) THEN
+         tmp = dn(ix,jy,kz)*an(ix,jy,kz,lh)/an(ix,jy,kz,lvh)
+        ELSE
+         tmp = rho_qh
+          an(ix,jy,kz,lvh) = dn(ix,jy,kz)*an(ix,jy,kz,lh)/tmp
+        ENDIF
 
-!
+        IF (  tmp .lt. xdnmn(lh) ) THEN
+          tmp = Max( xdnmn(lh), tmp )
+          an(ix,jy,kz,lvh) = dn(ix,jy,kz)*an(ix,jy,kz,lh)/tmp
+        ENDIF
 
-!
-!  electricity constants
-!
-!  mixing ratio epsilon
-!
-      qeps  = 1.0e-20
+        IF ( tmp .gt. xdnmx(lh) .and. lhw .le. 0 ) THEN ! no liquid allowed on graupel
+          tmp = Min( xdnmx(lh), tmp )
+          an(ix,jy,kz,lvh) = dn(ix,jy,kz)*an(ix,jy,kz,lh)/tmp
+        ELSEIF ( tmp .gt. xdnmx(lh) .and. lhw .gt. 1 ) THEN  ! allow for liquid on graupel
+          fw = an(ix,jy,kz,lhw)/an(ix,jy,kz,lh)
+!          tmpmx = xdnmx(lh) + fw*(xdnmx(lr) - xdnmx(lh)) ! maximum possible average density
+                                                           ! it is not exactly linear, but approx. is close enough for this
+!          tmpmx = 1./( (1. - fw)/900. + fw/1000. ) is exact max, where 900 is xdnmx
+          tmpmx = xdnmx(lh)/( 1. - fw*(1. - xdnmx(lh)/xdnmx(lr) )) 
 
-!  rebound efficiency (erbnd)
-!
-!
-!
-!  constants
-!
+          IF ( tmp .gt. tmpmx  ) THEN
+            an(ix,jy,kz,lvh) = dn(ix,jy,kz)*an(ix,jy,kz,lh)/tmpmx
+          ENDIF
 
-      cp608 = 0.608
-      aradcw = -0.27544
-      bradcw = 0.26249e+06
-      cradcw = -1.8896e+10
-      dradcw = 4.4626e+14
-      bta1 = 0.6
-      cnit = 1.0e-02
-      dragh = 0.60
-      dnz00 = 1.225
-!      cs = 4.83607122
-!      ds = 0.25
-!  new values for  cs and ds
-      cs = 12.42
-      ds = 0.42
-      pii = piinv ! 1./pi
-      pid4 = pi/4.0 
-!      qscrit = 6.0e-04
-      gf1 = 1.0 ! gamma(1.0)
-      gf1p5 = 0.8862269255  ! gamma(1.5)
-      gf2 = 1.0 ! gamma(2.0)
-      gf3 = 2.0 ! gamma(3.0)
-      gf3p5 = 3.32335097 ! gamma(3.5)
-      gf4 = 6.00 ! gamma(4.0)
-      gf5 = 24.0 ! gamma(5.0)
-      gf6 = 120.0 ! gamma(6.0)
-      gf7 = 720.0 ! gamma(7.0)
-      gf4br = 17.837861981813607 ! gamma(4.0+br)
-      gf4ds = 10.41688578110938 ! gamma(4.0+ds)
-      gf4p5 = 11.63172839656745 ! gamma(4.0+0.5)
-      gf3ds = 3.0458730354120997 ! gamma(3.0+ds)
-      gf1ds = 0.8863557896089221 ! gamma(1.0+ds)
-      gr = 9.8
-      gf43rds = 0.8929795116 ! gamma(4./3.)
-      gf53rds = 0.9027452930 ! gamma(5./3.)
-      gf73rds = 1.190639349 ! gamma(7./3.)
-      gf83rds = 1.504575488 ! gamma(8./3.)
-      
-      gamice73fac =  (Gamma_sp(7./3. + cinu))**3/ (Gamma_sp(1. + cinu)**3 * (1. + cinu)**4)
-      gamsnow73fac =  (Gamma_sp(7./3. + snu))**3/ (Gamma_sp(1. + snu)**3 * (1. + snu)**4)
-      
-      gcnup1 = Gamma_sp(cnu + 1.)
-      gcnup2 = Gamma_sp(cnu + 2.)
-!
-!  constants
-!
-!
-!  general constants for microphysics
-!
-      brz = 100.0
-      arz = 0.66
-      
-      bfnu1 = (4. + alphar)*(5. + alphar)*(6. + alphar)/ &
-     &       ((1. + alphar)*(2. + alphar)*(3. + alphar))
+!          IF ( tmp .gt. xdnmx(lh) .and. an(ix,jy,kz,lhw) .lt. qxmin(lh) ) THEN
+!            tmp = Min( xdnmx(lh), tmp )
+!            an(ix,jy,kz,lvh) = dn(ix,jy,kz)*an(ix,jy,kz,lh)/tmp
+!          ELSEIF ( tmp .gt. xdnmx(lr) ) THEN
+!            tmp =  xdnmx(lr)
+!            an(ix,jy,kz,lvh) = dn(ix,jy,kz)*an(ix,jy,kz,lh)/tmp
+!          ENDIF
 
-       galpharaut = (6.+alpharaut)*(5.+alpharaut)*(4.+alpharaut)/ &
-     &             ((3.+alpharaut)*(2.+alpharaut)*(1.+alpharaut))
-      
-      vfrz = 0.523599*(dfrz)**3 
-      vmlt = Min(xvmx(lr), 0.523599*(dmlt)**3 )
-      vshd = Min(xvmx(lr), 0.523599*(dshd)**3 )
+        ENDIF
 
-     
+        IF ( lhw .gt. 1 ) THEN ! check if basically pure water
+          IF ( an(ix,jy,kz,lhw) .gt. 0.98*an(ix,jy,kz,lh) ) THEN
+           tmp = xdnmx(lr)
+           an(ix,jy,kz,lvh) = dn(ix,jy,kz)*an(ix,jy,kz,lh)/tmp
+          ENDIF
+        ENDIF
+        
+       ENDIF
 
-      tdtol = 1.0e-05
-      tfrcbw = tfr - cbw
-      tfrcbi = tfr - cbi
-!
-!
-! #ifdef COMMAS
-!      print*,'ventr,ventc = ',ventr,ventc
+!  CHECK INTERCEPT
+       IF ( ipconc == 5 .and.  an(ix,jy,kz,lh) .gt. qxmin(lh) .and.  alphah .le. 0.1 .and. lnh .gt. 1 .and. lzh == 0 ) THEN
+       
+         IF ( lvh .gt. 1 ) THEN
+           IF ( an(ix,jy,kz,lvh) .gt. 0.0 ) THEN
+             hwdn = dn(ix,jy,kz)*an(ix,jy,kz,lh)/an(ix,jy,kz,lvh)
+           ELSE
+             hwdn = xdn0(lh)
+           ENDIF
+           hwdn = Max( xdnmn(lh), hwdn )
+         ELSE
+           hwdn = xdn0(lh)
+         ENDIF
+           tmp = (hwdn*an(ix,jy,kz,lnh))/(dn(ix,jy,kz)*an(ix,jy,kz,lh))
+           tmpg = an(ix,jy,kz,lnh)*(tmp*(3.14159))**(1./3.)
+           IF ( tmpg .lt. cnohmn ) THEN
+!           tmpg = an(ix,jy,kz,lnh)*( (hwdn*an(ix,jy,kz,lnh))/(dn(ix,jy,kz)*an(ix,jy,kz,lh))*(3.14159))**(1./3.)
+!           tmpg = an(ix,jy,kz,lnh)**(4./3.)*( (hwdn)/(dn(ix,jy,kz)*an(ix,jy,kz,lh))*(3.14159))**(1./3.)
+             tmp = ( (hwdn)/(dn(ix,jy,kz)*an(ix,jy,kz,lh))*(3.14159))**(1./3.)
+              an(ix,jy,kz,lnh) = (cnohmn/tmp)**(3./4.)
+           ENDIF
+       
+       ENDIF
+        
+      end if
 
-!
-!  Set up look up tables for supersaturation w.r.t. liq and ice
-!
-!VD$L SKIP
-!      do l = 1,nqsat
-!      temq = 163.15 + (l-1)*fqsat
-!      tabqvs(l) = exp(caw*(temq-273.15)/(temq-cbw))
-!      tabqis(l) = exp(cai*(temq-273.15)/(temq-cbi))
-!      end do
 
-      mltmass1inv = 1.0/( 1000.0*(4.0*pi/3.0)*((0.01*0.5*takshedsize1)**3) ) ! for drops melting from ice with diameter > 1.9cm
-      mltmass2inv = 1.0/( 1000.0*(4.0*pi/3.0)*((0.01*0.5*takshedsize2)**3) ) ! for drops melting from ice with 0.9cm < d < 1.9cm
-      mltmass1cgs =  1.0*(4.0*pi/3.0)*((0.5*takshedsize1)**3) 
-      mltmass2cgs =  1.0*(4.0*pi/3.0)*((0.5*takshedsize2)**3) 
+      if ( an(ix,jy,kz,ls) .lt.  frac*qxmin(ls)  .or. zerocx(ls)  & ! .or.  an(ix,jy,kz,lns) .lt. 0.1 ! .and.
+     &         ) then
+      IF ( t0(ix,jy,kz) .lt. 273.15 ) THEN
+!        IF ( an(ix,jy,kz,ls) .gt. 0 ) THEN
+          an(ix,jy,kz,lv) = an(ix,jy,kz,lv) + an(ix,jy,kz,ls)
+          an(ix,jy,kz,ls) = 0.0
+!        ENDIF
       
-!      real, parameter :: mltdiam1 = 9.0e-3, mltdiam2 = 19.0e-3, mltdiam05 = 4.5e-3
+        IF ( ipconc .ge. 4 ) THEN ! .and. an(ix,jy,kz,lns) .gt. 0.0  ) THEN ! 
+!          an(ix,jy,kz,lni) = an(ix,jy,kz,lni) + an(ix,jy,kz,lns)
+          an(ix,jy,kz,lns) = 0.0
+        ENDIF
+        
+        IF ( lvs .gt. 1 ) THEN
+           an(ix,jy,kz,lvs) = 0.0
+        ENDIF
+
+        IF ( lsw .gt. 1 ) THEN
+           an(ix,jy,kz,lsw) = 0.0
+        ENDIF
 
-      IF ( .false. ) THEN
-        numdiam = 1 ! must have numdiam < ndiam because numdiam+1 holds values for the interval of mltdiam(numdiam) to mltdiam(ndiam+1)
-        mltdiam(1) = 4.5e-3
-      ELSEIF ( .true. ) THEN
-        numdiam = 2 ! must have numdiam < ndiam because numdiam+1 holds values for the interval of mltdiam(numdiam) to mltdiam(ndiam+1)
-        mltdiam(1) = 1.5e-3
-        mltdiam(2) = 4.5e-3
       ELSE
-        numdiam = 5 ! must have numdiam < ndiam because numdiam+1 holds values for the interval of mltdiam(numdiam) to mltdiam(ndiam+1)
-        mltdiam(1) = 0.5e-3
-        mltdiam(2) = 1.0e-3
-        mltdiam(3) = 2.0e-3
-        mltdiam(4) = 4.0e-3
-        mltdiam(5) = 6.0e-3
-      ENDIF
+!        IF ( an(ix,jy,kz,ls) .gt. 0 ) THEN
+          an(ix,jy,kz,lv) = an(ix,jy,kz,lv) + an(ix,jy,kz,ls)
+          an(ix,jy,kz,ls) = 0.0
+!        ENDIF
 
+        IF ( lvs .gt. 1 ) THEN
+           an(ix,jy,kz,lvs) = 0.0
+        ENDIF
 
-      mltdiam(ndiam+1) = mltdiam1 !  9.0e-3
-      mltdiam(ndiam+2) = mltdiam2 ! 19.0e-3
-      mltdiam(ndiam+3) = mltdiam3 !100.0e-3
+        IF ( lsw .gt. 1 ) THEN
+           an(ix,jy,kz,lsw) = 0.0
+        ENDIF
 
-      kzb = 1
-      kze = ktile
-!      if (kzend .eq. nzend) kze = kzend-kzbeg+1-kstag
+        IF ( ipconc .ge. 4 ) THEN ! .and. an(ix,jy,kz,lns) .gt. 0.0  ) THEN ! 
+!          an(ix,jy,kz,lnr) = an(ix,jy,kz,lnr) + an(ix,jy,kz,lns)
+          an(ix,jy,kz,lns) = 0.0
+        ENDIF
 
-!
-!  cw constants in mks units
-!
-!      cwmasn = 4.25e-15  ! radius of 1.0e-6
-      mwfac = 6.0**(1./3.)
-      IF ( ipconc .ge. 2 ) THEN
-!        cwmasn = xvmn(lc)*1000.
-!        cwradn = 1.0e-6
-!        cwmasx = xvmx(lc)*1000.
       ENDIF
-        rwmasn = xvmn(lr)*1000.
-        rwmasx = xvmx(lr)*1000.
+      
+        IF ( ipelec > 0 .and. lscs > 1 ) THEN
+          IF ( an(ix,jy,kz,lscs) .gt. 0.0 ) THEN
+            an(ix,jy,kz,lscpi) = an(ix,jy,kz,lscpi) + an(ix,jy,kz,lscs)*eci
+          ELSE
+            an(ix,jy,kz,lscni) = an(ix,jy,kz,lscni) - an(ix,jy,kz,lscs)*eci
+          ENDIF
+          
+          an(ix,jy,kz,lscs) = 0.0
+          
+        ENDIF
 
-!
-!  ci constants in mks units
-!
-      cimasn = Min(cimas0, cimas1) ! 12 microns for  0.1871*(xmas(mgs,li)**(0.3429))
-      cimasx = 1.0e-8   ! 338 microns
-      ccimx = 5000.0e3   ! max of 5000 per liter
+      ELSEIF ( lvol(ls) .gt. 1 ) THEN  ! check density
+        IF ( an(ix,jy,kz,lvs) .gt. 0.0 ) THEN
+          tmp = dn(ix,jy,kz)*an(ix,jy,kz,ls)/an(ix,jy,kz,lvs)
+          IF ( tmp .gt. xdnmx(ls) .or. tmp .lt. xdnmn(ls) ) THEN
+            tmp = Min( xdnmx(ls), Max( xdnmn(ls), tmp ) )
+            an(ix,jy,kz,lvs) = dn(ix,jy,kz)*an(ix,jy,kz,ls)/tmp
+          ENDIF
+        ELSE
+          tmp = rho_qs
+          an(ix,jy,kz,lvs) = dn(ix,jy,kz)*an(ix,jy,kz,ls)/tmp
+        ENDIF
 
-!
-!  constants for paramerization
-!
-!
-!  set save counter (number of saves):  nsvcnt
-!
-!      nsvcnt = 0
-      iend = 0
 
+      end if
 
-!      timetd1 = etime(tarray)
-!      timetd1 = tarray(1)
+
+      if ( an(ix,jy,kz,lr) .lt. frac*qxmin(lr)  .or. zerocx(lr)  &
+     &  ) then
+        an(ix,jy,kz,lv) = an(ix,jy,kz,lv) + an(ix,jy,kz,lr)
+        an(ix,jy,kz,lr) = 0.0
+        IF ( ipconc .ge. 3 ) THEN
+!          an(ix,jy,kz,lnc) = an(ix,jy,kz,lnc) + an(ix,jy,kz,lnr)
+          an(ix,jy,kz,lnr) = 0.0
+        ENDIF
+        
+        IF ( ipelec > 0 .and. lscr .gt. 1 ) THEN
+          IF ( an(ix,jy,kz,lscr) .gt. 0.0 ) THEN
+            an(ix,jy,kz,lscpi) = an(ix,jy,kz,lscpi) + an(ix,jy,kz,lscr)*eci
+          ELSE
+            an(ix,jy,kz,lscni) = an(ix,jy,kz,lscni) - an(ix,jy,kz,lscr)*eci
+          ENDIF
+
+           an(ix,jy,kz,lscr) = 0.0
+
+        ENDIF
+      end if
 
 !
-!***********************************************************
-!  start jy loop
-!***********************************************************
+!  for qci
 !
+      IF ( an(ix,jy,kz,li) .le. frac*qxmin(li) .or. zerocx(li)   & ! .or.  an(ix,jy,kz,lni) .lt. 0.1
+     &    ) THEN
+      an(ix,jy,kz,lv) = an(ix,jy,kz,lv) + an(ix,jy,kz,li)
+      an(ix,jy,kz,li)= 0.0
+       IF ( ipconc .ge. 1 ) THEN
+         an(ix,jy,kz,lni) = 0.0
+       ENDIF
+        IF ( ipelec > 0 .and. lsci .gt. 1 ) THEN
+          IF ( an(ix,jy,kz,lsci) .gt. 0.0 ) THEN
+            an(ix,jy,kz,lscpi) = an(ix,jy,kz,lscpi) + an(ix,jy,kz,lsci)*eci
+          ELSE
+            an(ix,jy,kz,lscni) = an(ix,jy,kz,lscni) - an(ix,jy,kz,lsci)*eci
+          ENDIF
+           an(ix,jy,kz,lsci) = 0.0
+        ENDIF
+      ENDIF
 
-!      do 9999 jy = 1,ny-jstag
 !
-!  VERY IMPORTANT:  SET jy = jgs
+!  for qis
 !
-      jy = jgs
-     
-     
-!      t1(:,:,:) = 0
-!      t2(:,:,:) = 0
-!      t3(:,:,:) = 0
-!      t4(:,:,:) = 0
-!      t5(:,:,:) = 0
-!      t6(:,:,:) = 0
-!      t8(:,:,:) = 0
-      
-      IF ( ipconc < 2 ) THEN ! Make a copy of cloud droplet mixing ratio to use for homogeneous freezing
-        DO kz = 1,kze
-         DO ix = 1,itile
-           t9(ix,jy,kz) = an(ix,jy,kz,lc)
-         ENDDO
-        ENDDO
-      ENDIF
+      IF ( lis > 1 ) THEN ! {
+      IF ( an(ix,jy,kz,lis) .le. frac*qxmin(lis) .or. zerocx(lis)   & ! .or.  an(ix,jy,kz,lni) .lt. 0.1
+     &    ) THEN ! { {
+      an(ix,jy,kz,lv) = an(ix,jy,kz,lv) + an(ix,jy,kz,lis)
+      an(ix,jy,kz,lis)= 0.0
+       IF ( ipconc .ge. 1 ) THEN
+         an(ix,jy,kz,lnis) = 0.0
+       ENDIF
+        IF ( ipelec > 0 .and. lscis .gt. 1 ) THEN
+          IF ( an(ix,jy,kz,lscis) .gt. 0.0 ) THEN
+            an(ix,jy,kz,lscpi) = an(ix,jy,kz,lscpi) + an(ix,jy,kz,lscis)*eci
+          ELSE
+            an(ix,jy,kz,lscni) = an(ix,jy,kz,lscni) - an(ix,jy,kz,lscis)*eci
+          ENDIF
+           an(ix,jy,kz,lscis) = 0.0
+        ENDIF
       
+      ELSEIF ( icespheres >= 2 ) THEN ! } {
+       km1 = Max(1, kz-1)
+       IF ( 0.5*( w(ix,jy,kz) + w(ix,jy,kz+1)) < -1.0 .or.    &
+     &      (icespheres == 3 .and. ( t0(ix,jy,kz) < 232.15 .or. an(ix,jy,kz,lc) < qxmin(lc) ) ) .or. &
+     &      (icespheres == 5 .and. ( t0(ix,jy,kz) < 232.15 .or. ( an(ix,jy,kz,lc) < qxmin(lc) .and. an(ix,jy,km1,lc) < qxmin(lc)  )) ) .or. &
+     &      (icespheres == 4 .and. ( t0(ix,jy,kz) < 235.15 )) ) THEN ! transfer to regular ice crystals in downdraft or at low temp
+         an(ix,jy,kz,li) = an(ix,jy,kz,li) + an(ix,jy,kz,lis)
+         an(ix,jy,kz,lni) = an(ix,jy,kz,lni) + an(ix,jy,kz,lnis)
+         an(ix,jy,kz,lis)= 0.0
+         an(ix,jy,kz,lnis)= 0.0
+        IF ( ipelec > 0 .and. lscis .gt. 1 ) THEN
+         an(ix,jy,kz,lsci) = an(ix,jy,kz,lsci) + an(ix,jy,kz,lscis)
+         an(ix,jy,kz,lscis)= 0.0
+        ENDIF
+         
+       ENDIF
+       
+      ENDIF ! } }
+      ENDIF ! }
+
 !
-!..Gather microphysics  
+!  for qcw
 !
-      if ( ndebug .gt. 0 ) write(0,*) 'ICEZVD_GS: ENTER GATHER STAGE'
-
-
-      
-      nxmpb = 1
-      nzmpb = 1
-      nxz = itile*nz
-      numgs = nxz/ngs + 1
-!      write(0,*) 'ICEZVD_GS: ENTER GATHER STAGE: nx,nz,nxz,numgs,ngs = ',nx,nz,nxz,numgs,ngs
 
-      do 1000 inumgs = 1,numgs
-      ngscnt = 0
-      
-      do kz = nzmpb,kze
-      do ix = nxmpb,itile
+      IF ( an(ix,jy,kz,lc) .le. frac*qxmin(lc) .or. zerocx(lc)   &
+     &       ) THEN
+      an(ix,jy,kz,lv) = an(ix,jy,kz,lv) + an(ix,jy,kz,lc)
+      an(ix,jy,kz,lc)= 0.0
+       IF ( ipconc .ge. 2 ) THEN
+        IF ( lccn .gt. 1 ) THEN
+         an(ix,jy,kz,lccn) =     &
+     &       an(ix,jy,kz,lccn) + Max(0.0,an(ix,jy,kz,lnc))
+        ENDIF
+         an(ix,jy,kz,lnc) = 0.0
+         
+         IF ( lccna > 0  ) THEN ! apply exponential decay to activated CCN to restore to environmental value
+           tmp = an(ix,jy,kz,li) + an(ix,jy,kz,ls)  
+           
+           IF ( an(ix,jy,kz,lccna) > 1. .and. tmp < qxmin(li) ) an(ix,jy,kz,lccna) = an(ix,jy,kz,lccna)*Exp(-dtp/ccntimeconst)
 
-      pqs(1) = t00(ix,jy,kz)
-!      pqs(kz) = t00(ix,jy,kz)
+         ELSEIF ( lccn > 1 .and. restoreccn ) THEN
+           ! in this case, we are treating the ccn field as ccna
+           tmp = an(ix,jy,kz,li) + an(ix,jy,kz,ls)  
+           
+           IF ( an(ix,jy,kz,lccn) > 1. .and. tmp < qxmin(li) ) an(ix,jy,kz,lccn) =  &
+                    dn(ix,jy,kz)*qccn - Max(0.0 , dn(ix,jy,kz)*qccn - an(ix,jy,kz,lccn))*Exp(-dtp/ccntimeconst)
+         
+         ENDIF
 
-      theta(1) = an(ix,jy,kz,lt)
-      temg(1) = t0(ix,jy,kz)
-      temcg(1) = temg(1) - tfr
-      tqvcon = temg(1)-cbw
-      ltemq = (temg(1)-163.15)/fqsat+1.5
-      ltemq = Min( nqsat, Max(1,ltemq) )
-      qvs(1) = pqs(1)*tabqvs(ltemq)
-      qis(1) = pqs(1)*tabqis(ltemq)
+        IF ( ipelec > 0 .and. lscw .gt. 1 ) THEN
+          IF ( an(ix,jy,kz,lscw) .gt. 0.0 ) THEN
+            an(ix,jy,kz,lscpi) = an(ix,jy,kz,lscpi) + an(ix,jy,kz,lscw)*eci
+          ELSE
+            an(ix,jy,kz,lscni) = an(ix,jy,kz,lscni) - an(ix,jy,kz,lscw)*eci
+          ENDIF
 
-      qss(1) = qvs(1)
+           an(ix,jy,kz,lscw) = 0.0
 
-!      IF ( jy .eq. 1 .and. ix .eq. 24 ) THEN
-!       write(91,*) 'kz,qv,th: ',kz,an(ix,jy,kz,lv),an(ix,jy,kz,lt),pqs(kz),tabqvs(ltemq),qvs(kz)
-!      ENDIF
+        ENDIF
+       ENDIF
 
-      if ( temg(1) .lt. tfr ) then
-!      if( qcw(kz) .le. qxmin(lc) .and. qci(kz) .gt. qxmin(li))
-!     >  qss(kz) = qis(kz)
-!      if( qcw(kz) .gt. qxmin(lc) .and. qci(kz) .gt. qxmin(li))
-!     >   qss(kz) = (qcw(kz)*qvs(kz) + qci(kz)*qis(kz)) /
-!     >   (qcw(kz) + qci(kz))
-      qss(1) = qis(1)
-      else
-!       IF ( an(ix,jy,kz,lv)  .gt. qss(kz) ) THEN
-!       write(iunit,*) 'qss exceeded at ',ix,jy,kz,qss(kz),an(ix,jy,kz,lv),temg(kz)
-!       write(iunit,*) 'other temg = ',theta(kz)*(pinit(kz)+p2(ix,jy,kz))
-!       ENDIF
-      end if
-!
-      ishail = .false.
-      IF ( lhl > 1 ) THEN
-        IF ( an(ix,jy,kz,lhl)  .gt. qxmin(lhl) ) ishail = .true.
       ENDIF
+
+      end do
+!      end do
+      end do
       
-      if ( an(ix,jy,kz,lv)  .gt. qss(1) .or.   &
-     &     an(ix,jy,kz,lc)  .gt. qxmin(lc)   .or.    &
-     &     an(ix,jy,kz,li)  .gt. qxmin(li)   .or.   &
-     &     an(ix,jy,kz,lr)  .gt. qxmin(lr)   .or.   &
-     &     an(ix,jy,kz,ls)  .gt. qxmin(ls)   .or.   &
-     &     an(ix,jy,kz,lh)  .gt. qxmin(lh)   .or.  ishail ) then
-      ngscnt = ngscnt + 1
-      igs(ngscnt) = ix
-      kgs(ngscnt) = kz
-      if ( ngscnt .eq. ngs ) goto 1100
-      end if
-      enddo !ix
-      nxmpb = 1
-      enddo !kz
- 1100 continue
+      
+      IF ( ndebug .ge. 1 ) write(6,*) 'END OF ICEZVD_DR'
+!
+!
+   
+   
+   9999 RETURN
+   
+   END SUBROUTINE NUCOND
 
-      if ( ngscnt .eq. 0 ) go to 9998
 
-      if ( ndebug .gt. 0 ) write(0,*) 'ICEZVD_GS: dbg = 5'
+! #####################################################################
+! #####################################################################
 
-!      write(0,*) 'allocating qc
 
-      
-      xv(:,:) = 0.0
-      xmas(:,:) = 0.0
-      vtxbar(:,:,:) = 0.0
-      xdia(:,:,:) = 0.0
-      raindn(:,:) = 900.
-      cx(:,:) = 0.0
-      alpha(:,:) = 0.0
-      DO il = li,lhab
-        DO mgs = 1,ngscnt
-          rimdn(mgs,il)  = rimedens ! xdn0(il)
-        ENDDO
-      ENDDO
+
+!c--------------------------------------------------------------------------
 !
-!  define temporaries for state variables to be used in calculations
 !
-      do mgs = 1,ngscnt
-      kgsm(mgs) = max(kgs(mgs)-1,1)
-      kgsp(mgs) = min(kgs(mgs)+1,nz-1)
-      kgsm2(mgs) = Max(kgs(mgs)-2,1)
-      theta0(mgs) = an(igs(mgs),jy,kgs(mgs),lt)
-      thetap(mgs) = an(igs(mgs),jy,kgs(mgs),lt) - theta0(mgs)
-      theta(mgs) = an(igs(mgs),jy,kgs(mgs),lt)
-      qv0(mgs) = an(igs(mgs),jy,kgs(mgs),lv)
-      qwvp(mgs) = an(igs(mgs),jy,kgs(mgs),lv)  - qv0(mgs) ! qv0(mgs) is full qv, so qwvp starts as zero!
+!--------------------------------------------------------------------------
+!
 
-      pres(mgs) = pn(igs(mgs),jy,kgs(mgs)) + pb(kgs(mgs))
-      pipert(mgs) = p2(igs(mgs),jy,kgs(mgs))
-      rho0(mgs) = dn(igs(mgs),jy,kgs(mgs))
-      rhoinv(mgs) = 1.0/rho0(mgs)
-      rhovt(mgs) = Sqrt(rho00/rho0(mgs))
-      pi0(mgs) = p2(igs(mgs),jy,kgs(mgs)) + pinit(kgs(mgs))
-      temg(mgs) = t0(igs(mgs),jy,kgs(mgs))
-      temgkm1(mgs) = t0(igs(mgs),jy,kgsm(mgs))
-      temgkm2(mgs) = t0(igs(mgs),jy,kgsm2(mgs))
-      pk(mgs)   = p2(igs(mgs),jy,kgs(mgs)) + pinit(kgs(mgs)) ! t77(igs(mgs),jy,kgs(mgs))
-      temcg(mgs) = temg(mgs) - tfr
-      qss0(mgs) = (380.0)/(pres(mgs))
-      pqs(mgs) = (380.0)/(pres(mgs))
-      ltemq = (temg(mgs)-163.15)/fqsat+1.5
-      ltemq = Min( nqsat, Max(1,ltemq) )
-      qvs(mgs) = pqs(mgs)*tabqvs(ltemq)
-      qis(mgs) = pqs(mgs)*tabqis(ltemq)
-!      es(mgs)  = 6.1078e2*tabqvs(ltemq)
-!      eis(mgs) = 6.1078e2*tabqis(ltemq)
-      cnostmp(mgs) = cno(ls)
-!
-
-      il5(mgs) = 0
-      if ( temg(mgs) .lt. tfr ) then
-      il5(mgs) = 1
-      end if
-      enddo !mgs
-      
-      IF ( ipconc < 1 .and. lwsm6 ) THEN
-        DO mgs = 1,ngscnt
-          tmp = Min( 0.0, temcg(mgs) )
-          cnostmp(mgs) = Min( 2.e8, 2.e6*exp(0.12*tmp) )
-        ENDDO
-      ENDIF
+      subroutine nssl_2mom_gs   &
+     &  (nx,ny,nz,na,jyslab  &
+     &  ,nor,norz          &
+     &  ,dtp,gz       &
+     &  ,t0,t1,t2,t3,t4,t5,t6,t7,t8,t9      &
+     &  ,an,dn,p2                  &
+     &  ,pn,w,iunit                   &
+     &  ,t00,t77,                             &
+     &   ventr,ventc,c1sw,jgs,ido,    &
+     &   xdnmx,xdnmn,               &
+!     &   ln,ipc,lvol,lz,lliq,   &
+     &   cdx,                              &
+     &   xdn0,tmp3d,tkediss  &
+     & ,timevtcalc,axtra,io_flag  &
+     & ,rainprod2d, evapprod2d &
+     & ,elec,its,ids,ide,jds,jde &
+     & )
 
 
 !
-! zero arrays that are used but not otherwise set (tm)
+!--------------------------------------------------------------------------
+!                                
+!     Ziegler 1985 parameterized microphysics (also Zrnic et al. 1993)
+!     1)  cloud water
+!     2)  rain
+!     3)  column ice 
+!     6)  snow
+!     11) graupel/hail
+!
+!--------------------------------------------------------------------------
+!
+! Notes:
+!
+!  4/27/2009: allows for liquid water to be advected on snow and graupel particles using flag "mixedphase"
+!
+!  3/14/2007: (APS) added qproc temp to make microphysic process timeseries
+!
+!  10/17/2006: added flag (iehw) to select how to calculate ehw
+!
+!  10/5/2006: switched chacr to integrated version rather than assuming that average rain
+!             drop mass does not change.  This acts to reduce rain size somewhat via graupel
+!             collection.
+!             Use Mason data for ehw, with scaling toward ehw=1 as air density decreases.
+!
+!  10/3/2006: Turned off Meyers nucleation for T > -5 (can turn on with imeyers5 flag)
+!             Turned off contact nucleation in updrafts
+!
+!  7/24/2006:  Turned on Meyers nucleation for -5 < T < 0
+!
+!  5/12/2006:  Converted qsacw/csacw and qsaci/csaci to Z93
+!
+!  5/12/2006:  Put a threshold on Bigg rain freezing.  If the frozen drops
+!              have an average volume less than xvhmn, then the drops are put
+!              into snow instead of graupel/hail.
+!
+!              Fixed bug when vapor deposition was limited.
+!
+!  5/13/2006:  Note that qhacr has a large effect, but Z85 did not include it.
+!              Turned off qsacr (set to zero).
+!
+!  9/14/2007: erm: recalculate vx(lh) after setting xdn(lh) in case xdn was out of allowed range.
+!             added parameter rimc3 for minimum rime density.  Default value set at 170. kg/m**3
+!             instead of previous use of 100.  (Farley, 1987)
+!
+!--------------------------------------------------------------------------
+!
+!  general declarations
+!
+!--------------------------------------------------------------------------
 !
-      do mgs = 1,ngscnt
-         qhshr(mgs) = 0.0 
-       end do
 !
-!  set temporaries for microphysics variables
 !
-      DO il = lv,lhab
-      do mgs = 1,ngscnt
-        qx(mgs,il) = max(an(igs(mgs),jy,kgs(mgs),il), 0.0) 
-      ENDDO
-      end do
 
-      qxw(:,:) = 0.0
 
+      implicit none
+!
+!      integer icond 
+!      parameter ( icond = 2 )
 
+      integer, parameter :: ng1 = 1
 
-        scx(:,:) = 0.0
-!
-!  set shape parameters
-!
-      IF ( imurain == 1 ) THEN
-        alpha(:,lr) = alphar
-      ELSEIF ( imurain == 3 ) THEN
-        alpha(:,lr) = xnu(lr)
-      ENDIF
+      integer nx,ny,nz,na,nba,nv
+      integer nor,norz,istag,jstag,kstag ! ,nht,ngt,igsr
+      integer iwrite
+      real dtp,dx,dy,dz
+
+      logical, intent(in) :: io_flag
+
+      integer itile,jtile,ktile
+      integer ixbeg,jybeg
+      integer ixend,jyend,kzend,kzbeg
+      integer nxend,nyend,nzend,nzbeg
+      integer :: my_rank = 0
+      integer, parameter :: myprock = 1, nprock = 1
+      real rainprod2d(-nor+1:nx+nor,-norz+ng1:nz+norz)
+      real evapprod2d(-nor+1:nx+nor,-norz+ng1:nz+norz)
+
+
+      real tkediss(-nor+1:nx+nor,-norz+ng1:nz+norz)
+      real axtra(-nor+ng1:nx+nor,-nor+ng1:ny+nor,-norz+ng1:nz+norz,nxtra)
+
+      real :: galpharaut
+      real :: xvbarmax
       
-      alpha(:,li) = xnu(li)
+      integer jyslab,its,ids,ide,jds,jde ! domain boundaries
+      integer, intent(in) :: iunit !,iunit0
+      real qvex
+      integer iraincv, icgxconv
+      parameter ( iraincv = 1, icgxconv = 1)
+      real ffrz
 
-      IF ( imusnow == 1 ) THEN
-        alpha(:,ls) = alphas
-      ELSEIF ( imusnow == 3 ) THEN
-        alpha(:,ls) = xnu(ls)
-      ENDIF
+      real qcitmp,cirdiatmp ! ,qiptmp,qirtmp
+      real ccwtmp,ccitmp ! ,ciptmp,cirtmp
+      real cpqc,cpci ! ,cpip,cpir
+      real cpqc0,cpci0 ! ,cpip0,cpir0
+      real scfac ! ,cpip1
       
-      DO il = lc,lhab
-      do mgs = 1,ngscnt
-        IF ( il .ge. lg ) alpha(mgs,il) = dnu(il)
-        DO ic = lr,lhab
-        dab0lh(mgs,il,ic) = dab0(ic,il)
-        dab1lh(mgs,il,ic) = dab1(ic,il)
-        ENDDO
-      ENDDO
-      end do
+      double precision dp1
       
+      double precision frac, frach, xvfrz
       
-!      DO mgs = 1,ngscnt
-        da0lh(:) = da0(lh)
-        da0lr(:) = da0(lr)
-        IF ( lzh < 1 .or. lzhl < 1 ) THEN
-          rzxhlh(:) = rzhl/rz
-        ELSEIF ( lzh > 1 .and. lzhl > 1 ) THEN
-          rzxhlh(:) = 1.
-        ENDIF
-        IF ( lzr > 1 ) THEN
-          rzxh(:) = 1.
-          rzxhl(:) = 1.
-        ELSE
-          rzxh(:) = rz
-          rzxhl(:) = rzhl
-        ENDIF
-        
-        IF ( imurain == 1 .and. imusnow == 3 ) THEN
-          rzxs(:) = rzs
-        ELSEIF ( imurain == imusnow ) THEN
-          rzxs(:) = 1.
-        ENDIF
- !     ENDDO
+      double precision :: timevtcalc
+      double precision :: dpt1,dpt2
+            
       
-      IF ( lhl .gt. 1 ) THEN
-      DO mgs = 1,ngscnt
-        da0lhl(mgs) = da0(lhl)
-      ENDDO
-      ENDIF
+      logical, parameter :: usegamxinf = .false.
+      logical, parameter :: usegamxinf2 = .false.
+      logical, parameter :: usegamxinf3 = .false.
+!      real rar  ! rime accretion rate as calculated from qxacw
+
+
+! a few vars for time-split fallout      
+      real vtmax
+      integer n,ndfall
       
-      ventrx(:) = ventr
-      ventrxn(:) = ventrn
-      gf1palp(:) = gamma_sp(1.0 + alphar)
+      double precision chgneg,chgpos,sctot
+      
+      real temgtmp
+
+      real pb(-norz+ng1:nz+norz)
+      real pinit(-norz+ng1:nz+norz)
+
+      real gz(-nor+ng1:nx+nor,-nor+ng1:ny+nor,-norz+ng1:nz+norz) ! dz
+      
+      real qimax,xni0,roqi0
+
+
+      real dv
+
+      real dtptmp
+      integer itest,nidx,id1,jd1,kd1
+      parameter (itest=1)
+      parameter (nidx=10)
+      parameter (id1=1,jd1=1,kd1=1)
+      integer ierr
+      integer iend
 
+      integer ix,kz, il, ic, ir, icp1, irp1, ip1,jp1,kp1
+      integer :: jy
+      integer i,j,k,i1
+      integer kzb,kze
+      real slope1, slope2
+      real x1, x2, x3
+      real eps,eps2
+      parameter (eps=1.e-20,eps2=1.e-5)
 !
-!  set concentrations
+!  Other elec. vars
 !
-!      ssmax = 0.0
-      
-      
+      real  temele
+      real  trev
       
-      if ( ipconc .ge. 1 ) then
-       do mgs = 1,ngscnt
-        cx(mgs,li) = Max(an(igs(mgs),jy,kgs(mgs),lni), 0.0)
-        IF ( lcina .gt. 1 ) THEN
-         cina(mgs) = an(igs(mgs),jy,kgs(mgs),lcina)
-        ELSE
-         cina(mgs) = cx(mgs,li)
-        ENDIF
-        IF ( lcin > 1 ) THEN
-         ccin(mgs) = an(igs(mgs),jy,kgs(mgs),lcin)
-        ENDIF
-       end do
-      end if
-      if ( ipconc .ge. 2 ) then
-       do mgs = 1,ngscnt
-        cx(mgs,lc) = Max(an(igs(mgs),jy,kgs(mgs),lnc), 0.0)
-!        cx(mgs,lc) = Min( ccwmx, cx(mgs,lc) )
-        IF ( lss > 1 ) THEN
-        ssmax(mgs) = an(igs(mgs),jy,kgs(mgs),lss)
-        ENDIF
-        IF ( lccn .gt. 1 ) THEN
-         ccnc(mgs) = an(igs(mgs),jy,kgs(mgs),lccn)
-        ELSE
-         ccnc(mgs) = 0.0
-        ENDIF
-        IF ( lccna .gt. 1 ) THEN
-         ccna(mgs) = an(igs(mgs),jy,kgs(mgs),lccna)
-        ELSE
-         ccna(mgs) = cx(mgs,lc)
-        ENDIF
-       end do
-!       ELSE
-!       cx(mgs,lc) = Abs(ccn)
-      end if
-      if ( ipconc .ge. 3 ) then
-       do mgs = 1,ngscnt
-        cx(mgs,lr) = Max(an(igs(mgs),jy,kgs(mgs),lnr), 0.0)
-        IF ( qx(mgs,lr) .le. qxmin(lr) ) THEN
-!          cx(mgs,lr) = 0.0
-        ELSEIF ( cx(mgs,lr) .eq. 0.0 .and. qx(mgs,lr) .lt. 3.0*qxmin(lr) ) THEN
-          qx(mgs,lv) = qx(mgs,lv) + qx(mgs,lr)
-          qx(mgs,lr) = 0.0
-        ELSE
-          cx(mgs,lr) = Max( 1.e-9, cx(mgs,lr) )
-        ENDIF
-       end do
-      end if
-      if ( ipconc .ge. 4 ) then
-       do mgs = 1,ngscnt
-        cx(mgs,ls) = Max(an(igs(mgs),jy,kgs(mgs),lns), 0.0)
-        IF ( qx(mgs,ls) .le. qxmin(ls) ) THEN
-!          cx(mgs,ls) = 0.0
-        ELSEIF ( cx(mgs,ls) .eq. 0.0 .and. qx(mgs,ls) .lt. 3.0*qxmin(ls) ) THEN
-          qx(mgs,lv) = qx(mgs,lv) + qx(mgs,ls)
-          qx(mgs,ls) = 0.0
-        ELSE
-          cx(mgs,ls) = Max( 1.e-9, cx(mgs,ls) )
-
-         IF ( ilimit .ge. ipc(ls) ) THEN
-            tmp = (xdn0(ls)*cx(mgs,ls))/(rho0(mgs)*qx(mgs,ls))
-            tmp2 = (tmp*(3.14159))**(1./3.)
-            cnox = cx(mgs,ls)*(tmp2)
-         IF ( cnox .gt. 3.0*cno(ls) ) THEN
-           cx(mgs,ls) = 3.0*cno(ls)/tmp2
-         ENDIF
-         ENDIF
-        ENDIF
-       end do
-      end if
-      if ( ipconc .ge. 5 ) then
-       do mgs = 1,ngscnt
-
-        cx(mgs,lh) = Max(an(igs(mgs),jy,kgs(mgs),lnh), 0.0)
-        IF ( qx(mgs,lh) .le. qxmin(lh) ) THEN
-!          cx(mgs,lh) = 0.0
-        ELSEIF ( cx(mgs,lh) .eq. 0.0 .and. qx(mgs,lh) .lt. 3.0*qxmin(lh) ) THEN
-          qx(mgs,lv) = qx(mgs,lv) + qx(mgs,lh) 
-          qx(mgs,lh) = 0.0
-        ELSE
-          cx(mgs,lh) = Max( 1.e-9, cx(mgs,lh) )
-         IF ( ilimit .ge. ipc(lh) ) THEN
-            tmp = (xdn0(lh)*cx(mgs,lh))/(rho0(mgs)*qx(mgs,lh))
-            tmp2 = (tmp*(3.14159))**(1./3.)
-            cnox = cx(mgs,lh)*(tmp2)
-         IF ( cnox .gt. 3.0*cno(lh) ) THEN
-           cx(mgs,lh) = 3.0*cno(lh)/tmp2
-         ENDIF
-         ENDIF
-        ENDIF
-       end do
-      end if
-
-      if ( lhl .gt. 1 .and. ipconc .ge. 5 ) then
-       do mgs = 1,ngscnt
-
-        cx(mgs,lhl) = Max(an(igs(mgs),jy,kgs(mgs),lnhl), 0.0)
-        IF ( qx(mgs,lhl) .le. qxmin(lhl) ) THEN
-          cx(mgs,lhl) = 0.0
-        ELSEIF ( cx(mgs,lhl) .eq. 0.0 .and. qx(mgs,lhl) .lt. 3.0*qxmin(lhl) ) THEN
-          qx(mgs,lv) = qx(mgs,lv) + qx(mgs,lhl) 
-          qx(mgs,lhl) = 0.0
-        ELSE
-          cx(mgs,lhl) = Max( 1.e-9, cx(mgs,lhl) )
-         IF ( ilimit .ge. ipc(lhl) ) THEN
-            tmp = (xdn0(lhl)*cx(mgs,lhl))/(rho0(mgs)*qx(mgs,lhl))
-            tmp2 = (tmp*(3.14159))**(1./3.)
-            cnox = cx(mgs,lhl)*(tmp2)
-         IF ( cnox .gt. 3.0*cno(lhl) ) THEN
-           cx(mgs,lhl) = 3.0*cno(lhl)/tmp2
-         ENDIF
-         ENDIF
-        ENDIF
-       end do
-      end if
-
+      logical ldovol, ishail, ltest
 !
-! Set mean particle volume
 !
-      IF ( ldovol ) THEN
-      
-      vx(:,:) = 0.0
-      
-       DO il = li,lhab
-        
-        IF ( lvol(il) .ge. 1 ) THEN
-        
-          DO mgs = 1,ngscnt
-            vx(mgs,il) = Max(an(igs(mgs),jy,kgs(mgs),lvol(il)), 0.0)
-          ENDDO
-
-        ENDIF
+!  wind indicies
+!
+      integer mu,mv,mw
+      parameter (mu=1,mv=2,mw=3)
+!
+!  conversion parameters
+!
+      integer mqcw,mqxw,mtem,mrho,mtim
+      parameter (mqcw=21,mqxw=21,mtem=21,mrho=5,mtim=6)
 
-       ENDDO
+      real xftim,xftimi,yftim, xftem,yftem, xfqcw,yfqcw, xfqxw,yfqxw
+      parameter (xftim=0.05,xftimi = 1./xftim,yftim=1.)
+      parameter (xftem=0.5,yftem=1.)
+      parameter (xfqcw=2000.,yfqcw=1.)
+      parameter (xfqxw=2000.,yfqxw=1.)
+      real dtfac
+      parameter ( dtfac = 1.0 )
+      integer ido(lc:lqmx)
 
-      ENDIF
+!      integer iexy(lc:lqmx,lc:lqmx)
+!      integer ieswi, ieswir, ieswip, ieswc, ieswr
+!      integer ieglsw, iegli, ieglir, ieglip, ieglc, ieglr
+!      integer iegmsw, iegmi, iegmir, iegmip, iegmc, iegmr
+!      integer ieghsw, ieghi, ieghir, ieghip, ieghc, ieghr
+!      integer iefwsw, iefwi, iefwir, iefwip, iefwc, iefwr
+!      integer iehwsw, iehwi, iehwir, iehwip, iehwc, iehwr
+!      integer iehlsw, iehli, iehlir, iehlip, iehlc, iehlr
+!      real delqnsa, delqxsa, delqnsb, delqxsb, delqnia, delqxia
+!      real delqnra, delqxra
 
+       real delqnxa(lc:lqmx)
+       real delqxxa(lc:lqmx)
+!
+! external temporary arrays
+!
+      real t00(-nor+ng1:nx+nor,-nor+ng1:ny+nor,-norz+ng1:nz+norz)
+      real t77(-nor+ng1:nx+nor,-nor+ng1:ny+nor,-norz+ng1:nz+norz)
 
+      real t0(-nor+ng1:nx+nor,-nor+ng1:ny+nor,-norz+ng1:nz+norz)
+      real t1(-nor+ng1:nx+nor,-nor+ng1:ny+nor,-norz+ng1:nz+norz)
+      real t2(-nor+ng1:nx+nor,-nor+ng1:ny+nor,-norz+ng1:nz+norz)
+      real t3(-nor+ng1:nx+nor,-nor+ng1:ny+nor,-norz+ng1:nz+norz)
+      real t4(-nor+ng1:nx+nor,-nor+ng1:ny+nor,-norz+ng1:nz+norz)
+      real t5(-nor+ng1:nx+nor,-nor+ng1:ny+nor,-norz+ng1:nz+norz)
+      real t6(-nor+ng1:nx+nor,-nor+ng1:ny+nor,-norz+ng1:nz+norz)
+      real t7(-nor+ng1:nx+nor,-nor+ng1:ny+nor,-norz+ng1:nz+norz)
+      real t8(-nor+ng1:nx+nor,-nor+ng1:ny+nor,-norz+ng1:nz+norz)
+      real t9(-nor+ng1:nx+nor,-nor+ng1:ny+nor,-norz+ng1:nz+norz)
 
+      real p2(-nor+1:nx+nor,-nor+1:ny+nor,-norz+ng1:nz+norz)  ! perturbation Pi
+      real pn(-nor+1:nx+nor,-nor+1:ny+nor,-norz+ng1:nz+norz)
+      real an(-nor+ng1:nx+nor,-nor+ng1:ny+nor,-norz+ng1:nz+norz,na)
+      real dn(-nor+1:nx+nor,-nor+1:ny+nor,-norz+ng1:nz+norz)
+      real w(-nor+1:nx+nor,-nor+1:ny+nor,-norz+ng1:nz+norz)
 
+      real tmp3d(-nor+ng1:nx+nor,-nor+ng1:ny+nor,-norz+ng1:nz+norz)
 
+! 
+!  declarations microphyscs and for gather/scatter
 !
-!  set factors
-!
-      do mgs = 1,ngscnt
-!
-      ssi(mgs) = qx(mgs,lv)/qis(mgs)
-      ssw(mgs) = qx(mgs,lv)/qvs(mgs)
+      integer nxmpb,nzmpb,nxz
+      integer jgs,mgs,ngs,numgs
+      parameter (ngs=500) !500)
+      integer, parameter :: ngsz = 500
+      integer ntt
+      parameter (ntt=300)
+
+      real dvmgs(ngs)
+      
+      integer ngscnt,igs(ngs),kgs(ngs)
+      integer kgsp(ngs),kgsm(ngs),kgsm2(ngs)
+      integer ncuse
+      parameter (ncuse=0)
+      integer il0(ngs),il5(ngs),il2(ngs),il3(ngs)
+!      integer il1m(ngs),il2m(ngs),il3m(ngs),il4m(ngs),il5m(ngs)
 !
-      tsqr(mgs) = temg(mgs)**2
+      real tdtol,temsav,tfrcbw,tfrcbi
+      real, parameter :: thnuc = 235.15
 !
-      temgx(mgs) = min(temg(mgs),313.15)
-      temgx(mgs) = max(temgx(mgs),233.15)
-      felv(mgs) = 2500837.367 * (273.15/temgx(mgs))**((0.167)+(3.67e-4)*temgx(mgs))
+!  Ice Multiplication Arrays.
 !
-      temcgx(mgs) = min(temg(mgs),273.15)
-      temcgx(mgs) = max(temcgx(mgs),223.15)
-      temcgx(mgs) = temcgx(mgs)-273.15
-
-! felf = latent heat of fusion, fels = LH of sublimation, felv = LH of vaporization
-      felf(mgs) = 333690.6098 + (2030.61425)*temcgx(mgs) - (10.46708312)*temcgx(mgs)**2
+      real  fimt1(ngs),fimta(ngs),fimt2(ngs) !,qmul1(ngs),qmul2(ngs)
+      real xcwmas
 !
-      fels(mgs) = felv(mgs) + felf(mgs)
 !
-      felvs(mgs) = felv(mgs)*felv(mgs)
-      felss(mgs) = fels(mgs)*fels(mgs)
-      
-        IF ( eqtset <= 1 ) THEN
-          felvcp(mgs) = felv(mgs)*cpi
-          felscp(mgs) = fels(mgs)*cpi
-          felfcp(mgs) = felf(mgs)*cpi
-        ELSE
-          
-          ! equations from appendix in Bryan and Morrison (2012, MWR)
-          ! note that rw is Rv in the paper, and rd is R.
-          
-          tmp = qx(mgs,li)+qx(mgs,ls)+qx(mgs,lh)
-          IF ( lhl > 1 ) tmp = tmp + qx(mgs,lhl)
-          cvm = cv+cvv*qx(mgs,lv)+cpl*(qx(mgs,lc)+qx(mgs,lr))   &
-                                  +cpigb*(tmp)
-
-          IF ( eqtset == 2 ) THEN ! compact form from treating dT/dt = theta*d(pi)/dt + pi*d(theta)dt and then applied to theta assuming constant pi
-          felvcp(mgs) = (felv(mgs)-rw*temg(mgs))/cvm
-          felscp(mgs) = (fels(mgs)-rw*temg(mgs))/cvm
-          felfcp(mgs) = felf(mgs)/cvm
-          
-          ELSE
-           ! equivalent version that applies separate updates of latent heating to theta and pi, when both are returned.
-
-          cpm = cp+cpv*qx(mgs,lv)+cpl*(qx(mgs,lc)+qx(mgs,lr))   &
-                                  +cpigb*(tmp)
-          rmm=rd+rw*qx(mgs,lv)
-          
-          felvcp(mgs) = (felv(mgs)*cv/(cp) - rw*temg(mgs)*(1.0-rovcp*cpm/rmm))/cvm
-          felscp(mgs) = (fels(mgs)*cv/(cp) - rw*temg(mgs)*(1.0-rovcp*cpm/rmm))/cvm
-          felfcp(mgs) = felf(mgs)*cv/(cp*cvm)
+! Variables for Ziegler warm rain microphysics
+!      
 
-          felvpi(mgs) = pi0(mgs)*rovcp*(felv(mgs)/(temg(mgs)) - rw*cpm/rmm)/cvm
-          felspi(mgs) = pi0(mgs)*rovcp*(fels(mgs)/(temg(mgs)) - rw*cpm/rmm)/cvm 
-          felfpi(mgs) = pi0(mgs)*rovcp*(felf(mgs)/(cvm*temg(mgs)))
-          
-          ENDIF
 
-        ENDIF
-!
-      fgamw(mgs) = felvcp(mgs)/pi0(mgs)
-      fgams(mgs) = felscp(mgs)/pi0(mgs)
-!
-      fcqv1(mgs) = 4098.0258*pi0(mgs)*fgamw(mgs)
-      fcqv2(mgs) = 5807.6953*pi0(mgs)*fgams(mgs)
-      fcc3(mgs) = felfcp(mgs)/pi0(mgs)
-!
-!  fwvdf = water vapor diffusivity
-      fwvdf(mgs) = (2.11e-05)*((temg(mgs)/tfr)**1.94)*(101325.0/(pres(mgs)))
-!
-! fadvisc = kinematic viscosity
-      fadvisc(mgs) = advisc0*(416.16/(temg(mgs)+120.0))*(temg(mgs)/296.0)**(1.5) ! dynamic visc.
-!
-      fakvisc(mgs) = fadvisc(mgs)*rhoinv(mgs) ! divide by rho_air to get kinematic visc. (note the 'k' vs. 'd')
-!
-      temcgx(mgs) = min(temg(mgs),273.15)
-      temcgx(mgs) = max(temcgx(mgs),233.15)
-      temcgx(mgs) = temcgx(mgs)-273.15
-      fci(mgs) = (2.118636 + 0.007371*(temcgx(mgs)))*(1.0e+03)
-!
-      if ( temg(mgs) .lt. 273.15 ) then
-      temcgx(mgs) = min(temg(mgs),273.15)
-      temcgx(mgs) = max(temcgx(mgs),233.15)
-      temcgx(mgs) = temcgx(mgs)-273.15
-      fcw(mgs) = 4203.1548  + (1.30572e-2)*((temcgx(mgs)-35.)**2)   &
-     &                 + (1.60056e-5)*((temcgx(mgs)-35.)**4)
-      end if
-      if ( temg(mgs) .ge. 273.15 ) then
-      temcgx(mgs) = min(temg(mgs),308.15)
-      temcgx(mgs) = max(temcgx(mgs),273.15)
-      temcgx(mgs) = temcgx(mgs)-273.15
-      fcw(mgs) = 4243.1688  + (3.47104e-1)*(temcgx(mgs)**2)
-      end if
-!
-      ftka(mgs) = tka0*fadvisc(mgs)/advisc1  ! thermal conductivity: proportional to dynamic viscosity
-      fthdf(mgs) = ftka(mgs)*cpi*rhoinv(mgs)
-!
-      fschm(mgs) = (fakvisc(mgs)/fwvdf(mgs))  ! Schmidt number
-      fpndl(mgs) = (fakvisc(mgs)/fthdf(mgs))  ! Prandl number (not used)
-!
-      fai(mgs) = (fels(mgs)**2)/(ftka(mgs)*rw*temg(mgs)**2)
-      fbi(mgs) = (1.0/(rho0(mgs)*fwvdf(mgs)*qis(mgs)))
-      fav(mgs) = (felv(mgs)**2)/(ftka(mgs)*rw*temg(mgs)**2)
-      fbv(mgs) = (1.0/(rho0(mgs)*fwvdf(mgs)*qvs(mgs)))
+      real ccnc(ngs),ccin(ngs),cina(ngs),ccna(ngs)
+      real cwnccn(ngs)
+      real sscb  ! 'cloud base' SS threshold
+      parameter ( sscb = 2.0 )
+      integer idecss  ! flag to turn on (=1) decay of ssmax when no cloud or ice crystals
+      parameter ( idecss = 1 )
+      integer iba ! flag to do condensation/nucleation in 1st or 2nd loop
+                  ! =0 to use ad to calculate SS
+                  ! =1 to use an at end of main jy loop to calculate SS
+      parameter (iba = 1)
+      integer ifilt   ! =1 to filter ssat, =0 to set ssfilt=ssat
+      parameter ( ifilt = 0 ) 
+      real temp1,temp2 ! ,ssold
+      real :: mwat, mice, dice, mwshed, fwmax, fw, mwcrit, massfactor, tmpdiam
+      real, parameter :: shedalp = 3.  ! set 3 for maximum mass diameter (same as area-weighted diameter), 4 for mass-weighted diameter
+      real ssmax(ngs)       ! maximum SS experienced by a parcel
+      real ssmx
+      real dnnet,dqnet
+!      real cnu,rnu,snu,cinu
+!      parameter ( cnu = 0.0, rnu = -0.8, snu = -0.8, cinu = 0.0 )
+      real bfnu, bfnu0, bfnu1
+      parameter ( bfnu0 = (rnu + 2.0)/(rnu + 1.0)  )
+      real ventr, ventc
+      real volb, aa1, aa2
+      double precision t2s, xdp
+      double precision xl2p(ngs),rb(ngs)
+      parameter ( aa1 = 9.44e15, aa2 = 5.78e3 ) ! a1 in Ziegler
+! snow parameters:
+      real cexs, cecs
+      parameter ( cexs = 0.1, cecs = 0.5 )
+      real rvt      ! ratio of collection kernels (Zrnic et al, 1993)
+      parameter ( rvt = 0.104 )
+      real kfrag    ! rate coefficent for collisional splintering (Schuur & Rutledge 00b)
+      parameter ( kfrag = 1.0e-6 )
+      real mfrag    ! assumed ice fragment mass for collisional splintering (Schuur & Rutledge 00b)
+      parameter ( mfrag = 1.0e-10)
+      double precision cautn(ngs), rh(ngs), nh(ngs)
+      real ex1, ft, rhoinv(ngs)
+      double precision ec0(ngs)
+      
+      real ac1,bc, taus, c1,d1,e1,f1,p380,tmp,tmp1,tmp2,tmp3,tmp4,tmp5 ! , sstdy, super
+      double precision :: tmpz, tmpzmlt
+      real ratio, delx, dely
+      real dbigg,volt
+      real chgtmp,fac,mixedphasefac
+      real x,y,y2,del,r,rtmp,alpr
+      double precision :: vent1,vent2
+      real g1palp,g4palp
+      real fqt !charge separation as fn of temperature from Dong and Hallett 1992
+      real bs
+      real v1, v2
+      real d1r, d1i, d1s, e1i
+      real c1sw   ! integration factor for snow melting with snu = -0.8
+      real, parameter :: vr1mm = 5.23599e-10 ! volume of 1mm diameter sphere (m**3)
+      real, parameter :: vr3mm = 5.23599e-10*(3.0/1.)**3   ! volume of a 3 mm diameter sphere (m**3) (Rasmussen et al. 1984b, JAS)
+      real, parameter :: vr4p5mm = 5.23599e-10*(4.5/1.)**3 ! volume of 4.5mm diameter sphere (m**3) (Rasmussen et al. 1984b, JAS)
+      real vmlt,vshd, vshdgs(ngs,lh:lhab), maxmassfac(lc:lhab)
+      real rhosm
+      parameter ( rhosm = 500. )
+      integer nc ! condensation step
+      real dtcon,dtcon1,dtcon2 ! condensation time step (dtcon*nc = dtp)
+      real delta
+      integer ltemq1,ltemq1m ! ,ltemq1m2
+      real dqv,qv1,ss1,ss2,qvs1,dqvs,dtemp,dt1   ! temporaries for condensation
+      real ssi1, ssi2, dqvi, dqvis, dqvii,qis1
+      real dqvr, dqc, dqr, dqi, dqs
+      real qv1m,qvs1m,ss1m,ssi1m,qis1m
+      real cwmastmp
+      real  dcloud,dcloud2 ! ,as, bs
+      real cn(ngs)
+      double precision xvc, xvr
+      real mwfac
+!      real  es(ngs) ! ss(ngs),
+!      real  eis(ngs)
+
+      real rwmasn,rwmasx
+
+      real vgra,vfrz
+      parameter ( vgra = 0.523599*(1.0e-3)**3 )
+     
+      real epsi,d
+      parameter (epsi = 0.622, d = 0.266)
+      real r1,qevap ! ,slv
+      
+      real vr,nrx,chw,g1,qr,z,z1,rdi,alp,xnutmp,xnuc,g1r,rd1,rdia,rmas
+      real :: snowmeltmass = 0
+      
+      real, parameter :: rhofrz = 900.   ! density of graupel from newly-frozen rain
+      real, parameter :: rimedens = 500. ! default rime density
+
+!      real svc(ngs)  !  droplet volume
 !
-      end do
+!  contact freezing nucleation
 !
+      real raero,kaero !assumd aerosol radius, thermal conductivity
+      parameter ( raero = 3.e-7, kaero = 5.39e-3 )
+      real kb   ! Boltzman constant  J K-1
+      parameter (kb = 1.3807e-23)
+      
+      real knud(ngs),knuda(ngs) !knudsen number and correction factor
+      real gtp(ngs)  !G(T,p) = 1/(a' + b')  Cotton 72b
+      real dfar(ngs) !aerosol diffusivity
+      real fn1(ngs),fn2(ngs),fnft(ngs)
+      
+      real ccia(ngs)
+      real ctfzbd(ngs),ctfzth(ngs),ctfzdi(ngs)
 !
-!   ice habit fractions
+!  misc
 !
+      real ni,nis,nr,d0
+      real dqvcnd(ngs),dqwv(ngs),dqcw(ngs),dqci(ngs)
+      real tempc(ngs)
+      real temg(ngs),temcg(ngs),theta(ngs),qvap(ngs) 
+      real temgkm1(ngs), temgkm2(ngs)
+      real temgx(ngs),temcgx(ngs)
+      real qvs(ngs),qis(ngs),qss(ngs),pqs(ngs)
+      real elv(ngs),elf(ngs),els(ngs)
+      real tsqr(ngs),ssi(ngs),ssw(ngs)
+      real qcwtmp(ngs),qtmp,qtot(ngs) 
+      real qcond(ngs)
+      real ctmp, sctmp
+      real cimasn,cimasx,ccimx
+      real pid4
+      real cs,ds,gf7,gf6,gf5,gf4,gf3,gf2,gf1
+      real gcnup1,gcnup2
+      real gf73rds, gf83rds
+      real gamice73fac, gamsnow73fac
+      real gf43rds, gf53rds
+      real aradcw,bradcw,cradcw,dradcw,cwrad,rwrad,rwradmn
+      parameter ( rwradmn = 50.e-6 )
+      real dh0
+      
+      real clionpmx,clionnmx
+      parameter (clionpmx=1.e9,clionnmx=1.e9) ! Takahashi 84
 !
+!  other arrays
+
+      real fwet1(ngs),fwet2(ngs)   
+      real fmlt1(ngs),fmlt2(ngs)  
+      real fvds(ngs),fvce(ngs),fiinit(ngs) 
+      real fvent(ngs),fraci(ngs),fracl(ngs)
 !
-!  Set density
+      real fai(ngs),fav(ngs),fbi(ngs),fbv(ngs)
+      real felv(ngs),fels(ngs),felf(ngs)
+      real felvcp(ngs),felscp(ngs),felfcp(ngs)
+      real felvpi(ngs),felspi(ngs),felfpi(ngs)
+      real felvs(ngs),felss(ngs)      !   ,felfs(ngs)
+      real fwvdf(ngs),ftka(ngs),fthdf(ngs)
+      real fadvisc(ngs),fakvisc(ngs)
+      real fci(ngs),fcw(ngs)
+      real fschm(ngs),fpndl(ngs)
+      real fgamw(ngs),fgams(ngs)
+      real fcqv1(ngs),fcqv2(ngs),fcc3(ngs) 
+      
+      real cvm,cpm,rmm
+
+      real, parameter :: rovcp = rd/cp
+      real, parameter ::      cpv = 1885.0       ! specific heat of water vapor at constant pressure
 !
-      if (ndebug .gt. 0 ) write(0,*) 'ICEZVD_GS: Set density'
+      real fcci(ngs), fcip(ngs)
 !
+      real :: sfm1(ngs),sfm2(ngs)
+      real :: gfm1(ngs),gfm2(ngs)
+      real :: hfm1(ngs),hfm2(ngs)
 
-      do mgs = 1,ngscnt
-        xdn(mgs,li) = xdn0(li)
-        xdn(mgs,lc) = xdn0(lc)
-        xdn(mgs,lr) = xdn0(lr)
-        xdn(mgs,ls) = xdn0(ls)
-        xdn(mgs,lh) = xdn0(lh)
-        IF ( lvol(ls) .gt. 1 ) THEN
-         IF ( vx(mgs,ls) .gt. 0.0 .and. qx(mgs,ls) .gt. qxmin(ls) ) THEN
-           xdn(mgs,ls) = Min( xdnmx(ls), Max( xdnmn(ls), rho0(mgs)*qx(mgs,ls)/vx(mgs,ls) ) )
-         ENDIF
-        ENDIF
-
-        IF ( lvol(lh) .gt. 1 ) THEN
-         IF ( vx(mgs,lh) .gt. 0.0 .and. qx(mgs,lh) .gt. qxmin(lh) ) THEN
-           IF ( mixedphase ) THEN
-           ELSE
-             dnmx = xdnmx(lh)
-           ENDIF
-           xdn(mgs,lh) = Min( dnmx, Max( xdnmn(lh), rho0(mgs)*qx(mgs,lh)/vx(mgs,lh) ) )
-           vx(mgs,lh) = rho0(mgs)*qx(mgs,lh)/xdn(mgs,lh)
-         
-         ELSEIF ( vx(mgs,lh) == 0.0 .and. qx(mgs,lh) .gt. qxmin(lh) ) THEN ! if volume is zero, need to initialize the default value
-
-           vx(mgs,lh) = rho0(mgs)*qx(mgs,lh)/xdn(mgs,lh)
-         
-         ENDIF
-        ENDIF
-
-        IF ( lhl .gt. 1 ) THEN
-
-          xdn(mgs,lhl) = xdn0(lhl)
-
-          IF ( lvol(lhl) .gt. 1 ) THEN
-           IF ( vx(mgs,lhl) .gt. 0.0 .and. qx(mgs,lhl) .gt. qxmin(lhl) ) THEN
-
-           IF ( mixedphase .and. lhlw > 1 ) THEN
-           ELSE
-             dnmx = xdnmx(lhl)
-           ENDIF
-
-             xdn(mgs,lhl) = Min( dnmx, Max( xdnmn(lhl), rho0(mgs)*qx(mgs,lhl)/vx(mgs,lhl) ) )
-             vx(mgs,lhl) = rho0(mgs)*qx(mgs,lhl)/xdn(mgs,lhl)
-         
-           ELSEIF ( vx(mgs,lhl) == 0.0 .and. qx(mgs,lhl) .gt. qxmin(lhl) ) THEN ! if volume is zero, need to initialize the default value
+      logical :: wetsfc(ngs),wetsfchl(ngs)
+      logical :: wetgrowth(ngs), wetgrowthhl(ngs)
 
-             vx(mgs,lhl) = rho0(mgs)*qx(mgs,lhl)/xdn(mgs,lhl)
-         
-           ENDIF
-          ENDIF
+       real qitmp(ngs),qistmp(ngs)
+       
+      real rzxh(ngs), rzxhl(ngs), rzxhlh(ngs)
+      real rzxs(ngs)
+      real axh(ngs),bxh(ngs),axhl(ngs),bxhl(ngs)
+      real vt2ave(ngs)
 
-        ENDIF
-
-! adjust density for wet snow and graupel (Ferrier 94)
-! (aps): for the time being, do not adjust density until we keep track of fully melted snow/graupel
+      real :: qcwresv(ngs), ccwresv(ngs) ! "reserved" droplet mass and number that are too small for accretion
+      
+      real ::  qx(ngs,lv:lhab)
+      real ::  qxw(ngs,ls:lhab)
+      real ::  cx(ngs,lc:lhab)
+      real ::  cxmxd(ngs,lc:lhab)
+      real ::  qxmxd(ngs,lv:lhab)
+      real ::  scx(ngs,lc:lhab)
+      real ::  xv(ngs,lc:lhab)
+      real ::  vtxbar(ngs,lc:lhab,3)
+      real ::  xmas(ngs,lc:lhab)
+      real ::  xdn(ngs,lc:lhab)
+      real ::  xdia(ngs,lc:lhab,3)
+      real ::  rarx(ngs,ls:lhab)
+      real ::  vx(ngs,li:lhab)
+      real ::  rimdn(ngs,li:lhab)
+      real ::  raindn(ngs,li:lhab)
+      real ::  alpha(ngs,lc:lhab)
+      real ::  dab0lh(ngs,lc:lhab,lr:lhab)
+      real ::  dab1lh(ngs,lc:lhab,lr:lhab)
+      
+      real :: galphrout
+      
+      real ventrx(ngs)
+      real ventrxn(ngs)
+      real g1shr, alphashr
+      real g1mlr, alphamlr
+      real massfacshr, massfacmlr
+      
+      real :: qhgt8mm ! ice mass greater than 8mm
+      real :: qhwgt8mm ! ice + max water mass greater than 8mm
+      real :: qhgt10mm ! mass greater than 10mm
+      real :: qhgt20mm ! mass greater than 20mm
+      real :: fwmhtmp
+      real, parameter :: fwmhtmptem = -15. ! temperature at which fwmhtmp fully switches to liquid water only being on large particles
+      real, parameter :: d1t = (6.0 * 0.268e-3/(917.* pi))**(1./3.) ! d1t is the diameter of the ice sphere with the mass of an 8mm spherical drop
+      real, parameter :: srasheym = 0.1389 ! slope fraction from Rasmussen and Heymsfield 
 !
-!        IF (mixedphase) THEN
-          IF (qsdenmod) THEN
-           IF(fsw(mgs) .gt. 0.01) THEN
-            xdn(mgs,ls) = (1.-fsw(mgs))*rho_qs + fsw(mgs)*rho_qr        !Ferrier: 100./(1.-fsw(mgs))
-            IF(fsw(mgs) .eq. 1.) xdn(mgs,ls) = rho_qr   ! fsw = 1 means it's liquid water, yo!
-           ENDIF
-          ENDIF
-
-          IF (qhdenmod) THEN
-!          IF(fhw(mgs) .gt. 0.01) THEN
-!           IF(fhw(mgs) .lt. 1.) xdn(mgs,lh) = rho_qh / (1. - fhw(mgs))       !Ferrier: 400./(1.-fsw(mgs))
-!           IF(fhw(mgs) .eq. 1.) xdn(mgs,lh) = rho_qr   ! fhw = 1 means it's liquid water, yo!
-!          ENDIF
-          ENDIF
-!        ENDIF
-
-      end do
-
-
-       IF ( imurain == 3 ) THEN
-         IF ( lzr > 1 ) THEN
-           alphashr = 0.0
-           alphamlr = -2.0/3.0
-         ELSE
-           alphashr = xnu(lr)
-           alphamlr = xnu(lr)
-         ENDIF
-!         massfacshr = ( (2. + 3.*(1. +alphashr) )/( 3.*(1. + alphashr) ) )**(1./3.) ! this is the diameter factor
-!         massfacmlr = ( (2. + 3.*(1. +alphamlr) )/( 3.*(1. + alphamlr) ) )**(1./3.)
-         massfacshr = ( (2. + 3.*(1. +alphashr) )**3/( 3.*(1. + alphashr) ) )  ! this is the mass or volume factor
-         massfacmlr = ( (2. + 3.*(1. +alphamlr) )**3/( 3.*(1. + alphamlr) ) )
-       ELSEIF ( imurain == 1 ) THEN
-         IF ( lzr > 1 ) THEN
-           alphashr = 4.0
-           alphamlr = 4.0
-         ELSE
-           alphashr = alphar
-           alphamlr = alphar
-         ENDIF
-!         massfacshr = (3.0 + alphashr)*((3.+alphashr)*(2.+alphashr)*(1. + alphashr) )**(-1./3.) ! this is the diameter factor
-!         massfacmlr = (3.0 + alphamlr)*((3.+alphamlr)*(2.+alphamlr)*(1. + alphamlr) )**(-1./3.)
-         massfacshr = (3.0 + alphashr)**3/((3.+alphashr)*(2.+alphashr)*(1. + alphashr) ) ! this is the mass or volume factor
-         massfacmlr = (3.0 + alphamlr)**3/((3.+alphamlr)*(2.+alphamlr)*(1. + alphamlr) )
-       ENDIF
-       
-
+      real swvent(ngs),hwvent(ngs),rwvent(ngs),hlvent(ngs),hwventy(ngs),hlventy(ngs),rwventz(ngs)
+      integer, parameter :: ndiam = 10
+      integer :: numdiam
+      real hwvent0(ndiam+3),hlvent0 ! 0 to d1
+      real hwvent1,hlvent1 ! d1 to infinity
+      real hwvent2,hlvent2 ! d2 to infinity
+      real gama0,gamb0
+      real gama1,gamb1
+      real gama2,gamb2
+      real, parameter :: mltdiam1 = 9.0e-3, mltdiam2 = 19.0e-3, mltdiam3 = 200.0e-3, mltdiam05 = 4.5e-3
+      real :: mltdiam(ndiam+3)
+      real mltmass1inv,mltmass2inv, mltmass1cgs, mltmass2cgs
+      real qhmlr0, qhmlr05, qhmlr1, qhmlr2, qhmlr12
+      real qhlmlr0, qhlmlr05, qhlmlr1, qhlmlr2, qhlmlr12
+      real qxd1, cxd1 ! mass and number up to mltdiam1
+      real qxd05, cxd05 ! mass and number up to mltdiam1/2
+      
+      real :: qxd(ndiam+3), cxd(ndiam+3), qhml(ndiam+3), qhml0(ndiam+3)
+      real :: dqxd(ndiam+3), dcxd(ndiam+3), dqhml(ndiam+3)
+      
+      
+      real civent(ngs)
+      real isvent(ngs)
 !
-!  set some values for ice nucleation
+      real xmascw(ngs)
+      real xdnmx(lc:lhab), xdnmn(lc:lhab)
+      real dnmx
+      real :: xdiamxmas(ngs,lc:lhab)
 !
-      do mgs = 1,ngscnt
-      kp1 = Min(nz, kgs(mgs)+1 )
-      wvel(mgs) = (0.5)*(w(igs(mgs),jgs,kp1)   &
-     &                  +w(igs(mgs),jgs,kgs(mgs)))
+      real cilen(ngs) ! ,ciplen(ngs)
+!
+!
+      real rwcap(ngs),swcap(ngs)
+      real hwcap(ngs)
+      real hlcap(ngs)
+      real cicap(ngs)
+      real iscap(ngs)
 
-      
-        wvelkm1(mgs) = (0.5)*(w(igs(mgs),jgs,kgs(mgs))   &
-     &                    +w(igs(mgs),jgs,kgsm(mgs)))
-      cninm(mgs) = t7(igs(mgs),jgs,kgsm(mgs))
-      cnina(mgs) = t7(igs(mgs),jgs,kgs(mgs))
-      cninp(mgs) = t7(igs(mgs),jgs,kgsp(mgs))
-      end do
+      real qvimxd(ngs)
+      real qimxd(ngs),qismxd(ngs),qcmxd(ngs),qrmxd(ngs),qsmxd(ngs),qhmxd(ngs),qhlmxd(ngs)
+      real cimxd(ngs),ccmxd(ngs),crmxd(ngs),csmxd(ngs),chmxd(ngs)
+      real cionpmxd(ngs),cionnmxd(ngs)
+      real clionpmxd(ngs),clionnmxd(ngs)
 
 !
-!  Set a couple of cloud variables...
 !
+!  Da electricity array work space...
+!
+!
+      real dezcomp(ngs)
+      real sctem(ngs)
+      real dellwc(ngs)
+!
+!  space charge arrays.....
+!
+      real scsacw(ngs)
+      real scsacr(ngs)
+      real sciacw(ngs) ! not present...
+      real scsaci(ngs)
+      real :: scsacis(ngs)
+      real sxsaci(ngs)
+!
+      real schacw(ngs), schacr(ngs)
+      real schaci(ngs), schacs(ngs)
+      real :: schacis(ngs) = 0.0
+      real sxhaci(ngs), sxhacs(ngs)
 
-!      SUBROUTINE setvt(ngscnt,qx,qxmin,cx,rho0,rhovt,xdia,cno,
-!     :                 xmas,xdn,xvmn,xvmx,xv,cdx,
-!     :                 ipconc,ndebug)
-!      SUBROUTINE setvtz(ngscnt,qx,qxmin,qxw,cx,rho0,rhovt,xdia,cno, &
-!     &                 xmas,vtxbar,xdn,xvmn,xvmx,xv,cdx,            &
-!     &                 ipconc1,ndebug1,ngs,nz,kgs,cwnccn,fadvisc,   &
-!     &                 cwmasn,cwmasx,cwradn,cnina,cimna,cimxa,      &
-!     &                 itype1a,itype2a,temcg,infdo,alpha)
-
+      real schmlr(ngs), scsmlr(ngs)
+      real scsshr(ngs), schshr(ngs)
+      real scscev(ngs), scsdep(ngs)
+!
+      real schlacw(ngs), schlacr(ngs)
+      real schlaci(ngs), schlacs(ngs)
+      real :: schlacis(ngs) = 0.0
 
-      infdo = 0
-      IF ( io_flag .and. nxtra > 1 ) infdo = 1
+      real exy(ngs,ls:lhab,lc:ls)
+      real scxacy(ngs,ls:lhab,lc:ls)
+      real cxacy(ngs,ls:lhab,lc:ls)
+      real sxxacy(ngs,ls:lhab,li:ls)
 
-      call setvtz(ngscnt,qx,qxmin,qxw,cx,rho0,rhovt,xdia,cno,cnostmp,   &
-     &                 xmas,vtxbar,xdn,xvmn,xvmx,xv,cdx,   &
-     &                 ipconc,ndebug,ngs,nz,kgs,fadvisc,   &
-     &                 cwmasn,cwmasx,cwradn,cnina,cimn,cimx,   &
-     &                 itype1,itype2,temcg,infdo,alpha,0,axh,bxh,axhl,bxhl)
+! ions  - one size assumed
 
+      real cionp(ngs),cionn(ngs),clionp(ngs),clionn(ngs) 
 
-       IF ( lwsm6 .and. ipconc == 0 ) THEN
-         tmp = Max(qxmin(lh), qxmin(ls))
-         DO mgs = 1,ngscnt
-           sum = qx(mgs,lh) + qx(mgs,ls)
-           IF ( sum > tmp ) THEN
-             vt2ave(mgs) = (qx(mgs,lh)*vtxbar(mgs,lh,1) + qx(mgs,ls)*vtxbar(mgs,ls,1))/sum
-           ELSE
-             vt2ave(mgs) = 0.0
-           ENDIF
-         ENDDO
-       ENDIF
+!    charge concentration
 
+!    production of space charge per collison/per unit mass?
 
-!
-!  Set number concentrations (need xdia from setvt)
-!
-      if ( ndebug .gt. 0 ) write(0,*) 'ICEZVD_GS: Set concentration'
-      IF ( ipconc .lt. 1 ) THEN
-         cina(1:ngscnt) = cx(1:ngscnt,li)
-      ENDIF
-      if ( ipconc .lt. 5 ) then
-      do mgs = 1,ngscnt
+      real fschw(ngs),fscsw(ngs),fschl(ngs)
+      real fschw2(ngs),fscsw2(ngs),fschl2(ngs)
+      real fsccw(ngs),fscci(ngs),fscrw(ngs),fscis(ngs)
 
+!    production of space charge term  + / -
 
-      IF ( ipconc .lt. 3 ) THEN
-!      cx(mgs,lr) = 0.0
-      if ( qx(mgs,lr) .gt. qxmin(lh) )  then
-!      cx(mgs,lr) = cno(lr)*xdia(mgs,lr,1)
-!      xv(mgs,lr) = rho0(mgs)*qx(mgs,lr)/(xdn(mgs,lr)*cx(mgs,lr))
-      end if
-      ENDIF
+      real  psctot(ngs)
+      real  psctotmx,psctotmn
+      real  psccwi(ngs), psccwd(ngs) ! cloud water
+      real  psccii(ngs), psccid(ngs) ! ice crystals
+      real  pscisi(ngs), pscisd(ngs) ! ice spheres
+      real  pscrwi(ngs), pscrwd(ngs)  ! rain water
+      real  pscswi(ngs), pscswd(ngs)  ! snow
+      real  pschwi(ngs), pschwd(ngs)  ! graupel
+      real  pschli(ngs), pschld(ngs)   ! hail
 
-      IF ( ipconc .lt. 4 ) THEN
-!      tmp = cx(mgs,ls)
-!      cx(mgs,ls) = 0.0
-      if ( qx(mgs,ls) .gt. qxmin(ls) )  then
-!      cx(mgs,ls) = cno(ls)*xdia(mgs,ls,1)
-!      xv(mgs,ls) = rho0(mgs)*qx(mgs,ls)/(xdn(mgs,ls)*cx(mgs,ls))
-      end if
-      ENDIF ! ( ipconc .lt. 4 )
+!ions assume mass = 0
+      real  pscpii(ngs), pscpid(ngs) !positive ions
+      real  pscnii(ngs), pscnid(ngs) !negative ions
+      real  pscplii(ngs), pscplid(ngs) !positive (large) ions
+      real  pscnlii(ngs), pscnlid(ngs) !negative (large) ions
 
-      IF ( ipconc .lt. 5 ) THEN
+!      production of space charge from mass transfer
 
+      real  psccwmi(ngs), psccwmd(ngs)
+      real  psccimi(ngs), psccimd(ngs)
+      real  pscismi(ngs), pscismd(ngs)
+      real  pscrwmi(ngs), pscrwmd(ngs)
+      real  pscswmi(ngs), pscswmd(ngs)
+      real  pschwmi(ngs), pschwmd(ngs)
+      real  pschlmi(ngs), pschlmd(ngs)
 
-!      cx(mgs,lh) = 0.0
-      if ( qx(mgs,lh) .gt. qxmin(lh) )  then
-!      cx(mgs,lh) = cno(lh)*xdia(mgs,lh,1)
-!      xv(mgs,lh) = Max(xvmn(lh), rho0(mgs)*qx(mgs,lh)/(xdn(mgs,lh)*cx(mgs,lh)) )
-!      xdia(mgs,lh,3) = (xv(mgs,lh)*6./pi)**(1./3.) 
-      end if
 
-      ENDIF ! ( ipconc .lt. 5 )
+      real elec(-nor+ng1:nx+nor,-nor+ng1:ny+nor,-norz+ng1:nz+norz) ! Ez (elecsave)
 
-      end do
-      end if
-      
-      IF ( ipconc .ge. 2 ) THEN
-      DO mgs = 1,ngscnt
-        rb(mgs) = 0.5*xdia(mgs,lc,1)*((1./(1.+cnu)))**(1./6.)
-        xl2p(mgs) = Max(0.0d0, 2.7e-2*xdn(mgs,lc)*cx(mgs,lc)*xv(mgs,lc)*   &
-     &           ((0.5e20*rb(mgs)**3*xdia(mgs,lc,1))-0.4) )
-        IF ( rb(mgs) .gt. 3.51e-6 ) THEN
-!          rh(mgs) = Max( 0.5d0*xdia(mgs,lc,1), 6.3d-4/(1.d6*(rb(mgs) - 3.5d-6)) )
-          rh(mgs) = Max( 41.d-6, 6.3d-4/(1.d6*(rb(mgs) - 3.5d-6)) )
-        ELSE
-          rh(mgs) = 41.d-6
-        ENDIF
-        IF ( xl2p(mgs) .gt. 0.0 ) THEN
-          nh(mgs) = 4.2d9*xl2p(mgs)
-        ELSE
-          nh(mgs) = 1.e30
-        ENDIF
-      ENDDO
-      ENDIF
-      
 !
 !
-!              
+      ! Hallett-Mossop arrays
+      real chmul1(ngs),chlmul1(ngs),csmul1(ngs),csmul(ngs)
+      real qhmul1(ngs),qhlmul1(ngs),qsmul1(ngs),qsmul(ngs)
+      
+      ! splinters from drop freezing
+      real csplinter(ngs),qsplinter(ngs)
+      real csplinter2(ngs),qsplinter2(ngs)
 !
-!  maximum depletion tendency by any one source
 !
+!  concentration arrays...
 !
-      if( ndebug .ge. 0 ) THEN
-!mpi!        write(0,*) 'Set depletion max/min1'
-      endif
-      do mgs = 1,ngscnt
-      qvimxd(mgs) = 0.70*(qx(mgs,lv)-qis(mgs))/dtp ! depletion by all vap. dep to ice.
-      
-      IF ( qx(mgs,lc) < qxmin(lc) ) qvimxd(mgs) = 0.99*(qx(mgs,lv)-qis(mgs))/dtp ! this makes virtually no difference whatsoever, but what the heck
-      
-      qvimxd(mgs) = max(qvimxd(mgs), 0.0)
-!      qimxd(mgs)  = 0.20*qx(mgs,li)/dtp
-!      qcmxd(mgs)  = 0.20*qx(mgs,lc)/dtp
-!      qrmxd(mgs)  = 0.20*qx(mgs,lr)/dtp
-!      qsmxd(mgs)  = 0.20*qx(mgs,ls)/dtp
-!      qhmxd(mgs)  = 0.20*qx(mgs,lh)/dtp
+      real :: chlcnh(ngs), vhlcnh(ngs), vhlcnhl(ngs)
+      real cracif(ngs), ciacrf(ngs)
+      real cracr(ngs)
 
-      frac = 0.1d0
-      qimxd(mgs)  = frac*qx(mgs,li)/dtp
-      qcmxd(mgs)  = frac*qx(mgs,lc)/dtp
-      qrmxd(mgs)  = frac*qx(mgs,lr)/dtp
-      qsmxd(mgs)  = frac*qx(mgs,ls)/dtp
-      qhmxd(mgs)  = frac*qx(mgs,lh)/dtp
-      IF ( lhl > 1 ) qhlmxd(mgs)  = frac*qx(mgs,lhl)/dtp
-      end do
 !
-      if( ndebug .ge. 0 ) THEN
-!mpi!        write(0,*) 'Set depletion max/min2'
-      endif
-
-      do mgs = 1,ngscnt
+      real ciint(ngs), crfrz(ngs), crfrzf(ngs), crfrzs(ngs)
+      real cicint(ngs)
+      real cipint(ngs)
+      real ciacw(ngs), cwacii(ngs) 
+      real ciacr(ngs), craci(ngs)
+      real csacw(ngs)
+      real csacr(ngs)
+      real csaci(ngs),   csacs(ngs)
+      real cracw(ngs) 
+      real chacw(ngs), chacr(ngs)
+      real :: chlacw(ngs) ! = 0.0
+      real chaci(ngs), chacs(ngs)
 !
-      if ( qx(mgs,lc) .le. qxmin(lc) ) then
-      ccmxd(mgs)  = 0.20*cx(mgs,lc)/dtp
-      else
-      IF ( ipconc .ge. 2 ) THEN
-        ccmxd(mgs)  = frac*cx(mgs,lc)/dtp
-      ELSE
-        ccmxd(mgs)  = frac*qx(mgs,lc)/(xmas(mgs,lc)*rho0(mgs)*dtp)
-      ENDIF
-      end if
-!
-      if ( qx(mgs,li) .le. qxmin(li) ) then
-      cimxd(mgs)  = frac*cx(mgs,li)/dtp
-      else
-      IF ( ipconc .ge. 1 ) THEN
-        cimxd(mgs)  = frac*cx(mgs,li)/dtp
-      ELSE
-        cimxd(mgs)  = frac*qx(mgs,li)/(xmas(mgs,li)*rho0(mgs)*dtp)
-      ENDIF
-      end if
-!
-!
-      crmxd(mgs)  = 0.10*cx(mgs,lr)/dtp
-      csmxd(mgs)  = frac*cx(mgs,ls)/dtp
-      chmxd(mgs)  = frac*cx(mgs,lh)/dtp
+      real :: chlacr(ngs)
+      real :: chlaci(ngs), chlacs(ngs)
+      real crcnw(ngs) 
+      real cidpv(ngs),cisbv(ngs)
+      real cisdpv(ngs),cissbv(ngs)
+      real cimlr(ngs),cismlr(ngs)
 
-      ccmxd(mgs)  = frac*cx(mgs,lc)/dtp
-      cimxd(mgs)  = frac*cx(mgs,li)/dtp
-      crmxd(mgs)  = frac*cx(mgs,lr)/dtp
-      csmxd(mgs)  = frac*cx(mgs,ls)/dtp
-      chmxd(mgs)  = frac*cx(mgs,lh)/dtp
+      real chlsbv(ngs), chldpv(ngs)
+      real chlmlr(ngs), chlmlrr(ngs) 
+      real chlshr(ngs), chlshrr(ngs)
 
-      qxmxd(mgs,lv) = Max(0.0, 0.1*(qx(mgs,lv) - qvs(mgs))/dtp)
+      real chdpv(ngs),chsbv(ngs)
+      real chmlr(ngs),chcev(ngs)
+      real chmlrr(ngs)
+      real chshr(ngs), chshrr(ngs)
 
-      DO il = lc,lhab
-       qxmxd(mgs,il) = frac*qx(mgs,il)/dtp
-       cxmxd(mgs,il) = frac*cx(mgs,il)/dtp
-      ENDDO
+      real csdpv(ngs),cssbv(ngs)
+      real csmlr(ngs),csmlrr(ngs),cscev(ngs)
+      real csshr(ngs), csshrr(ngs)
 
-      end do
+      real crcev(ngs)
+      real crshr(ngs)
+!
+!
+! arrays for w-ac-x ;  x-ac-w
+!
+!
+!
+      real qrcnw(ngs), qwcnr(ngs)
+      real zrcnw(ngs),zracr(ngs),zracw(ngs),zrcev(ngs)
 
 
+      real qracw(ngs) ! qwacr(ngs),
+      real qiacw(ngs) !, qwaci(ngs)
 
+      real qsacw(ngs) ! ,qwacs(ngs),
+      real qhacw(ngs) ! qwach(ngs),
+      real :: qhlacw(ngs) ! = 0.0
+      real vhacw(ngs), vsacw(ngs), vhlacw(ngs), vhlacr(ngs)
 
+!
+      real qsacws(ngs)
 
-    ! default factors between mean volume and maximum mass volume
-      maxmassfac(lc) = ( (2. + 3.*(1. + xnu(lc)) )**3/( 3.*(1. + xnu(lc)) ) )
-      maxmassfac(li) = ( (2. + 3.*(1. + xnu(li)) )**3/( 3.*(1. + xnu(li)) ) )
+!
+!  arrays for x-ac-r and r-ac-x; 
+!
+      real qsacr(ngs),qracs(ngs)
+      real qhacr(ngs),qhacrmlr(ngs) ! ,qrach(ngs)
+      real vhacr(ngs), zhacr(ngs), zhacrf(ngs), zrach(ngs), zrachl(ngs)
+      real qiacr(ngs),qraci(ngs)
+      
+      real ziacr(ngs)
 
-      IF ( imurain == 3 ) THEN
-        maxmassfac(lr) = ( (2. + 3.*(1. + xnu(lr)) )**3/( 3.*(1. + xnu(lr)) ) )
-      ELSE
-        maxmassfac(lr) =  (3.0 + alphar)**3/    &
-     &                  ((3.+alphar)*(2.+alphar)*(1. + alphar) )
-      ENDIF
+      real qracif(ngs),qiacrf(ngs),qiacrs(ngs),ciacrs(ngs)
 
-      IF ( imusnow == 3 ) THEN
-        maxmassfac(ls) = ( (2. + 3.*(1. + alphas) )**3/( 3.*(1. + alphas) ) )
-      ELSE
-        maxmassfac(ls) =  (3.0 + alphas)**3/    &
-     &                  ((3.+alphas)*(2.+alphas)*(1. + alphas) )
-      ENDIF
-      
-        maxmassfac(lh) =  (3.0 + alphah)**3/    &
-     &                  ((3.+alphah)*(2.+alphah)*(1. + alphah) )
+      real :: qhlacr(ngs),qhlacrmlr(ngs) ! = 0.0
+      real qsacrs(ngs) !,qracss(ngs)
+!
+!  ice - ice interactions
+!
+      real qsaci(ngs)
+      real qsacis(ngs)
+      real qhaci(ngs)
+      real qhacs(ngs)
 
-       IF ( lhl > 1 ) THEN
-        maxmassfac(lhl) =  (3.0 + alphahl)**3/    &
-     &                  ((3.+alphahl)*(2.+alphahl)*(1. + alphahl) )
-       ENDIF
-      
+      real :: qhacis(ngs) = 0.0
+      real :: chacis(ngs) = 0.0
+      real :: chacis0(ngs) = 0.0
 
+      real :: csaci0(ngs) ! collision rate only
+      real :: chaci0(ngs) ! collision rate only
+      real :: chacs0(ngs) ! collision rate only
+      real :: chlaci0(ngs) ! = 0.0
+      real :: chlacis(ngs) = 0.0
+      real :: chlacis0(ngs) = 0.0
+      real :: chlacs0(ngs) ! = 0.0
 
-       DO mgs = 1,ngscnt
-          DO il = lh,lhab ! graupel and hail only
-            
-            vshdgs(mgs,il) = vshd ! base value
-            
-            IF ( qx(mgs,il) > qxmin(il) ) THEN
-              
-              tmpdiam = (shedalp+alpha(mgs,il))*xdia(mgs,il,1)*( xdn(mgs,il)/917. )**(1./3.) ! erm added density factor for equiv. solid ice sphere 10.12.2015
-              
-              IF ( tmpdiam > sheddiam0 ) THEN
-                vshdgs(mgs,il) = 0.523599*(1.5e-3)**3/massfacshr ! 1.5mm drops from very large ice
-              ELSEIF ( tmpdiam > sheddiam ) THEN ! intermediate size
-                vshdgs(mgs,il) = 0.523599*(3.0e-3)**3/massfacshr ! 3.0mm drops from medium-large ice
-              ELSE
-!                vshdgs(mgs,il) = Min( xvmx(lr), xv(mgs,il)*xdn(mgs,il)*0.001 ) ! size of drop from melted mean ice particle
-                vshdgs(mgs,il) = Min( xvmx(lr), 6./pi*xdn(mgs,il)*0.001*tmpdiam**3 )/massfacshr ! size of drop from melted mean ice particle
-              ENDIF
-            ENDIF
-          ENDDO
-       ENDDO
+      real :: qsaci0(ngs) ! collision rate only
+      real :: qsacis0(ngs) ! collision rate only
+      real :: qhaci0(ngs) ! collision rate only
+      real :: qhacis0(ngs) ! collision rate only
+      real :: qhacs0(ngs) ! collision rate only
+      real :: qhlaci0(ngs) ! = 0.0
+      real :: qhlacis0(ngs) ! = 0.0
+      real :: qhlacs0(ngs) ! = 0.0
 
+      real :: qhlaci(ngs) ! = 0.0
+      real :: qhlacis(ngs) ! = 0.0
+      real :: qhlacs(ngs) ! = 0.0
 !
+!  conversions
 !
-!  microphysics source terms (1/s) for mixing ratios 
+      real qrfrz(ngs) ! , qirirhr(ngs)
+      real zrfrz(ngs), zrfrzf(ngs), zrfrzs(ngs)
+      real ziacrf(ngs), zhcnsh(ngs), zhcnih(ngs)
+      real zhacw(ngs), zhacs(ngs), zhaci(ngs)
+      real zhmlr(ngs), zhdsv(ngs), zhsbv(ngs), zhlcnh(ngs), zhshr(ngs)
+      real zhmlrtmp,zhmlr0inf,zhlmlr0inf
+      real zhmlrr(ngs),zhlmlrr(ngs),zhshrr(ngs),zhlshrr(ngs)
+      real zsmlr(ngs), zsmlrr(ngs), zsshr(ngs)
+      real zhcns(ngs), zhcni(ngs)
+      real zhwdn(ngs) ! change in Z due to density changes
+      real zhldn(ngs) ! change in Z due to density changes
+
+      real zhlacw(ngs), zhlacs(ngs), zhlacr(ngs)
+      real zhlmlr(ngs), zhldsv(ngs), zhlsbv(ngs), zhlshr(ngs)
+
+      
+      real vrfrzf(ngs), viacrf(ngs)
+      real qrfrzs(ngs), qrfrzf(ngs)
+      real qwfrz(ngs), qwctfz(ngs)
+      real cwfrz(ngs), cwctfz(ngs)
+      real qwfrzis(ngs), qwctfzis(ngs) ! droplet freezing to ice spheres
+      real cwfrzis(ngs), cwctfzis(ngs)
+      real qwfrzc(ngs), qwctfzc(ngs) ! droplet freezing to columns
+      real cwfrzc(ngs), cwctfzc(ngs)
+      real qwfrzp(ngs), qwctfzp(ngs) ! droplet freezing to plates
+      real cwfrzp(ngs), cwctfzp(ngs)
+      real xcolmn(ngs), xplate(ngs)
+      real ciihr(ngs), qiihr(ngs)
+      real cicichr(ngs), qicichr(ngs)
+      real cipiphr(ngs), qipiphr(ngs)
+      real qscni(ngs), cscni(ngs), cscnis(ngs)
+      real qscnvi(ngs), cscnvi(ngs), cscnvis(ngs)
+      real qhcns(ngs), chcns(ngs), chcnsh(ngs), vhcns(ngs)
+      real qscnh(ngs), cscnh(ngs), vscnh(ngs)
+      real qhcni(ngs), chcni(ngs), chcnih(ngs), vhcni(ngs)
+      real qiint(ngs),qipipnt(ngs),qicicnt(ngs)
+      real cninm(ngs),cnina(ngs),cninp(ngs),wvel(ngs),wvelkm1(ngs)
+      real tke(ngs)
+      real uvel(ngs),vvel(ngs)
 !
+      real qidpv(ngs),qisbv(ngs) ! qicnv(ngs),qievv(ngs),
+      real qimlr(ngs),qidsv(ngs),qisdsv(ngs),qidsvp(ngs) ! ,qicev(ngs)
+      real qismlr(ngs)
+
 !
+      real qfdpv(ngs),qfsbv(ngs) ! qfcnv(ngs),qfevv(ngs),
+      real qfmlr(ngs),qfdsv(ngs) ! ,qfcev(ngs)
+      real qfwet(ngs),qfdry(ngs),qfshr(ngs)
+      real qfshrp(ngs)
 !
-!  Collection efficiencies:
+      real :: qhldpv(ngs), qhlsbv(ngs) ! qhlcnv(ngs),qhlevv(ngs),
+      real :: qhlmlr(ngs), qhldsv(ngs) 
+      real :: qhlwet(ngs), qhldry(ngs), qhlshr(ngs) 
 !
-      if (ndebug .gt. 0 ) write(0,*) 'ICEZVD_GS: Set collection efficiencies'
+      real :: qrfz(ngs),qsfz(ngs),qhfz(ngs),qhlfz(ngs)
 !
-      do mgs = 1,ngscnt
+      real qhdpv(ngs),qhsbv(ngs) ! qhcnv(ngs),qhevv(ngs),
+      real qhmlr(ngs),qhdsv(ngs),qhcev(ngs),qhcndv(ngs),qhevv(ngs)
+      real qhmlrlg(ngs),qhlmlrlg(ngs) ! melting from the larger diameters
+      real qhlcev(ngs), chlcev(ngs)
+      real qhwet(ngs),qhdry(ngs),qhshr(ngs)
+      real qhshrp(ngs)
+      real qhshh(ngs) !accreted water that remains on graupel
+      real qhmlh(ngs) !melt water that remains on graupel
+      real qhfzh(ngs) !water that freezes on mixed-phase graupel
+      real qhlfzhl(ngs) !water that freezes on mixed-phase hail
+
+      real vhfzh(ngs) ! change in volume from water that freezes on mixed-phase graupel
+      real vhlfzhl(ngs) !  change in volume from water that freezes on mixed-phase hail
+
+      real vhshdr(ngs) !accreted water that leaves on graupel (mixedphase)
+      real vhlshdr(ngs) !accreted water that leaves on hail (mixedphase)
+      real vhmlr(ngs) !melt water that leaves graupel (single phase)
+      real vhlmlr(ngs) !melt water that leaves hail (single phase)
+      real vhsoak(ngs) !  aquired water that seeps into graupel.
+      real vhlsoak(ngs) !  aquired water that seeps into hail.
 !
+      real qsdpv(ngs),qssbv(ngs) ! qscnv(ngs),qsevv(ngs),
+      real qsmlr(ngs),qsdsv(ngs),qscev(ngs),qscndv(ngs),qsevv(ngs)
+      real qswet(ngs),qsdry(ngs),qsshr(ngs)
+      real qsshrp(ngs)
+      real qsfzs(ngs)
 !
 !
-      erw(mgs) = 0.0
-      esw(mgs) = 0.0
-      ehw(mgs) = 0.0
-      ehlw(mgs) = 0.0
-!      ehxw(mgs) = 0.0
+      real qipdpv(ngs),qipsbv(ngs)
+      real qipmlr(ngs),qipdsv(ngs)
 !
-      err(mgs) = 0.0
-      esr(mgs) = 0.0
-      il2(mgs) = 0
-      il3(mgs) = 0
-      ehr(mgs) = 0.0
-      ehlr(mgs) = 0.0
-!      ehxr(mgs) = 0.0
+      real qirdpv(ngs),qirsbv(ngs)
+      real qirmlr(ngs),qirdsv(ngs),qirmlw(ngs)
 !
-      eri(mgs) = 0.0
-      esi(mgs) = 0.0
-      ehi(mgs) = 0.0 ! used as sticking efficiency, so collection efficiency is ehi*ehiclsn
-      ehis(mgs) = 0.0 ! used as sticking efficiency, so collection efficiency is ehi*ehiclsn
-      ehli(mgs) = 0.0 ! used as sticking efficiency, so collection efficiency is ehli*ehliclsn
-      ehlis(mgs) = 0.0 ! used as sticking efficiency, so collection efficiency is ehli*ehliclsn
-!      ehxi(mgs) = 0.0
+      real qgldpv(ngs),qglsbv(ngs)
+      real qglmlr(ngs),qgldsv(ngs)
+      real qglwet(ngs),qgldry(ngs),qglshr(ngs)
+      real qglshrp(ngs)
 !
-      ers(mgs) = 0.0
-      ess(mgs) = 0.0
-      ehs(mgs) = 0.0 ! used as sticking efficiency, so collection efficiency is ehs*ehsclsn
-      ehls(mgs) = 0.0 ! used as sticking efficiency, so collection efficiency is ehls*ehlsclsn
-      ehscnv(mgs) = 0.0
-!      ehxs(mgs) = 0.0
+      real qgmdpv(ngs),qgmsbv(ngs)
+      real qgmmlr(ngs),qgmdsv(ngs)
+      real qgmwet(ngs),qgmdry(ngs),qgmshr(ngs)
+      real qgmshrp(ngs)
+      real qghdpv(ngs),qghsbv(ngs)
+      real qghmlr(ngs),qghdsv(ngs) 
+      real qghwet(ngs),qghdry(ngs),qghshr(ngs)
+      real qghshrp(ngs)
 !
-      eiw(mgs) = 0.0
-      eii(mgs) = 0.0
-
-      ehsclsn(mgs) = 0.0
-      ehiclsn(mgs) = 0.0
-      ehlsclsn(mgs) = 0.0
-      ehliclsn(mgs) = 0.0
-      esiclsn(mgs) = 0.0
-
-
-      icwr(mgs) = 1
-      IF ( qx(mgs,lc) .gt. qxmin(lc) ) THEN
-       cwrad = 0.5*xdia(mgs,lc,1)
-      DO il = 1,8
-         IF ( cwrad .ge. 1.e-6*cwr(il,1) ) icwr(mgs) = il
-      ENDDO
-      ENDIF
-
+      real qrztot(ngs),qrzmax(ngs),qrzfac(ngs)
+      real qrcev(ngs)
+      real qrshr(ngs)
+      real fsw(ngs),fhw(ngs),fhlw(ngs) !liquid water fractions
+      real qhcnf(ngs) 
+      real :: qhlcnh(ngs) ! = 0.0
+      real qhcngh(ngs),qhcngm(ngs),qhcngl(ngs)
+      
+      real :: qhcnhl(ngs), chcnhl(ngs), zhcnhl(ngs), vhcnhl(ngs) ! conversion of low-density hail back to graupel
 
-      irwr(mgs) = 1
-      IF ( qx(mgs,lr) .gt. qxmin(lr) ) THEN
-         rwrad = 0.5*xdia(mgs,lr,3)  ! changed to mean volume diameter (10/6/06)
-      DO il = 1,6
-         IF ( rwrad .ge. 1.e-6*grad(il,1) ) irwr(mgs) = il
-      ENDDO
-      ENDIF
+      real eiw(ngs),eii(ngs),eiri(ngs),eipir(ngs),eisw(ngs)
+      real erw(ngs),esw(ngs),eglw(ngs),eghw(ngs),efw(ngs)
+      real ehxw(ngs),ehlw(ngs),egmw(ngs),ehw(ngs)
+      real err(ngs),esr(ngs),eglr(ngs),eghr(ngs),efr(ngs)
+      real ehxr(ngs),ehlr(ngs),egmr(ngs) 
+      real eri(ngs),esi(ngs),egli(ngs),eghi(ngs),efi(ngs)
+      real ehxi(ngs),ehli(ngs),egmi(ngs),ehi(ngs),ehis(ngs),ehlis(ngs)
+      real ers(ngs),ess(ngs),egls(ngs),eghs(ngs),efs(ngs),ehs(ngs)
+      real ehscnv(ngs)
+      real ehxs(ngs),ehls(ngs),egms(ngs),egmip(ngs) 
 
+      real ehsclsn(ngs),ehiclsn(ngs),ehisclsn(ngs)
+      real ehlsclsn(ngs),ehliclsn(ngs),ehlisclsn(ngs)
+      real esiclsn(ngs)
 
-      igwr(mgs) = 1
-!      IF ( qx(mgs,lr) .gt. qxmin(lr) ) THEN
-!         rwrad = 0.5*xdia(mgs,lr,1)
-! setting erw = 1 always, so now use igwr for graupel
-      IF ( qx(mgs,lh) .gt. qxmin(lh) ) THEN
-         rwrad = 0.5*xdia(mgs,lh,3)  ! changed to mean volume diameter (10/6/06)
-      DO il = 1,6
-         IF ( rwrad .ge. 1.e-6*grad(il,1) ) igwr(mgs) = il
-      ENDDO
-      ENDIF
+      real :: ehs_collsn = 0.5, ehi_collsn = 1.0
+      real :: ehls_collsn = 1.0, ehli_collsn = 1.0
+      real :: esi_collsn = 1.0
+      
+      real ew(8,6)
+      real cwr(8,2)  ! radius and inverse of interval
+      data cwr / 2.0, 3.0, 4.0, 6.0,  8.0,  10.0, 15.0,  20.0 , & ! radius
+     &           1.0, 1.0, 0.5, 0.5,  0.5,   0.2,  0.2,  1.  /   ! inverse of interval
+      integer icwr(ngs), igwr(ngs), irwr(ngs), ihlr(ngs)
+      real grad(6,2) ! graupel radius and inverse of interval
+      data grad / 100., 200., 300., 400., 600., 1000.,   &
+     &            1.e-2,1.e-2,1.e-2,5.e-3,2.5e-3, 1.    /
+!droplet radius: 2     3     4     6     8    10    15    20
+      data ew /0.03, 0.07, 0.17, 0.41, 0.58, 0.69, 0.82, 0.88,  & ! 100
+!     :         0.07, 0.13, 0.27, 0.48, 0.65, 0.73, 0.84, 0.91,  ! 150
+     &         0.10, 0.20, 0.34, 0.58, 0.70, 0.78, 0.88, 0.92,  & ! 200
+     &         0.15, 0.31, 0.44, 0.65, 0.75, 0.83, 0.96, 0.91,  & ! 300
+     &         0.17, 0.37, 0.50, 0.70, 0.81, 0.87, 0.93, 0.96,  & ! 400
+     &         0.17, 0.40, 0.54, 0.71, 0.83, 0.88, 0.94, 0.98,  & ! 600
+     &         0.15, 0.37, 0.52, 0.74, 0.82, 0.88, 0.94, 0.98 / ! 1000
+!     :         0.11, 0.34, 0.49, 0.71, 0.83, 0.88, 0.94, 0.95 / ! 1400
 
-      IF ( lhl .gt. 1 ) THEN ! hail is turned on
-      ihlr(mgs) = 1
-      IF ( qx(mgs,lhl) .gt. qxmin(lhl) ) THEN
-         rwrad = 0.5*xdia(mgs,lhl,3)  ! changed to mean volume diameter (10/6/06)
-      DO il = 1,6
-         IF ( rwrad .ge. 1.e-6*grad(il,1) ) ihlr(mgs) = il
-      ENDDO
-      ENDIF
-      ENDIF
 
+      real da0lr(ngs)
+      real da0lh(ngs)
+      real da0lhl(ngs)
+      
+      real va0 (lc:lqmx)          ! collection coefficients from Seifert 2005
+      real vab0(lc:lqmx,lc:lqmx)  ! collection coefficients from Seifert 2005
+      real vab1(lc:lqmx,lc:lqmx)  ! collection coefficients from Seifert 2005
+      real va1 (lc:lqmx)          ! collection coefficients from Seifert 2005
+      real ehip(ngs),ehlip(ngs),ehlir(ngs)
+      real erir(ngs),esir(ngs),eglir(ngs),egmir(ngs),eghir(ngs)
+      real efir(ngs),ehir(ngs),eirw(ngs),eirir(ngs),ehr(ngs)
+      real erip(ngs),esip(ngs),eglip(ngs),eghip(ngs)
+      real efip(ngs),eipi(ngs),eipw(ngs),eipip(ngs)
 !
+!  arrays for production terms
 !
-!  Ice-Ice: Collection (cxc) efficiencies
-!
+      real ptotal(ngs) ! , pqtot(ngs)
 !
-      if ( qx(mgs,li) .gt. qxmin(li) ) then
-!      IF ( ipconc .ge. 14 ) THEN
-!       eii(mgs)=0.1*exp(0.1*temcg(mgs))
-!       if ( temg(mgs) .lt. 243.15 .and. qx(mgs,lc) .gt. 1.e-6 ) then
-!        eii(mgs)=0.1
-!       end if
-!      
-!      ELSE
-        eii(mgs) = exp(0.025*Min(temcg(mgs),0.0))  ! alpha1 from LFO83 (21)
-!      ENDIF
-      if ( temg(mgs) .gt. 273.15 ) eii(mgs) = 1.0
-      end if
+      real pqcwi(ngs),pqcii(ngs),pqrwi(ngs),pqisi(ngs)
+      real pqswi(ngs),pqhwi(ngs),pqwvi(ngs)
+      real pqgli(ngs),pqghi(ngs),pqfwi(ngs)
+      real pqgmi(ngs),pqhli(ngs) ! ,pqhxi(ngs)
+      real pqiri(ngs),pqipi(ngs) ! pqwai(ngs),
+      real pqlwsi(ngs),pqlwhi(ngs),pqlwhli(ngs)
+      
+      real pvhwi(ngs), pvhwd(ngs)
+      real pvhli(ngs), pvhld(ngs)
+      real pvswi(ngs), pvswd(ngs)
 !
+      real pqcwd(ngs),pqcid(ngs),pqrwd(ngs),pqisd(ngs), pqcwdacc(ngs)
+      real pqswd(ngs),pqhwd(ngs),pqwvd(ngs)
+      real pqgld(ngs),pqghd(ngs),pqfwd(ngs)
+      real pqgmd(ngs),pqhld(ngs) ! ,pqhxd(ngs)
+      real pqird(ngs),pqipd(ngs) ! pqwad(ngs),
+      real pqlwsd(ngs),pqlwhd(ngs),pqlwhld(ngs)
 !
+!      real pqxii(ngs,nhab),pqxid(ngs,nhab)
 !
-!  Ice-cloud water: Collection (cxc) efficiencies
+      real  pctot(ngs)
+      real  pcipi(ngs), pcipd(ngs)
+      real  pciri(ngs), pcird(ngs)
+      real  pccwi(ngs), pccwd(ngs), pccwdacc(ngs)
+      real  pccii(ngs), pccid(ngs)
+      real  pcisi(ngs), pcisd(ngs)
+      real  pccin(ngs)
+      real  pcrwi(ngs), pcrwd(ngs)
+      real  pcswi(ngs), pcswd(ngs)
+      real  pchwi(ngs), pchwd(ngs)
+      real  pchli(ngs), pchld(ngs)
+      real  pcfwi(ngs), pcfwd(ngs)
+      real  pcgli(ngs), pcgld(ngs)
+      real  pcgmi(ngs), pcgmd(ngs)
+      real  pcghi(ngs), pcghd(ngs)
+
+      real  pzrwi(ngs), pzrwd(ngs)
+      real  pzhwi(ngs), pzhwd(ngs)
+      real  pzhli(ngs), pzhld(ngs)
+      real  pzswi(ngs), pzswd(ngs)
+
 !
+!  other arrays
 !
-      eiw(mgs) = 0.0
-      if ( qx(mgs,li).gt.qxmin(li) .and. qx(mgs,lc).gt.qxmin(lc) ) then
-      
-      
-      if (xdia(mgs,lc,1).gt.15.0e-06 .and. xdia(mgs,li,1).gt.30.0e-06) then
-! erm 5/10/2007 test following change:
-!      if (xdia(mgs,lc,1).gt.12.0e-06 .and. xdia(mgs,li,1).gt.50.0e-06) then
-      eiw(mgs) = 0.5
-      end if
-      if ( temg(mgs) .ge. 273.15 ) eiw(mgs) = 0.0
-      end if
+      real dqisdt(ngs) !,advisc(ngs) !dqwsdt(ngs), ,schm(ngs),pndl(ngs)
+
+      real qss0(ngs)
 
+      real qsacip(ngs)
+      real pres(ngs),pipert(ngs)
+      real pk(ngs)
+      real rho0(ngs),pi0(ngs)
+      real rhovt(ngs),sqrtrhovt
+      real thetap(ngs),theta0(ngs),qwvp(ngs),qv0(ngs)
+      real thsave(ngs)
+      real ptwfzi(ngs),ptimlw(ngs)
+      real psub(ngs),pvap(ngs),pfrz(ngs),ptem(ngs),pmlt(ngs),pevap(ngs),pdep(ngs),ptem2(ngs)
+      
+      real cnostmp(ngs)   ! for diagnosed snow intercept
 !
+!  iholef = 1 to do hole filling technique version 1
+!  which uses all hydrometerors to do hole filling of all hydrometeors
+!  iholef = 2 to do hole filling technique version 2
+!  which uses an individual hydrometeror species to do hole
+!  filling of a species of a hydrometeor
 !
+!  iholen = interval that hole filling is done
 !
-!  Rain: Collection (cxc) efficiencies
+      integer  iholef
+      integer  iholen
+      parameter (iholef = 1)
+      parameter (iholen = 1)
+      real  cqtotn,cqtotn1
+      real  cctotn
+      real  citotn
+      real  crtotn
+      real  cstotn
+      real  cvtotn
+      real  cftotn
+      real  cgltotn
+      real  cghtotn
+      real  chtotn
+      real  cqtotp,cqtotp1
+      real  cctotp
+      real  citotp
+      real  ciptotp
+      real  crtotp
+      real  cstotp
+      real  cvtotp
+      real  cftotp
+      real  chltotp
+      real  cgltotp
+      real  cgmtotp
+      real  cghtotp
+      real  chtotp
+      real  cqfac
+      real  ccfac
+      real  cifac
+      real  cipfac
+      real  crfac
+      real  csfac
+      real  cvfac
+      real  cffac
+      real  cglfac
+      real  cghfac
+      real  chfac
+      
+      real ssifac, qvapor
 !
+!   Miscellaneous variables
 !
-      if ( qx(mgs,lr).gt.qxmin(lr) .and. qx(mgs,lc).gt.qxmin(lc) ) then
+      integer ireadqf,lrho,lqsw,lqgl,lqgm ,lqgh 
+      integer lqrw
+      real vt
+      real arg  ! gamma is a function
+      real erbnd1, fdgt1, costhe1
+      real qeps
+      real dyi2,dzi2,cp608,bta1,cnit,dragh,dnz00,pii
+      real qccrit,gf4br,gf4ds,gf4p5, gf3ds, gf1ds,gr
+      real gf1palp(ngs) ! for storing Gamma[1.0 + alphar]
 
-       IF ( lnr .gt. 1 ) THEN
-       erw(mgs) = 1.0
+      
+      real xdn0(lc:lhab)
+      real xdn_new,drhodt
+      
+      integer l ,ltemq,inumgs, idelq
 
-       ELSE
+      real brz,arz,temq
 
-!      cwrad = 0.5*xdia(mgs,lc,1)
-!      erw(mgs) =
-!     >  min((aradcw + cwrad*(bradcw + cwrad*
-!     <  (cradcw + cwrad*(dradcw)))), 1.0)
-!       IF ( xdia(mgs,lc,1) .lt. 2.4e-06 .or. xdia(mgs,lr,1) .le. 50.0e-6 ) THEN
-!          erw(mgs)=0.0
-!       ENDIF
-!       erw(mgs) = ew(icwr(mgs),igwr(mgs))
-! interpolate along droplet radius
-       ic = icwr(mgs)
-       icp1 = Min( 8, ic+1 )
-       ir = irwr(mgs)
-       irp1 = Min( 6, ir+1 )
-       cwrad = 0.5*xdia(mgs,lc,3)
-       rwrad = 0.5*xdia(mgs,lr,3)
-       
-       slope1 = (ew(icp1, ir  ) - ew(ic,ir  ))*cwr(ic,2)
-       slope2 = (ew(icp1, irp1) - ew(ic,irp1))*cwr(ic,2)
-
-!       write(iunit,*) 'slop1: ',slope1,slope2,ew(ic,ir),cwr(ic,2)
+      real ssival,tqvcon
+      real cdx(lc:lhab)
+      real cnox
+      real cval,aval,eval,fval,gval ,qsign,ftelwc,qconkq,elecfac,altelecfac
+      real qconm,qconn,cfce15,gf8,gf4i,gf3p5,gf1a,gf1p5,qdiff,argrcnw
+      real c4,bradp,bl2,bt2,dtrh,hrifac, hdia0,hdia1,civenta,civentb
+      real civentc,civentd,civente,civentf,civentg,cireyn,xcivent
+      real cipventa,cipventb,cipventc,cipventd,cipreyn,cirventa
+      real cirventb
+      integer igmrwa,igmrwb,igmswa, igmswb,igmfwa,igmfwb,igmhwa,igmhwb
+      real rwventa ,rwventb,swventa,swventb,fwventa,fwventb,fwventc
+      real hwventa,hwventb
+      real    hwventc, hlventa, hlventb,  hlventc
+      real  glventa, glventb, glventc
+      real   gmventa, gmventb,  gmventc, ghventa, ghventb, ghventc
+      real  dzfacp,  dzfacm,  cmassin,  cwdiar 
+      real  rimmas, rhobar
+      real   argtim, argqcw, argqxw, argtem
+      real   frcswsw, frcswgl, frcswgm, frcswgh, frcswfw, frcswsw1
+      real   frcglgl, frcglgm, frcglgh,  frcglfw, frcglgl1
+      real   frcgmgl, frcgmgm, frcgmgh,  frcgmfw, frcgmgm1
+      real   frcghgl, frcghgm, frcghgh,  frcghfw,  frcghgh1
+      real   frcfwgl, frcfwgm, frcfwgh, frcfwfw,  frcfwfw1
+      real   frcswrsw, frcswrgl,  frcswrgm,  frcswrgh, frcswrfw
+      real   frcswrsw1
+      real   frcrswsw, frcrswgl, frcrswgm, frcrswgh, frcrswfw
+      real  frcrswsw1
+      real  frcglrgl, frcglrgm, frcglrgh,  frcglrfw, frcglrgl1
+      real  frcrglgl
+      real  frcrglgm,  frcrglgh, frcrglfw, frcrglgl1
+      real  frcgmrgl, frcgmrgm, frcgmrgh, frcgmrfw,  frcgmrgm1
+      real  frcrgmgl, frcrgmgm,  frcrgmgh, frcrgmfw, frcrgmgm1
+      real  sum,  qweps,  gf2a, gf4a, dqldt, dqidt, dqdt
+      real frcghrgl, frcghrgm, frcghrgh, frcghrfw, frcghrgh1, frcrghgl
+      real frcrghgm, frcrghgh,  frcrghfw, frcrghgh1
+      real    a1,a2,a3,a4,a5,a6
+      real   gamss
+      real cdw, cdi, denom1, denom2, delqci1, delqip1
+      real cirtotn,  ciptotn, cgmtotn, chltotn,  cirtotp
+      real  cgmfac, chlfac,  cirfac
+      integer igmhla, igmhlb, igmgla, igmglb, igmgma,  igmgmb
+      integer igmgha, igmghb
+      integer idqis, item, itim0 
+      integer  iqgl, iqgm, iqgh, iqrw, iqsw 
+      integer  itertd, ia
+      
+      integer :: infdo
+      
+      real tau, ewtmp
+      real ftau
+      
+      integer cntnic_noliq
+      real     q_noliqmn, q_noliqmx
+      real     scsacimn, scsacimx
+      
+      real :: dtpinv
+      
+!   arrays for temporary bin space
 
-       x1 = ew(ic,  ir) + slope1*Max(0.0, (cwrad - cwr(ic,1)) )
-       x2 = ew(icp1,ir) + slope2*Max(0.0, (cwrad - cwr(ic,1)) )
+      real :: qhmlrtmp,qhmlrtmp2, chmlrtmp, chmlrtmpd1inf, chlmlrtmp, zhlmlrtmp, zhlmlrrtmp, qvs0,tmpcmlt
 
-       slope1 = (x2 - x1)*grad(ir,2)
+      real :: term1,term2,term3,term4
+      real :: qaacw ! combined qsacw-qhacw for WSM6 variation
 
-       erw(mgs) = Max(0.0, x1 + slope1*Max(0.0, (rwrad - grad(ir,1)) ))
 
-!       write(iunit,*) 'erw: ',erw(mgs),1.e6*cwrad,1.e6*rwrad,ic,ir,x1,x2
-!       write(iunit,*)
+! inline function for charging formula
+      ftau(tau) = (-1.7e-5)*tau**3 - 0.003*tau**2 - 0.05*tau + 0.13
 
-       erw(mgs) = Max(0.0, erw(mgs) )
-       IF ( rwrad .lt. 50.e-6 ) THEN
-         erw(mgs) = 0.0
-       ELSEIF (  rwrad .lt. 100.e-6 ) THEN  ! linear change from zero at 50 to erw at 100 microns
-         erw(mgs) = erw(mgs)*(rwrad - 50.e-6)/50.e-6
-       ENDIF
 
-       ENDIF
-      end if
-      IF ( cx(mgs,lc) .le. 0.0 ) erw(mgs) = 0.0
 !
-      if ( qx(mgs,lr).gt.qxmin(lr) .and. qx(mgs,lr).gt.qxmin(lr) ) then
-      err(mgs)=1.0
-      end if
+! ####################################################################
 !
-      if ( qx(mgs,lr).gt.qxmin(lr) .and. qx(mgs,ls).gt.qxmin(ls) ) then
-      ers(mgs)=1.0
-      end if
+!  Start routine
 !
-      if ( qx(mgs,lr).gt.qxmin(lr) .and. qx(mgs,li).gt.qxmin(li) ) then
-!        IF ( vtxbar(mgs,lr,1) .gt. vtxbar(mgs,li,1) .and.
-!     :       xdia(mgs,lr,3) .gt. 200.e-6 .and. xdia(mgs,li,3) .gt. 100.e-6 ) THEN
-         eri(mgs) = eri0
-!      cwrad = 0.5*xdia(mgs,li,3)
-!      eri(mgs) =
-!     >  1.0*min((aradcw + cwrad*(bradcw + cwrad*
-!     <  (cradcw + cwrad*(dradcw)))), 1.0)
-!         ENDIF
-!       if ( xdia(mgs,li,1) .lt. 10.e-6 ) eri(mgs)=0.0
-       if ( xdia(mgs,li,3) .lt. eri_cimin ) eri(mgs)=0.0
-      end if
+! ####################################################################
+
+
+
 !
+
+       pb(:) = 0.0
+       pinit(:) = 0.0
+      itile = nx
+      jtile = ny
+      ktile = nz
+      ixend = nx
+      jyend = ny
+      kzend = nz
+      nxend = nx + 1
+      nyend = ny + 1
+      nzend = nz
+      kzbeg = 1
+      nzbeg = 1
+
+      istag = 0
+      jstag = 0
+      kstag = 1
+
+
 !
-!  Snow aggregates: Collection (cxc) efficiencies
+!  slope intercepts
 !
-! Modified by ERM with a linear function for small droplets and large
-! snow agg. based numerical data from Wang and Ji (1992) in P&K 1997 (Fig. 14-13), which
-! allows collection of very small droplets, albeit at low efficiency.  But slow
-! fall speeds of snow make up for the efficiency.
+
+      IF ( ngs .lt. nz ) THEN
+!       write(0,*) 'Error in ICEZVD: Must have ngs .ge. nz!'
+!       STOP
+      ENDIF
+
+      cntnic_noliq = 0
+      q_noliqmn = 0.0
+      q_noliqmx = 0.0
+      scsacimn = 0.0
+      scsacimx = 0.0
+
+      ldovol = .false.
+
+      DO il = lc,lhab
+        ldovol = ldovol .or. ( lvol(il) .gt. 1 )
+      ENDDO
+
+      delqnxa(lc:lqmx) = 0.0 ! delqnia
+      delqxxa(lc:lqmx) = 0.0 ! delqxia
+
+      delqnxa(li) = delqnia
+      delqxxa(li) = delqxia
+
+      IF ( lis > 1 ) THEN
+        delqnxa(lis) = delqnia
+        delqxxa(lis) = delqxia
+      ENDIF
+
+      delqnxa(ls) = delqnsa
+      delqxxa(ls) = delqxsa
+
+!      DO il = lc,lhab
+!        write(iunit,*) 'delqnxa(',il,') = ',delqnxa(il)
+!      ENDDO
+      
 !
-      esw(mgs) = 0.0
-      if ( qx(mgs,ls).gt.qxmin(ls) .and. qx(mgs,lc).gt.qxmin(lc) ) then
-        esw(mgs) = 0.5
-        if ( xdia(mgs,lc,1) .gt. 15.e-6 .and. xdia(mgs,ls,1) .gt. 100.e-6) then
-          esw(mgs) = 0.5
-        ELSEIF ( xdia(mgs,ls,1) .ge. 500.e-6 ) THEN
-          esw(mgs) = Min(0.5, 0.05 + (0.8-0.05)/(40.e-6)*xdia(mgs,lc,1) )
-        ENDIF
-      end if
+!  density maximums and minimums
 !
-      if ( qx(mgs,ls).gt.qxmin(ls) .and. qx(mgs,lr).gt.qxmin(lr)  &
-     &     .and. temg(mgs) .lt. tfr - 1.   &
-     &                               ) then
-      esr(mgs)=Exp(-(40.e-6)**3/xv(mgs,lr))*Exp(-40.e-6/xdia(mgs,ls,1))
-      IF ( qx(mgs,ls) < 1.e-4 .and. qx(mgs,lr) < 1.e-4 ) il2(mgs) = 1
-      end if
-      
-      IF ( ipconc < 3 .and. temg(mgs) < tfr .and. qx(mgs,lr).gt.qxmin(lr) .and. qx(mgs,lr) < 1.e-4 ) THEN
-        il3(mgs) = 1
-      ENDIF
+
 !
-!      if ( qx(mgs,ls).gt.qxmin(ls) ) then
-      if ( temcg(mgs) < 0.0 ) then
-            
-      IF ( ipconc .lt. 4 .or. temcg(mgs) < esstem1 ) THEN
-        ess(mgs) = 0.0
-!        ess(mgs)=0.1*exp(0.1*min(temcg(mgs),0.0))
-!        ess(mgs)=min(0.1,ess(mgs))
-      
-      ELSE
-      
-        fac = Abs(ess0)
-        IF ( .true. .and. ess0 < 0.0 ) THEN
-!         IF ( wvel(mgs) > 2.0 .or. wvel(mgs) < -0.5 .or. ssi(mgs) < 1.0 ) THEN
-         IF ( wvel(mgs) > 2.0 ) THEN
-          ! assume convective cell or downdraft
-           fac = 0.0
-         ELSEIF ( wvel(mgs) > 1.0 ) THEN ! transition to stratiform range of values
-           fac = Max(0.0, 2.0 - wvel(mgs))*fac
-         ENDIF
-        ENDIF
-        
-        IF ( temcg(mgs) > esstem1 .and. temcg(mgs) < esstem2 ) THEN  ! only nonzero for T > -25
-          ess(mgs) = fac*Exp(ess1*(esstem2) )*(temcg(mgs) - esstem1)/(esstem2 - esstem1) ! linear ramp up from zero at esstem1 to value at esstem2
-        ELSEIF ( temcg(mgs) >= esstem2 ) THEN
-          ess(mgs) = fac*Exp(ess1*Min( temcg(mgs), 0.0 ) )
-        ENDIF
-        
-      ENDIF
-      end if
+!  Set terminal velocities...
+!    also set drag coefficients
 !
-      if ( qx(mgs,ls).gt.qxmin(ls) .and. qx(mgs,li).gt.qxmin(li) ) then
-       esiclsn(mgs) = esi_collsn
-!      IF ( ipconc .lt. 4 ) THEN
-      IF ( ipconc < 1 .and. lwsm6 ) THEN
-        esi(mgs) = exp(0.7*min(temcg(mgs),0.0))
-      ELSE
-        esi(mgs) = esi0*exp(0.1*min(temcg(mgs),0.0))
-        esi(mgs) = Min(0.1,esi(mgs))
-      ENDIF
-      IF ( ipconc .le. 3 ) THEN
-       esi(mgs) =  exp(0.025*min(temcg(mgs),0.0)) ! LFO
-!       esi(mgs) =  Min(0.5, exp(0.025*min(temcg(mgs),0.0)) ) ! LFO
-!       esi(mgs)=0.5*exp(0.1*min(temcg(mgs),0.0))  ! 10ice
-      ENDIF
-!      ELSE ! zrnic/ziegler 1993
-!      esi(mgs)= 0.1 ! 0.5*exp(0.1*min(temcg(mgs),0.0))
-!      ENDIF
-      if ( temg(mgs) .gt. 273.15 ) esi(mgs) = 0.0
-      end if
+
+      dtpinv = 1.d0/dtp
+
 !
+
 !
+!  electricity constants
 !
+!  mixing ratio epsilon
 !
-!  Graupel: Collection (cxc) efficiencies
+      qeps  = 1.0e-20
+
+!  rebound efficiency (erbnd)
 !
 !
-       xmascw(mgs) = xmas(mgs,lc)
-      if ( qx(mgs,lh).gt.qxmin(lh) .and. qx(mgs,lc).gt.qxmin(lc) ) then
-       ehw(mgs) = 1.0
-       IF ( iehw .eq. 0 ) THEN
-       ehw(mgs) = ehw0  ! default value is 1.0
-       ELSEIF ( iehw .eq. 1 .or. iehw .eq. 10 ) THEN
-      cwrad = 0.5*xdia(mgs,lc,1)
-      ehw(mgs) = Min( ehw0,    &
-     &  ewfac*min((aradcw + cwrad*(bradcw + cwrad*   &
-     &  (cradcw + cwrad*(dradcw)))), 1.0) )
-      
-       ELSEIF ( iehw .eq. 2 .or. iehw .eq. 10 ) THEN
-       ic = icwr(mgs)
-       icp1 = Min( 8, ic+1 )
-       ir = igwr(mgs)
-       irp1 = Min( 6, ir+1 )
-       cwrad = 0.5*xdia(mgs,lc,1)
-       rwrad = 0.5*xdia(mgs,lh,3)  ! changed to mean volume diameter
-       
-       slope1 = (ew(icp1, ir  ) - ew(ic,ir  ))*cwr(ic,2)
-       slope2 = (ew(icp1, irp1) - ew(ic,irp1))*cwr(ic,2)
- 
-!        write(iunit,*) 'slop1: ',slope1,slope2,ew(ic,ir),cwr(ic,2)
-
-       x1 = ew(ic,  ir) + slope1*Max(0.0, (cwrad - cwr(ic,1)) )
-       x2 = ew(icp1,ir) + slope2*Max(0.0, (cwrad - cwr(ic,1)) )
-       
-       slope1 = (x2 - x1)*grad(ir,2)
-       
-       tmp = Max( 0.0, Min( 1.0, x1 + slope1*Max(0.0, (rwrad - grad(ir,1)) ) ) )
-       ehw(mgs) = Min( ehw(mgs), tmp )
-
-!       write(iunit,*) 'ehw: ',ehw(mgs),1.e6*cwrad,1.e6*rwrad,ic,ir,x1,x2
-!       write(iunit,*)
-
-!       ehw(mgs) = Max( 0.2, ehw(mgs) )
-!  assume that ehw = 1 for zero air resistance (rho0 = 0.0) and extrapolate toward that
-!      ehw(mgs) = ehw(mgs) + (ehw(mgs) - 1.0)*(rho0(mgs) - rho00)/rho00
-!      ehw(mgs) = ehw(mgs) + (1.0 - ehw(mgs))*((Max(0.0,rho00 - rho0(mgs)))/rho00)**2
-
-       ELSEIF ( iehw .eq. 3 .or. iehw .eq. 10 ) THEN ! use fraction of droplets greater than dmincw diameter
-         tmp = Exp(- (dmincw/xdia(mgs,lc,1))**3)
-         xmascw(mgs) = xmas(mgs,lc) + xdn0(lc)*(pi*dmincw**3/6.0) ! this is the average mass of the droplets with d > dmincw
-         ehw(mgs) = Min( ehw(mgs), tmp )
-       ELSEIF ( iehw .eq. 4 .or. iehw .eq. 10 ) THEN ! Cober and List 1993
-         tmp =  &
-     &   2.0*xdn(mgs,lc)*vtxbar(mgs,lh,1)*(0.5*xdia(mgs,lc,1))**2 &
-     &  /(9.0*fadvisc(mgs)*0.5*xdia(mgs,lh,3))
-         tmp = Max( 1.5, Min(10.0, tmp) )
-         ehw(mgs) = Min( ehw(mgs), 0.55*Log10(2.51*tmp) )
-       ENDIF
-      if ( xdia(mgs,lc,1) .lt. 2.4e-06 ) ehw(mgs)=0.0
-
-       ehw(mgs) = Min( ehw0, ehw(mgs) )
-       
-       IF ( ibfc == -1 .and. temcg(mgs) < -41.0 ) THEN
-        ehw(mgs) = 0.0
-       ENDIF 
+!
+!  constants
+!
 
-      end if
+      cp608 = 0.608
+      aradcw = -0.27544
+      bradcw = 0.26249e+06
+      cradcw = -1.8896e+10
+      dradcw = 4.4626e+14
+      bta1 = 0.6
+      cnit = 1.0e-02
+      dragh = 0.60
+      dnz00 = 1.225
+!      cs = 4.83607122
+!      ds = 0.25
+!  new values for  cs and ds
+      cs = 12.42
+      ds = 0.42
+      pii = piinv ! 1./pi
+      pid4 = pi/4.0 
+!      qscrit = 6.0e-04
+      gf1 = 1.0 ! gamma(1.0)
+      gf1p5 = 0.8862269255  ! gamma(1.5)
+      gf2 = 1.0 ! gamma(2.0)
+      gf3 = 2.0 ! gamma(3.0)
+      gf3p5 = 3.32335097 ! gamma(3.5)
+      gf4 = 6.00 ! gamma(4.0)
+      gf5 = 24.0 ! gamma(5.0)
+      gf6 = 120.0 ! gamma(6.0)
+      gf7 = 720.0 ! gamma(7.0)
+      gf4br = 17.837861981813607 ! gamma(4.0+br)
+      gf4ds = 10.41688578110938 ! gamma(4.0+ds)
+      gf4p5 = 11.63172839656745 ! gamma(4.0+0.5)
+      gf3ds = 3.0458730354120997 ! gamma(3.0+ds)
+      gf1ds = 0.8863557896089221 ! gamma(1.0+ds)
+      gr = 9.8
+      gf43rds = 0.8929795116 ! gamma(4./3.)
+      gf53rds = 0.9027452930 ! gamma(5./3.)
+      gf73rds = 1.190639349 ! gamma(7./3.)
+      gf83rds = 1.504575488 ! gamma(8./3.)
+      
+      gamice73fac =  (Gamma_sp(7./3. + cinu))**3/ (Gamma_sp(1. + cinu)**3 * (1. + cinu)**4)
+      gamsnow73fac =  (Gamma_sp(7./3. + snu))**3/ (Gamma_sp(1. + snu)**3 * (1. + snu)**4)
+      
+      gcnup1 = Gamma_sp(cnu + 1.)
+      gcnup2 = Gamma_sp(cnu + 2.)
 !
-      if ( qx(mgs,lh).gt.qxmin(lh) .and. qx(mgs,lr).gt.qxmin(lr)    &
-!     &     .and. temg(mgs) .lt. tfr    &
-     &                               ) then
-!      ehr(mgs) = Exp(-(40.e-6)**3/xv(mgs,lr))*Exp(-40.e-6/xdia(mgs,lh,1))
-!      ehr(mgs) = 1.0
-       ehr(mgs) = Exp(-(40.e-6)/xdia(mgs,lr,3))*Exp(-40.e-6/xdia(mgs,lh,3))
-       ehr(mgs) = Min( ehr0, ehr(mgs) )
-      end if
+!  constants
 !
-      IF ( qx(mgs,ls).gt.qxmin(ls) ) THEN
-        IF ( ipconc .ge. 4 ) THEN
-        ehscnv(mgs) = ehs0*exp(ehs1*min(temcg(mgs),0.0)) ! for 2-moment, used as default for ehs and ehls. Otherwise not used for snow->graupel conversion
-        ELSE
-        ehscnv(mgs) = exp(0.09*min(temcg(mgs),0.0))
-        ENDIF
-        if ( qx(mgs,lh).gt.qxmin(lh) .and. qx(mgs,lc) > qxmin(lc)  ) then
-          ehsclsn(mgs) = ehs_collsn
-          IF ( xdia(mgs,ls,3) < 40.e-6 ) THEN
-            ehsclsn(mgs) = 0.0
-          ELSEIF ( xdia(mgs,ls,3) < 150.e-6 ) THEN
-            ehsclsn(mgs) =  ehs_collsn*(xdia(mgs,ls,3) - 40.e-6)/(150.e-6 - 40.e-6)
-          ELSE
-            ehsclsn(mgs) = ehs_collsn
-          ENDIF
-!          ehs(mgs) = ehscnv(mgs)*Min(1.0, Max(0., xdn(mgs,lh) - xdnmn(lh)*1.2)/xdnmn(lh)  ) ! shut off qhacs as graupel goes to lowest density
-          ehs(mgs) = ehscnv(mgs)*Min(1.0, Max(0.0,xdn(mgs,lh) - 300.)/300.  ) ! shut off qhacs as graupel goes to low density
-          ehs(mgs) = Min(ehs(mgs),ehsmax)
-          IF ( qx(mgs,lc) < qxmin(lc) ) ehs(mgs) = 0.0
-        end if
-      ENDIF
 !
-      if ( qx(mgs,lh).gt.qxmin(lh) .and. qx(mgs,li).gt.qxmin(li) ) then
-      ehiclsn(mgs) = ehi_collsn
-      ehi(mgs)=eii0*exp(eii1*min(temcg(mgs),0.0))
-      ehi(mgs) = Min( ehimax, Max( ehi(mgs), ehimin ) )
-      if ( temg(mgs) .gt. 273.15 .or. ( qx(mgs,lc) < qxmin(lc)) ) ehi(mgs) = 0.0
-      end if
+!  general constants for microphysics
+!
+      brz = 100.0
+      arz = 0.66
+      
+      bfnu1 = (4. + alphar)*(5. + alphar)*(6. + alphar)/ &
+     &       ((1. + alphar)*(2. + alphar)*(3. + alphar))
 
-      IF ( lis > 1 ) THEN
-      if ( qx(mgs,lh).gt.qxmin(lh) .and. qx(mgs,lis).gt.qxmin(lis) ) then
-      ehisclsn(mgs) = ehi_collsn
-      ehis(mgs)=eii0*exp(eii1*min(temcg(mgs),0.0))
-      ehis(mgs) = Min( ehimax, Max( ehis(mgs), ehimin ) )
-      if ( temg(mgs) .gt. 273.15 .or. ( qx(mgs,lc) < qxmin(lc)) ) ehis(mgs) = 0.0
-      end if
-      ENDIF
+       galpharaut = (6.+alpharaut)*(5.+alpharaut)*(4.+alpharaut)/ &
+     &             ((3.+alpharaut)*(2.+alpharaut)*(1.+alpharaut))
+      
+      vfrz = 0.523599*(dfrz)**3 
+      vmlt = Min(xvmx(lr), 0.523599*(dmlt)**3 )
+      vshd = Min(xvmx(lr), 0.523599*(dshd)**3 )
 
+      snowmeltmass = pi/6.0 * 1000. * snowmeltdia**3  ! maximum rain particle mass from melting snow (if snowmeltdia > 0)
 
+      tdtol = 1.0e-05
+      tfrcbw = tfr - cbw
+      tfrcbi = tfr - cbi
 !
 !
-!  Hail: Collection (cxc) efficiencies
+! #ifdef COMMAS
+!      print*,'ventr,ventc = ',ventr,ventc
+
 !
+!  Set up look up tables for supersaturation w.r.t. liq and ice
 !
-      IF ( lhl .gt. 1 ) THEN
+!VD$L SKIP
+!      do l = 1,nqsat
+!      temq = 163.15 + (l-1)*fqsat
+!      tabqvs(l) = exp(caw*(temq-273.15)/(temq-cbw))
+!      tabqis(l) = exp(cai*(temq-273.15)/(temq-cbi))
+!      end do
 
-      if ( qx(mgs,lhl).gt.qxmin(lhl) .and. qx(mgs,lc).gt.qxmin(lc) ) then
-       IF ( iehw == 3 ) iehlw = 3
-       IF ( iehw == 4 ) iehlw = 4
-       ehlw(mgs) = ehlw0
-       IF ( iehlw .eq. 0 ) THEN
-       ehlw(mgs) = ehlw0  ! default value is 1.0
-       ELSEIF ( iehlw .eq. 1 .or. iehlw .eq. 10 ) THEN
-      cwrad = 0.5*xdia(mgs,lc,1)
-      ehlw(mgs) = Min( ehlw0,    &
-     &  ewfac*min((aradcw + cwrad*(bradcw + cwrad*   &
-     &  (cradcw + cwrad*(dradcw)))), 1.0) )
+      mltmass1inv = 1.0/( 1000.0*(4.0*pi/3.0)*((0.01*0.5*takshedsize1)**3) ) ! for drops melting from ice with diameter > 1.9cm
+      mltmass2inv = 1.0/( 1000.0*(4.0*pi/3.0)*((0.01*0.5*takshedsize2)**3) ) ! for drops melting from ice with 0.9cm < d < 1.9cm
+      mltmass1cgs =  1.0*(4.0*pi/3.0)*((0.5*takshedsize1)**3) 
+      mltmass2cgs =  1.0*(4.0*pi/3.0)*((0.5*takshedsize2)**3) 
       
-       ELSEIF ( iehlw .eq. 2 .or. iehlw .eq. 10 ) THEN
-       ic = icwr(mgs)
-       icp1 = Min( 8, ic+1 )
-       ir = ihlr(mgs)
-       irp1 = Min( 6, ir+1 )
-       cwrad = 0.5*xdia(mgs,lc,1)
-       rwrad = 0.5*xdia(mgs,lhl,3)  ! changed to mean volume diameter
-       
-       slope1 = (ew(icp1, ir  ) - ew(ic,ir  ))*cwr(ic,2)
-       slope2 = (ew(icp1, irp1) - ew(ic,irp1))*cwr(ic,2)
-       
-       x1 = ew(ic,  ir) + slope1*(cwrad - cwr(ic,1))
-       x2 = ew(icp1,ir) + slope2*(cwrad - cwr(ic,1))
-       
-       slope1 = (x2 - x1)*grad(ir,2)
-       
-       tmp = Max( 0.0, Min( 1.0, x1 + slope1*(rwrad - grad(ir,1)) ) )
-         ehlw(mgs) = Min( ehlw(mgs), tmp )
-       ehlw(mgs) = Min( ehlw0, ehlw(mgs) )
-!       ehw(mgs) = Max( 0.2, ehw(mgs) )
-!  assume that ehw = 1 for zero air resistance (rho0 = 0.0) and extrapolate toward that
-!      ehw(mgs) = ehw(mgs) + (ehw(mgs) - 1.0)*(rho0(mgs) - rho00)/rho00
-!      ehlw(mgs) = ehlw(mgs) + (1.0 - ehlw(mgs))*((Max(0.0,rho00 - rho0(mgs)))/rho00)**2
+!      real, parameter :: mltdiam1 = 9.0e-3, mltdiam2 = 19.0e-3, mltdiam05 = 4.5e-3
 
-       ELSEIF ( iehlw .eq. 3 .or. iehlw .eq. 10 ) THEN ! use fraction of droplets greater than 15 micron diameter
-         tmp = Exp(- (dmincw/xdia(mgs,lc,1))**3)
-         ehlw(mgs) = Min( ehlw(mgs), tmp )
-       ELSEIF ( iehlw .eq. 4 .or. iehlw .eq. 10 ) THEN ! Cober and List 1993
-         tmp =  &
-     &   2.0*xdn(mgs,lc)*vtxbar(mgs,lhl,1)*(0.5*xdia(mgs,lc,1))**2 &
-     &  /(9.0*fadvisc(mgs)*0.5*xdia(mgs,lhl,3))
-         tmp = Max( 1.5, Min(10.0, tmp) )
-         ehlw(mgs) = Min( ehlw(mgs), 0.55*Log10(2.51*tmp) )
-       ENDIF
-      if ( xdia(mgs,lc,1) .lt. 2.4e-06 ) ehlw(mgs)=0.0
-       ehlw(mgs) = Min( ehlw0, ehlw(mgs) )
+      IF ( .false. ) THEN
+        numdiam = 1 ! must have numdiam < ndiam because numdiam+1 holds values for the interval of mltdiam(numdiam) to mltdiam(ndiam+1)
+        mltdiam(1) = 4.5e-3
+      ELSEIF ( .true. ) THEN
+        numdiam = 2 ! must have numdiam < ndiam because numdiam+1 holds values for the interval of mltdiam(numdiam) to mltdiam(ndiam+1)
+        mltdiam(1) = 1.5e-3
+        mltdiam(2) = 4.5e-3
+      ELSE
+        numdiam = 5 ! must have numdiam < ndiam because numdiam+1 holds values for the interval of mltdiam(numdiam) to mltdiam(ndiam+1)
+        mltdiam(1) = 0.5e-3
+        mltdiam(2) = 1.0e-3
+        mltdiam(3) = 2.0e-3
+        mltdiam(4) = 4.0e-3
+        mltdiam(5) = 6.0e-3
+      ENDIF
 
-       IF ( ibfc == -1 .and. temcg(mgs) < -41.0 ) THEN 
-        ehlw(mgs) = 0.0
-       ENDIF 
 
-      end if
-!
-      if ( qx(mgs,lhl).gt.qxmin(lhl) .and. qx(mgs,lr).gt.qxmin(lr)    &
-!     &     .and. temg(mgs) .lt. tfr    &
-     &                               ) then
-        ehlr(mgs) = 1.0
-       ehlr(mgs) = Min( ehlr0, ehlr(mgs) )
-      end if
+      mltdiam(ndiam+1) = mltdiam1 !  9.0e-3
+      mltdiam(ndiam+2) = mltdiam2 ! 19.0e-3
+      mltdiam(ndiam+3) = mltdiam3 !100.0e-3
+
+      kzb = 1
+      kze = ktile
+!      if (kzend .eq. nzend) kze = kzend-kzbeg+1-kstag
+
 !
-      IF ( qx(mgs,ls).gt.qxmin(ls) ) THEN
-        if ( qx(mgs,lhl).gt.qxmin(lhl)  ) then
-          ehlsclsn(mgs) = ehls_collsn
-          ehls(mgs) = ehscnv(mgs)
-          ehls(mgs) = Min(ehls(mgs),ehsmax)
-        end if
-      ENDIF
+!  cw constants in mks units
 !
-      if ( qx(mgs,lhl).gt.qxmin(lhl) .and. qx(mgs,li).gt.qxmin(li) ) then
-      ehliclsn(mgs) = ehli_collsn
-      ehli(mgs)=eii0hl*exp(eii1hl*min(temcg(mgs),0.0))
-      ehli(mgs) = Min( ehimax, Max( ehli(mgs), ehimin ) )
-      if ( temg(mgs) .gt. 273.15 .or. ( qx(mgs,lc) < qxmin(lc)) ) ehli(mgs) = 0.0
-      end if
-
-      IF ( lis > 1 ) THEN
-      if ( qx(mgs,lhl).gt.qxmin(lhl) .and. qx(mgs,lis).gt.qxmin(lis) ) then
-      ehlisclsn(mgs) = ehli_collsn
-      ehlis(mgs)=eii0*exp(eii1*min(temcg(mgs),0.0))
-      ehlis(mgs) = Min( ehimax, Max( ehlis(mgs), ehimin ) )
-      if ( temg(mgs) .gt. 273.15 .or. ( qx(mgs,lc) < qxmin(lc)) ) ehlis(mgs) = 0.0
-      end if
+!      cwmasn = 4.25e-15  ! radius of 1.0e-6
+      mwfac = 6.0**(1./3.)
+      IF ( ipconc .ge. 2 ) THEN
+!        cwmasn = xvmn(lc)*1000.
+!        cwradn = 1.0e-6
+!        cwmasx = xvmx(lc)*1000.
       ENDIF
+        rwmasn = xvmn(lr)*1000.
+        rwmasx = xvmx(lr)*1000.
 
-
-      ENDIF ! lhl .gt. 1
-
-      ENDDO  ! mgs loop for collection efficiencies
-
-!
-!
 !
-!  Set flags for plates vs. columns
+!  ci constants in mks units
 !
+      cimasn = Min(cimas0, cimas1) ! 12 microns for  0.1871*(xmas(mgs,li)**(0.3429))
+      cimasx = 1.0e-8   ! 338 microns
+      ccimx = 5000.0e3   ! max of 5000 per liter
+
 !
-      do mgs = 1,ngscnt
+!  constants for paramerization
 !
-      xplate(mgs) = 0.0
-      xcolmn(mgs) = 1.0
 !
-!      if ( temcg(mgs) .lt. 0. .and. temcg(mgs) .ge. -4. ) then
-!      xplate(mgs) = 1.0
-!      xcolmn(mgs) = 0.0
-!      end if
-!c
-!      if ( temcg(mgs) .lt. -4. .and. temcg(mgs) .ge. -9. ) then
-!      xplate(mgs) = 0.0
-!      xcolmn(mgs) = 1.0
-!      end if
-!c
-!      if ( temcg(mgs) .lt. -9. .and. temcg(mgs) .ge. -22.5 ) then
-!      xplate(mgs) = 1.0
-!      xcolmn(mgs) = 0.0
-!      end if
-!c
-!      if ( temcg(mgs) .lt. -22.5 .and. temcg(mgs) .ge. -90. ) then
-!      xplate(mgs) = 0.0
-!      xcolmn(mgs) = 1.0
-!      end if
+!  set save counter (number of saves):  nsvcnt
 !
-      end do
+!      nsvcnt = 0
+      iend = 0
+
+
+!      timetd1 = etime(tarray)
+!      timetd1 = tarray(1)
+
 !
+!***********************************************************
+!  start jy loop
+!***********************************************************
 !
+
+!      do 9999 jy = 1,ny-jstag
 !
-!  Collection growth equations....
+!  VERY IMPORTANT:  SET jy = jgs
 !
+      jy = jgs
+     
+     
+!      t1(:,:,:) = 0
+!      t2(:,:,:) = 0
+!      t3(:,:,:) = 0
+!      t4(:,:,:) = 0
+!      t5(:,:,:) = 0
+!      t6(:,:,:) = 0
+!      t8(:,:,:) = 0
+      
+      IF ( ipconc < 2 ) THEN ! Make a copy of cloud droplet mixing ratio to use for homogeneous freezing
+        DO kz = 1,kze
+         DO ix = 1,itile
+           t9(ix,jy,kz) = an(ix,jy,kz,lc)
+         ENDDO
+        ENDDO
+      ENDIF
+      
 !
-      if (ndebug .gt. 0 ) write(0,*) 'Collection: rain collects xxxxx'
+!..Gather microphysics  
 !
-      do mgs = 1,ngscnt
-      qracw(mgs) =  0.0
-      IF ( qx(mgs,lr) .gt. qxmin(lr) .and. erw(mgs) .gt. 0.0 ) THEN
-      IF ( ipconc .lt. 3 ) THEN
-       IF ( erw(mgs) .gt. 0.0 .and. qx(mgs,lr) .gt. 1.e-7 ) THEN
-       vt = (ar*(xdia(mgs,lc,1)**br))*rhovt(mgs)
-       qracw(mgs) =    &
-     &   (0.25)*pi*erw(mgs)*qx(mgs,lc)*cx(mgs,lr) &
-!     >  *abs(vtxbar(mgs,lr,1)-vtxbar(mgs,lc,1))   &
-     &  *Max(0.0, vtxbar(mgs,lr,1)-vt)   &
-     &  *(  gf3*xdia(mgs,lr,2)    &
-     &    + 2.0*gf2*xdia(mgs,lr,1)*xdia(mgs,lc,1)    &
-     &    + gf1*xdia(mgs,lc,2) )
-!       qracw(mgs) = 0.0
-!      write(iunit,*) 'qracw,cx =',qracw(mgs),1.e6*xdia(mgs,lr,1),erw(mgs)
-!      write(iunit,*) 'qracw,cx =',qracw(mgs),cx(mgs,lc),kgs(mgs),cx(mgs,lr),1.e6*xdia(mgs,lr,1),vtxbar(mgs,lr,1),vt
-!      write(iunit,*) 'vtr: ',vtxbar(mgs,lr,1), ar*gf4br/6.0*xdia(mgs,lr,1)**br, rhovt(mgs),
-!     :         ar*gf4br/6.0*xdia(mgs,lr,1)**br * rhovt(mgs)
-       ENDIF
-      ELSE
-
-      IF ( dmrauto <= 0 .or.  rho0(mgs)*qx(mgs,lr) > 1.2*xl2p(mgs) ) THEN 
-       rwrad = 0.5*xdia(mgs,lr,3)
-        IF ( rwrad .gt. rh(mgs) ) THEN ! .or. cx(mgs,lr) .gt. nh(mgs) ) THEN
-         IF ( rwrad .gt. rwradmn ) THEN
-!      DM1CCC=A2*XNC*XNR*XVC*(((CNU+2.)/(CNU+1.))*XVC+XVR)       ! (A12)
-!     NOTE: Result is independent of imurain, assumes mucloud = 3
-           qracw(mgs) = erw(mgs)*aa2*cx(mgs,lr)*cx(mgs,lc)*xmas(mgs,lc)*   &
-     &        ((cnu + 2.)*xv(mgs,lc)/(cnu + 1.) + xv(mgs,lr))/rho0(mgs) !*rhoinv(mgs)
-         ELSE
+      if ( ndebug .gt. 0 ) write(0,*) 'ICEZVD_GS: ENTER GATHER STAGE'
 
-          IF ( imurain == 3 ) THEN
 
-!      DM1CCC=A1*XNC*XNR*(((CNU+3.)*(CNU+2.)/(CNU+1.)**2)*XVC**3+ ! (A14)
-!     1 ((RNU+2.)/(RNU+1.))*XVC*XVR**2)
+      
+      nxmpb = 1
+      nzmpb = 1
+      nxz = itile*nz
+      numgs = nxz/ngs + 1
+!      write(0,*) 'ICEZVD_GS: ENTER GATHER STAGE: nx,nz,nxz,numgs,ngs = ',nx,nz,nxz,numgs,ngs
 
-!           qracw(mgs) = aa1*cx(mgs,lr)*cx(mgs,lc)*xdn(mgs,lc)*   &
-!     &        ((cnu + 3.)*(cnu + 2.)*xv(mgs,lc)**3/(cnu + 1.)**2 +    &
-!     &         (alpha(mgs,lr) + 2.)*xv(mgs,lc)*xv(mgs,lr)**2/(alpha(mgs,lr) + 1.))/rho0(mgs) !*rhoinv(mgs)
-! save multiplies by converting cx*xdn*xv/rho0 to qx
-           qracw(mgs) = aa1*cx(mgs,lr)*qx(mgs,lc)*   &
-     &        ((cnu + 3.)*(cnu + 2.)*xv(mgs,lc)**2/(cnu + 1.)**2 +    &
-     &         (alpha(mgs,lr) + 2.)*xv(mgs,lr)**2/(alpha(mgs,lr) + 1.)) 
-           
-           ELSE ! imurain == 1
+      do 1000 inumgs = 1,numgs
+      ngscnt = 0
+      
+      do kz = nzmpb,kze
+      do ix = nxmpb,itile
 
-           qracw(mgs) = aa1*cx(mgs,lr)*qx(mgs,lc)*   &
-     &        ((cnu + 3.)*(cnu + 2.)*xv(mgs,lc)**2/(cnu + 1.)**2 +    &
-     &         (alpha(mgs,lr) + 6.)*(alpha(mgs,lr) + 5.)*(alpha(mgs,lr) + 4.)*xv(mgs,lr)**2/ &
-     &          ((alpha(mgs,lr) + 3.)*(alpha(mgs,lr) + 2.)*(alpha(mgs,lr) + 1.))) 
-           
-           ENDIF
-           
-         ENDIF
-        ENDIF
-        ENDIF
-       ENDIF
-!       qracw(mgs) = Min(qracw(mgs), qx(mgs,lc))
-       qracw(mgs) = Min(qracw(mgs), qcmxd(mgs))
-       ENDIF
-      end do
-!
-      do mgs = 1,ngscnt
-      qraci(mgs) = 0.0
-      craci(mgs) = 0.0
-      IF ( eri(mgs) .gt. 0.0 .and. iacr .ge. 1 .and. xdia(mgs,lr,3) .gt. 2.*rwradmn ) THEN
-        IF ( ipconc .ge. 3 ) THEN
+      pqs(1) = t00(ix,jy,kz)
+!      pqs(kz) = t00(ix,jy,kz)
 
-           tmp = eri(mgs)*aa2*cx(mgs,lr)*cx(mgs,li)*   &
-     &        ((cinu + 2.)*xv(mgs,li)/(cinu + 1.) + xv(mgs,lr))
+      theta(1) = an(ix,jy,kz,lt)
+      temg(1) = t0(ix,jy,kz)
+      temcg(1) = temg(1) - tfr
+      tqvcon = temg(1)-cbw
+      ltemq = (temg(1)-163.15)/fqsat+1.5
+      ltemq = Min( nqsat, Max(1,ltemq) )
+      qvs(1) = pqs(1)*tabqvs(ltemq)
+      qis(1) = pqs(1)*tabqis(ltemq)
 
-        qraci(mgs) = Min( qxmxd(mgs,li), tmp*xmas(mgs,li)*rhoinv(mgs) )
-        craci(mgs) = Min( cxmxd(mgs,li), tmp )
+      qss(1) = qvs(1)
 
-!       vt = Sqrt((vtxbar(mgs,lr,1)-vtxbar(mgs,li,1))**2 +
-!     :            0.04*vtxbar(mgs,lr,1)*vtxbar(mgs,li,1) )
-!
-!          qraci(mgs) = 0.25*pi*eri(mgs)*cx(mgs,lr)*qx(mgs,li)*vt*
-!     :         (  da0(lr)*xdia(mgs,lr,3)**2 +
-!     :            dab1(lr,li)*xdia(mgs,lr,3)*xdia(mgs,li,3) +
-!     :            da1(li)*xdia(mgs,li,3)**2 )
-!
-!
-!       vt = Sqrt((vtxbar(mgs,lr,1)-vtxbar(mgs,li,1))**2 +
-!     :            0.04*vtxbar(mgs,lr,1)*vtxbar(mgs,li,1) )
-!
-!          craci(mgs) = 0.25*pi*eri(mgs)*cx(mgs,lr)*cx(mgs,li)*vt*
-!     :         (  da0(lr)*xdia(mgs,lr,3)**2 +
-!     :            dab0(lr,li)*xdia(mgs,lr,3)*xdia(mgs,li,3) +
-!     :            da0(li)*xdia(mgs,li,3)**2 )
-!
-!          qraci(mgs) = Min( qraci(mgs), qxmxd(mgs,li) )
-!          craci(mgs) = Min( craci(mgs), cxmxd(mgs,li) )
+!      IF ( jy .eq. 1 .and. ix .eq. 24 ) THEN
+!       write(91,*) 'kz,qv,th: ',kz,an(ix,jy,kz,lv),an(ix,jy,kz,lt),pqs(kz),tabqvs(ltemq),qvs(kz)
+!      ENDIF
 
-        ELSE
-          qraci(mgs) =    &
-     &     min(   &
-     &     (0.25)*pi*eri(mgs)*qx(mgs,li)*cx(mgs,lr)   &
-     &    *abs(vtxbar(mgs,lr,1)-vtxbar(mgs,li,1))   &
-     &    *(  gf3*xdia(mgs,lr,2)    &
-     &      + 2.0*gf2*xdia(mgs,lr,1)*xdia(mgs,li,1)    &
-     &      + gf1*xdia(mgs,li,2) )     &
-     &    , qimxd(mgs))
-        ENDIF
-      if ( temg(mgs) .gt. 268.15 ) then
-      qraci(mgs) = 0.0
+      if ( temg(1) .lt. tfr ) then
+!      if( qcw(kz) .le. qxmin(lc) .and. qci(kz) .gt. qxmin(li))
+!     >  qss(kz) = qis(kz)
+!      if( qcw(kz) .gt. qxmin(lc) .and. qci(kz) .gt. qxmin(li))
+!     >   qss(kz) = (qcw(kz)*qvs(kz) + qci(kz)*qis(kz)) /
+!     >   (qcw(kz) + qci(kz))
+      qss(1) = qis(1)
+      else
+!       IF ( an(ix,jy,kz,lv)  .gt. qss(kz) ) THEN
+!       write(iunit,*) 'qss exceeded at ',ix,jy,kz,qss(kz),an(ix,jy,kz,lv),temg(kz)
+!       write(iunit,*) 'other temg = ',theta(kz)*(pinit(kz)+p2(ix,jy,kz))
+!       ENDIF
       end if
-      ENDIF
-      end do
 !
-      do mgs = 1,ngscnt
-      qracs(mgs) =  0.0
-      IF ( ers(mgs) .gt. 0.0 .and. ipconc < 3 ) THEN
-       IF ( lwsm6 .and. ipconc == 0 ) THEN
-         vt = vt2ave(mgs)
-       ELSE
-         vt = vtxbar(mgs,ls,1)
-       ENDIF
-      qracs(mgs) =      &
-     &   min(     &
-     &   ((0.25)*pi/gf4)*ers(mgs)*qx(mgs,ls)*cx(mgs,lr)     &
-     &  *abs(vtxbar(mgs,lr,1)-vt)     &
-     &  *(  gf6*gf1*xdia(mgs,ls,2)     &
-     &    + 2.0*gf5*gf2*xdia(mgs,ls,1)*xdia(mgs,lr,1)      &
-     &    + gf4*gf3*xdia(mgs,lr,2) )      &
-     &  , qsmxd(mgs))
+      ishail = .false.
+      IF ( lhl > 1 ) THEN
+        IF ( an(ix,jy,kz,lhl)  .gt. qxmin(lhl) ) ishail = .true.
       ENDIF
-      end do
-
-!
-!
-      if (ndebug .gt. 0 ) write(0,*) 'Collection: snow collects xxxxx'
-!
-      do mgs = 1,ngscnt
-      qsacw(mgs) =  0.0
-      csacw(mgs) =  0.0
-      vsacw(mgs) =  0.0
-      IF ( esw(mgs) .gt. 0.0 ) THEN
-
-       IF ( ipconc .ge. 4 ) THEN
-!      QSACC=CECS*RVT*A2*XNC*XNS*XVC*ROS*
-!     *    (((CNU+2.)/(CNU+1.))*XVC+XVS)/RO
-
-!        tmp = esw(mgs)*rvt*aa2*cx(mgs,ls)*cx(mgs,lc)*
-!     :        ((cnu + 2.)*xv(mgs,lc)/(cnu + 1.) + xv(mgs,ls))
-        tmp = 1.0*rvt*aa2*cx(mgs,ls)*cx(mgs,lc)*   &
-     &        ((cnu + 2.)*xv(mgs,lc)/(cnu + 1.) + xv(mgs,ls))
+      
+      if ( an(ix,jy,kz,lv)  .gt. qss(1) .or.   &
+     &     an(ix,jy,kz,lc)  .gt. qxmin(lc)   .or.    &
+     &     an(ix,jy,kz,li)  .gt. qxmin(li)   .or.   &
+     &     an(ix,jy,kz,lr)  .gt. qxmin(lr)   .or.   &
+     &     an(ix,jy,kz,ls)  .gt. qxmin(ls)   .or.   &
+     &     an(ix,jy,kz,lh)  .gt. qxmin(lh)   .or.  ishail ) then
+      ngscnt = ngscnt + 1
+      igs(ngscnt) = ix
+      kgs(ngscnt) = kz
+      if ( ngscnt .eq. ngs ) goto 1100
+      end if
+      enddo !ix
+      nxmpb = 1
+      enddo !kz
+ 1100 continue
 
-        qsacw(mgs) = Min( qxmxd(mgs,lc), tmp*xmas(mgs,lc)*rhoinv(mgs) )
-        csacw(mgs) = Min( cxmxd(mgs,lc), tmp )
+      if ( ngscnt .eq. 0 ) go to 9998
 
-          IF ( lvol(ls) .gt. 1 ) THEN
-             IF ( temg(mgs) .lt. 273.15) THEN
-             rimdn(mgs,ls) = rimc1*(-((0.5)*(1.e+06)*xdia(mgs,lc,1))   &
-     &                *((0.60)*vtxbar(mgs,ls,1))   &
-     &                /(temg(mgs)-273.15))**(rimc2)
-             rimdn(mgs,ls) = Min( Max( rimc3, rimdn(mgs,ls) ), rimc4 )
-             ELSE
-             rimdn(mgs,ls) = 1000.
-             ENDIF
+      if ( ndebug .gt. 0 ) write(0,*) 'ICEZVD_GS: dbg = 5'
 
-           vsacw(mgs) = rho0(mgs)*qsacw(mgs)/rimdn(mgs,ls)
+!      write(0,*) 'allocating qc'
 
-          ENDIF
+      
+      xv(:,:) = 0.0
+      xmas(:,:) = 0.0
+      vtxbar(:,:,:) = 0.0
+      xdia(:,:,:) = 0.0
+      raindn(:,:) = 900.
+      cx(:,:) = 0.0
+      alpha(:,:) = 0.0
+      DO il = li,lhab
+        DO mgs = 1,ngscnt
+          rimdn(mgs,il)  = rimedens ! xdn0(il)
+        ENDDO
+      ENDDO
+!
+!  define temporaries for state variables to be used in calculations
+!
+      do mgs = 1,ngscnt
+      kgsm(mgs) = max(kgs(mgs)-1,1)
+      kgsp(mgs) = min(kgs(mgs)+1,nz-1)
+      kgsm2(mgs) = Max(kgs(mgs)-2,1)
+      theta0(mgs) = an(igs(mgs),jy,kgs(mgs),lt)
+      thetap(mgs) = an(igs(mgs),jy,kgs(mgs),lt) - theta0(mgs)
+      theta(mgs) = an(igs(mgs),jy,kgs(mgs),lt)
+      qv0(mgs) = an(igs(mgs),jy,kgs(mgs),lv)
+      qwvp(mgs) = an(igs(mgs),jy,kgs(mgs),lv)  - qv0(mgs) ! qv0(mgs) is full qv, so qwvp starts as zero!
 
+      pres(mgs) = pn(igs(mgs),jy,kgs(mgs)) + pb(kgs(mgs))
+      pipert(mgs) = p2(igs(mgs),jy,kgs(mgs))
+      rho0(mgs) = dn(igs(mgs),jy,kgs(mgs))
+      rhoinv(mgs) = 1.0/rho0(mgs)
+      rhovt(mgs) = Sqrt(rho00/rho0(mgs))
+      pi0(mgs) = p2(igs(mgs),jy,kgs(mgs)) + pinit(kgs(mgs))
+      temg(mgs) = t0(igs(mgs),jy,kgs(mgs))
+      temgkm1(mgs) = t0(igs(mgs),jy,kgsm(mgs))
+      temgkm2(mgs) = t0(igs(mgs),jy,kgsm2(mgs))
+      pk(mgs)   = p2(igs(mgs),jy,kgs(mgs)) + pinit(kgs(mgs)) ! t77(igs(mgs),jy,kgs(mgs))
+      temcg(mgs) = temg(mgs) - tfr
+      qss0(mgs) = (380.0)/(pres(mgs))
+      pqs(mgs) = (380.0)/(pres(mgs))
+      ltemq = (temg(mgs)-163.15)/fqsat+1.5
+      ltemq = Min( nqsat, Max(1,ltemq) )
+      qvs(mgs) = pqs(mgs)*tabqvs(ltemq)
+      qis(mgs) = pqs(mgs)*tabqis(ltemq)
+!      es(mgs)  = 6.1078e2*tabqvs(ltemq)
+!      eis(mgs) = 6.1078e2*tabqis(ltemq)
+      cnostmp(mgs) = cno(ls)
+!
 
-!        qsacw(mgs) = cecs*aa2*cx(mgs,ls)*cx(mgs,lc)*xmas(mgs,lc)*
-!     :        ((cnu + 2.)*xv(mgs,lc)/(cnu + 1.) + xv(mgs,ls))*rhoinv(mgs)
-       ELSE
-!      qsacw(mgs) =
-!     >   min(
-!     >   ((0.25)*pi)*esw(mgs)*qx(mgs,lc)*cx(mgs,ls)
-!     >  *abs(vtxbar(mgs,ls,1)-vtxbar(mgs,lc,1))
-!     >  *(  gf3*xdia(mgs,ls,2)
-!     >    + 2.0*gf2*xdia(mgs,ls,1)*xdia(mgs,lc,1)
-!     >    + gf1*xdia(mgs,lc,2) )
-!     <  , qcmxd(mgs))
+      il5(mgs) = 0
+      if ( temg(mgs) .lt. tfr ) then
+      il5(mgs) = 1
+      end if
+      enddo !mgs
+      
+      IF ( ipconc < 1 .and. lwsm6 ) THEN
+        DO mgs = 1,ngscnt
+          tmp = Min( 0.0, temcg(mgs) )
+          cnostmp(mgs) = Min( 2.e8, 2.e6*exp(0.12*tmp) )
+        ENDDO
+      ENDIF
 
-            vt = abs(vtxbar(mgs,ls,1)-vtxbar(mgs,lc,1))
 
-          qsacw(mgs) = 0.25*pi*esw(mgs)*cx(mgs,ls)*qx(mgs,lc)*vt*   &
-     &         (  da0(ls)*xdia(mgs,ls,3)**2 +     &
-     &            dab1(ls,lc)*xdia(mgs,ls,3)*xdia(mgs,lc,3) +    &
-     &            da1(lc)*xdia(mgs,lc,3)**2 )
-        qsacw(mgs) = Min( qsacw(mgs), qxmxd(mgs,ls) )
-        csacw(mgs) = rho0(mgs)*qsacw(mgs)/xmas(mgs,lc)
-       ENDIF
-      ENDIF
-      end do
 !
+! zero arrays that are used but not otherwise set (tm)
 !
       do mgs = 1,ngscnt
-      qsaci(mgs) = 0.0
-      csaci(mgs) = 0.0
-      csaci0(mgs) = 0.0
-      IF ( ipconc .ge. 4 ) THEN
-      IF ( esi(mgs) .gt. 0.0 .or. ( ipelec > 0 .and. esiclsn(mgs) > 0.0 )) THEN
-!      QSCOI=CEXS*RVT*A2*XNCI*XNS*XVCI*ROS*
-!     *  (((CINU+2.)/(CINU+1.))*VCIP+XVS)/RO
+         qhshr(mgs) = 0.0 
+       end do
+!
+!  set temporaries for microphysics variables
+!
+      DO il = lv,lhab
+      do mgs = 1,ngscnt
+        qx(mgs,il) = max(an(igs(mgs),jy,kgs(mgs),il), 0.0) 
+      ENDDO
+      end do
 
-        tmp = esiclsn(mgs)*rvt*aa2*cx(mgs,ls)*cx(mgs,li)*   &
-     &        ((cinu + 2.)*xv(mgs,li)/(cinu + 1.) + xv(mgs,ls))
+      qxw(:,:) = 0.0
 
-        qsaci(mgs) = Min( qxmxd(mgs,li), esi(mgs)*tmp*xmas(mgs,li)*rhoinv(mgs) )
-        csaci0(mgs) = tmp
-        csaci(mgs) = Min(cxmxd(mgs,li), esi(mgs)*tmp )
 
-!      qsaci(mgs) =
-!     >   min(
-!     >   ((0.25)*pi)*esi(mgs)*qx(mgs,li)*cx(mgs,ls)
-!     >  *abs(vtxbar(mgs,ls,1)-vtxbar(mgs,li,1))
-!     >  *(  gf3*xdia(mgs,ls,2)
-!     >    + 2.0*gf2*xdia(mgs,ls,1)*xdia(mgs,li,1)
-!     >    + gf1*xdia(mgs,li,2) )
-!     <  , qimxd(mgs))
-      ENDIF
-      ELSE ! 
-      IF ( esi(mgs) .gt. 0.0 ) THEN
-         qsaci(mgs) =    &
-     &   min(   &
-     &   ((0.25)*pi)*esi(mgs)*qx(mgs,li)*cx(mgs,ls)   &
-     &  *abs(vtxbar(mgs,ls,1)-vtxbar(mgs,li,1))   &
-     &  *(  gf3*xdia(mgs,ls,2)    &
-     &    + 2.0*gf2*xdia(mgs,ls,1)*xdia(mgs,li,1)    &
-     &    + gf1*xdia(mgs,li,2) )     &
-     &  , qimxd(mgs))
-      ENDIF
+
+! load charges
+      IF ( ipelec > 0 .and. lscw .gt. 1 ) THEN
+        DO il = lc,lhab
+          DO mgs = 1,ngscnt
+            scx(mgs,il) = an(igs(mgs),jy,kgs(mgs),lsc(il))
+!            IF ( .not. (scx(mgs,il) > -1.e-6 .and. scx(mgs,il) < 1.e-6 ) ) THEN
+!            IF ( Abs (scx(mgs,il) ) > 1000.e-9 .or. Abs (scx(mgs,il) ) > 1.e-9 ) THEN ! DEBUGTED
+            IF ( Abs (scx(mgs,il) ) > 1000.e-9 ) THEN 
+             write(0,*) 'Problem0a with scx il = ',il,lsc(il),scx(mgs,il),qx(mgs,il),cx(mgs,il)
+             write(0,*) 'at ix,jy,kz = ',igs(mgs),jyslab,kgs(mgs)
+        STOP
+             IF ( il == ls ) THEN
+             IF ( Abs (scx(mgs,il) ) > 10.e-9 ) THEN
+               write(0,*) 'myrank,scs,mgs = ',my_rank,scx(mgs,il),mgs
+             ENDIF
+             ENDIF
+            ENDIF
+          ENDDO
+        ENDDO
+
+      DO mgs = 1,ngscnt
+       cionp(mgs) = an(igs(mgs),jy,kgs(mgs),lscpi)
+       cionn(mgs) = an(igs(mgs),jy,kgs(mgs),lscni)
+      if ( largeion ) then
+       clionp(mgs) = an(igs(mgs),jy,kgs(mgs),lscpli)
+       clionn(mgs) = an(igs(mgs),jy,kgs(mgs),lscnli)
+      end if
+      ENDDO ! mgs 
+
+!$PAR CRITICAL SECTION
+!$PAR END CRITICAL SECTION
+
+      ELSE
+        scx(:,:) = 0.0
       ENDIF
-      end do
-!
+
 !
+!  set shape parameters
 !
-      do mgs = 1,ngscnt
-      qsacr(mgs) = 0.0
-      qsacrs(mgs) = 0.0
-      csacr(mgs) = 0.0
-      IF ( esr(mgs) .gt. 0.0 ) THEN
-      IF ( ipconc .ge. 3 ) THEN
-!       vt = Sqrt((vtxbar(mgs,ls,1)-vtxbar(mgs,lr,1))**2 + 
-!     :            0.04*vtxbar(mgs,ls,1)*vtxbar(mgs,lr,1) )
-!       qsacr(mgs) = esr(mgs)*cx(mgs,ls)*vt*
-!     :     qx(mgs,lr)*0.25*pi*
-!     :      (3.02787*xdia(mgs,lr,2) + 
-!     :       3.30669*xdia(mgs,ls,1)*xdia(mgs,lr,1) + 
-!     :       2.*xdia(mgs,ls,2))
-!        qsacr(mgs) = Min( qsacr(mgs), qrmxd(mgs) )
-!        csacr(mgs) = qsacr(mgs)*cx(mgs,lr)/qx(mgs,lr)
-!        csacr(mgs) = min(csacr(mgs),crmxd(mgs))
-      ELSE
-       IF ( lwsm6 .and. ipconc == 0 ) THEN
-         vt = vt2ave(mgs)
-       ELSE
-         vt = vtxbar(mgs,ls,1)
-       ENDIF
-       
-       qsacr(mgs) =   &
-     &   min(   &
-     &   ((0.25)*pi/gf4)*esr(mgs)*qx(mgs,lr)*cx(mgs,ls)   &
-     &  *abs(vtxbar(mgs,lr,1)-vt)   &
-     &  *(  gf6*gf1*xdia(mgs,lr,2)   &
-     &    + 2.0*gf5*gf2*xdia(mgs,lr,1)*xdia(mgs,ls,1)    &
-     &    + gf4*gf3*xdia(mgs,ls,2) )    &
-     &  , qrmxd(mgs))
+      IF ( imurain == 1 ) THEN
+        alpha(:,lr) = alphar
+      ELSEIF ( imurain == 3 ) THEN
+        alpha(:,lr) = xnu(lr)
       ENDIF
+      
+      alpha(:,li) = xnu(li)
+
+      IF ( imusnow == 1 ) THEN
+        alpha(:,ls) = alphas
+      ELSEIF ( imusnow == 3 ) THEN
+        alpha(:,ls) = xnu(ls)
       ENDIF
-      end do
-!
-!
-!
-      if (ndebug .gt. 0 ) write(0,*) 'Collection: graupel collects xxxxx'
-!
+      
+      DO il = lc,lhab
       do mgs = 1,ngscnt
-      qhacw(mgs) = 0.0
-      rarx(mgs,lh) = 0.0
-      vhacw(mgs) = 0.0
-      vhsoak(mgs) = 0.0
-      zhacw(mgs) = 0.0
+        IF ( il .ge. lg ) alpha(mgs,il) = dnu(il)
+        DO ic = lr,lhab
+        dab0lh(mgs,il,ic) = dab0(ic,il)
+        dab1lh(mgs,il,ic) = dab1(ic,il)
+        ENDDO
+      ENDDO
+      end do
       
-      IF ( .false. ) THEN
-        vtmax = (gz(igs(mgs),jgs,kgs(mgs))/dtp)
-        vtxbar(mgs,lh,1) = Min( vtmax, vtxbar(mgs,lh,1))
-        vtxbar(mgs,lh,2) = Min( vtmax, vtxbar(mgs,lh,2))
-        vtxbar(mgs,lh,3) = Min( vtmax, vtxbar(mgs,lh,3))
-      ENDIF
-      IF ( ehw(mgs) .gt. 0.0 ) THEN
-
-        IF ( ipconc .ge. 2 ) THEN
-
-        IF ( .false. ) THEN  
-        qhacw(mgs) = (ehw(mgs)*qx(mgs,lc)*cx(mgs,lh)*pi*   &
-     &    abs(vtxbar(mgs,lh,1)-vtxbar(mgs,lc,1))*   &
-     &    (2.0*xdia(mgs,lh,1)*(xdia(mgs,lh,1) +    &
-     &         xdia(mgs,lc,1)*gf73rds) +    &
-     &      xdia(mgs,lc,2)*gf83rds))/4.     
-     
-         ELSE  ! using Seifert coefficients
-            vt = abs(vtxbar(mgs,lh,1)-vtxbar(mgs,lc,1)) 
+      
+!      DO mgs = 1,ngscnt
+        da0lh(:) = da0(lh)
+        da0lr(:) = da0(lr)
+        IF ( lzh < 1 .or. lzhl < 1 ) THEN
+          rzxhlh(:) = rzhl/rz
+        ELSEIF ( lzh > 1 .and. lzhl > 1 ) THEN
+          rzxhlh(:) = 1.
+        ENDIF
+        IF ( lzr > 1 ) THEN
+          rzxh(:) = 1.
+          rzxhl(:) = 1.
+        ELSE
+          rzxh(:) = rz
+          rzxhl(:) = rzhl
+        ENDIF
+        
+        IF ( imurain == 1 .and. imusnow == 3 .and. lzr < 1 ) THEN
+          rzxs(:) = rzs
+        ELSEIF ( imurain == imusnow .or. lzr > 1 ) THEN
+          rzxs(:) = 1.
+        ENDIF
+ !     ENDDO
+      
+      IF ( lhl .gt. 1 ) THEN
+      DO mgs = 1,ngscnt
+        da0lhl(mgs) = da0(lhl)
+      ENDDO
+      ENDIF
+      
+      ventrx(:) = ventr
+      ventrxn(:) = ventrn
+      gf1palp(:) = gamma_sp(1.0 + alphar)
 
-          qhacw(mgs) = 0.25*pi*ehw(mgs)*cx(mgs,lh)*qx(mgs,lc)*vt*   &
-     &         (  da0lh(mgs)*xdia(mgs,lh,3)**2 +     &
-     &            dab1lh(mgs,lc,lh)*xdia(mgs,lh,3)*xdia(mgs,lc,3) +    &
-     &            da1(lc)*xdia(mgs,lc,3)**2 ) 
-         
+!
+!  set concentrations
+!
+!      ssmax = 0.0
+      
+      
+      
+      if ( ipconc .ge. 1 ) then
+       do mgs = 1,ngscnt
+        cx(mgs,li) = Max(an(igs(mgs),jy,kgs(mgs),lni), 0.0)
+        IF ( lcina .gt. 1 ) THEN
+         cina(mgs) = an(igs(mgs),jy,kgs(mgs),lcina)
+        ELSE
+         cina(mgs) = cx(mgs,li)
+        ENDIF
+        IF ( lcin > 1 ) THEN
+         ccin(mgs) = an(igs(mgs),jy,kgs(mgs),lcin)
+        ENDIF
+       end do
+      end if
+      if ( ipconc .ge. 2 ) then
+       do mgs = 1,ngscnt
+        cx(mgs,lc) = Max(an(igs(mgs),jy,kgs(mgs),lnc), 0.0)
+!        cx(mgs,lc) = Min( ccwmx, cx(mgs,lc) )
+        IF ( lss > 1 ) THEN
+        ssmax(mgs) = an(igs(mgs),jy,kgs(mgs),lss)
+        ENDIF
+        IF ( lccn .gt. 1 ) THEN
+         ccnc(mgs) = an(igs(mgs),jy,kgs(mgs),lccn)
+        ELSE
+         ccnc(mgs) = 0.0
+        ENDIF
+        IF ( lccna .gt. 1 ) THEN
+         ccna(mgs) = an(igs(mgs),jy,kgs(mgs),lccna)
+        ELSE
+         ccna(mgs) = cx(mgs,lc)
+        ENDIF
+       end do
+!       ELSE
+!       cx(mgs,lc) = Abs(ccn)
+      end if
+      if ( ipconc .ge. 3 ) then
+       do mgs = 1,ngscnt
+        cx(mgs,lr) = Max(an(igs(mgs),jy,kgs(mgs),lnr), 0.0)
+        IF ( qx(mgs,lr) .le. qxmin(lr) ) THEN
+!          cx(mgs,lr) = 0.0
+        ELSEIF ( cx(mgs,lr) .eq. 0.0 .and. qx(mgs,lr) .lt. 3.0*qxmin(lr) ) THEN
+          qx(mgs,lv) = qx(mgs,lv) + qx(mgs,lr)
+          qx(mgs,lr) = 0.0
+        ELSE
+          cx(mgs,lr) = Max( 1.e-9, cx(mgs,lr) )
+        ENDIF
+       end do
+      end if
+      if ( ipconc .ge. 4 ) then
+       do mgs = 1,ngscnt
+        cx(mgs,ls) = Max(an(igs(mgs),jy,kgs(mgs),lns), 0.0)
+        IF ( qx(mgs,ls) .le. qxmin(ls) ) THEN
+!          cx(mgs,ls) = 0.0
+        ELSEIF ( cx(mgs,ls) .eq. 0.0 .and. qx(mgs,ls) .lt. 3.0*qxmin(ls) ) THEN
+          qx(mgs,lv) = qx(mgs,lv) + qx(mgs,ls)
+          qx(mgs,ls) = 0.0
+        ELSE
+          cx(mgs,ls) = Max( 1.e-9, cx(mgs,ls) )
+
+         IF ( ilimit .ge. ipc(ls) ) THEN
+            tmp = (xdn0(ls)*cx(mgs,ls))/(rho0(mgs)*qx(mgs,ls))
+            tmp2 = (tmp*(3.14159))**(1./3.)
+            cnox = cx(mgs,ls)*(tmp2)
+         IF ( cnox .gt. 3.0*cno(ls) ) THEN
+           cx(mgs,ls) = 3.0*cno(ls)/tmp2
          ENDIF
-          qhacw(mgs) = Min( qhacw(mgs), 0.5*qx(mgs,lc)/dtp )
-        
-         IF ( lzh .gt. 1 ) THEN
-          tmp = qx(mgs,lh)/cx(mgs,lh)
-          
-!!          g1 = (6.0 + alpha(mgs,lh))*(5.0 + alpha(mgs,lh))*(4.0 + alpha(mgs,lh))/
-!!     :         ((3.0 + alpha(mgs,lh))*(2.0 + alpha(mgs,lh))*(1.0 + alpha(mgs,lh)))
-!          alp = Max( 1.0, alpha(mgs,lh)+1. )
-!          g1 = (6.0 + alp)*(5.0 + alp)*(4.0 + alp)/
-!     :         ((3.0 + alp)*(2.0 + alp)*(1.0 + alp))
-!          zhacw(mgs) =  g1*(6.*rho0(mgs)/(pi*1000.))**2*( 2.*( qx(mgs,lh)/cx(mgs,lh)) * qhacw(mgs) )
          ENDIF
-        
+        ENDIF
+       end do
+      end if
+      if ( ipconc .ge. 5 ) then
+       do mgs = 1,ngscnt
+
+        cx(mgs,lh) = Max(an(igs(mgs),jy,kgs(mgs),lnh), 0.0)
+        IF ( qx(mgs,lh) .le. qxmin(lh) ) THEN
+!          cx(mgs,lh) = 0.0
+        ELSEIF ( cx(mgs,lh) .eq. 0.0 .and. qx(mgs,lh) .lt. 3.0*qxmin(lh) ) THEN
+          qx(mgs,lv) = qx(mgs,lv) + qx(mgs,lh) 
+          qx(mgs,lh) = 0.0
         ELSE
-         qhacw(mgs) =    &
-     &   min(   &
-     &   ((0.25)*pi)*ehw(mgs)*qx(mgs,lc)*cx(mgs,lh)   &
-     &  *abs(vtxbar(mgs,lh,1)-vtxbar(mgs,lc,1))   &
-     &  *(  gf3*xdia(mgs,lh,2)    &
-     &    + 2.0*gf2*xdia(mgs,lh,1)*xdia(mgs,lc,1)    &
-     &    + gf1*xdia(mgs,lc,2) )     &
-     &    , 0.5*qx(mgs,lc)/dtp)
-!     <  , qxmxd(mgs,lc))
-!     <  , qcmxd(mgs))
-       
-       
-         IF ( lwsm6 .and. qsacw(mgs) > 0.0 .and.  qhacw(mgs) > 0.0) THEN
-           qaacw = ( qx(mgs,ls)*qsacw(mgs) + qx(mgs,lh)*qhacw(mgs) )/(qx(mgs,ls) + qx(mgs,lh))
-!           qaacw = Min( qaacw, 0.5*(qsacw(mgs) + qhacw(mgs) ) )
-           qsacw(mgs) = qaacw
-           qhacw(mgs) = qaacw
+          cx(mgs,lh) = Max( 1.e-9, cx(mgs,lh) )
+         IF ( ilimit .ge. ipc(lh) ) THEN
+            tmp = (xdn0(lh)*cx(mgs,lh))/(rho0(mgs)*qx(mgs,lh))
+            tmp2 = (tmp*(3.14159))**(1./3.)
+            cnox = cx(mgs,lh)*(tmp2)
+         IF ( cnox .gt. 3.0*cno(lh) ) THEN
+           cx(mgs,lh) = 3.0*cno(lh)/tmp2
          ENDIF
-         
-       ENDIF
+         ENDIF
+        ENDIF
+       end do
+      end if
 
-          IF ( lvol(lh) .gt. 1 .or. lhl .gt. 1 ) THEN ! calculate rime density for graupel volume and/or for graupel conversion to hail
-             
-             IF ( temg(mgs) .lt. 273.15) THEN
-             rimdn(mgs,lh) = rimc1*(-((0.5)*(1.e+06)*xdia(mgs,lc,1))   &
-     &                *((0.60)*vtxbar(mgs,lh,1))   &
-     &                /(temg(mgs)-273.15))**(rimc2)
-!             rimdn(mgs,lh) = Min( Max( hdnmn, rimc3, rimdn(mgs,lh) ), rimc4 )
-             rimdn(mgs,lh) = Min( Max( rimc3, rimdn(mgs,lh) ), rimc4 )
-             ELSE
-             rimdn(mgs,lh) = 1000.
-             ENDIF
-             
-             IF ( lvol(lh) > 1 ) vhacw(mgs) = rho0(mgs)*qhacw(mgs)/rimdn(mgs,lh)
+      if ( lhl .gt. 1 .and. ipconc .ge. 5 ) then
+       do mgs = 1,ngscnt
 
-          ENDIF
-      
-        IF ( qx(mgs,lh) .gt. qxmin(lh) .and. ipelec .ge. 1 ) THEN
-         rarx(mgs,lh) =     &
-     &    qhacw(mgs)*1.0e3*rho0(mgs)/((pi/2.0)*xdia(mgs,lh,2)*cx(mgs,lh))
+        cx(mgs,lhl) = Max(an(igs(mgs),jy,kgs(mgs),lnhl), 0.0)
+        IF ( qx(mgs,lhl) .le. qxmin(lhl) ) THEN
+          cx(mgs,lhl) = 0.0
+        ELSEIF ( cx(mgs,lhl) .eq. 0.0 .and. qx(mgs,lhl) .lt. 3.0*qxmin(lhl) ) THEN
+          qx(mgs,lv) = qx(mgs,lv) + qx(mgs,lhl) 
+          qx(mgs,lhl) = 0.0
+        ELSE
+          cx(mgs,lhl) = Max( 1.e-9, cx(mgs,lhl) )
+         IF ( ilimit .ge. ipc(lhl) ) THEN
+            tmp = (xdn0(lhl)*cx(mgs,lhl))/(rho0(mgs)*qx(mgs,lhl))
+            tmp2 = (tmp*(3.14159))**(1./3.)
+            cnox = cx(mgs,lhl)*(tmp2)
+         IF ( cnox .gt. 3.0*cno(lhl) ) THEN
+           cx(mgs,lhl) = 3.0*cno(lhl)/tmp2
+         ENDIF
+         ENDIF
         ENDIF
-      
-      ENDIF  
-      end do   
+       end do
+      end if
+
 !
+! Set mean particle volume
 !
-      do mgs = 1,ngscnt
-      qhaci(mgs) = 0.0
-      qhaci0(mgs) = 0.0
-      IF ( ehi(mgs) .gt. 0.0 ) THEN
-       IF (  ipconc .ge. 5 ) THEN
+      IF ( ldovol ) THEN
+      
+      vx(:,:) = 0.0
+      
+       DO il = li,lhab
+        
+        IF ( lvol(il) .ge. 1 ) THEN
+        
+          DO mgs = 1,ngscnt
+            vx(mgs,il) = Max(an(igs(mgs),jy,kgs(mgs),lvol(il)), 0.0)
+          ENDDO
 
-       vt = Sqrt((vtxbar(mgs,lh,1)-vtxbar(mgs,li,1))**2 +    &
-     &            0.04*vtxbar(mgs,lh,1)*vtxbar(mgs,li,1) )
+        ENDIF
+
+       ENDDO
 
-          qhaci0(mgs) = 0.25*pi*ehiclsn(mgs)*cx(mgs,lh)*qx(mgs,li)*vt*   &
-     &         (  da0lh(mgs)*xdia(mgs,lh,3)**2 +     &
-     &            dab1lh(mgs,li,lh)*xdia(mgs,lh,3)*xdia(mgs,li,3) +    &
-     &            da1(li)*xdia(mgs,li,3)**2 ) 
-          qhaci(mgs) = Min( ehi(mgs)*qhaci0(mgs), qimxd(mgs) )
-       ELSE
-        qhaci(mgs) =    &
-     &  min(   &
-     &  ((0.25)*pi)*ehi(mgs)*ehiclsn(mgs)*qx(mgs,li)*cx(mgs,lh)   &
-     &  *abs(vtxbar(mgs,lh,1)-vtxbar(mgs,li,1))   &
-     &  *(  gf3*xdia(mgs,lh,2)    &
-     &    + 2.0*gf2*xdia(mgs,lh,1)*xdia(mgs,li,1)    &
-     &    + gf1*xdia(mgs,li,2) )     &
-     &  , qimxd(mgs))
-       ENDIF
       ENDIF
-      end do   
 
 
-      IF ( lis > 1 .and. ipconc >= 5 ) THEN
-      do mgs = 1,ngscnt
-      qhacis(mgs) = 0.0
-      qhacis0(mgs) = 0.0
-      IF ( ehis(mgs) .gt. 0.0 ) THEN
 
-       vt = Sqrt((vtxbar(mgs,lh,1)-vtxbar(mgs,lis,1))**2 +    &
-     &            0.04*vtxbar(mgs,lh,1)*vtxbar(mgs,lis,1) )
 
-          qhacis0(mgs) = 0.25*pi*ehisclsn(mgs)*cx(mgs,lh)*qx(mgs,lis)*vt*   &
-     &         (  da0lh(mgs)*xdia(mgs,lh,3)**2 +     &
-     &            dab1lh(mgs,lis,lh)*xdia(mgs,lh,3)*xdia(mgs,lis,3) +    &
-     &            da1(li)*xdia(mgs,lis,3)**2 ) 
-          qhacis(mgs) = Min( ehis(mgs)*qhacis0(mgs), qxmxd(mgs,lis) )
-      ENDIF
-      end do
-      ENDIF
 
 !
+!  set factors
 !
       do mgs = 1,ngscnt
-      qhacs(mgs) = 0.0
-      qhacs0(mgs) = 0.0
-      IF ( ehs(mgs) .gt. 0.0 ) THEN
-       IF ( ipconc .ge. 5 ) THEN
-
-       vt = Sqrt((vtxbar(mgs,lh,1)-vtxbar(mgs,ls,1))**2 +    &
-     &            0.04*vtxbar(mgs,lh,1)*vtxbar(mgs,ls,1) )
-
-          qhacs0(mgs) = 0.25*pi*ehsclsn(mgs)*cx(mgs,lh)*qx(mgs,ls)*vt*   &
-     &         (  da0lh(mgs)*xdia(mgs,lh,3)**2 +     &
-     &            dab1lh(mgs,ls,lh)*xdia(mgs,lh,3)*xdia(mgs,ls,3) +    &
-     &            da1(ls)*xdia(mgs,ls,3)**2 ) 
-      
-          qhacs(mgs) = Min( ehs(mgs)*qhacs0(mgs), qsmxd(mgs) )
-
-       ELSE
-         qhacs(mgs) =   &
-     &   min(   &
-     &   ((0.25)*pi/gf4)*ehs(mgs)*ehsclsn(mgs)*qx(mgs,ls)*cx(mgs,lh)   &
-     &  *abs(vtxbar(mgs,lh,1)-vtxbar(mgs,ls,1))   &
-     &  *(  gf6*gf1*xdia(mgs,ls,2)   &
-     &    + 2.0*gf5*gf2*xdia(mgs,ls,1)*xdia(mgs,lh,1)   &
-     &    + gf4*gf3*xdia(mgs,lh,2) )   &
-     &  , qsmxd(mgs))
-        ENDIF
-      ENDIF
-      end do   
 !
-      do mgs = 1,ngscnt
-      qhacr(mgs) = 0.0
-      qhacrmlr(mgs) = 0.0
-      vhacr(mgs) = 0.0
-      chacr(mgs) = 0.0
-      zhacr(mgs) = 0.0
-      IF ( temg(mgs) .gt. tfr ) raindn(mgs,lh) = 1000.0
-
-      IF ( ehr(mgs) .gt. 0.0 ) THEN
-      IF ( ipconc .ge. 3 ) THEN
-       vt = Sqrt((vtxbar(mgs,lh,1)-vtxbar(mgs,lr,1))**2 +    &
-     &            0.04*vtxbar(mgs,lh,1)*vtxbar(mgs,lr,1) )
-!       qhacr(mgs) = ehr(mgs)*cx(mgs,lh)*vt*
-!     :     qx(mgs,lr)*0.25*pi*
-!     :      (3.02787*xdia(mgs,lr,2) + 
-!     :       3.30669*xdia(mgs,lh,1)*xdia(mgs,lr,1) + 
-!     :       2.*xdia(mgs,lh,2))
-     
-       qhacr(mgs) = 0.25*pi*ehr(mgs)*cx(mgs,lh)*qx(mgs,lr)*vt*   &
-     &         (  da0lh(mgs)*xdia(mgs,lh,3)**2 +     &
-     &            dab1lh(mgs,lr,lh)*xdia(mgs,lh,3)*xdia(mgs,lr,3) +    &
-     &            da1(lr)*xdia(mgs,lr,3)**2 )
-!       IF ( qhacr(mgs) .gt. 0. .or. tmp .gt. 0.0 ) write(0,*) 'qhacr= ',qhacr(mgs),tmp
-!!        qhacr(mgs) = Min( qhacr(mgs), qrmxd(mgs) )
-!!        chacr(mgs) = qhacr(mgs)*cx(mgs,lr)/qx(mgs,lr)
-!!        chacr(mgs) = min(chacr(mgs),crmxd(mgs))
-
-        qhacr(mgs) = Min( qhacr(mgs), qxmxd(mgs,lr) )
+      ssi(mgs) = qx(mgs,lv)/qis(mgs)
+      ssw(mgs) = qx(mgs,lv)/qvs(mgs)
+!
+      tsqr(mgs) = temg(mgs)**2
+!
+      temgx(mgs) = min(temg(mgs),313.15)
+      temgx(mgs) = max(temgx(mgs),233.15)
+      felv(mgs) = 2500837.367 * (273.15/temgx(mgs))**((0.167)+(3.67e-4)*temgx(mgs))
+!
+      temcgx(mgs) = min(temg(mgs),273.15)
+      temcgx(mgs) = max(temcgx(mgs),223.15)
+      temcgx(mgs) = temcgx(mgs)-273.15
 
-        IF ( temg(mgs) > tfr ) THEN
-          qhacrmlr(mgs) = qhacr(mgs)
-          qhacr(mgs) = 0.0
+! felf = latent heat of fusion, fels = LH of sublimation, felv = LH of vaporization
+      felf(mgs) = 333690.6098 + (2030.61425)*temcgx(mgs) - (10.46708312)*temcgx(mgs)**2
+!
+      fels(mgs) = felv(mgs) + felf(mgs)
+!
+      felvs(mgs) = felv(mgs)*felv(mgs)
+      felss(mgs) = fels(mgs)*fels(mgs)
+      
+        IF ( eqtset <= 1 ) THEN
+          felvcp(mgs) = felv(mgs)*cpi
+          felscp(mgs) = fels(mgs)*cpi
+          felfcp(mgs) = felf(mgs)*cpi
         ELSE
-!        chacr(mgs) = Min( qhacr(mgs)*rho0(mgs)/xmas(mgs,lr), cxmxd(mgs,lr) )
-
-!       chacr(mgs) = ehr(mgs)*cx(mgs,lh)*vt*
-!     :     cx(mgs,lr)*0.25*pi*
-!     :      (0.69874*xdia(mgs,lr,2) +
-!     :       1.24001*xdia(mgs,lh,1)*xdia(mgs,lr,1) +
-!     :       2.*xdia(mgs,lh,2))
-
-!        chacr(mgs) = 0.25*pi*ehr(mgs)*cx(mgs,lh)*cx(mgs,lr)*vt*
-!     :         (  da0lh(mgs)*xdia(mgs,lh,3)**2 +
-!     :            dab0lh(mgs,lr)*xdia(mgs,lh,3)*xdia(mgs,lr,3) +
-!     :            da0(lr)*xdia(mgs,lr,3)**2 )
-
-!       IF ( qhacr(mgs) .gt. 0. .or. tmp .gt. 0.0 ) write(0,*) 'chacr= ',chacr(mgs),tmp
+          
+          ! equations from appendix in Bryan and Morrison (2012, MWR)
+          ! note that rw is Rv in the paper, and rd is R.
+          
+          tmp = qx(mgs,li)+qx(mgs,ls)+qx(mgs,lh)
+          IF ( lhl > 1 ) tmp = tmp + qx(mgs,lhl)
+          cvm = cv+cvv*qx(mgs,lv)+cpl*(qx(mgs,lc)+qx(mgs,lr))   &
+                                  +cpigb*(tmp)
 
-        chacr(mgs) = qhacr(mgs)*cx(mgs,lr)/qx(mgs,lr)
-        chacr(mgs) = min(chacr(mgs),crmxd(mgs))
+          IF ( eqtset == 2 ) THEN ! compact form from treating dT/dt = theta*d(pi)/dt + pi*d(theta)dt and then applied to theta assuming constant pi
+          felvcp(mgs) = (felv(mgs)-rw*temg(mgs))/cvm
+          felscp(mgs) = (fels(mgs)-rw*temg(mgs))/cvm
+          felfcp(mgs) = felf(mgs)/cvm
+          
+          ELSE
+           ! equivalent version that applies separate updates of latent heating to theta and pi, when both are returned.
 
-      IF ( lzh .gt. 1 ) THEN
-          tmp = qx(mgs,lh)/cx(mgs,lh)
+          cpm = cp+cpv*qx(mgs,lv)+cpl*(qx(mgs,lc)+qx(mgs,lr))   &
+                                  +cpigb*(tmp)
+          rmm=rd+rw*qx(mgs,lv)
+          
+          felvcp(mgs) = (felv(mgs)*cv/(cp) - rw*temg(mgs)*(1.0-rovcp*cpm/rmm))/cvm
+          felscp(mgs) = (fels(mgs)*cv/(cp) - rw*temg(mgs)*(1.0-rovcp*cpm/rmm))/cvm
+          felfcp(mgs) = felf(mgs)*cv/(cp*cvm)
 
-!          g1 = (6.0 + alpha(mgs,lh))*(5.0 + alpha(mgs,lh))*(4.0 + alpha(mgs,lh))/
-!     :         ((3.0 + alpha(mgs,lh))*(2.0 + alpha(mgs,lh))*(1.0 + alpha(mgs,lh)))
-!          alp = Max( 1.0, alpha(mgs,lh)+1. )
-!          g1 = (6.0 + alp)*(5.0 + alp)*(4.0 + alp)/
-!     :         ((3.0 + alp)*(2.0 + alp)*(1.0 + alp))
-!        zhacr(mgs) =  g1*(6.*rho0(mgs)/(pi*1000.))**2*( 2.*( tmp ) * qhacr(mgs) - tmp**2 * chacr(mgs) )
-!        zhacr(mgs) =  g1*(6.*rho0(mgs)/(pi*xdn(mgs,lh)))**2*( 2.*( tmp ) * qhacr(mgs) )
-      ENDIF
-      ENDIF ! temg > tfr
-      
-      ELSE
-       IF ( lwsm6 .and. ipconc == 0 ) THEN
-         vt = vt2ave(mgs)
-       ELSE
-         vt = vtxbar(mgs,lh,1)
-       ENDIF
+          felvpi(mgs) = pi0(mgs)*rovcp*(felv(mgs)/(temg(mgs)) - rw*cpm/rmm)/cvm
+          felspi(mgs) = pi0(mgs)*rovcp*(fels(mgs)/(temg(mgs)) - rw*cpm/rmm)/cvm 
+          felfpi(mgs) = pi0(mgs)*rovcp*(felf(mgs)/(cvm*temg(mgs)))
+          
+          ENDIF
 
-      qhacr(mgs) =   &
-     &   min(   &
-     &   ((0.25)*pi/gf4)*ehr(mgs)*qx(mgs,lr)*cx(mgs,lh)   &
-     &  *abs(vt-vtxbar(mgs,lr,1))   &
-     &  *(  gf6*gf1*xdia(mgs,lr,2)   &
-     &    + 2.0*gf5*gf2*xdia(mgs,lr,1)*xdia(mgs,lh,1)   &
-     &    + gf4*gf3*xdia(mgs,lh,2) )   &
-     &  , qrmxd(mgs))
-      
-        IF ( temg(mgs) > tfr ) THEN
-          qhacrmlr(mgs) = qhacr(mgs)
-          qhacr(mgs) = 0.0
         ENDIF
-      
-      ENDIF
-        IF ( lvol(lh) .gt. 1 ) THEN
-         vhacr(mgs) = rho0(mgs)*qhacr(mgs)/raindn(mgs,lh)
-        ENDIF
-      ENDIF
+!
+      fgamw(mgs) = felvcp(mgs)/pi0(mgs)
+      fgams(mgs) = felscp(mgs)/pi0(mgs)
+!
+      fcqv1(mgs) = 4098.0258*pi0(mgs)*fgamw(mgs)
+      fcqv2(mgs) = 5807.6953*pi0(mgs)*fgams(mgs)
+      fcc3(mgs) = felfcp(mgs)/pi0(mgs)
+!
+!  fwvdf = water vapor diffusivity
+      fwvdf(mgs) = (2.11e-05)*((temg(mgs)/tfr)**1.94)*(101325.0/(pres(mgs)))
+!
+! fadvisc = 'd' for dynamic viscosity
+! fakvisc = 'k' for kinematic viscosity
+      fadvisc(mgs) = advisc0*(416.16/(temg(mgs)+120.0))*(temg(mgs)/296.0)**(1.5) ! dynamic visc.
+!
+      fakvisc(mgs) = fadvisc(mgs)*rhoinv(mgs) ! divide by rho_air to get kinematic visc. (note the 'k' vs. 'd')
+!
+      temcgx(mgs) = min(temg(mgs),273.15)
+      temcgx(mgs) = max(temcgx(mgs),233.15)
+      temcgx(mgs) = temcgx(mgs)-273.15
+      fci(mgs) = (2.118636 + 0.007371*(temcgx(mgs)))*(1.0e+03)
+!
+      if ( temg(mgs) .lt. 273.15 ) then
+      temcgx(mgs) = min(temg(mgs),273.15)
+      temcgx(mgs) = max(temcgx(mgs),233.15)
+      temcgx(mgs) = temcgx(mgs)-273.15
+      fcw(mgs) = 4203.1548  + (1.30572e-2)*((temcgx(mgs)-35.)**2)   &
+     &                 + (1.60056e-5)*((temcgx(mgs)-35.)**4)
+      end if
+      if ( temg(mgs) .ge. 273.15 ) then
+      temcgx(mgs) = min(temg(mgs),308.15)
+      temcgx(mgs) = max(temcgx(mgs),273.15)
+      temcgx(mgs) = temcgx(mgs)-273.15
+      fcw(mgs) = 4243.1688  + (3.47104e-1)*(temcgx(mgs)**2)
+      end if
+!
+      ftka(mgs) = tka0*fadvisc(mgs)/advisc1  ! thermal conductivity: proportional to dynamic viscosity
+      fthdf(mgs) = ftka(mgs)*cpi*rhoinv(mgs)
+!
+      fschm(mgs) = (fakvisc(mgs)/fwvdf(mgs))  ! Schmidt number
+      fpndl(mgs) = (fakvisc(mgs)/fthdf(mgs))  ! Prandl number (only used for bin melting)
+!
+      fai(mgs) = (fels(mgs)**2)/(ftka(mgs)*rw*temg(mgs)**2)
+      fbi(mgs) = (1.0/(rho0(mgs)*fwvdf(mgs)*qis(mgs)))
+      fav(mgs) = (felv(mgs)**2)/(ftka(mgs)*rw*temg(mgs)**2)
+      fbv(mgs) = (1.0/(rho0(mgs)*fwvdf(mgs)*qvs(mgs)))
+!
       end do
-
 !
 !
-      if (ndebug .gt. 0 ) write(0,*) 'Collection: hail collects xxxxx'
+!   ice habit fractions
+!
+!
+!
+!  Set density
+!
+      if (ndebug .gt. 0 ) write(0,*) 'ICEZVD_GS: Set density'
 !
 
       do mgs = 1,ngscnt
-      qhlacw(mgs) = 0.0
-      vhlacw(mgs) = 0.0
-      vhlsoak(mgs) = 0.0
-      IF ( lhl > 1 .and. .true.) THEN
-        vtmax = (gz(igs(mgs),jgs,kgs(mgs))/dtp)
-        vtxbar(mgs,lhl,1) = Min( vtmax, vtxbar(mgs,lhl,1))
-        vtxbar(mgs,lhl,2) = Min( vtmax, vtxbar(mgs,lhl,2))
-        vtxbar(mgs,lhl,3) = Min( vtmax, vtxbar(mgs,lhl,3))
-      ENDIF
+        xdn(mgs,li) = xdn0(li)
+        xdn(mgs,lc) = xdn0(lc)
+        xdn(mgs,lr) = xdn0(lr)
+        xdn(mgs,ls) = xdn0(ls)
+        xdn(mgs,lh) = xdn0(lh)
+        IF ( lvol(ls) .gt. 1 ) THEN
+         IF ( vx(mgs,ls) .gt. 0.0 .and. qx(mgs,ls) .gt. qxmin(ls) ) THEN
+           xdn(mgs,ls) = Min( xdnmx(ls), Max( xdnmn(ls), rho0(mgs)*qx(mgs,ls)/vx(mgs,ls) ) )
+         ENDIF
+        ENDIF
 
-      IF ( lhl > 0 ) THEN
-      rarx(mgs,lhl) = 0.0
-      ENDIF
+        IF ( lvol(lh) .gt. 1 ) THEN
+         IF ( vx(mgs,lh) .gt. 0.0 .and. qx(mgs,lh) .gt. qxmin(lh) ) THEN
+           IF ( mixedphase ) THEN
+           ELSE
+             dnmx = xdnmx(lh)
+           ENDIF
+           xdn(mgs,lh) = Min( dnmx, Max( xdnmn(lh), rho0(mgs)*qx(mgs,lh)/vx(mgs,lh) ) )
+           vx(mgs,lh) = rho0(mgs)*qx(mgs,lh)/xdn(mgs,lh)
+         
+         ELSEIF ( vx(mgs,lh) == 0.0 .and. qx(mgs,lh) .gt. qxmin(lh) ) THEN ! if volume is zero, need to initialize the default value
 
-      IF ( lhl .gt. 1 .and. ehlw(mgs) .gt. 0.0 ) THEN
+           vx(mgs,lh) = rho0(mgs)*qx(mgs,lh)/xdn(mgs,lh)
+         
+         ENDIF
+        ENDIF
 
+        IF ( lhl .gt. 1 ) THEN
 
-!        IF ( ipconc .ge. 2 ) THEN
+          xdn(mgs,lhl) = xdn0(lhl)
 
-            vt = abs(vtxbar(mgs,lhl,1)-vtxbar(mgs,lc,1))
+          IF ( lvol(lhl) .gt. 1 ) THEN
+           IF ( vx(mgs,lhl) .gt. 0.0 .and. qx(mgs,lhl) .gt. qxmin(lhl) ) THEN
 
-          qhlacw(mgs) = 0.25*pi*ehlw(mgs)*cx(mgs,lhl)*qx(mgs,lc)*vt*   &
-     &         (  da0lhl(mgs)*xdia(mgs,lhl,3)**2 +     &
-     &            dab1lh(mgs,lc,lhl)*xdia(mgs,lhl,3)*xdia(mgs,lc,3) +    &
-     &            da1(lc)*xdia(mgs,lc,3)**2 )
+           IF ( mixedphase .and. lhlw > 1 ) THEN
+           ELSE
+             dnmx = xdnmx(lhl)
+           ENDIF
 
+             xdn(mgs,lhl) = Min( dnmx, Max( xdnmn(lhl), rho0(mgs)*qx(mgs,lhl)/vx(mgs,lhl) ) )
+             vx(mgs,lhl) = rho0(mgs)*qx(mgs,lhl)/xdn(mgs,lhl)
+         
+           ELSEIF ( vx(mgs,lhl) == 0.0 .and. qx(mgs,lhl) .gt. qxmin(lhl) ) THEN ! if volume is zero, need to initialize the default value
 
-          qhlacw(mgs) = Min( qhlacw(mgs), 0.5*qx(mgs,lc)/dtp )
+             vx(mgs,lhl) = rho0(mgs)*qx(mgs,lhl)/xdn(mgs,lhl)
+         
+           ENDIF
+          ENDIF
 
-          IF ( lvol(lhl) .gt. 1 ) THEN
+        ENDIF
 
-             IF ( temg(mgs) .lt. 273.15) THEN
-             rimdn(mgs,lhl) = rimc1*(-((0.5)*(1.e+06)*xdia(mgs,lc,1))   &
-     &                *((0.60)*vtxbar(mgs,lhl,1))   &
-     &                /(temg(mgs)-273.15))**(rimc2)
-             rimdn(mgs,lhl) = Min( Max( hldnmn, rimc3, rimdn(mgs,lhl) ), rimc4 )
-             ELSE
-             rimdn(mgs,lhl) = 1000.
-             ENDIF
 
-             vhlacw(mgs) = rho0(mgs)*qhlacw(mgs)/rimdn(mgs,lhl)
+      end do
 
-          ENDIF
 
+       IF ( imurain == 3 ) THEN
+         IF ( lzr > 1 ) THEN
+           alphashr = 0.0
+           alphamlr = -2.0/3.0
+         ELSE
+           alphashr = xnu(lr)
+           alphamlr = xnu(lr)
+         ENDIF
+!         massfacshr = ( (2. + 3.*(1. +alphashr) )/( 3.*(1. + alphashr) ) )**(1./3.) ! this is the diameter factor
+!         massfacmlr = ( (2. + 3.*(1. +alphamlr) )/( 3.*(1. + alphamlr) ) )**(1./3.)
+         massfacshr = ( (2. + 3.*(1. +alphashr) )**3/( 3.*(1. + alphashr) ) )  ! this is the mass or volume factor
+         massfacmlr = ( (2. + 3.*(1. +alphamlr) )**3/( 3.*(1. + alphamlr) ) )
+       ELSEIF ( imurain == 1 ) THEN
+         IF ( lzr > 1 ) THEN
+           alphashr = 4.0
+           alphamlr = 4.0
+         ELSE
+           alphashr = alphar
+           alphamlr = alphar
+         ENDIF
+!         massfacshr = (3.0 + alphashr)*((3.+alphashr)*(2.+alphashr)*(1. + alphashr) )**(-1./3.) ! this is the diameter factor
+!         massfacmlr = (3.0 + alphamlr)*((3.+alphamlr)*(2.+alphamlr)*(1. + alphamlr) )**(-1./3.)
+         massfacshr = (3.0 + alphashr)**3/((3.+alphashr)*(2.+alphashr)*(1. + alphashr) ) ! this is the mass or volume factor
+         massfacmlr = (3.0 + alphamlr)**3/((3.+alphamlr)*(2.+alphamlr)*(1. + alphamlr) )
+       ENDIF
+       
 
-        IF ( qx(mgs,lhl) .gt. qxmin(lhl) .and. ipelec .ge. 1 ) THEN
-         rarx(mgs,lhl) =     &
-     &    qhlacw(mgs)*1.0e3*rho0(mgs)/((pi/2.0)*xdia(mgs,lhl,2)*cx(mgs,lhl))
-        ENDIF
+!
+!  set some values for ice nucleation
+!
+      do mgs = 1,ngscnt
+      kp1 = Min(nz, kgs(mgs)+1 )
+      wvel(mgs) = (0.5)*(w(igs(mgs),jgs,kp1)   &
+     &                  +w(igs(mgs),jgs,kgs(mgs)))
 
-      ENDIF
+      
+        wvelkm1(mgs) = (0.5)*(w(igs(mgs),jgs,kgs(mgs))   &
+     &                    +w(igs(mgs),jgs,kgsm(mgs)))
+      cninm(mgs) = t7(igs(mgs),jgs,kgsm(mgs))
+      cnina(mgs) = t7(igs(mgs),jgs,kgs(mgs))
+      cninp(mgs) = t7(igs(mgs),jgs,kgsp(mgs))
       end do
 
-      qhlaci(:) = 0.0
-      qhlaci0(:) = 0.0
-      IF ( lhl .gt. 1  ) THEN
-      do mgs = 1,ngscnt
-      IF ( ehli(mgs) .gt. 0.0 ) THEN
-       IF (  ipconc .ge. 5 ) THEN
+!
+!  Set a couple of cloud variables...
+!
 
-       vt = Sqrt((vtxbar(mgs,lhl,1)-vtxbar(mgs,li,1))**2 +    &
-     &            0.04*vtxbar(mgs,lhl,1)*vtxbar(mgs,li,1) )
+!      SUBROUTINE setvt(ngscnt,qx,qxmin,cx,rho0,rhovt,xdia,cno,
+!     :                 xmas,xdn,xvmn,xvmx,xv,cdx,
+!     :                 ipconc,ndebug)
+!      SUBROUTINE setvtz(ngscnt,qx,qxmin,qxw,cx,rho0,rhovt,xdia,cno, &
+!     &                 xmas,vtxbar,xdn,xvmn,xvmx,xv,cdx,            &
+!     &                 ipconc1,ndebug1,ngs,nz,kgs,cwnccn,fadvisc,   &
+!     &                 cwmasn,cwmasx,cwradn,cnina,cimna,cimxa,      &
+!     &                 itype1a,itype2a,temcg,infdo,alpha)
 
-          qhlaci0(mgs) = 0.25*pi*ehliclsn(mgs)*cx(mgs,lhl)*qx(mgs,li)*vt*   &
-     &         (  da0lhl(mgs)*xdia(mgs,lhl,3)**2 +     &
-     &            dab1lh(mgs,li,lhl)*xdia(mgs,lhl,3)*xdia(mgs,li,3) +    &
-     &            da1(li)*xdia(mgs,li,3)**2 )
-        ! qhlaci(mgs) = Min( qhlaci(mgs), qimxd(mgs) )
-          qhlaci(mgs) = Min( ehli(mgs)*qhlaci0(mgs), qimxd(mgs) )
+
+      infdo = 0
+      IF ( io_flag .and. nxtra > 1 ) infdo = 1
+
+      call setvtz(ngscnt,qx,qxmin,qxw,cx,rho0,rhovt,xdia,cno,cnostmp,   &
+     &                 xmas,vtxbar,xdn,xvmn,xvmx,xv,cdx,   &
+     &                 ipconc,ndebug,ngs,nz,kgs,fadvisc,   &
+     &                 cwmasn,cwmasx,cwradn,cnina,cimn,cimx,   &
+     &                 itype1,itype2,temcg,infdo,alpha,0,axh,bxh,axhl,bxhl)
+
+
+       IF ( lwsm6 .and. ipconc == 0 ) THEN
+         tmp = Max(qxmin(lh), qxmin(ls))
+         DO mgs = 1,ngscnt
+           sum = qx(mgs,lh) + qx(mgs,ls)
+           IF ( sum > tmp ) THEN
+             vt2ave(mgs) = (qx(mgs,lh)*vtxbar(mgs,lh,1) + qx(mgs,ls)*vtxbar(mgs,ls,1))/sum
+           ELSE
+             vt2ave(mgs) = 0.0
+           ENDIF
+         ENDDO
        ENDIF
-      ENDIF
-      end do
-      ENDIF
+
+
 !
-      qhlacs(:) = 0.0
-      qhlacs0(:) = 0.0
-      IF ( lhl .gt. 1 ) THEN
+!  Set number concentrations (need xdia from setvt)
+!
+      if ( ndebug .gt. 0 ) write(0,*) 'ICEZVD_GS: Set concentration'
+      IF ( ipconc .lt. 1 ) THEN
+         cina(1:ngscnt) = cx(1:ngscnt,li)
+      ENDIF
+      if ( ipconc .lt. 5 ) then
       do mgs = 1,ngscnt
-      IF ( ehls(mgs) .gt. 0.0) THEN
-       IF ( ipconc .ge. 5 ) THEN
-
-       vt = Sqrt((vtxbar(mgs,lhl,1)-vtxbar(mgs,ls,1))**2 +    &
-     &            0.04*vtxbar(mgs,lhl,1)*vtxbar(mgs,ls,1) )
 
-          qhlacs0(mgs) = 0.25*pi*ehlsclsn(mgs)*cx(mgs,lhl)*qx(mgs,ls)*vt*   &
-     &         (  da0lhl(mgs)*xdia(mgs,lhl,3)**2 +     &
-     &            dab1lh(mgs,ls,lhl)*xdia(mgs,lhl,3)*xdia(mgs,ls,3) +    &
-     &            da1(ls)*xdia(mgs,ls,3)**2 )
 
-          qhlacs(mgs) = Min( ehls(mgs)*qhlacs0(mgs), qsmxd(mgs) )
-        ENDIF
-      ENDIF
-      end do
+      IF ( ipconc .lt. 3 ) THEN
+!      cx(mgs,lr) = 0.0
+      if ( qx(mgs,lr) .gt. qxmin(lh) )  then
+!      cx(mgs,lr) = cno(lr)*xdia(mgs,lr,1)
+!      xv(mgs,lr) = rho0(mgs)*qx(mgs,lr)/(xdn(mgs,lr)*cx(mgs,lr))
+      end if
       ENDIF
 
+      IF ( ipconc .lt. 4 ) THEN
+!      tmp = cx(mgs,ls)
+!      cx(mgs,ls) = 0.0
+      if ( qx(mgs,ls) .gt. qxmin(ls) )  then
+!      cx(mgs,ls) = cno(ls)*xdia(mgs,ls,1)
+!      xv(mgs,ls) = rho0(mgs)*qx(mgs,ls)/(xdn(mgs,ls)*cx(mgs,ls))
+      end if
+      ENDIF ! ( ipconc .lt. 4 )
 
-      do mgs = 1,ngscnt
-      qhlacr(mgs) = 0.0
-      qhlacrmlr(mgs) = 0.0
-      chlacr(mgs) = 0.0
-      vhlacr(mgs) = 0.0
-      IF ( lhl .gt. 1 .and. temg(mgs) .gt. tfr ) raindn(mgs,lhl) = 1000.0
+      IF ( ipconc .lt. 5 ) THEN
 
-      IF ( lhl .gt. 1 .and. ehlr(mgs) .gt. 0.0 ) THEN
-      IF ( ipconc .ge. 3 ) THEN
-       vt = Sqrt((vtxbar(mgs,lhl,1)-vtxbar(mgs,lr,1))**2 +    &
-     &            0.04*vtxbar(mgs,lhl,1)*vtxbar(mgs,lr,1) )
 
-       qhlacr(mgs) = 0.25*pi*ehlr(mgs)*cx(mgs,lhl)*qx(mgs,lr)*vt*   &
-     &         (  da0lhl(mgs)*xdia(mgs,lhl,3)**2 +     &
-     &            dab1lh(mgs,lr,lhl)*xdia(mgs,lhl,3)*xdia(mgs,lr,3) +    &
-     &            da1(lr)*xdia(mgs,lr,3)**2 )
-!       IF ( qhacr(mgs) .gt. 0. .or. tmp .gt. 0.0 ) write(0,*) 'qhacr= ',qhacr(mgs),tmp
-!!        qhacr(mgs) = Min( qhacr(mgs), qrmxd(mgs) )
-!!        chacr(mgs) = qhacr(mgs)*cx(mgs,lr)/qx(mgs,lr)
-!!        chacr(mgs) = min(chacr(mgs),crmxd(mgs))
+!      cx(mgs,lh) = 0.0
+      if ( qx(mgs,lh) .gt. qxmin(lh) )  then
+!      cx(mgs,lh) = cno(lh)*xdia(mgs,lh,1)
+!      xv(mgs,lh) = Max(xvmn(lh), rho0(mgs)*qx(mgs,lh)/(xdn(mgs,lh)*cx(mgs,lh)) )
+!      xdia(mgs,lh,3) = (xv(mgs,lh)*6./pi)**(1./3.) 
+      end if
 
-        qhlacr(mgs) = Min( qhlacr(mgs), qxmxd(mgs,lr) )
+      ENDIF ! ( ipconc .lt. 5 )
 
-     
-        qhlacrmlr(mgs) = qhlacr(mgs)
-        IF ( temg(mgs) > tfr ) THEN
-        qhlacr(mgs) = 0.0
+      end do
+      end if
+      
+      IF ( ipconc .ge. 2 ) THEN
+      DO mgs = 1,ngscnt
+        rb(mgs) = 0.5*xdia(mgs,lc,1)*((1./(1.+cnu)))**(1./6.)
+        xl2p(mgs) = Max(0.0d0, 2.7e-2*xdn(mgs,lc)*cx(mgs,lc)*xv(mgs,lc)*   &
+     &           ((0.5e20*rb(mgs)**3*xdia(mgs,lc,1))-0.4) )
+        IF ( rb(mgs) .gt. 3.51e-6 ) THEN
+!          rh(mgs) = Max( 0.5d0*xdia(mgs,lc,1), 6.3d-4/(1.d6*(rb(mgs) - 3.5d-6)) )
+          rh(mgs) = Max( 41.d-6, 6.3d-4/(1.d6*(rb(mgs) - 3.5d-6)) )
         ELSE
-        chlacr(mgs) = 0.25*pi*ehlr(mgs)*cx(mgs,lhl)*cx(mgs,lr)*vt*   &
-     &         (  da0lhl(mgs)*xdia(mgs,lhl,3)**2 +     &
-     &            dab0(lhl,lr)*xdia(mgs,lhl,3)*xdia(mgs,lr,3) +    &
-     &            da0(lr)*xdia(mgs,lr,3)**2 )
-
-        chlacr(mgs) = min(chlacr(mgs),crmxd(mgs))
-
-        IF ( lvol(lhl) .gt. 1 ) THEN
-         vhlacr(mgs) = rho0(mgs)*qhlacr(mgs)/raindn(mgs,lhl)
+          rh(mgs) = 41.d-6
         ENDIF
+        IF ( xl2p(mgs) .gt. 0.0 ) THEN
+          nh(mgs) = 4.2d9*xl2p(mgs)
+        ELSE
+          nh(mgs) = 1.e30
         ENDIF
+      ENDDO
       ENDIF
-      ENDIF
-      end do
-
-
-
+      
 !
 !
+!              
 !
+!  maximum depletion tendency by any one source
 !
-!      if (ndebug .gt. 0 ) write(0,*) 'Collection: Cloud collects xxxxx'
-
-      if (ndebug .gt. 0 ) write(0,*) 'Collection: cloud ice collects xxxx2'
 !
+      if( ndebug .ge. 0 ) THEN
+!mpi!        write(0,*) 'Set depletion max/min1'
+      endif
       do mgs = 1,ngscnt
-      qiacw(mgs) = 0.0
-      IF ( eiw(mgs) .gt. 0.0 ) THEN
-
-       vt = Sqrt((vtxbar(mgs,li,1)-vtxbar(mgs,lc,1))**2 +    &
-     &            0.04*vtxbar(mgs,li,1)*vtxbar(mgs,lc,1) )
-
-          qiacw(mgs) = 0.25*pi*eiw(mgs)*cx(mgs,li)*qx(mgs,lc)*vt*   &
-     &         (  da0(li)*xdia(mgs,li,3)**2 +     &
-     &            dab1(li,lc)*xdia(mgs,li,3)*xdia(mgs,lc,3) +    &
-     &            da1(lc)*xdia(mgs,lc,3)**2 )
+      qvimxd(mgs) = 0.70*(qx(mgs,lv)-qis(mgs))*dtpinv ! depletion by all vap. dep to ice.
+      
+      IF ( qx(mgs,lc) < qxmin(lc) ) qvimxd(mgs) = 0.99*(qx(mgs,lv)-qis(mgs))*dtpinv ! this makes virtually no difference whatsoever, but what the heck
+      
+      qvimxd(mgs) = max(qvimxd(mgs), 0.0)
+!      qimxd(mgs)  = 0.20*qx(mgs,li)*dtpinv
+!      qcmxd(mgs)  = 0.20*qx(mgs,lc)*dtpinv
+!      qrmxd(mgs)  = 0.20*qx(mgs,lr)*dtpinv
+!      qsmxd(mgs)  = 0.20*qx(mgs,ls)*dtpinv
+!      qhmxd(mgs)  = 0.20*qx(mgs,lh)*dtpinv
 
-       qiacw(mgs) = Min( qiacw(mgs), qxmxd(mgs,lc) )
-      ENDIF
+      frac = 0.1d0
+      qimxd(mgs)  = frac*qx(mgs,li)*dtpinv
+      qcmxd(mgs)  = frac*qx(mgs,lc)*dtpinv
+      qrmxd(mgs)  = frac*qx(mgs,lr)*dtpinv
+      qsmxd(mgs)  = frac*qx(mgs,ls)*dtpinv
+      qhmxd(mgs)  = frac*qx(mgs,lh)*dtpinv
+      IF ( lhl > 1 ) qhlmxd(mgs)  = frac*qx(mgs,lhl)*dtpinv
       end do
-
-
-!
-!
-      if (ndebug .gt. 0 ) write(0,*) 'Collection: cloud ice collects xxxx8'
 !
+      if( ndebug .ge. 0 ) THEN
+!mpi!        write(0,*) 'Set depletion max/min2'
+      endif
+
       do mgs = 1,ngscnt
-      qiacr(mgs) = 0.0
-      qiacrf(mgs) = 0.0
-      qiacrs(mgs) = 0.0
-      ciacrs(mgs) = 0.0
-      ciacr(mgs) = 0.0
-      ciacrf(mgs) = 0.0
-      viacrf(mgs) = 0.0
-      csplinter(mgs) = 0.0
-      qsplinter(mgs) = 0.0
-      csplinter2(mgs) = 0.0
-      qsplinter2(mgs) = 0.0
-      IF ( iacr .ge. 1 .and. eri(mgs) .gt. 0.0    &
-     &     .and. temg(mgs) .le. 270.15 ) THEN
-      IF ( ipconc .ge. 3 ) THEN
-       ni = 0.0
-         IF ( xdia(mgs,li,1) .ge. 10.e-6 ) THEN
-          ni = ni + cx(mgs,li)*Exp(- (40.e-6/xdia(mgs,li,1))**3 )
-         ENDIF
-       IF ( imurain == 1 ) THEN ! gamma of diameter
-           IF ( iacrsize /= 4 ) THEN
-           IF ( iacrsize .eq. 1 ) THEN
-             ratio = 500.e-6/xdia(mgs,lr,1)
-           ELSEIF ( iacrsize .eq. 2 ) THEN
-             ratio = 300.e-6/xdia(mgs,lr,1)
-           ELSEIF ( iacrsize .eq. 3 ) THEN
-             ratio = 40.e-6/xdia(mgs,lr,1)
-           ELSEIF ( iacrsize .eq. 5 ) THEN
-             ratio = 150.e-6/xdia(mgs,lr,1)
-           ENDIF
-           i = Min(nqiacrratio,Int(ratio*dqiacrratioinv))
-           j = Int(Max(0.0,Min(15.,alpha(mgs,lr)))*dqiacralphainv)
-           delx = ratio - float(i)*dqiacrratio
-           dely = alpha(mgs,lr) - float(j)*dqiacralpha
-           ip1 = Min( i+1, nqiacrratio )
-           jp1 = Min( j+1, nqiacralpha )
+!
+      if ( qx(mgs,lc) .le. qxmin(lc) ) then
+      ccmxd(mgs)  = 0.20*cx(mgs,lc)*dtpinv
+      else
+      IF ( ipconc .ge. 2 ) THEN
+        ccmxd(mgs)  = frac*cx(mgs,lc)*dtpinv
+      ELSE
+        ccmxd(mgs)  = frac*qx(mgs,lc)/(xmas(mgs,lc)*rho0(mgs)*dtp)
+      ENDIF
+      end if
+!
+      if ( qx(mgs,li) .le. qxmin(li) ) then
+      cimxd(mgs)  = frac*cx(mgs,li)*dtpinv
+      else
+      IF ( ipconc .ge. 1 ) THEN
+        cimxd(mgs)  = frac*cx(mgs,li)*dtpinv
+      ELSE
+        cimxd(mgs)  = frac*qx(mgs,li)/(xmas(mgs,li)*rho0(mgs)*dtp)
+      ENDIF
+      end if
+!
+!
+      crmxd(mgs)  = 0.10*cx(mgs,lr)*dtpinv
+      csmxd(mgs)  = frac*cx(mgs,ls)*dtpinv
+      chmxd(mgs)  = frac*cx(mgs,lh)*dtpinv
 
-           ! interpolate along x, i.e., ratio
-           tmp1 = ciacrratio(i,j) + delx*dqiacrratioinv*(ciacrratio(ip1,j) - ciacrratio(i,j))
-           tmp2 = ciacrratio(i,jp1) + delx*dqiacrratioinv*(ciacrratio(ip1,jp1) - ciacrratio(i,jp1))
-           
-           ! interpolate along alpha
-           
-           nr = (tmp1 + dely*dqiacralphainv*(tmp2 - tmp1))*cx(mgs,lr)
-           
-           ! interpolate along x, i.e., ratio; 
-           tmp1 = qiacrratio(i,j) + delx*dqiacrratioinv*(qiacrratio(ip1,j) - qiacrratio(i,j))
-           tmp2 = qiacrratio(i,jp1) + delx*dqiacrratioinv*(qiacrratio(ip1,jp1) - qiacrratio(i,jp1))
-           
-           ! interpolate along alpha; 
-           
-           qr = (tmp1 + dely*dqiacralphainv*(tmp2 - tmp1))*qx(mgs,lr)
-           
-           ELSE ! iacrsize == 4 : use all
-             nr = cx(mgs,lr)
-             qr = qx(mgs,lr)
-           ENDIF
+      ccmxd(mgs)  = frac*cx(mgs,lc)*dtpinv
+      cimxd(mgs)  = frac*cx(mgs,li)*dtpinv
+      crmxd(mgs)  = frac*cx(mgs,lr)*dtpinv
+      csmxd(mgs)  = frac*cx(mgs,ls)*dtpinv
+      chmxd(mgs)  = frac*cx(mgs,lh)*dtpinv
 
-          vt = Sqrt((vtxbar(mgs,lr,1)-vtxbar(mgs,li,1))**2 +     &
-     &            0.04*vtxbar(mgs,lr,1)*vtxbar(mgs,li,1) )
+      qxmxd(mgs,lv) = Max(0.0, 0.1*(qx(mgs,lv) - qvs(mgs))*dtpinv)
 
-          qiacr(mgs) = 0.25*pi*eri(mgs)*ni*qr*vt*   &
-     &         (  da0(li)*xdia(mgs,li,3)**2 +     &
-     &            dab1lh(mgs,lr,li)*xdia(mgs,lh,3)*xdia(mgs,li,3) +    &
-     &            da1(lr)*xdia(mgs,lr,3)**2 ) 
-          
-          qiacr(mgs) = Min( qrmxd(mgs), qiacr(mgs) )
-          
+      DO il = lc,lhab
+       qxmxd(mgs,il) = frac*qx(mgs,il)*dtpinv
+       cxmxd(mgs,il) = frac*cx(mgs,il)*dtpinv
+      ENDDO
 
-          ciacr(mgs) = 0.25*pi*eri(mgs)*ni*nr*vt*   &
-     &         (  da0(li)*xdia(mgs,li,3)**2 +     &
-     &            dab0lh(mgs,lr,li)*xdia(mgs,lr,3)*xdia(mgs,li,3) +    &
-     &            da0(lr)*xdia(mgs,lr,3)**2 ) 
+      end do
 
-          ciacr(mgs) = Min( crmxd(mgs), ciacr(mgs) )
-          
-!          write(iunit,*) 'qiacr: ',cx(mgs,lr),nr,qx(mgs,lr),qr,qiacr(mgs),ciacr(mgs)
-!          write(iunit,*) 'xdia r li = ',xdia(mgs,lr,3),xdia(mgs,li,3),xdia(mgs,lr,1),xdia(mgs,li,1)
-!          write(iunit,*) 'i,j,ratio = ',i,j,ciacrratio(i,j),qiacrratio(i,j)
-!          write(iunit,*) 'ni,ci = ',ni,cx(mgs,li),qx(mgs,li)
 
-       ELSEIF ( imurain == 3 ) THEN ! gamma of volume
-!   Set nr to the number of drops greater than 40 microns.
-         arg = 1000.*xdia(mgs,lr,3)
-!         nr = cx(mgs,lr)*gaml02( arg )
-!        IF ( iacr .eq. 1 ) THEN
-         IF ( ipconc .ge. 3 ) THEN
-           IF ( iacrsize .eq. 1 ) THEN
-            nr = cx(mgs,lr)*gaml02d500( arg )  ! number greater than 500 microns in diameter
-           ELSEIF ( iacrsize .eq. 2 .or. iacrsize .eq. 5 ) THEN
-            nr = cx(mgs,lr)*gaml02d300( arg )  ! number greater than 300 microns in diameter
-           ELSEIF ( iacrsize .eq. 3 ) THEN
-            nr = cx(mgs,lr)*gaml02( arg ) ! number greater than 40 microns in diameter
-           ELSEIF ( iacrsize .eq. 4 ) THEN
-            nr = cx(mgs,lr) ! all raindrops
-           ENDIF
-         ELSE
-         nr = cx(mgs,lr)*gaml02( arg )
-         ENDIF
-!        ELSEIF ( iacr .eq. 2 ) THEN
-!         nr = cx(mgs,lr)*gaml02d300( arg )  ! number greater than 300 microns in diameter
-!        ENDIF
-       IF ( ni .gt. 0.0 .and. nr .gt. 0.0 ) THEN
-       d0 = xdia(mgs,lr,3)
-       qiacr(mgs) = xdn(mgs,lr)*rhoinv(mgs)*   &
-     &     (0.217239*(0.522295*(d0**5) +    &
-     &      49711.81*(d0**6) -    &
-     &      1.673016e7*(d0**7)+    &
-     &      2.404471e9*(d0**8) -    &
-     &      1.22872e11*(d0**9))*ni*nr)
-      qiacr(mgs) = Min( qrmxd(mgs), qiacr(mgs) )
-      ciacr(mgs) =   &
-     &   (0.217239*(0.2301947*(d0**2) +    &
-     &      15823.76*(d0**3) -    &
-     &      4.167685e6*(d0**4) +    &
-     &      4.920215e8*(d0**5) -    &
-     &      2.133344e10*(d0**6))*ni*nr)
-      ciacr(mgs) = Min( crmxd(mgs), ciacr(mgs) )
-!      ciacr(mgs) = qiacr(mgs)*cx(mgs,lr)/qx(mgs,lr)
-      ENDIF
+
+
+      IF ( ipelec .ge. 1 ) THEN
+      DO mgs = 1,ngscnt
+      cionpmxd(mgs) = frac*cionp(mgs)*dtpinv
+      cionnmxd(mgs) = frac*cionn(mgs)*dtpinv
+      
+      if (largeion) then
+       clionpmxd(mgs) = frac*clionp(mgs)*dtpinv
+       clionnmxd(mgs) = frac*clionn(mgs)*dtpinv
+      endif
+      
+      ENDDO
       ENDIF
-       IF ( iacr .eq. 1 .or. iacr .eq. 3 ) THEN
-         ciacrf(mgs) = Min(ciacr(mgs), qiacr(mgs)/(1.0*vr1mm*1000.0)*rho0(mgs) ) ! *rzxh(mgs)
-       ELSEIF ( iacr .eq. 2 ) THEN
-         ciacrf(mgs) = ciacr(mgs) ! *rzxh(mgs)
-       ELSEIF ( iacr .eq. 4 ) THEN
-         ciacrf(mgs) = Min(ciacr(mgs), qiacr(mgs)/(1.0*vfrz*1000.0)*rho0(mgs) ) ! *rzxh(mgs)
-       ELSEIF ( iacr .eq. 5 ) THEN
-         ciacrf(mgs) = ciacr(mgs)*rzxh(mgs)
-       ENDIF 
-!      crfrzf(mgs) = Min(crfrz(mgs), qrfrz(mgs)/(bfnu*27.0*vr1mm*1000.0)*rho0(mgs) ) ! rzxh(mgs)*crfrz(mgs)
-       ENDIF
+
+      if ( ipelec .gt. 1 ) then
+!
+!  vertical component of e
+!
+      do mgs = 1,ngscnt
+      dezcomp(mgs) = Max(-1.00e5,   &
+     &   Min(elec(igs(mgs),jgs,kgs(mgs)),1.00e5 )) ! Ez is passed (elecsave)
+      end do
+!       write(0,*) 'dezcomp',MAXVAL(dezcomp),MAXLOC(dezcomp),MINVAL(dezcomp),MINLOC(dezcomp)
+!       write(0,*) 'ELEC3',MAXVAL(elec),MAXLOC(elec),MINVAL(elec),MINLOC(elec)
+
+!
+!  others...
+!
+      if ( nonigrd .ge. 2 ) then
       
+      sctem(:) = 0.0
       
-      ELSE ! single-moment rain
-      qiacr(mgs) =    &
-     &  min(        &
-     &   ((0.25/gf4)*pi)*eri(mgs)*cx(mgs,li)*qx(mgs,lr)   &
-     &  *abs(vtxbar(mgs,lr,1)-vtxbar(mgs,li,1))   &
-     &  *(  gf6*gf1*xdia(mgs,lr,2)    &
-     &    + 2.0*gf5*gf2*xdia(mgs,lr,1)*xdia(mgs,li,1)    &
-     &    + gf4*gf3*xdia(mgs,li,2) )     &
-     &  , qrmxd(mgs))
+      do mgs = 1,ngscnt
+!
+!
+!  temperature factor:
+!      if trever = -21: reduces to jayratene
+!      if trever = -10: reduces to takahashi
+!
+      IF (isaund .eq. 1 .or. isaund .eq. 11) THEN
+        trev = trever
+      ELSEIF (isaund .eq. 2 .or. isaund .eq. 12) THEN  
+        ewtmp = 0.5*1.e3*rho0(mgs)*qx(mgs,lc)
+        trev = max(-23.8, (-15.06 * ewtmp - 7.38))  ! Saunders reversal temp.
+      ELSE
+        trev = trever
       ENDIF
-!      if ( temg(mgs) .gt. 268.15 ) then
-!      qiacr(mgs) = 0.0
-!      ciacr(mgs) = 0.0
-!      end if
 
-      IF ( ipconc .ge. 1 ) THEN
-        IF ( nsplinter .ge. 1000 ) THEN
-        ! Lawson et al. 2015 JAS
-         ! ave. diam of freezing drops in microns
-           IF ( qiacr(mgs)*dtp > qxmin(lh) .and. ciacr(mgs) > 1.e-3 ) THEN
-             tmpdiam = 1.e6*( 6.*qiacr(mgs)/(1000.*pi*ciacr(mgs) ) )**(1./3.) ! avg. diameter of newly frozen drops in microns
-             csplinter(mgs) = lawson_splinter_fac*tmpdiam**4*ciacr(mgs)
-           ENDIF
-        ELSEIF ( nsplinter .ge. 0 ) THEN
-          csplinter(mgs) = nsplinter*ciacr(mgs)
+       IF (ftauopt == 2 ) THEN
+! shift the charge function ftau so that zero crossing matches local
+! reversal temperature.
+        IF (temcg(mgs) .le. -7.5) THEN
+          sctem(mgs) =  ftau( temcg(mgs) - 21.0 - trev )
         ELSE
-          csplinter(mgs) = -nsplinter*ciacrf(mgs)
+          sctem(mgs) = ftau(-7.5 - 21.0 - trev)*(-temcg(mgs)*(1./7.5))
         ENDIF
-        qsplinter(mgs) = Min(0.1*qiacr(mgs), csplinter(mgs)*splintermass/rho0(mgs) ) ! makes splinters smaller if too much mass is taken from graupel
-      ENDIF
-      
-      frach = 1.0
-           IF ( ibiggsnow == 2 .or. ibiggsnow == 3 ) THEN
-           IF ( ciacr(mgs) > qxmin(lh) ) THEN
-           xvfrz = rho0(mgs)*qiacr(mgs)/(ciacr(mgs)*900.) ! mean volume of frozen drops; 900. for frozen drop density
-           frach = 0.5 *(1. +  Tanh(0.2e12 *( xvfrz - 1.15*xvmn(lh))))
-
-             qiacrs(mgs) = (1.-frach)*qiacr(mgs)
-             ciacrs(mgs) = (1.-frach)*ciacr(mgs) ! *rzxh(mgs)
-           
-           ENDIF
-           ENDIF
-
-      qiacrf(mgs) = frach*qiacr(mgs)
-      ciacrf(mgs) = frach*ciacrf(mgs)
+       ELSEIF ( ftauopt == 1 ) THEN
+! do the ziegler/straka shift...
+        IF (temcg(mgs) .lt. 0.0) THEN
+          sctem(mgs) = ftau(max(-25.0,((-21.0)/trev)*temcg(mgs)) )
+        ENDIF
+       
+       ENDIF
 
-      IF ( lvol(lh) > 1 ) THEN
-         viacrf(mgs) = rho0(mgs)*qiacrf(mgs)/rhofrz
-      ENDIF
-      
-      end do
+!      temele = max(-25.0,((-21.0)/trever)*temcg(mgs))
 !
+!      sctem(mgs)  =
+!     >   (-1.7e-05)*(temele**3)
+!     > + (-3.0e-03)*(temele**2)
+!     > + (-5.0e-02)*(temele**1)
+!     > + ( 1.3e-01)
 !
+!  critical (threshold) liquid water content factor (1.0e-04 kg/m**3)
+!
+      if ( temcg(mgs) .ge. trev ) then
+      dellwc(mgs) = (1000.0)*(rho0(mgs)*qx(mgs,lc)-(1.0e-04))
+      end if
+      if ( temcg(mgs) .lt. trev ) then
+      dellwc(mgs) = (1000.0)*(rho0(mgs)*qx(mgs,lc))
+      end if
+      if ( qx(mgs,lc) .lt. 1.e-6 ) dellwc(mgs) = 0.0
 !
+! parabolic function to reduce charging at low temperature
 !
+!      IF ( temcg(mgs) .lt. -30 .and. temcg(mgs) .gt. -43.0 ) THEN
+!        sctem(mgs) = sctem(mgs)*(1.0 - ((temcg(mgs)+30.0)/(43.0 - 30.0))**2)
+      IF ( temcg(mgs) .lt. -30 .and. temcg(mgs) .gt. -40.0 ) THEN
+        sctem(mgs) = sctem(mgs)*(1.0 - ((temcg(mgs)+30.0)/(40.0 - 30.0))**2)
+!      ELSEIF ( temcg(mgs) .le. -43.0 ) THEN
+      ELSEIF ( temcg(mgs) .le. -40.0 ) THEN
+        sctem(mgs) = 0.0
+      END IF
 
-! snow aggregation here
-      if ( ipconc .ge. 4 ) then !
-      do mgs = 1,ngscnt
-      csacs(mgs) = 0.0
-      IF ( qx(mgs,ls) > qxmin(ls) .and. ess(mgs) .gt. 0.0 .and. xv(mgs,ls) < 0.25*xvmx(ls)*Max(1.,100./Min(100.,xdn(mgs,ls)))  ) THEN
-      csacs(mgs) = rvt*aa2*ess(mgs)*cx(mgs,ls)**2*xv(mgs,ls) *Min(1.,xdn(mgs,ls)/100. ) ! Min func tries to recalibrate for low diagnosed density 
-      csacs(mgs) = min(csacs(mgs),csmxd(mgs))
-      ENDIF
       end do
       end if
 !
+      end if
 !
-      if (ndebug .gt. 0 ) write(0,*) 'ICEZVD_GS: conc 11'
-      if ( ipconc .ge. 2 .or. ipelec .ge. 9 ) then
-      do mgs = 1,ngscnt
-      ciacw(mgs) = 0.0
-      IF ( eiw(mgs) .gt. 0.0 ) THEN
-        ciacw(mgs) = qiacw(mgs)*rho0(mgs)/xmas(mgs,lc)
-        ciacw(mgs) = min(ciacw(mgs),ccmxd(mgs))
-      ENDIF
-      end do
 
-      end if
 
-      if (ndebug .gt. 0 ) write(0,*) 'ICEZVD_GS: conc 18'
-      if ( ipconc .ge. 2 .or. ipelec .ge. 1 ) then
-      do mgs = 1,ngscnt
-       cracw(mgs) = 0.0
-       cracr(mgs) = 0.0
-       ec0(mgs) = 1.e9
-      IF ( qx(mgs,lc) .gt. qxmin(lc) .and. qx(mgs,lr) .gt. qxmin(lr)    &
-     &      .and. qracw(mgs) .gt. 0.0 ) THEN
 
-       IF ( ipconc .lt. 3 ) THEN
-        IF ( erw(mgs) .gt. 0.0 ) THEN
-        cracw(mgs) =   &
-     &   ((0.25)*pi)*erw(mgs)*cx(mgs,lc)*cx(mgs,lr)   &
-     &  *abs(vtxbar(mgs,lr,1)-vtxbar(mgs,lc,1))   &
-     &  *(  gf1*xdia(mgs,lc,2)   &
-     &    + 2.0*gf2*xdia(mgs,lc,1)*xdia(mgs,lr,1)   &
-     &    + gf3*xdia(mgs,lr,2) )
-        ENDIF
-       ELSE ! IF ( ipconc .ge. 3 .and. 
-        IF ( dmrauto <= 0 .or.  rho0(mgs)*qx(mgs,lr) > 1.2*xl2p(mgs) ) THEN  !{
-        IF ( 0.5*xdia(mgs,lr,3) .gt. rh(mgs) ) THEN ! { .or. cx(mgs,lr) .gt. nh(mgs) 
-!        IF ( qx(mgs,lc) .gt. qxmin(lc) .and. qx(mgs,lr) .gt. qxmin(lr) ) THEN
-          IF ( 0.5*xdia(mgs,lr,3) .gt. rwradmn ) THEN ! r > 50.e-6 
-!          DM0CCC=A2*XNC*XNR*(XVC+XVR)                               ! (A11)
-!         NOTE: murain drops out, so same result for imurain = 1 and 3
-            cracw(mgs) = aa2*cx(mgs,lr)*cx(mgs,lc)*(xv(mgs,lc) + xv(mgs,lr))
-          ELSE
-            IF ( imurain == 3 ) THEN
-!          DM0CCC=A1*XNC*XNR*(((CNU+2.)/(CNU+1.))*XVC**2+((RNU+2.)/(RNU+1.))*XVR**2) ! (A13)
-            cracw(mgs) = aa1*cx(mgs,lr)*cx(mgs,lc)*   &
-     &          ((cnu + 2.)*xv(mgs,lc)**2/(cnu + 1.) +    &
-     &          (alpha(mgs,lr) + 2.)*xv(mgs,lr)**2/(alpha(mgs,lr) + 1.))
-            ELSE ! imurain == 1 USE CP00 for rain DSD in diameter
-            cracw(mgs) = aa1*cx(mgs,lr)*cx(mgs,lc)*   &
-     &          ((cnu + 2.)*xv(mgs,lc)**2/(cnu + 1.) +    &
-     &          (alpha(mgs,lr) + 6.)*(alpha(mgs,lr) + 5.)*(alpha(mgs,lr) + 4.)*xv(mgs,lr)**2/  &
-     &             ((alpha(mgs,lr) + 3.)*(alpha(mgs,lr) + 2.)*(alpha(mgs,lr) + 1.)) )
-            ENDIF ! imurain
-          ENDIF
-        ENDIF ! } rh
-        ENDIF ! } dmrauto
-       ENDIF ! ipconc
-      ENDIF ! qc > qcmin & qr > qrmin
-        
-! Rain self collection (cracr) and break-up (factor of ec0)
-!
-!       
-        ec0(mgs) = 2.e9
-        IF ( qx(mgs,lr) .gt. qxmin(lr) ) THEN
-        rwrad = 0.5*xdia(mgs,lr,3)
-        IF ( xdia(mgs,lr,3) .gt. 2.0e-3 ) THEN
-          ec0(mgs) = 0.0
-          cracr(mgs) = 0.0
-        ELSE
-         IF ( dmrauto <= 0 .or.  rho0(mgs)*qx(mgs,lr) > 1.2*xl2p(mgs) ) THEN 
-          IF ( xdia(mgs,lr,3) .lt. 6.1e-4 ) THEN
-            ec0(mgs) = 1.0
-          ELSE
-            ec0(mgs) = Exp(-50.0*(50.0*(xdia(mgs,lr,3) - 6.0e-4)))
-          ENDIF
-          
+    ! default factors between mean volume and maximum mass volume
+      maxmassfac(lc) = ( (2. + 3.*(1. + xnu(lc)) )**3/( 3.*(1. + xnu(lc)) ) )
+      maxmassfac(li) = ( (2. + 3.*(1. + xnu(li)) )**3/( 3.*(1. + xnu(li)) ) )
 
-          IF ( rwrad .ge. 50.e-6 ) THEN
-              cracr(mgs) = ec0(mgs)*aa2*cx(mgs,lr)**2*xv(mgs,lr)
-          ELSE
-            IF ( imurain == 3 ) THEN
-             cracr(mgs) = ec0(mgs)*aa1*(cx(mgs,lr)*xv(mgs,lr))**2*   &
-     &                   (alpha(mgs,lr) + 2.)/(alpha(mgs,lr) + 1.)
-            ELSE ! imurain == 1
-             cracr(mgs) = ec0(mgs)*aa1*(cx(mgs,lr)*xv(mgs,lr))**2*   &
-     &                   (alpha(mgs,lr) + 6.)*(alpha(mgs,lr) + 5.)*(alpha(mgs,lr) + 4.)/ &
-     &                  ((alpha(mgs,lr) + 3.)*(alpha(mgs,lr) + 2.)*(alpha(mgs,lr) + 1.))
+      IF ( imurain == 3 ) THEN
+        maxmassfac(lr) = ( (2. + 3.*(1. + xnu(lr)) )**3/( 3.*(1. + xnu(lr)) ) )
+      ELSE
+        maxmassfac(lr) =  (3.0 + alphar)**3/    &
+     &                  ((3.+alphar)*(2.+alphar)*(1. + alphar) )
+      ENDIF
+
+      IF ( imusnow == 3 ) THEN
+        maxmassfac(ls) = ( (2. + 3.*(1. + alphas) )**3/( 3.*(1. + alphas) ) )
+      ELSE
+        maxmassfac(ls) =  (3.0 + alphas)**3/    &
+     &                  ((3.+alphas)*(2.+alphas)*(1. + alphas) )
+      ENDIF
+      
+        maxmassfac(lh) =  (3.0 + alphah)**3/    &
+     &                  ((3.+alphah)*(2.+alphah)*(1. + alphah) )
+
+       IF ( lhl > 1 ) THEN
+        maxmassfac(lhl) =  (3.0 + alphahl)**3/    &
+     &                  ((3.+alphahl)*(2.+alphahl)*(1. + alphahl) )
+       ENDIF
+      
+
+
+       DO mgs = 1,ngscnt
+          DO il = lh,lhab ! graupel and hail only
+            
+            vshdgs(mgs,il) = vshd ! base value
+            
+            IF ( qx(mgs,il) > qxmin(il) ) THEN
+              
+              tmpdiam = (shedalp+alpha(mgs,il))*xdia(mgs,il,1)*( xdn(mgs,il)/917. )**(1./3.) ! erm added density factor for equiv. solid ice sphere 10.12.2015
               
+              IF ( tmpdiam > sheddiam0 ) THEN
+                vshdgs(mgs,il) = 0.523599*(1.5e-3)**3/massfacshr ! 1.5mm drops from very large ice
+              ELSEIF ( tmpdiam > sheddiam ) THEN ! intermediate size
+                vshdgs(mgs,il) = 0.523599*(3.0e-3)**3/massfacshr ! 3.0mm drops from medium-large ice
+              ELSE
+!                vshdgs(mgs,il) = Min( xvmx(lr), xv(mgs,il)*xdn(mgs,il)*0.001 ) ! size of drop from melted mean ice particle
+                vshdgs(mgs,il) = Min( xvmx(lr), 6./pi*xdn(mgs,il)*0.001*tmpdiam**3 )/massfacshr ! size of drop from melted mean ice particle
+              ENDIF
             ENDIF
-          ENDIF
-!          cracr(mgs) = Min(cracr(mgs),crmxd(mgs))
-         ENDIF
-        ENDIF
-        ENDIF
+          ENDDO
+       ENDDO
 
-!      cracw(mgs) = min(cracw(mgs),cxmxd(mgs,lc)) 
-      end do
-      end if
 !
 !
+!  microphysics source terms (1/s) for mixing ratios 
+!
 !
-!  Graupel
 !
-      if (ndebug .gt. 0 ) write(0,*) 'ICEZVD_GS: conc 22ii'
-      chacw(:) = 0.0
-      if ( ipconc .ge. 1 .or. ipelec .ge. 1 ) then
+!  Collection efficiencies:
+!
+      if (ndebug .gt. 0 ) write(0,*) 'ICEZVD_GS: Set collection efficiencies'
+!
+       exy(:,:,:) = 0.0
       do mgs = 1,ngscnt
+!
+!
+!
+      qcwresv(mgs) = 0.0
+      ccwresv(mgs) = 0.0
+      
+      erw(mgs) = 0.0
+      esw(mgs) = 0.0
+      ehw(mgs) = 0.0
+      ehlw(mgs) = 0.0
+!      ehxw(mgs) = 0.0
+!
+      err(mgs) = 0.0
+      esr(mgs) = 0.0
+      il2(mgs) = 0
+      il3(mgs) = 0
+      ehr(mgs) = 0.0
+      ehlr(mgs) = 0.0
+!      ehxr(mgs) = 0.0
+!
+      eri(mgs) = 0.0
+      esi(mgs) = 0.0
+      ehi(mgs) = 0.0 ! used as sticking efficiency, so collection efficiency is ehi*ehiclsn
+      ehis(mgs) = 0.0 ! used as sticking efficiency, so collection efficiency is ehi*ehiclsn
+      ehli(mgs) = 0.0 ! used as sticking efficiency, so collection efficiency is ehli*ehliclsn
+      ehlis(mgs) = 0.0 ! used as sticking efficiency, so collection efficiency is ehli*ehliclsn
+!      ehxi(mgs) = 0.0
+!
+      ers(mgs) = 0.0
+      ess(mgs) = 0.0
+      ehs(mgs) = 0.0 ! used as sticking efficiency, so collection efficiency is ehs*ehsclsn
+      ehls(mgs) = 0.0 ! used as sticking efficiency, so collection efficiency is ehls*ehlsclsn
+      ehscnv(mgs) = 0.0
+!      ehxs(mgs) = 0.0
+!
+      eiw(mgs) = 0.0
+      eii(mgs) = 0.0
 
-      IF ( ipconc .ge. 5 ) THEN
-       IF ( qhacw(mgs) .gt. 0.0 .and. xmas(mgs,lc) .gt. 0.0 ) THEN
+      ehsclsn(mgs) = 0.0
+      ehiclsn(mgs) = 0.0
+      ehlsclsn(mgs) = 0.0
+      ehliclsn(mgs) = 0.0
+      esiclsn(mgs) = 0.0
 
-!  This is the explict version of chacw, which turns out to be very close to the
-!  approximation that the droplet size does not change, to within a few percent.
-!  This may _not_ be the case for cnu other than zero!
-!          chacw(mgs) = (ehw(mgs)*cx(mgs,lc)*cx(mgs,lh)*(pi/4.)*
-!     :    abs(vtxbar(mgs,lh,1)-vtxbar(mgs,lc,1))*
-!     :    (2.0*xdia(mgs,lh,1)*(xdia(mgs,lh,1) +
-!     :         xdia(mgs,lc,1)*gf43rds) +
-!     :      xdia(mgs,lc,2)*gf53rds))
 
-!          chacw(mgs) = Min( chacw(mgs), 0.6*cx(mgs,lc)/dtp )
+! reserve droplets
+         IF ( exwmindiam > 0 .and. qx(mgs,lc) > qxmin(lc) ) THEN
+           tmp = cx(mgs,lc)*Exp(- (exwmindiam/xdia(mgs,lc,1))**3 )
+           ccwresv(mgs) =  Min( cx(mgs,lc), Max( 2.e6,  cx(mgs,lc) -  tmp ) )
+           
+           tmp = cx(mgs,lc) - ccwresv(mgs)
 
-!        chacw(mgs) = qhacw(mgs)*rho0(mgs)/xmas(mgs,lc)
-        chacw(mgs) = qhacw(mgs)*rho0(mgs)/xmascw(mgs)
-!        chacw(mgs) = min(chacw(mgs),cxmxd(mgs,lc))
-        chacw(mgs) = Min( chacw(mgs), 0.5*cx(mgs,lc)/dtp )
-       ELSE
-        qhacw(mgs) = 0.0
-       ENDIF
-      ELSE
-      chacw(mgs) =   &
-     &   ((0.25)*pi)*ehw(mgs)*cx(mgs,lc)*cx(mgs,lh)   &
-     &  *abs(vtxbar(mgs,lh,1)-vtxbar(mgs,lc,1))   &
-     &  *(  gf1*xdia(mgs,lc,2)   &
-     &    + 2.0*gf2*xdia(mgs,lc,1)*xdia(mgs,lh,1)   &
-     &    + gf3*xdia(mgs,lh,2) )
-      chacw(mgs) = min(chacw(mgs),0.5*cx(mgs,lc)/dtp)
-!      chacw(mgs) = min(chacw(mgs),cxmxd(mgs,lc))
-!      chacw(mgs) = min(chacw(mgs),ccmxd(mgs))
-      ENDIF
-      end do
-      end if
-!
-      if (ndebug .gt. 0 ) write(0,*) 'ICEZVD_GS: conc 22kk'
-      chaci(:) = 0.0
-      if ( ipconc .ge. 1 .or. ipelec .ge. 1 ) then
-      do mgs = 1,ngscnt
-      IF ( ehi(mgs) .gt. 0.0 .or. ( ehiclsn(mgs) > 0.0 .and. ipelec > 0 )) THEN
-       IF ( ipconc .ge. 5 ) THEN
+           volt = pi/6.*(exwmindiam)**3
+           qcwresv(mgs) = qx(mgs,lc) - tmp*xdn0(lc)*rhoinv(mgs)*(volt + xv(mgs,lc))
+           
+           
+           IF ( .false. .and. qx(mgs,lc) > 0.1e-3 ) THEN
+           
+             write(0,*) 'cx,qx,crsv,qrsv = ',cx(mgs,lc),qx(mgs,lc),ccwresv(mgs),qcwresv(mgs)
+           
+           ENDIF
 
-       vt = Sqrt((vtxbar(mgs,lh,1)-vtxbar(mgs,li,1))**2 +    &
-     &            0.04*vtxbar(mgs,lh,1)*vtxbar(mgs,li,1) )
+         ENDIF
 
-          chaci0(mgs) = 0.25*pi*ehiclsn(mgs)*cx(mgs,lh)*cx(mgs,li)*vt*   &
-     &         (  da0lh(mgs)*xdia(mgs,lh,3)**2 +     &
-     &            dab0lh(mgs,li,lh)*xdia(mgs,lh,3)*xdia(mgs,li,3) +    &
-     &            da0(li)*xdia(mgs,li,3)**2 )
 
-       ELSE
-        chaci0(mgs) =   &
-     &   ((0.25)*pi)*ehiclsn(mgs)*cx(mgs,li)*cx(mgs,lh)   &
-     &  *abs(vtxbar(mgs,lh,1)-vtxbar(mgs,li,1))   &
-     &  *(  gf1*xdia(mgs,li,2)   &
-     &    + 2.0*gf2*xdia(mgs,li,1)*xdia(mgs,lh,1)   &
-     &    + gf3*xdia(mgs,lh,2) )
-        ENDIF
+      icwr(mgs) = 1
+      IF ( qx(mgs,lc) .gt. qxmin(lc) ) THEN
+       cwrad = 0.5*xdia(mgs,lc,1)
+      DO il = 1,8
+         IF ( cwrad .ge. 1.e-6*cwr(il,1) ) icwr(mgs) = il
+      ENDDO
+      ENDIF
 
-        chaci(mgs) = min(ehi(mgs)*chaci0(mgs),cimxd(mgs))
-       ENDIF
-      end do
-      end if
 
+      irwr(mgs) = 1
+      IF ( qx(mgs,lr) .gt. qxmin(lr) ) THEN
+         rwrad = 0.5*xdia(mgs,lr,3)  ! changed to mean volume diameter (10/6/06)
+      DO il = 1,6
+         IF ( rwrad .ge. 1.e-6*grad(il,1) ) irwr(mgs) = il
+      ENDDO
+      ENDIF
 
-      chacis(:) = 0.0
-      if ( lis > 1 .and. ipconc .ge. 5 .or. ipelec .ge. 1 ) then
-      do mgs = 1,ngscnt
-      IF ( ehis(mgs) .gt. 0.0 .or. ( ehisclsn(mgs) > 0.0 .and. ipelec > 0 )) THEN
 
-       vt = Sqrt((vtxbar(mgs,lh,1)-vtxbar(mgs,lis,1))**2 +    &
-     &            0.04*vtxbar(mgs,lh,1)*vtxbar(mgs,lis,1) )
+      igwr(mgs) = 1
+!      IF ( qx(mgs,lr) .gt. qxmin(lr) ) THEN
+!         rwrad = 0.5*xdia(mgs,lr,1)
+! setting erw = 1 always, so now use igwr for graupel
+      IF ( qx(mgs,lh) .gt. qxmin(lh) ) THEN
+         rwrad = 0.5*xdia(mgs,lh,3)  ! changed to mean volume diameter (10/6/06)
+      DO il = 1,6
+         IF ( rwrad .ge. 1.e-6*grad(il,1) ) igwr(mgs) = il
+      ENDDO
+      ENDIF
 
-          chacis0(mgs) = 0.25*pi*ehisclsn(mgs)*cx(mgs,lh)*cx(mgs,lis)*vt*   &
-     &         (  da0lh(mgs)*xdia(mgs,lh,3)**2 +     &
-     &            dab0lh(mgs,lis,lh)*xdia(mgs,lh,3)*xdia(mgs,lis,3) +    &
-     &            da0(lis)*xdia(mgs,lis,3)**2 )
+      IF ( lhl .gt. 1 ) THEN ! hail is turned on
+      ihlr(mgs) = 1
+      IF ( qx(mgs,lhl) .gt. qxmin(lhl) ) THEN
+         rwrad = 0.5*xdia(mgs,lhl,3)  ! changed to mean volume diameter (10/6/06)
+      DO il = 1,6
+         IF ( rwrad .ge. 1.e-6*grad(il,1) ) ihlr(mgs) = il
+      ENDDO
+      ENDIF
+      ENDIF
 
-
-        chacis(mgs) = min(ehis(mgs)*chacis0(mgs),cxmxd(mgs,lis))
-       ENDIF
-      end do
+!
+!
+!  Ice-Ice: Collection (cxc) efficiencies
+!
+!
+      if ( qx(mgs,li) .gt. qxmin(li) ) then
+!      IF ( ipconc .ge. 14 ) THEN
+!       eii(mgs)=0.1*exp(0.1*temcg(mgs))
+!       if ( temg(mgs) .lt. 243.15 .and. qx(mgs,lc) .gt. 1.e-6 ) then
+!        eii(mgs)=0.1
+!       end if
+!      
+!      ELSE
+        eii(mgs) = exp(0.025*Min(temcg(mgs),0.0))  ! alpha1 from LFO83 (21)
+!      ENDIF
+      if ( temg(mgs) .gt. 273.15 ) eii(mgs) = 1.0
       end if
 !
 !
-      if (ndebug .gt. 0 ) write(0,*) 'ICEZVD_GS: conc 22nn'
-      chacs(:) = 0.0
-      if ( ipconc .ge. 1 .or. ipelec .ge. 1 ) then
-      do mgs = 1,ngscnt
-      IF ( ehs(mgs) .gt. 0 ) THEN
-       IF ( ipconc .ge. 5 .or. ( ehsclsn(mgs) > 0.0 .and. ipelec > 0 ) ) THEN
-
-       vt = Sqrt((vtxbar(mgs,lh,1)-vtxbar(mgs,ls,1))**2 +    &
-     &            0.04*vtxbar(mgs,lh,1)*vtxbar(mgs,ls,1) )
-
-          chacs0(mgs) = 0.25*pi*ehsclsn(mgs)*cx(mgs,lh)*cx(mgs,ls)*vt*   &
-     &         (  da0lh(mgs)*xdia(mgs,lh,3)**2 +     &
-     &            dab0lh(mgs,ls,lh)*xdia(mgs,lh,3)*xdia(mgs,ls,3) +    &
-     &            da0(ls)*xdia(mgs,ls,3)**2 )
-
-       ELSE
-      chacs0(mgs) =   &
-     &   ((0.25)*pi)*ehsclsn(mgs)*cx(mgs,ls)*cx(mgs,lh)   &
-     &  *abs(vtxbar(mgs,lh,1)-vtxbar(mgs,ls,1))   &
-     &  *(  gf3*gf1*xdia(mgs,ls,2)   &
-     &    + 2.0*gf2*gf2*xdia(mgs,ls,1)*xdia(mgs,lh,1)   &
-     &    + gf1*gf3*xdia(mgs,lh,2) )
-      ENDIF
-      chacs(mgs) = min(ehs(mgs)*chacs0(mgs),csmxd(mgs))
-      ENDIF
-      end do
+!
+!  Ice-cloud water: Collection (cxc) efficiencies
+!
+!
+      eiw(mgs) = 0.0
+      if ( qx(mgs,li).gt.qxmin(li) .and. qx(mgs,lc).gt.qxmin(lc) ) then
+      
+      
+      if (xdia(mgs,lc,1).gt.15.0e-06 .and. xdia(mgs,li,1).gt.30.0e-06) then
+! erm 5/10/2007 test following change:
+!      if (xdia(mgs,lc,1).gt.12.0e-06 .and. xdia(mgs,li,1).gt.50.0e-06) then
+      eiw(mgs) = 0.5
+      end if
+      if ( temg(mgs) .ge. 273.15 ) eiw(mgs) = 0.0
       end if
-
 
 !
 !
-!  Hail
 !
-      if (ndebug .gt. 0 ) write(0,*) 'ICEZVD_GS: conc 22ii'
-      chlacw(:) = 0.0
-      if ( ipconc .ge. 1 .or. ipelec .ge. 1 ) then
-      do mgs = 1,ngscnt
-
-      IF ( lhl .gt. 1 .and. ipconc .ge. 5 ) THEN
-       IF ( qhlacw(mgs) .gt. 0.0 .and. xmas(mgs,lc) .gt. 0.0 ) THEN
-
-!  This is the explict version of chacw, which turns out to be very close to the
-!  approximation that the droplet size does not change, to within a few percent.
-!  This may _not_ be the case for cnu other than zero!
-!          chlacw(mgs) = (ehlw(mgs)*cx(mgs,lc)*cx(mgs,lhl)*(pi/4.)*
-!     :    abs(vtxbar(mgs,lhl,1)-vtxbar(mgs,lc,1))*
-!     :    (2.0*xdia(mgs,lhl,1)*(xdia(mgs,lhl,1) +
-!     :         xdia(mgs,lc,1)*gf43rds) +
-!     :      xdia(mgs,lc,2)*gf53rds))
-
-!          chlacw(mgs) = Min( chlacw(mgs), 0.6*cx(mgs,lc)/dtp )
-
-!        chlacw(mgs) = qhlacw(mgs)*rho0(mgs)/xmas(mgs,lc)
-        chlacw(mgs) = qhlacw(mgs)*rho0(mgs)/xmascw(mgs)
-!        chlacw(mgs) = min(chlacw(mgs),cxmxd(mgs,lc))
-        chlacw(mgs) = Min( chlacw(mgs), 0.5*cx(mgs,lc)/dtp )
-       ELSE
-        qhlacw(mgs) = 0.0
-       ENDIF
-!      ELSE
-!      chlacw(mgs) =
-!     >   ((0.25)*pi)*ehlw(mgs)*cx(mgs,lc)*cx(mgs,lhl)
-!     >  *abs(vtxbar(mgs,lhl,1)-vtxbar(mgs,lc,1))
-!     >  *(  gf1*xdia(mgs,lc,2)
-!     >    + 2.0*gf2*xdia(mgs,lc,1)*xdia(mgs,lhl,1)
-!     >    + gf3*xdia(mgs,lhl,2) )
-!      chlacw(mgs) = min(chlacw(mgs),0.5*cx(mgs,lc)/dtp)
-!      chlacw(mgs) = min(chlacw(mgs),cxmxd(mgs,lc))
-!      chlacw(mgs) = min(chlacw(mgs),ccmxd(mgs))
-      ENDIF
-      end do
-      end if
+!  Rain: Collection (cxc) efficiencies
 !
-      if (ndebug .gt. 0 ) write(0,*) 'ICEZVD_GS: conc 22kk'
-      chlaci(:) = 0.0
-      chlaci0(:) = 0.0
-      if ( ipconc .ge. 1 .or. ipelec .ge. 1 ) then
-      do mgs = 1,ngscnt
-      IF ( lhl .gt. 1 .and. ( ehli(mgs) .gt. 0.0 .or. (ipelec > 0 .and. ehliclsn(mgs) > 0.0) )  ) THEN
-       IF ( ipconc .ge. 5 ) THEN
-
-       vt = Sqrt((vtxbar(mgs,lhl,1)-vtxbar(mgs,li,1))**2 +    &
-     &            0.04*vtxbar(mgs,lhl,1)*vtxbar(mgs,li,1) )
+!
+      if ( qx(mgs,lr).gt.qxmin(lr) .and. qx(mgs,lc).gt.qxmin(lc) ) then
 
-          chlaci0(mgs) = 0.25*pi*ehliclsn(mgs)*cx(mgs,lhl)*cx(mgs,li)*vt*   &
-     &         (  da0lhl(mgs)*xdia(mgs,lhl,3)**2 +     &
-     &            dab0(lhl,li)*xdia(mgs,lhl,3)*xdia(mgs,li,3) +    &
-     &            da0(li)*xdia(mgs,li,3)**2 )
+       IF ( lnr .gt. 1 ) THEN
+       erw(mgs) = 1.0
 
-!       ELSE
-!        chlaci(mgs) =
-!     >   ((0.25)*pi)*ehli(mgs)*cx(mgs,li)*cx(mgs,lhl)
-!     >  *abs(vtxbar(mgs,lhl,1)-vtxbar(mgs,li,1))
-!     >  *(  gf1*xdia(mgs,li,2)
-!     >    + 2.0*gf2*xdia(mgs,li,1)*xdia(mgs,lhl,1)
-!     >    + gf3*xdia(mgs,lhl,2) )
-        ENDIF
+       ELSE
 
-        chlaci(mgs) = min(ehli(mgs)*chlaci0(mgs),cimxd(mgs))
-       ENDIF
-      end do
-      end if
+!      cwrad = 0.5*xdia(mgs,lc,1)
+!      erw(mgs) =
+!     >  min((aradcw + cwrad*(bradcw + cwrad*
+!     <  (cradcw + cwrad*(dradcw)))), 1.0)
+!       IF ( xdia(mgs,lc,1) .lt. 2.4e-06 .or. xdia(mgs,lr,1) .le. 50.0e-6 ) THEN
+!          erw(mgs)=0.0
+!       ENDIF
+!       erw(mgs) = ew(icwr(mgs),igwr(mgs))
+! interpolate along droplet radius
+       ic = icwr(mgs)
+       icp1 = Min( 8, ic+1 )
+       ir = irwr(mgs)
+       irp1 = Min( 6, ir+1 )
+       cwrad = 0.5*xdia(mgs,lc,3)
+       rwrad = 0.5*xdia(mgs,lr,3)
+       
+       slope1 = (ew(icp1, ir  ) - ew(ic,ir  ))*cwr(ic,2)
+       slope2 = (ew(icp1, irp1) - ew(ic,irp1))*cwr(ic,2)
 
+!       write(iunit,*) 'slop1: ',slope1,slope2,ew(ic,ir),cwr(ic,2)
 
-      IF ( lis > 1 .and. ipconc .ge. 5) THEN
-      
-      if (ndebug .gt. 0 ) write(0,*) 'ICEZVD_GS: conc 22kk'
-      chlacis(:) = 0.0
-      chlacis0(:) = 0.0
-       do mgs = 1,ngscnt
-      IF ( lhl .gt. 1 .and. ( ehlis(mgs) .gt. 0.0 .or. (ipelec > 0 .and. ehlisclsn(mgs) > 0.0) )  ) THEN
+       x1 = ew(ic,  ir) + slope1*Max(0.0, (cwrad - cwr(ic,1)) )
+       x2 = ew(icp1,ir) + slope2*Max(0.0, (cwrad - cwr(ic,1)) )
 
-       vt = Sqrt((vtxbar(mgs,lhl,1)-vtxbar(mgs,lis,1))**2 +    &
-     &            0.04*vtxbar(mgs,lhl,1)*vtxbar(mgs,lis,1) )
+       slope1 = (x2 - x1)*grad(ir,2)
 
-          chlacis0(mgs) = 0.25*pi*ehlisclsn(mgs)*cx(mgs,lhl)*cx(mgs,lis)*vt*   &
-     &         (  da0lhl(mgs)*xdia(mgs,lhl,3)**2 +     &
-     &            dab0(lhl,lis)*xdia(mgs,lhl,3)*xdia(mgs,lis,3) +    &
-     &            da0(lis)*xdia(mgs,lis,3)**2 )
+       erw(mgs) = Max(0.0, x1 + slope1*Max(0.0, (rwrad - grad(ir,1)) ))
 
+!       write(iunit,*) 'erw: ',erw(mgs),1.e6*cwrad,1.e6*rwrad,ic,ir,x1,x2
+!       write(iunit,*)
 
-        chlacis(mgs) = min(ehlis(mgs)*chlacis0(mgs),cxmxd(mgs,lis))
+       erw(mgs) = Max(0.0, erw(mgs) )
+       IF ( rwrad .lt. 50.e-6 ) THEN
+         erw(mgs) = 0.0
+       ELSEIF (  rwrad .lt. 100.e-6 ) THEN  ! linear change from zero at 50 to erw at 100 microns
+         erw(mgs) = erw(mgs)*(rwrad - 50.e-6)/50.e-6
        ENDIF
-      end do
-      ENDIF
 
+       ENDIF
+      end if
+      IF ( cx(mgs,lc) .le. 0.0 ) erw(mgs) = 0.0
 !
+      if ( qx(mgs,lr).gt.qxmin(lr) .and. qx(mgs,lr).gt.qxmin(lr) ) then
+      err(mgs)=1.0
+      end if
 !
-      if (ndebug .gt. 0 ) write(0,*) 'ICEZVD_GS: conc 22jj'
-      chlacs(:) = 0.0
-      chlacs0(:) = 0.0
-      if ( ipconc .ge. 1 .or. ipelec .ge. 1 ) then
-      do mgs = 1,ngscnt
-      IF ( lhl .gt. 1 .and. ( ehls(mgs) .gt. 0.0 .or. (ipelec > 0 .and. ehlsclsn(mgs) > 0.0) ) ) THEN
-       IF ( ipconc .ge. 5 ) THEN
-
-       vt = Sqrt((vtxbar(mgs,lhl,1)-vtxbar(mgs,ls,1))**2 +    &
-     &            0.04*vtxbar(mgs,lhl,1)*vtxbar(mgs,ls,1) )
-
-          chlacs0(mgs) = 0.25*pi*ehlsclsn(mgs)*cx(mgs,lhl)*cx(mgs,ls)*vt*   &
-     &         (  da0lhl(mgs)*xdia(mgs,lhl,3)**2 +     &
-     &            dab0(lhl,ls)*xdia(mgs,lhl,3)*xdia(mgs,ls,3) +    &
-     &            da0(ls)*xdia(mgs,ls,3)**2 )
-
-!       ELSE
-!      chlacs(mgs) =
-!     >   ((0.25)*pi)*ehls(mgs)*cx(mgs,ls)*cx(mgs,lhl)
-!     >  *abs(vtxbar(mgs,lhl,1)-vtxbar(mgs,ls,1))
-!     >  *(  gf3*gf1*xdia(mgs,ls,2)
-!     >    + 2.0*gf2*gf2*xdia(mgs,ls,1)*xdia(mgs,lhl,1)
-!     >    + gf1*gf3*xdia(mgs,lhl,2) )
-      ENDIF
-      chlacs(mgs) = min(ehls(mgs)*chlacs0(mgs),csmxd(mgs))
-      ENDIF
-      end do
+      if ( qx(mgs,lr).gt.qxmin(lr) .and. qx(mgs,ls).gt.qxmin(ls) ) then
+      ers(mgs)=1.0
       end if
-
 !
-! Ziegler (1985) autoconversion
+      if ( qx(mgs,lr).gt.qxmin(lr) .and. qx(mgs,li).gt.qxmin(li) ) then
+!        IF ( vtxbar(mgs,lr,1) .gt. vtxbar(mgs,li,1) .and.
+!     :       xdia(mgs,lr,3) .gt. 200.e-6 .and. xdia(mgs,li,3) .gt. 100.e-6 ) THEN
+         eri(mgs) = eri0
+!      cwrad = 0.5*xdia(mgs,li,3)
+!      eri(mgs) =
+!     >  1.0*min((aradcw + cwrad*(bradcw + cwrad*
+!     <  (cradcw + cwrad*(dradcw)))), 1.0)
+!         ENDIF
+!       if ( xdia(mgs,li,1) .lt. 10.e-6 ) eri(mgs)=0.0
+       if ( xdia(mgs,li,3) .lt. eri_cimin ) eri(mgs)=0.0
+      end if
 !
 !
-      IF ( ipconc .ge. 2 .and. ircnw /= -1) THEN ! DTD: added flag for autoconversion.  If -1, turns off autoconversion
-      if (ndebug .gt. 0 ) write(0,*) 'conc 26a'
+!  Snow aggregates: Collection (cxc) efficiencies
+!
+! Modified by ERM with a linear function for small droplets and large
+! snow agg. based numerical data from Wang and Ji (1992) in P&K 1997 (Fig. 14-13), which
+! allows collection of very small droplets, albeit at low efficiency.  But slow
+! fall speeds of snow make up for the efficiency.
+!
+      esw(mgs) = 0.0
+      if ( qx(mgs,ls).gt.qxmin(ls) .and. qx(mgs,lc).gt.qxmin(lc) ) then
+        esw(mgs) = 0.5
+        if ( xdia(mgs,lc,1) .gt. 15.e-6 .and. xdia(mgs,ls,1) .gt. 100.e-6) then
+          esw(mgs) = 0.5
+        ELSEIF ( xdia(mgs,ls,1) .ge. 500.e-6 ) THEN
+          esw(mgs) = Min(0.5, 0.05 + (0.8-0.05)/(40.e-6)*xdia(mgs,lc,1) )
+        ENDIF
+      end if
+!
+      if ( qx(mgs,ls).gt.qxmin(ls) .and. qx(mgs,lr).gt.qxmin(lr)  &
+     &     .and. temg(mgs) .lt. tfr - 1.   &
+     &                               ) then
+      esr(mgs)=Exp(-(40.e-6)**3/xv(mgs,lr))*Exp(-40.e-6/xdia(mgs,ls,1))
+      IF ( qx(mgs,ls) < 1.e-4 .and. qx(mgs,lr) < 1.e-4 ) il2(mgs) = 1
+      end if
       
-      DO mgs = 1,ngscnt
-        zrcnw(mgs) = 0.0
-        qrcnw(mgs) = 0.0
-        crcnw(mgs) = 0.0
-        cautn(mgs) = 0.0
-      ENDDO
+      IF ( ipconc < 3 .and. temg(mgs) < tfr .and. qx(mgs,lr).gt.qxmin(lr) .and. qx(mgs,lr) < 1.e-4 ) THEN
+        il3(mgs) = 1
+      ENDIF
+!
+!      if ( qx(mgs,ls).gt.qxmin(ls) ) then
+      if ( temcg(mgs) < 0.0 ) then
+            
+      IF ( ipconc .lt. 4 .or. temcg(mgs) < esstem1 ) THEN
+        ess(mgs) = 0.0
+!        ess(mgs)=0.1*exp(0.1*min(temcg(mgs),0.0))
+!        ess(mgs)=min(0.1,ess(mgs))
       
-      DO mgs = 1,ngscnt
-!      qracw(mgs) = 0.0
-!      cracw(mgs) = 0.0
-       IF ( qx(mgs,lc) .gt. qxmin(lc) .and. cx(mgs,lc) .gt. 1000. .and. temg(mgs) .gt. tfrh+4.) THEN
-       ! .and. w(igs(mgs),jgs,kgs(mgs)) > 5.0) THEN ! DTD: added w threshold for testing                                                                                                            
-         volb = xv(mgs,lc)*(1./(1.+CNU))**(1./2.)
-         cautn(mgs) = Min(ccmxd(mgs),   &
-     &      ((CNU+2.)/(CNU+1.))*aa1*cx(mgs,lc)**2*xv(mgs,lc)**2)
-         cautn(mgs) = Max( 0.0d0, cautn(mgs) )
-         IF ( rb(mgs) .le. 7.51d-6 ) THEN
-           t2s = 1.d30
-!           cautn(mgs) = 0.0
-         ELSE
-!         XL2P=2.7E-2*XNC*XVC*((1.E12*RB**3*RC)-0.4)
-         
-!        T2S=3.72E-3/(((1.E4*RB)-7.5)*XNC*XVC) 
-!           t2s = 3.72E-3/(((1.e6*rb)-7.5)*cx(mgs,lc)*xv(mgs,lc))
-!           t2s = 3.72/(((1.e6*rb(mgs))-7.5)*rho0(mgs)*qx(mgs,lc))
-           t2s = 3.72/(1.e6*(rb(mgs)-7.500d-6)*rho0(mgs)*qx(mgs,lc))
-
-           qrcnw(mgs) = Max( 0.0d0, xl2p(mgs)/(t2s*rho0(mgs)) )
-           crcnw(mgs) = Max( 0.0d0, Min(3.5e9*xl2p(mgs)/t2s,0.5*cautn(mgs)) )
-           
-           IF ( dmrauto == 0 ) THEN
-             IF ( qx(mgs,lr)*rho0(mgs) > 1.2*xl2p(mgs) .and. cx(mgs,lr) > cxmin ) THEN ! Cohard and Pinty (2000a) switch over from (18) to (19)
-               crcnw(mgs) = cx(mgs,lr)/qx(mgs,lr)*qrcnw(mgs)
-             ENDIF
-           ELSEIF ( dmrauto == 1  .and. cx(mgs,lr) > cxmin) THEN
-             IF ( qx(mgs,lr) > qxmin(lr) ) THEN
-               tmp = qrcnw(mgs)*cx(mgs,lr)/qx(mgs,lr)
-               crcnw(mgs) = Min(tmp,crcnw(mgs) )
-             ENDIF
-           ELSEIF ( dmrauto == 2  .and. cx(mgs,lr) > cxmin) THEN
-               tmp = crcnw(mgs)
-               tmp2 = qrcnw(mgs)*cx(mgs,lr)/qx(mgs,lr)
-               ! try mass-weighted average of old and new Dmr
-               crcnw(mgs) = (tmp*qrcnw(mgs)+tmp2*qx(mgs,lr))/(qrcnw(mgs)+qx(mgs,lr))
-           ELSEIF ( dmrauto == 3  .and. cx(mgs,lr) > cxmin) THEN ! adapted from MY/CP code
-              tmp = Max( 2.d0*rh(mgs), dble( xdia(mgs,lr,3) ) )
-              crcnw(mgs) = rho0(mgs)*qrcnw(mgs)/(pi/6.*1000.*tmp**3)
-           ENDIF
-           
-           IF ( crcnw(mgs) < 1.e-30 ) qrcnw(mgs) = 0.0
-
-!           IF (  crcnw(mgs) .gt. cautn(mgs) .and. crcnw(mgs) .gt. 1.0 )
-!     :          THEN
-!             write(0,*)  'crcnw,cautn ',crcnw(mgs)/cautn(mgs),
-!     :          crcnw(mgs),cautn(mgs),igs(mgs),kgs(mgs),t2s,qx(mgs,lr)
-!             write(0,*)  '            ',qx(mgs,lc),cx(mgs,lc),0.5e6*xdia(mgs,lc,1)
-!             write(0,*)  '            ',rho0(mgs)*qrcnw(mgs)/crcnw(mgs),
-!     :         1.e6*(( 3/(4.*pi))*rho0(mgs)*qrcnw(mgs)/
-!     :       (crcnw(mgs)*xdn(mgs,lr)))**(1./3.),rh(mgs)*1.e6,rwrad(mgs)
-!           ELSEIF ( crcnw(mgs) .gt. 1.0 .and. cautn(mgs) .gt. 0.) THEN
-!             write(0,*)  'crcnw,cautn ',crcnw(mgs)/cautn(mgs),
-!     :          crcnw(mgs),cautn(mgs),igs(mgs),kgs(mgs),t2s
-!             write(0,*)  '            ',rho0(mgs)*qrcnw(mgs)/crcnw(mgs),
-!     :  1.e6*(( 3*pi/4.)*rho0(mgs)*qrcnw(mgs)/
-!     :   (crcnw(mgs)*xdn(mgs,lr)))**(1./3.)
-!           ENDIF
-!           crcnw(mgs) = Min(cautn(mgs),3.5e9*xl2p(mgs)/t2s)
-
-!           IF ( qrcnw(mgs) .gt. 0.3e-2 ) THEN
-!            write(0,*)  'QRCNW'
-!            write(0,*)  qrcnw(mgs),crcnw(mgs),cautn(mgs)
-!            write(0,*)  xl2p,t2s,rho0(mgs),xv(mgs,lc),cx(mgs,lc),qx(mgs,lc)
-!            write(0,*)  rb,0.5*xdia(mgs,lc,1),mgs,igs(mgs),kgs(mgs)
-!           ENDIF
-!           qrcnw(mgs) = Min(qrcnw(mgs),qcmxd(mgs))
+      ELSE
+      
+        fac = Abs(ess0)
+        IF ( .true. .and. ess0 < 0.0 ) THEN
+!         IF ( wvel(mgs) > 2.0 .or. wvel(mgs) < -0.5 .or. ssi(mgs) < 1.0 ) THEN
+         IF ( wvel(mgs) > 2.0 ) THEN
+          ! assume convective cell or downdraft
+           fac = 0.0
+         ELSEIF ( wvel(mgs) > 1.0 ) THEN ! transition to stratiform range of values
+           fac = Max(0.0, 2.0 - wvel(mgs))*fac
          ENDIF
+        ENDIF
+        
+        IF ( temcg(mgs) > esstem1 .and. temcg(mgs) < esstem2 ) THEN  ! only nonzero for T > -25
+          ess(mgs) = fac*Exp(ess1*(esstem2) )*(temcg(mgs) - esstem1)/(esstem2 - esstem1) ! linear ramp up from zero at esstem1 to value at esstem2
+        ELSEIF ( temcg(mgs) >= esstem2 ) THEN
+          ess(mgs) = fac*Exp(ess1*Min( temcg(mgs), 0.0 ) )
+        ENDIF
+        
+      ENDIF
+      end if
+!
+      if ( qx(mgs,ls).gt.qxmin(ls) .and. qx(mgs,li).gt.qxmin(li) ) then
+       esiclsn(mgs) = esi_collsn
+!      IF ( ipconc .lt. 4 ) THEN
+      IF ( ipconc < 1 .and. lwsm6 ) THEN
+        esi(mgs) = exp(0.7*min(temcg(mgs),0.0))
+      ELSE
+        esi(mgs) = esi0*exp(0.1*min(temcg(mgs),0.0))
+        esi(mgs) = Min(0.1,esi(mgs))
+      ENDIF
+      IF ( ipconc .le. 3 ) THEN
+       esi(mgs) =  exp(0.025*min(temcg(mgs),0.0)) ! LFO
+!       esi(mgs) =  Min(0.5, exp(0.025*min(temcg(mgs),0.0)) ) ! LFO
+!       esi(mgs)=0.5*exp(0.1*min(temcg(mgs),0.0))  ! 10ice
+      ENDIF
+!      ELSE ! zrnic/ziegler 1993
+!      esi(mgs)= 0.1 ! 0.5*exp(0.1*min(temcg(mgs),0.0))
+!      ENDIF
+      if ( temg(mgs) .gt. 273.15 ) esi(mgs) = 0.0
+      end if
+!
+!
+!
+!
+!  Graupel: Collection (cxc) efficiencies
+!
+!
+       xmascw(mgs) = xmas(mgs,lc)
+      if ( qx(mgs,lh).gt.qxmin(lh) .and. qx(mgs,lc).gt.qxmin(lc) ) then
+       ehw(mgs) = 1.0
+       IF ( iehw .eq. 0 ) THEN
+       ehw(mgs) = ehw0  ! default value is 1.0
+       ELSEIF ( iehw .eq. 1 .or. iehw .eq. 10 ) THEN
+      cwrad = 0.5*xdia(mgs,lc,1)
+      ehw(mgs) = Min( ehw0,    &
+     &  ewfac*min((aradcw + cwrad*(bradcw + cwrad*   &
+     &  (cradcw + cwrad*(dradcw)))), 1.0) )
+      
+       ELSEIF ( iehw .eq. 2 .or. iehw .eq. 10 ) THEN
+       ic = icwr(mgs)
+       icp1 = Min( 8, ic+1 )
+       ir = igwr(mgs)
+       irp1 = Min( 6, ir+1 )
+       cwrad = 0.5*xdia(mgs,lc,1)
+       rwrad = 0.5*xdia(mgs,lh,3)  ! changed to mean volume diameter
+       
+       slope1 = (ew(icp1, ir  ) - ew(ic,ir  ))*cwr(ic,2)
+       slope2 = (ew(icp1, irp1) - ew(ic,irp1))*cwr(ic,2)
+ 
+!        write(iunit,*) 'slop1: ',slope1,slope2,ew(ic,ir),cwr(ic,2)
 
+       x1 = ew(ic,  ir) + slope1*Max(0.0, (cwrad - cwr(ic,1)) )
+       x2 = ew(icp1,ir) + slope2*Max(0.0, (cwrad - cwr(ic,1)) )
+       
+       slope1 = (x2 - x1)*grad(ir,2)
+       
+       tmp = Max( 0.0, Min( 1.0, x1 + slope1*Max(0.0, (rwrad - grad(ir,1)) ) ) )
+       ehw(mgs) = Min( ehw(mgs), tmp )
 
-       ENDIF
-      ENDDO
+!       write(iunit,*) 'ehw: ',ehw(mgs),1.e6*cwrad,1.e6*rwrad,ic,ir,x1,x2
+!       write(iunit,*)
 
+!       ehw(mgs) = Max( 0.2, ehw(mgs) )
+!  assume that ehw = 1 for zero air resistance (rho0 = 0.0) and extrapolate toward that
+!      ehw(mgs) = ehw(mgs) + (ehw(mgs) - 1.0)*(rho0(mgs) - rho00)/rho00
+!      ehw(mgs) = ehw(mgs) + (1.0 - ehw(mgs))*((Max(0.0,rho00 - rho0(mgs)))/rho00)**2
 
+       ELSEIF ( iehw .eq. 3 .or. iehw .eq. 10 ) THEN ! use fraction of droplets greater than dmincw diameter
+         tmp = Exp(- (dmincw/xdia(mgs,lc,1))**3)
+         xmascw(mgs) = xmas(mgs,lc) + xdn0(lc)*(pi*dmincw**3/6.0) ! this is the average mass of the droplets with d > dmincw
+         ehw(mgs) = Min( ehw(mgs), tmp )
+       ELSEIF ( iehw .eq. 4 .or. iehw .eq. 10 ) THEN ! Cober and List 1993
+         tmp =  &
+     &   2.0*xdn(mgs,lc)*vtxbar(mgs,lh,1)*(0.5*xdia(mgs,lc,1))**2 &
+     &  /(9.0*fadvisc(mgs)*0.5*xdia(mgs,lh,3))
+         tmp = Max( 1.5, Min(10.0, tmp) )
+         ehw(mgs) = Min( ehw(mgs), 0.55*Log10(2.51*tmp) )
+       ENDIF
+      if ( xdia(mgs,lc,1) .lt. 2.4e-06 ) ehw(mgs)=0.0
 
-      ELSE
+       ehw(mgs) = Min( ehw0, ehw(mgs) )
+       
+       IF ( ibfc == -1 .and. temcg(mgs) < -41.0 ) THEN
+        ehw(mgs) = 0.0
+       ENDIF 
 
+      end if
 !
-!  Berry 1968 auto conversion for rain (Orville & Kopp 1977)
+      if ( qx(mgs,lh).gt.qxmin(lh) .and. qx(mgs,lr).gt.qxmin(lr)    &
+!     &     .and. temg(mgs) .lt. tfr    &
+     &                               ) then
+!      ehr(mgs) = Exp(-(40.e-6)**3/xv(mgs,lr))*Exp(-40.e-6/xdia(mgs,lh,1))
+!      ehr(mgs) = 1.0
+       ehr(mgs) = Exp(-(40.e-6)/xdia(mgs,lr,3))*Exp(-40.e-6/xdia(mgs,lh,3))
+       ehr(mgs) = Min( ehr0, ehr(mgs) )
+      end if
 !
+      IF ( qx(mgs,ls).gt.qxmin(ls) ) THEN
+        IF ( ipconc .ge. 4 ) THEN
+        ehscnv(mgs) = ehs0*exp(ehs1*min(temcg(mgs),0.0)) ! for 2-moment, used as default for ehs and ehls. Otherwise not used for snow->graupel conversion
+        ELSE
+        ehscnv(mgs) = exp(0.09*min(temcg(mgs),0.0))
+        ENDIF
+        if ( qx(mgs,lh).gt.qxmin(lh) .and. qx(mgs,lc) > qxmin(lc)  ) then
+          ehsclsn(mgs) = ehs_collsn
+          IF ( xdia(mgs,ls,3) < 40.e-6 ) THEN
+            ehsclsn(mgs) = 0.0
+          ELSEIF ( xdia(mgs,ls,3) < 150.e-6 ) THEN
+            ehsclsn(mgs) =  ehs_collsn*(xdia(mgs,ls,3) - 40.e-6)/(150.e-6 - 40.e-6)
+          ELSE
+            ehsclsn(mgs) = ehs_collsn
+          ENDIF
+!          ehs(mgs) = ehscnv(mgs)*Min(1.0, Max(0., xdn(mgs,lh) - xdnmn(lh)*1.2)/xdnmn(lh)  ) ! shut off qhacs as graupel goes to lowest density
+          ehs(mgs) = ehscnv(mgs)*Min(1.0, Max(0.0,xdn(mgs,lh) - 300.)/300.  ) ! shut off qhacs as graupel goes to low density
+          ehs(mgs) = Min(ehs(mgs),ehsmax)
+          IF ( qx(mgs,lc) < qxmin(lc) ) ehs(mgs) = 0.0
+        end if
+      ENDIF
 !
-      if ( ircnw .eq. 4 ) then
-      do mgs = 1,ngscnt
-!      sconvmix(lcw,mgs) = 0.0
-      qrcnw(mgs) =  0.0
-      qdiff = max((qx(mgs,lc)-qminrncw),0.0)
-      if ( qdiff .gt. 0.0 .and. xdia(mgs,lc,1) .gt. 20.0e-6 ) then
-      argrcnw =   &
-     &  ((1.2e-4)+(1.596e-12)*(cx(mgs,lc)*1.0e-6)   &
-     &  /(cwdisp*qdiff*1.0e-3*rho0(mgs)))
-      qrcnw(mgs) = (rho0(mgs)*1e-3)*(qdiff**2)/argrcnw
-!      sconvmix(lcw,mgs) = max(sconvmix(lcw,mgs),0.0)
-      qrcnw(mgs) = (max(qrcnw(mgs),0.0))
+      if ( qx(mgs,lh).gt.qxmin(lh) .and. qx(mgs,li).gt.qxmin(li) ) then
+      ehiclsn(mgs) = ehi_collsn
+      ehi(mgs)=eii0*exp(eii1*min(temcg(mgs),0.0))
+      ehi(mgs) = Min( ehimax, Max( ehi(mgs), ehimin ) )
+      if ( temg(mgs) .gt. 273.15 .or. ( qx(mgs,lc) < qxmin(lc)) ) ehi(mgs) = 0.0
       end if
-      end do
 
+      IF ( lis > 1 ) THEN
+      if ( qx(mgs,lh).gt.qxmin(lh) .and. qx(mgs,lis).gt.qxmin(lis) ) then
+      ehisclsn(mgs) = ehi_collsn
+      ehis(mgs)=eii0*exp(eii1*min(temcg(mgs),0.0))
+      ehis(mgs) = Min( ehimax, Max( ehis(mgs), ehimin ) )
+      if ( temg(mgs) .gt. 273.15 .or. ( qx(mgs,lc) < qxmin(lc)) ) ehis(mgs) = 0.0
+      end if
       ENDIF
+
+
 !
 !
-!
-!  Berry 1968 auto conversion for rain (Ferrier 1994)
+!  Hail: Collection (cxc) efficiencies
 !
 !
-      if ( ircnw .eq. 5 ) then
-      do mgs = 1,ngscnt
-      qrcnw(mgs) = 0.0
-      qrcnw(mgs) =  0.0
-      qccrit = (pi/6.)*(cx(mgs,lc)*cwdiap**3)*xdn(mgs,lc)/rho0(mgs)
-      qdiff = max((qx(mgs,lc)-qccrit),0.)
-      if ( qdiff .gt. 0.0 .and. cx(mgs,lc) .gt. 1.0 ) then
-      argrcnw = &
-!     >  ((1.2e-4)+(1.596e-12)*cx(mgs,lc)/(cwdisp*rho0(mgs)*qdiff))   &
-     &  ((1.2e-4)+(1.596e-12)*cx(mgs,lc)*1.0e-3/(cwdisp*rho0(mgs)*qdiff))
-      qrcnw(mgs) = &
-!     >  timflg(mgs)*rho0(mgs)*(qdiff**2)/argrcnw   &
-     &  1.0e-3*rho0(mgs)*(qdiff**2)/argrcnw
-      qrcnw(mgs) = Min(qxmxd(mgs,lc), (max(qrcnw(mgs),0.0)) )
+      IF ( lhl .gt. 1 ) THEN
 
-!      write(iunit,*) 'qrcnw,cx =',qrcnw(mgs),cx(mgs,lc),mgs,1.e3*qx(mgs,lc),cno(lr)
-      end if
-      end do
-      end if
+      if ( qx(mgs,lhl).gt.qxmin(lhl) .and. qx(mgs,lc).gt.qxmin(lc) ) then
+       IF ( iehw == 3 ) iehlw = 3
+       IF ( iehw == 4 ) iehlw = 4
+       ehlw(mgs) = ehlw0
+       IF ( iehlw .eq. 0 ) THEN
+       ehlw(mgs) = ehlw0  ! default value is 1.0
+       ELSEIF ( iehlw .eq. 1 .or. iehlw .eq. 10 ) THEN
+      cwrad = 0.5*xdia(mgs,lc,1)
+      ehlw(mgs) = Min( ehlw0,    &
+     &  ewfac*min((aradcw + cwrad*(bradcw + cwrad*   &
+     &  (cradcw + cwrad*(dradcw)))), 1.0) )
+      
+       ELSEIF ( iehlw .eq. 2 .or. iehlw .eq. 10 ) THEN
+       ic = icwr(mgs)
+       icp1 = Min( 8, ic+1 )
+       ir = ihlr(mgs)
+       irp1 = Min( 6, ir+1 )
+       cwrad = 0.5*xdia(mgs,lc,1)
+       rwrad = 0.5*xdia(mgs,lhl,3)  ! changed to mean volume diameter
+       
+       slope1 = (ew(icp1, ir  ) - ew(ic,ir  ))*cwr(ic,2)
+       slope2 = (ew(icp1, irp1) - ew(ic,irp1))*cwr(ic,2)
+       
+       x1 = ew(ic,  ir) + slope1*(cwrad - cwr(ic,1))
+       x2 = ew(icp1,ir) + slope2*(cwrad - cwr(ic,1))
+       
+       slope1 = (x2 - x1)*grad(ir,2)
+       
+       tmp = Max( 0.0, Min( 1.0, x1 + slope1*(rwrad - grad(ir,1)) ) )
+         ehlw(mgs) = Min( ehlw(mgs), tmp )
+       ehlw(mgs) = Min( ehlw0, ehlw(mgs) )
+!       ehw(mgs) = Max( 0.2, ehw(mgs) )
+!  assume that ehw = 1 for zero air resistance (rho0 = 0.0) and extrapolate toward that
+!      ehw(mgs) = ehw(mgs) + (ehw(mgs) - 1.0)*(rho0(mgs) - rho00)/rho00
+!      ehlw(mgs) = ehlw(mgs) + (1.0 - ehlw(mgs))*((Max(0.0,rho00 - rho0(mgs)))/rho00)**2
 
+       ELSEIF ( iehlw .eq. 3 .or. iehlw .eq. 10 ) THEN ! use fraction of droplets greater than 15 micron diameter
+         tmp = Exp(- (dmincw/xdia(mgs,lc,1))**3)
+         ehlw(mgs) = Min( ehlw(mgs), tmp )
+       ELSEIF ( iehlw .eq. 4 .or. iehlw .eq. 10 ) THEN ! Cober and List 1993
+         tmp =  &
+     &   2.0*xdn(mgs,lc)*vtxbar(mgs,lhl,1)*(0.5*xdia(mgs,lc,1))**2 &
+     &  /(9.0*fadvisc(mgs)*0.5*xdia(mgs,lhl,3))
+         tmp = Max( 1.5, Min(10.0, tmp) )
+         ehlw(mgs) = Min( ehlw(mgs), 0.55*Log10(2.51*tmp) )
+       ENDIF
+      if ( xdia(mgs,lc,1) .lt. 2.4e-06 ) ehlw(mgs)=0.0
+       ehlw(mgs) = Min( ehlw0, ehlw(mgs) )
+
+       IF ( ibfc == -1 .and. temcg(mgs) < -41.0 ) THEN 
+        ehlw(mgs) = 0.0
+       ENDIF 
+
+      end if
 !
-!
-!  kessler auto conversion for rain.
-!
-      if ( ircnw .eq. 2 ) then
-      do mgs = 1,ngscnt
-      qrcnw(mgs) = 0.0
-      qrcnw(mgs) = (0.001)*max((qx(mgs,lc)-qminrncw),0.0)
-      end do
+      if ( qx(mgs,lhl).gt.qxmin(lhl) .and. qx(mgs,lr).gt.qxmin(lr)    &
+!     &     .and. temg(mgs) .lt. tfr    &
+     &                               ) then
+        ehlr(mgs) = 1.0
+       ehlr(mgs) = Min( ehlr0, ehlr(mgs) )
       end if
 !
-!  c4 = pi/6
-!  c1 = 0.12-0.32 for colorado storms...typically 0.3-0.4
-!  berry reinhart type conversion (proctor 1988)
+      IF ( qx(mgs,ls).gt.qxmin(ls) ) THEN
+        if ( qx(mgs,lhl).gt.qxmin(lhl)  ) then
+          ehlsclsn(mgs) = ehls_collsn
+          ehls(mgs) = ehscnv(mgs)
+          ehls(mgs) = Min(ehls(mgs),ehsmax)
+        end if
+      ENDIF
 !
-      if ( ircnw .eq. 1 ) then
-      do mgs = 1,ngscnt
-      qrcnw(mgs) = 0.0
-      c1 = 0.2
-      c4 = pi/(6.0)
-      bradp =    &
-     & (1.e+06) * ((c1/(0.38))**(1./3.)) * (xdia(mgs,lc,1)*(0.5))
-      bl2 =   &
-     & (0.027) * ((100.0)*(bradp**3)*(xdia(mgs,lc,1)*(0.5)) - (0.4))
-      bt2 = (bradp -7.5) / (3.72)
-      qrcnw(mgs) = 0.0
-      if ( bl2 .gt. 0.0 .and. bt2 .gt. 0.0 ) then
-      qrcnw(mgs) = bl2 * bt2 * rho0(mgs)   &
-     &  * qx(mgs,lc) * qx(mgs,lc)
+      if ( qx(mgs,lhl).gt.qxmin(lhl) .and. qx(mgs,li).gt.qxmin(li) ) then
+      ehliclsn(mgs) = ehli_collsn
+      ehli(mgs)=eii0hl*exp(eii1hl*min(temcg(mgs),0.0))
+      ehli(mgs) = Min( ehimax, Max( ehli(mgs), ehimin ) )
+      if ( temg(mgs) .gt. 273.15 .or. ( qx(mgs,lc) < qxmin(lc)) ) ehli(mgs) = 0.0
       end if
-      end do
+
+      IF ( lis > 1 ) THEN
+      if ( qx(mgs,lhl).gt.qxmin(lhl) .and. qx(mgs,lis).gt.qxmin(lis) ) then
+      ehlisclsn(mgs) = ehli_collsn
+      ehlis(mgs)=eii0*exp(eii1*min(temcg(mgs),0.0))
+      ehlis(mgs) = Min( ehimax, Max( ehlis(mgs), ehimin ) )
+      if ( temg(mgs) .gt. 273.15 .or. ( qx(mgs,lc) < qxmin(lc)) ) ehlis(mgs) = 0.0
       end if
+      ENDIF
 
 
+      ENDIF ! lhl .gt. 1
 
-      ENDIF  !  ( ipconc .ge. 2 )
+      ENDDO  ! mgs loop for collection efficiencies
 
 !
 !
 !
-!  Bigg Freezing of Rain
+!  Set flags for plates vs. columns
 !
-      if (ndebug .gt. 0 ) write(0,*) 'conc 27a'
-      qrfrz(:) = 0.0
-      qrfrzs(:) = 0.0
-      qrfrzf(:) = 0.0
-      vrfrzf(:) = 0.0
-      crfrz(:) = 0.0
-      crfrzs(:) = 0.0
-      crfrzf(:) = 0.0
-      zrfrz(:)  = 0.0
-      zrfrzs(:)  = 0.0
-      zrfrzf(:)  = 0.0
-      qwcnr(:) = 0.0
-      
-      IF ( .not. ( ipconc == 0 .and. lwsm6 ) ) THEN
-      
-      do mgs = 1,ngscnt 
-      if ( qx(mgs,lr) .gt. qxmin(lr) .and. temcg(mgs) .lt. -5. .and. ibiggopt > 0 ) then
-!      brz = 100.0
-!      arz = 0.66
-       IF ( ipconc .lt. 3 ) THEN
-       qrfrz(mgs) =    &
-     &  min(   &
-     &  (20.0)*(pi**2)*brz*(xdn(mgs,lr)/rho0(mgs))   &
-     &   *cx(mgs,lr)*(xdia(mgs,lr,1)**6)   &
-     &   *(exp(max(-arz*temcg(mgs), 0.0))-1.0)   &
-     &  , qrmxd(mgs))
-        qrfrzf(mgs) = qrfrz(mgs)
+!
+      do mgs = 1,ngscnt
+!
+      xplate(mgs) = 0.0
+      xcolmn(mgs) = 1.0
+!
+!      if ( temcg(mgs) .lt. 0. .and. temcg(mgs) .ge. -4. ) then
+!      xplate(mgs) = 1.0
+!      xcolmn(mgs) = 0.0
+!      end if
+!c
+!      if ( temcg(mgs) .lt. -4. .and. temcg(mgs) .ge. -9. ) then
+!      xplate(mgs) = 0.0
+!      xcolmn(mgs) = 1.0
+!      end if
+!c
+!      if ( temcg(mgs) .lt. -9. .and. temcg(mgs) .ge. -22.5 ) then
+!      xplate(mgs) = 1.0
+!      xcolmn(mgs) = 0.0
+!      end if
+!c
+!      if ( temcg(mgs) .lt. -22.5 .and. temcg(mgs) .ge. -90. ) then
+!      xplate(mgs) = 0.0
+!      xcolmn(mgs) = 1.0
+!      end if
+!
+      end do
+!
+!
+!
+!  Collection growth equations....
+!
+!
+      if (ndebug .gt. 0 ) write(0,*) 'Collection: rain collects xxxxx'
+!
+      do mgs = 1,ngscnt
+      qracw(mgs) =  0.0
+      IF ( qx(mgs,lr) .gt. qxmin(lr) .and. erw(mgs) .gt. 0.0 ) THEN
+      IF ( ipconc .lt. 3 ) THEN
+       IF ( erw(mgs) .gt. 0.0 .and. qx(mgs,lr) .gt. 1.e-7 ) THEN
+       vt = (ar*(xdia(mgs,lc,1)**br))*rhovt(mgs)
+       qracw(mgs) =    &
+     &   (0.25)*pi*erw(mgs)*(qx(mgs,lc)-qcwresv(mgs))*cx(mgs,lr) &
+!     >  *abs(vtxbar(mgs,lr,1)-vtxbar(mgs,lc,1))   &
+     &  *Max(0.0, vtxbar(mgs,lr,1)-vt)   &
+     &  *(  gf3*xdia(mgs,lr,2)    &
+     &    + 2.0*gf2*xdia(mgs,lr,1)*xdia(mgs,lc,1)    &
+     &    + gf1*xdia(mgs,lc,2) )
+!       qracw(mgs) = 0.0
+!      write(iunit,*) 'qracw,cx =',qracw(mgs),1.e6*xdia(mgs,lr,1),erw(mgs)
+!      write(iunit,*) 'qracw,cx =',qracw(mgs),cx(mgs,lc),kgs(mgs),cx(mgs,lr),1.e6*xdia(mgs,lr,1),vtxbar(mgs,lr,1),vt
+!      write(iunit,*) 'vtr: ',vtxbar(mgs,lr,1), ar*gf4br/6.0*xdia(mgs,lr,1)**br, rhovt(mgs),
+!     :         ar*gf4br/6.0*xdia(mgs,lr,1)**br * rhovt(mgs)
+       ENDIF
+      ELSE
 
-!       ELSEIF ( ipconc .ge. 3 .and. xv(mgs,lr) .gt. 1.1*xvmn(lr) ) THEN
-       ELSEIF ( ipconc .ge. 3 ) THEN
-!         tmp = brz*cx(mgs,lr)*(Exp(Max( -arz*temcg(mgs), 0.0 )) - 1.0)
-!         crfrz(mgs) = xv(mgs,lr)*tmp
+      IF ( dmrauto <= 0 .or.  rho0(mgs)*qx(mgs,lr) > 1.2*xl2p(mgs) ) THEN 
+       rwrad = 0.5*xdia(mgs,lr,3)
+        IF ( rwrad .gt. rh(mgs) ) THEN ! .or. cx(mgs,lr) .gt. nh(mgs) ) THEN
+         IF ( rwrad .gt. rwradmn ) THEN
+!      DM1CCC=A2*XNC*XNR*XVC*(((CNU+2.)/(CNU+1.))*XVC+XVR)       ! (A12)
+!     NOTE: Result is independent of imurain, assumes mucloud = 3
+           qracw(mgs) = erw(mgs)*aa2*cx(mgs,lr)*cx(mgs,lc)*xmas(mgs,lc)*   &
+     &        ((cnu + 2.)*xv(mgs,lc)/(cnu + 1.) + xv(mgs,lr))/rho0(mgs) !*rhoinv(mgs)
+         ELSE
 
-         frach = 1.0d0
-         
-!         IF ( ibiggopt == 2 .and. imurain == 1 .and. lzr < 1 ) THEN ! lzr check because results are weird for 3-moment
-         IF ( ibiggopt == 2 .and. imurain == 1 ) THEN !
-         ! integrate from Bigg diameter (for given supercooling Ts) to infinity
-           
-           volt = exp( 16.2 + 1.0*temcg(mgs) )* 1.0e-6 !  Ts == -temcg ; volt comes from the fit in Fig. 1 in Bigg 1953 
-                                               ! for mean temperature for freezing: -ln (V) = a*Ts - b, where a = 6.9/6.8, or approx a = 1.0, and b = 16.2
-                                               ! volt is given in cm**3, so convert to m**3
-           dbigg = (6./pi* volt )**(1./3.) 
-           
-           ! perhaps should also test that W > V_t_dbigg, i.e., that drops the size of dbigg are being lifted and cooled. 
-           
-             ratio = Min(maxratiolu, dbigg/xdia(mgs,lr,1) )
-           
-           i = Min(nqiacrratio,Int(ratio*dqiacrratioinv))
-!           j = Int(Max(0.0,Min(15.,alpha(mgs,lr))))
-           j = Int(Max(0.0,Min(15.,alpha(mgs,lr)))*dqiacralphainv)
-           delx = ratio - float(i)*dqiacrratio
-           dely = alpha(mgs,lr) - float(j)*dqiacralpha
-           ip1 = Min( i+1, nqiacrratio )
-           jp1 = Min( j+1, nqiacralpha )
+          IF ( imurain == 3 ) THEN
 
-           ! interpolate along x, i.e., ratio; 
-           tmp1 = ciacrratio(i,j) + delx*dqiacrratioinv*(ciacrratio(ip1,j) - ciacrratio(i,j))
-           tmp2 = ciacrratio(i,jp1) + delx*dqiacrratioinv*(ciacrratio(ip1,jp1) - ciacrratio(i,jp1))
+!      DM1CCC=A1*XNC*XNR*(((CNU+3.)*(CNU+2.)/(CNU+1.)**2)*XVC**3+ ! (A14)
+!     1 ((RNU+2.)/(RNU+1.))*XVC*XVR**2)
+
+!           qracw(mgs) = aa1*cx(mgs,lr)*cx(mgs,lc)*xdn(mgs,lc)*   &
+!     &        ((cnu + 3.)*(cnu + 2.)*xv(mgs,lc)**3/(cnu + 1.)**2 +    &
+!     &         (alpha(mgs,lr) + 2.)*xv(mgs,lc)*xv(mgs,lr)**2/(alpha(mgs,lr) + 1.))/rho0(mgs) !*rhoinv(mgs)
+! save multiplies by converting cx*xdn*xv/rho0 to qx
+           qracw(mgs) = aa1*cx(mgs,lr)*(qx(mgs,lc)-qcwresv(mgs))*   &
+     &        ((cnu + 3.)*(cnu + 2.)*xv(mgs,lc)**2/(cnu + 1.)**2 +    &
+     &         (alpha(mgs,lr) + 2.)*xv(mgs,lr)**2/(alpha(mgs,lr) + 1.)) 
            
-           ! interpolate along alpha; 
+           ELSE ! imurain == 1
+
+           qracw(mgs) = aa1*cx(mgs,lr)*(qx(mgs,lc)-qcwresv(mgs))*   &
+     &        ((cnu + 3.)*(cnu + 2.)*xv(mgs,lc)**2/(cnu + 1.)**2 +    &
+     &         (alpha(mgs,lr) + 6.)*(alpha(mgs,lr) + 5.)*(alpha(mgs,lr) + 4.)*xv(mgs,lr)**2/ &
+     &          ((alpha(mgs,lr) + 3.)*(alpha(mgs,lr) + 2.)*(alpha(mgs,lr) + 1.))) 
            
-           crfrz(mgs) = (tmp1 + dely*dqiacralphainv*(tmp2 - tmp1))*cx(mgs,lr)/dtp
-           crfrzf(mgs) = crfrz(mgs)
-           ! interpolate along x, i.e., ratio; 
-           tmp1 = qiacrratio(i,j) + delx*dqiacrratioinv*(qiacrratio(ip1,j) - qiacrratio(i,j))
-           tmp2 = qiacrratio(i,jp1) + delx*dqiacrratioinv*(qiacrratio(ip1,jp1) - qiacrratio(i,jp1))
+           ENDIF
            
-           ! interpolate along alpha; 
-           
-           qrfrz(mgs) = (tmp1 + dely*dqiacralphainv*(tmp2 - tmp1))*qx(mgs,lr)/dtp
-           qrfrzf(mgs) = qrfrz(mgs)
-           
-           
-            IF ( ibiggsmallrain > 0 .and. xv(mgs,lr) < 2.*xvmn(lr) .and. ( ibiggsnow == 1 .or. ibiggsnow == 3 ) ) THEN
-             ! rain drops are so small that they can't be pushed smaller, so put into snow (or cloud ice, depending on ifrzs)
-              crfrzf(mgs) = 0.0
-              qrfrzf(mgs) = 0.0
-              crfrzs(mgs) = crfrz(mgs)
-              qrfrzs(mgs) = qrfrz(mgs)
+         ENDIF
+        ENDIF
+        ENDIF
+       ENDIF
+!       qracw(mgs) = Min(qracw(mgs), qx(mgs,lc))
+       qracw(mgs) = Min(qracw(mgs), qcmxd(mgs))
+       ENDIF
+      end do
+!
+      do mgs = 1,ngscnt
+      qraci(mgs) = 0.0
+      craci(mgs) = 0.0
+      IF ( eri(mgs) .gt. 0.0 .and. iacr .ge. 1 .and. xdia(mgs,lr,3) .gt. 2.*rwradmn ) THEN
+        IF ( ipconc .ge. 3 ) THEN
 
-              IF ( lzr > 1 ) THEN
-                zrfrzs(mgs) = zrfrz(mgs)
-                zrfrzf(mgs) = 0.
-              ENDIF
-           ELSEIF ( dbigg < Max(dfrz,dhmn) .and. ( ibiggsnow == 1 .or. ibiggsnow == 3 ) ) THEN ! { convert some to snow or ice crystals
-            ! temporarily store qrfrz and crfrz in snow terms and caclulate new crfrzf, qrfrzf, and zrfrzf. Leave crfrz etc. alone!
-            
-            crfrzs(mgs) = crfrz(mgs)
-            qrfrzs(mgs) = qrfrz(mgs)
-            
-            IF ( ibiggsmallrain > 0 .and. xv(mgs,lr) < 1.2*xvmn(lr) ) THEN
-             ! rain drops are so small that they can't be pushed smaller, so put into snow (or cloud ice, depending on ifrzs)
-            crfrzf(mgs) = 0.0
-            qrfrzf(mgs) = 0.0
+           tmp = eri(mgs)*aa2*cx(mgs,lr)*cx(mgs,li)*   &
+     &        ((cinu + 2.)*xv(mgs,li)/(cinu + 1.) + xv(mgs,lr))
 
-             
-            ELSE !{
-            
-           ! recalculate using dhmn for ratio
-           ratio = Min( maxratiolu, Max(dfrz,dhmn)/xdia(mgs,lr,1) )
-           
-           i = Min(nqiacrratio,Int(ratio*dqiacrratioinv))
-!           j = Int(Max(0.0,Min(15.,alpha(mgs,lr))))
-           j = Int(Max(0.0,Min(15.,alpha(mgs,lr)))*dqiacralphainv)
-           delx = ratio - float(i)*dqiacrratio
-           dely = alpha(mgs,lr) - float(j)*dqiacralpha
-           ip1 = Min( i+1, nqiacrratio )
-           jp1 = Min( j+1, nqiacralpha )
+        qraci(mgs) = Min( qxmxd(mgs,li), tmp*xmas(mgs,li)*rhoinv(mgs) )
+        craci(mgs) = Min( cxmxd(mgs,li), tmp )
 
-           ! interpolate along x, i.e., ratio; 
-           tmp1 = ciacrratio(i,j) + delx*dqiacrratioinv*(ciacrratio(ip1,j) - ciacrratio(i,j))
-           tmp2 = ciacrratio(i,jp1) + delx*dqiacrratioinv*(ciacrratio(ip1,jp1) - ciacrratio(i,jp1))
+!       vt = Sqrt((vtxbar(mgs,lr,1)-vtxbar(mgs,li,1))**2 +
+!     :            0.04*vtxbar(mgs,lr,1)*vtxbar(mgs,li,1) )
+!
+!          qraci(mgs) = 0.25*pi*eri(mgs)*cx(mgs,lr)*qx(mgs,li)*vt*
+!     :         (  da0(lr)*xdia(mgs,lr,3)**2 +
+!     :            dab1(lr,li)*xdia(mgs,lr,3)*xdia(mgs,li,3) +
+!     :            da1(li)*xdia(mgs,li,3)**2 )
+!
+!
+!       vt = Sqrt((vtxbar(mgs,lr,1)-vtxbar(mgs,li,1))**2 +
+!     :            0.04*vtxbar(mgs,lr,1)*vtxbar(mgs,li,1) )
+!
+!          craci(mgs) = 0.25*pi*eri(mgs)*cx(mgs,lr)*cx(mgs,li)*vt*
+!     :         (  da0(lr)*xdia(mgs,lr,3)**2 +
+!     :            dab0(lr,li)*xdia(mgs,lr,3)*xdia(mgs,li,3) +
+!     :            da0(li)*xdia(mgs,li,3)**2 )
+!
+!          qraci(mgs) = Min( qraci(mgs), qxmxd(mgs,li) )
+!          craci(mgs) = Min( craci(mgs), cxmxd(mgs,li) )
 
+        ELSE
+          qraci(mgs) =    &
+     &     min(   &
+     &     (0.25)*pi*eri(mgs)*qx(mgs,li)*cx(mgs,lr)   &
+     &    *abs(vtxbar(mgs,lr,1)-vtxbar(mgs,li,1))   &
+     &    *(  gf3*xdia(mgs,lr,2)    &
+     &      + 2.0*gf2*xdia(mgs,lr,1)*xdia(mgs,li,1)    &
+     &      + gf1*xdia(mgs,li,2) )     &
+     &    , qimxd(mgs))
+        ENDIF
+      if ( temg(mgs) .gt. 268.15 ) then
+      qraci(mgs) = 0.0
+      end if
+      ENDIF
+      end do
+!
+      do mgs = 1,ngscnt
+      qracs(mgs) =  0.0
+      IF ( ers(mgs) .gt. 0.0 .and. ipconc < 3 ) THEN
+       IF ( lwsm6 .and. ipconc == 0 ) THEN
+         vt = vt2ave(mgs)
+       ELSE
+         vt = vtxbar(mgs,ls,1)
+       ENDIF
+      qracs(mgs) =      &
+     &   min(     &
+     &   ((0.25)*pi/gf4)*ers(mgs)*qx(mgs,ls)*cx(mgs,lr)     &
+     &  *abs(vtxbar(mgs,lr,1)-vt)     &
+     &  *(  gf6*gf1*xdia(mgs,ls,2)     &
+     &    + 2.0*gf5*gf2*xdia(mgs,ls,1)*xdia(mgs,lr,1)      &
+     &    + gf4*gf3*xdia(mgs,lr,2) )      &
+     &  , qsmxd(mgs))
+      ENDIF
+      end do
 
-           ! interpolate along alpha; 
-           
-           crfrzf(mgs) = (tmp1 + dely*dqiacralphainv*(tmp2 - tmp1))*cx(mgs,lr)/dtp
-           
-           ! interpolate along x, i.e., ratio; 
-           tmp1 = qiacrratio(i,j) + delx*dqiacrratioinv*(qiacrratio(ip1,j) - qiacrratio(i,j))
-           tmp2 = qiacrratio(i,jp1) + delx*dqiacrratioinv*(qiacrratio(ip1,jp1) - qiacrratio(i,jp1))
-           
-           ! interpolate along alpha; 
-           
-           qrfrzf(mgs) = (tmp1 + dely*dqiacralphainv*(tmp2 - tmp1))*qx(mgs,lr)/dtp
+!
+!
+      if (ndebug .gt. 0 ) write(0,*) 'Collection: snow collects xxxxx'
+!
+      do mgs = 1,ngscnt
+      qsacw(mgs) =  0.0
+      csacw(mgs) =  0.0
+      vsacw(mgs) =  0.0
+      IF ( esw(mgs) .gt. 0.0 ) THEN
 
-           ! now subtract off the difference
-            crfrzs(mgs) = crfrzs(mgs) - crfrzf(mgs)
-            qrfrzs(mgs) = qrfrzs(mgs) - qrfrzf(mgs)
+       IF ( ipconc .ge. 4 ) THEN
+!      QSACC=CECS*RVT*A2*XNC*XNS*XVC*ROS*
+!     *    (((CNU+2.)/(CNU+1.))*XVC+XVS)/RO
 
-            ENDIF ! }
-           ELSE
-            crfrzs(mgs) = 0.0
-            qrfrzs(mgs) = 0.0
-           ENDIF ! }
-           
-           IF ( (qrfrz(mgs))*dtp > qx(mgs,lr) ) THEN
-             fac = ( qrfrz(mgs) )*dtp/qx(mgs,lr)
-             qrfrz(mgs) = fac*qrfrz(mgs)
-             qrfrzs(mgs) = fac*qrfrzs(mgs)
-             qrfrzf(mgs) = fac*qrfrzf(mgs)
-             crfrz(mgs) = fac*crfrz(mgs)
-             crfrzs(mgs) = fac*crfrzs(mgs)
-             crfrzf(mgs) = fac*crfrzf(mgs)
-           ENDIF
-!           IF ( (crfrzs(mgs) + crfrz(mgs))*dtp > cx(mgs,lr) ) THEN
-!             fac = ( crfrzs(mgs) + crfrz(mgs) )*dtp/cx(mgs,lr)
-!             crfrz(mgs) = fac*crfrz(mgs)
-!             crfrzs(mgs) = fac*crfrzs(mgs)
-!           ENDIF
-           
-!           qrfrzf(mgs) = qrfrz(mgs)
-!           crfrzf(mgs) = crfrz(mgs)
-           
-   !        qrfrz(mgs) = qrfrzf(mgs) + qrfrzs(mgs)
-   !        crfrz(mgs) = crfrzf(mgs) + crfrzs(mgs)
+!        tmp = esw(mgs)*rvt*aa2*cx(mgs,ls)*cx(mgs,lc)*
+!     :        ((cnu + 2.)*xv(mgs,lc)/(cnu + 1.) + xv(mgs,ls))
+        tmp = 1.0*rvt*aa2*cx(mgs,ls)*cx(mgs,lc)*   &
+     &        ((cnu + 2.)*xv(mgs,lc)/(cnu + 1.) + xv(mgs,ls))
 
-           
-         ELSE ! ibiggopt == 1 
-         
-         tmp = xv(mgs,lr)*brz*cx(mgs,lr)*(Exp(Max( -arz*temcg(mgs), 0.0 )) - 1.0)
-         IF ( .false. .and. tmp .gt. cxmxd(mgs,lr) ) THEN ! {
-!           write(iunit,*) 'Bigg Freezing problem!',mgs,igs(mgs),kgs(mgs)
-!           write(iunit,*)  'tmp, cx(lr), xv = ',tmp, cx(mgs,lr), xv(mgs,lr), (Exp(Max( -arz*temcg(mgs), 0.0 )) - 1.0)
-!           write(iunit,*)  'qr,temcg = ',qx(mgs,lr)*1000.,temcg(mgs)
-           crfrz(mgs) = cxmxd(mgs,lr) ! cx(mgs,lr)/dtp
-           qrfrz(mgs) = qxmxd(mgs,lr) ! qx(mgs,lr)/dtp
-!           STOP
-         ELSE ! } {
-         crfrz(mgs) = tmp
- !        crfrzfmx = cx(mgs,lr)*Exp(-4./3.*pi*(40.e-6)**3/xv(mgs,lr))
- !        IF ( crfrz(mgs) .gt. crfrzmx ) THEN
- !          crfrz(mgs) = crfrzmx
- !          qrfrz(mgs) = bfnu*xmas(mgs,lr)*rhoinv(mgs)*crfrzmx
- !          qwcnr(mgs) = cx(mgs,lr) - crfrzmx
- !        ELSE
-         IF ( lzr < 1 ) THEN
-           IF ( imurain == 3 ) THEN
-             bfnu = bfnu0
-           ELSE !imurain == 1
-             bfnu = bfnu1
-           ENDIF
-         ELSE
- !         bfnu = 1.0 ! (alpha(mgs,lr)+2.0)/(alpha(mgs,lr)+1.)
-           IF ( imurain == 3 ) THEN
-             bfnu = (alpha(mgs,lr)+2.0)/(alpha(mgs,lr)+1.)
-           ELSE !imurain == 1
-!             bfnu = bfnu1
-            bfnu = (4. + alpha(mgs,lr))*(5. + alpha(mgs,lr))*(6. + alpha(mgs,lr))/  &
-     &            ((1. + alpha(mgs,lr))*(2. + alpha(mgs,lr))*(3. + alpha(mgs,lr)))
-!            bfnu = 1.
-           ENDIF
-         ENDIF 
-         qrfrz(mgs) = bfnu*xmas(mgs,lr)*rhoinv(mgs)*crfrz(mgs)
+        qsacw(mgs) = Min( qxmxd(mgs,lc), tmp*xmas(mgs,lc)*rhoinv(mgs) )
+        csacw(mgs) = Min( cxmxd(mgs,lc), tmp )
 
-         qrfrz(mgs) = Min( qrfrz(mgs), 1.*qx(mgs,lr)/dtp ) ! qxmxd(mgs,lr) 
-         crfrz(mgs) = Min( crfrz(mgs), 1.*cx(mgs,lr)/dtp ) !cxmxd(mgs,lr) 
-         qrfrz(mgs) = Min( qrfrz(mgs), qx(mgs,lr) )
-         qrfrzf(mgs) = qrfrz(mgs)
-         ENDIF !}
+          IF ( lvol(ls) .gt. 1 ) THEN
+             IF ( temg(mgs) .lt. 273.15) THEN
+             rimdn(mgs,ls) = rimc1*(-((0.5)*(1.e+06)*xdia(mgs,lc,1))   &
+     &                *((0.60)*vtxbar(mgs,ls,1))   &
+     &                /(temg(mgs)-273.15))**(rimc2)
+             rimdn(mgs,ls) = Min( Max( rimc3, rimdn(mgs,ls) ), rimc4 )
+             ELSE
+             rimdn(mgs,ls) = 1000.
+             ENDIF
 
-         
-         
-         
-         IF ( crfrz(mgs) .gt. qxmin(lh) ) THEN !{
-!          IF ( xdia(mgs,lr,1) .lt. 200.e-6 ) THEN
-!           IF ( xv(mgs,lr) .lt. xvmn(lh) ) THEN
-           
-           IF ( (ibiggsnow == 1 .or. ibiggsnow == 3 ) .and. ibiggopt /= 2 ) THEN
-           xvfrz = rho0(mgs)*qrfrz(mgs)/(crfrz(mgs)*900.) ! mean volume of frozen drops; 900. for frozen drop density
-           frach = 0.5 *(1. +  Tanh(0.2e12 *( xvfrz - 1.15*xvmn(lh))))
+           vsacw(mgs) = rho0(mgs)*qsacw(mgs)/rimdn(mgs,ls)
 
-             qrfrzs(mgs) = (1.-frach)*qrfrz(mgs)
-             crfrzs(mgs) = (1.-frach)*crfrz(mgs) ! *rzxh(mgs)
-!             qrfrzf(mgs) = frach*qrfrz(mgs)
-           
-           ENDIF
-           
-           IF ( ipconc .ge. 14 .and. 1.e-3*rho0(mgs)*qrfrz(mgs)/crfrz(mgs) .lt. xvmn(lh) ) THEN
-             qrfrzs(mgs) = qrfrz(mgs)
-             crfrzs(mgs) = crfrz(mgs) ! *rzxh(mgs)
-           ELSE
-!           crfrz(mgs) = Min( crfrz(mgs), 0.1*cx(mgs,lr)/dtp ) ! cxmxd(mgs,lr) 
-!           qrfrz(mgs) = Min( qrfrz(mgs), 0.1*qx(mgs,lr)/dtp ) ! qxmxd(mgs,lr) 
-             qrfrzf(mgs) = frach*qrfrz(mgs)
-!             crfrzf(mgs) = Min( qrfrz(mgs)*rho0(mgs)/(xdn(mgs,lh)*vgra), crfrz(mgs) )
-            IF ( ibfr .le. 1 ) THEN
-             crfrzf(mgs) = frach*Min(crfrz(mgs), qrfrz(mgs)/(bfnu*1.0*vr1mm*1000.0)*rho0(mgs) ) ! rzxh(mgs)*crfrz(mgs)
-            ELSEIF ( ibfr .eq. 5 ) THEN
-             crfrzf(mgs) = frach*Min(crfrz(mgs), qrfrz(mgs)/(bfnu*vfrz*1000.0)*rho0(mgs) )*rzxh(mgs)  !*crfrz(mgs)
-            ELSEIF ( ibfr .eq. 2 ) THEN
-             crfrzf(mgs) = frach*Min(crfrz(mgs), qrfrz(mgs)/(bfnu*vfrz*1000.0)*rho0(mgs) ) ! rzxh(mgs)*crfrz(mgs)
-            ELSEIF ( ibfr .eq. 6 ) THEN
-             crfrzf(mgs) = frach*Max(crfrz(mgs), qrfrz(mgs)/(bfnu*9.*xv(mgs,lr)*1000.0)*rho0(mgs) ) ! rzxh(mgs)*crfrz(mgs)
-            ELSE
-             crfrzf(mgs) = frach*crfrz(mgs)
-            ENDIF 
-!             crfrzf(mgs) = Min(crfrz(mgs), qrfrz(mgs)/(bfnu*xvmn(lh)*1000.0)*rho0(mgs) ) ! rzxh(mgs)*crfrz(mgs)
-!            IF ( lz(lr) > 1 .and. lz(lh) > 1 ) THEN
-!              crfrzf(mgs) = crfrz(mgs)
-!            ENDIF
-            
-           ENDIF
-!         crfrz(mgs) = Min( cxmxd(mgs,lr), rho0(mgs)*qrfrz(mgs)/xmas(mgs,lr) )
-         ELSE
-          crfrz(mgs) = 0.0
-          qrfrz(mgs) = 0.0
-         ENDIF !}
+          ENDIF
 
-         ENDIF ! ibiggopt
 
-          IF ( lvol(lh) .gt. 1 ) THEN
-           vrfrzf(mgs) = rho0(mgs)*qrfrzf(mgs)/rhofrz
-          ENDIF
+!        qsacw(mgs) = cecs*aa2*cx(mgs,ls)*cx(mgs,lc)*xmas(mgs,lc)*
+!     :        ((cnu + 2.)*xv(mgs,lc)/(cnu + 1.) + xv(mgs,ls))*rhoinv(mgs)
+       ELSE
+!      qsacw(mgs) =
+!     >   min(
+!     >   ((0.25)*pi)*esw(mgs)*qx(mgs,lc)*cx(mgs,ls)
+!     >  *abs(vtxbar(mgs,ls,1)-vtxbar(mgs,lc,1))
+!     >  *(  gf3*xdia(mgs,ls,2)
+!     >    + 2.0*gf2*xdia(mgs,ls,1)*xdia(mgs,lc,1)
+!     >    + gf1*xdia(mgs,lc,2) )
+!     <  , qcmxd(mgs))
 
-        
-        IF ( nsplinter .ne. 0 ) THEN
-          IF ( nsplinter .ge. 1000 ) THEN
-           ! Lawson et al. 2015 JAS
-           ! ave. diam of freezing drops in microns
-            tmp = 0
-            IF ( qrfrz(mgs)*dtp > qxmin(lh) .and. crfrz(mgs) > 1.e-3 ) THEN
-              tmpdiam = 1.e6*( 6.*qrfrz(mgs)/(1000.*pi*crfrz(mgs) ))**(1./3.)  ! avg. diameter of newly frozen drops in microns
-              tmp = lawson_splinter_fac*tmpdiam**4*crfrz(mgs)
-            ENDIF
-          ELSEIF ( nsplinter .gt. 0 ) THEN
-            tmp = nsplinter*crfrz(mgs)
-          ELSE
-            tmp = -nsplinter*crfrzf(mgs)
-          ENDIF
-          csplinter2(mgs) = tmp
-          qsplinter2(mgs) = Min(0.1*qrfrz(mgs), tmp*splintermass/rho0(mgs) ) ! makes splinters smaller if too much mass is taken from graupel
+            vt = abs(vtxbar(mgs,ls,1)-vtxbar(mgs,lc,1))
 
-!          csplinter(mgs) = csplinter(mgs) + tmp
-!          qsplinter(mgs) = qsplinter(mgs) + Min(0.1*qrfrz(mgs), tmp*splintermass/rho0(mgs) ) ! makes splinters smaller if too much mass is taken from graupel
-        ENDIF
-!         IF ( temcg(mgs) .lt. -31.0 ) THEN
-!           qrfrz(mgs) = qx(mgs,lr)/dtp + qrcnw(mgs)
-!           qrfrzf(mgs) = qrfrz(mgs)
-!           crfrz(mgs) = cx(mgs,lr)/dtp + crcnw(mgs)
-!           crfrzf(mgs) = Min(crfrz(mgs), qrfrz(mgs)/(bfnu*1.0*vr1mm*1000.0)*rho0(mgs) ) ! rzxh(mgs)*crfrz(mgs)
-!         ENDIF
-!         qrfrz(mgs) = 6.0*xdn(mgs,lr)*xv(mgs,lr)**2*tmp*rhoinv(mgs)
-!         qrfrz(mgs) = Min( qrfrz(mgs), ffrz*qrmxd(mgs) )
-!         crfrz(mgs) = Min( crmxd(mgs), ffrz*crfrz(mgs))
-!         crfrz(mgs) = Min(crmxd(mgs),qrfrz(mgs)*rho0(mgs)/xmas(mgs,lr))
+          qsacw(mgs) = 0.25*pi*esw(mgs)*cx(mgs,ls)*qx(mgs,lc)*vt*   &
+     &         (  da0(ls)*xdia(mgs,ls,3)**2 +     &
+     &            dab1(ls,lc)*xdia(mgs,ls,3)*xdia(mgs,lc,3) +    &
+     &            da1(lc)*xdia(mgs,lc,3)**2 )
+        qsacw(mgs) = Min( qsacw(mgs), qxmxd(mgs,ls) )
+        csacw(mgs) = rho0(mgs)*qsacw(mgs)/xmas(mgs,lc)
        ENDIF
-!      if ( temg(mgs) .gt. 268.15 ) then
-      else
-!      end if
-      end if
-      end do
-      
       ENDIF
+      end do
 !
-!  Homogeneous freezing of cloud drops to ice crystals
-!  following Bigg (1953) and Ferrier (1994).
 !
-      if (ndebug .gt. 0 ) write(0,*) 'conc 25b'
       do mgs = 1,ngscnt
-      qwfrz(mgs) = 0.0
-      cwfrz(mgs) = 0.0
-      qwfrzc(mgs) = 0.0
-      cwfrzc(mgs) = 0.0
-      qwfrzp(mgs) = 0.0
-      cwfrzp(mgs) = 0.0
-      IF ( ibfc .ge. 1 .and. ibfc /= 3 .and. temg(mgs) < 268.15 ) THEN
-!      if ( qx(mgs,lc) .gt. qxmin(lc) .and. cx(mgs,lc) .gt. 1.  .and.   &
-!     &     .not. (ipconc .ge. 2 .and. xdia(mgs,lc,1) .lt. 10.e-6) ) then
-      if ( qx(mgs,lc) .gt. qxmin(lc) .and. cx(mgs,lc) .gt. cxmin ) THEN
-      IF ( ipconc < 2 ) THEN
-      qwfrz(mgs) = ((2.0)*(brz)/(xdn(mgs,lc)*cx(mgs,lc)))   &
-     &  *(exp(max(-arz*temcg(mgs), 0.0))-1.0)   &
-     &  *rho0(mgs)*(qx(mgs,lc)**2)
-      qwfrz(mgs) = max(qwfrz(mgs), 0.0)
-      qwfrz(mgs) = min(qwfrz(mgs),qcmxd(mgs))
-         cwfrz(mgs) = qwfrz(mgs)*rho0(mgs)/xmas(mgs,li)
-       ELSEIF ( ipconc .ge. 2 ) THEN
-         IF ( xdia(mgs,lc,3) > 0.e-6 ) THEN
-          volt = exp( 16.2 + 1.0*temcg(mgs) )* 1.0e-6 !  Ts == -temcg ; volt comes from the fit in Fig. 1 in Bigg 1953 
-                                               ! for mean temperature for freezing: -ln (V) = a*Ts - b
-                                               ! volt is given in cm**3, so factor of 1.e-6 to convert to m**3
-!           dbigg = (6./pi* volt )**(1./3.) 
+      qsaci(mgs) = 0.0
+      csaci(mgs) = 0.0
+      csaci0(mgs) = 0.0
+      IF ( ipconc .ge. 4 ) THEN
+      IF ( esi(mgs) .gt. 0.0 .or. ( ipelec > 0 .and. esiclsn(mgs) > 0.0 )) THEN
+!      QSCOI=CEXS*RVT*A2*XNCI*XNS*XVCI*ROS*
+!     *  (((CINU+2.)/(CINU+1.))*VCIP+XVS)/RO
 
-         IF ( .true. .and. cnu == 0.0 ) THEN
-         cwfrz(mgs) = cx(mgs,lc)*Exp(-volt/xv(mgs,lc))/dtp ! number of droplets with volume greater than volt
-!turn off limit so that all can freeze at low temp
-!!!       cwfrz(mgs) = Min(cwfrz(mgs),ccmxd(mgs))
+        tmp = esiclsn(mgs)*rvt*aa2*cx(mgs,ls)*cx(mgs,li)*   &
+     &        ((cinu + 2.)*xv(mgs,li)/(cinu + 1.) + xv(mgs,ls))
 
-         qwfrz(mgs) = cwfrz(mgs)*xdn0(lc)*rhoinv(mgs)*(volt + xv(mgs,lc))
-!         cwfrz(mgs) = cx(mgs,lc)*qwfrz(mgs)/qx(mgs,lc) ! reset number frozen to same fraction as mass. This makes 
-                                                       ! sure that cwfrz and qwfrz are consistent and prevents 
-                                                       ! spurious creation of ice crystals.
-          ELSE
-            ratio = (1. + cnu)*volt/xv(mgs,lc)
-            cwfrz(mgs) = cx(mgs,lc)*Gamxinf(1.+cnu, ratio)/(dtp*gcnup1)
-          
-            qwfrz(mgs) = cx(mgs,lc)*xdn0(lc)*rhoinv(mgs)*Gamxinf(2.+cnu, ratio)/(dtp*gcnup2)
-          
-          ENDIF
+        qsaci(mgs) = Min( qxmxd(mgs,li), esi(mgs)*tmp*xmas(mgs,li)*rhoinv(mgs) )
+        csaci0(mgs) = tmp
+        csaci(mgs) = Min(cxmxd(mgs,li), esi(mgs)*tmp )
 
-!         IF ( temg(mgs) < tfrh - 3 ) THEN
-!          cwfrz(mgs) = cx(mgs,lc)
-!          qwfrz(mgs) = qx(mgs,lc)
-!         ENDIF
-!         IF ( qwfrz(mgs) > 0.5*qx(mgs,lc) ) THEN
-!           write(0,*) 'Problem with qwfrz(mgs): qwfrz,temcg,volt,xv,cx = ',qwfrz(mgs),qx(mgs,lc),temcg(mgs),volt,xv(mgs,lc),cx(mgs,lc),cwfrz(mgs)
-!           STOP
-!         ENDIF
-!turn off limit so that all can freeze at low temp
-!!!         qwfrz(mgs) = Min( qwfrz(mgs), qxmxd(mgs,lc) )
-         ENDIF
-       ENDIF
-      if ( temg(mgs) .gt. 268.15 ) then
-      qwfrz(mgs) = 0.0
-      cwfrz(mgs) = 0.0
-      end if
-      end if
+!      qsaci(mgs) =
+!     >   min(
+!     >   ((0.25)*pi)*esi(mgs)*qx(mgs,li)*cx(mgs,ls)
+!     >  *abs(vtxbar(mgs,ls,1)-vtxbar(mgs,li,1))
+!     >  *(  gf3*xdia(mgs,ls,2)
+!     >    + 2.0*gf2*xdia(mgs,ls,1)*xdia(mgs,li,1)
+!     >    + gf1*xdia(mgs,li,2) )
+!     <  , qimxd(mgs))
+      ENDIF
+      ELSE ! 
+      IF ( esi(mgs) .gt. 0.0 ) THEN
+         qsaci(mgs) =    &
+     &   min(   &
+     &   ((0.25)*pi)*esi(mgs)*qx(mgs,li)*cx(mgs,ls)   &
+     &  *abs(vtxbar(mgs,ls,1)-vtxbar(mgs,li,1))   &
+     &  *(  gf3*xdia(mgs,ls,2)    &
+     &    + 2.0*gf2*xdia(mgs,ls,1)*xdia(mgs,li,1)    &
+     &    + gf1*xdia(mgs,li,2) )     &
+     &  , qimxd(mgs))
       ENDIF
+      ENDIF
+      end do
 !
-        if ( xplate(mgs) .eq. 1 ) then
-          qwfrzp(mgs) = qwfrz(mgs)
-          cwfrzp(mgs) = cwfrz(mgs)
-        end if
-!  
-        if ( xcolmn(mgs) .eq. 1 ) then
-          qwfrzc(mgs) = qwfrz(mgs)
-          cwfrzc(mgs) = cwfrz(mgs)
-        end if
-      
 !
-!     qwfrzp(mgs) = 0.0
-!     qwfrzc(mgs) = qwfrz(mgs)
 !
+      do mgs = 1,ngscnt
+      qsacr(mgs) = 0.0
+      qsacrs(mgs) = 0.0
+      csacr(mgs) = 0.0
+      IF ( esr(mgs) .gt. 0.0 ) THEN
+      IF ( ipconc .ge. 3 ) THEN
+!       vt = Sqrt((vtxbar(mgs,ls,1)-vtxbar(mgs,lr,1))**2 + 
+!     :            0.04*vtxbar(mgs,ls,1)*vtxbar(mgs,lr,1) )
+!       qsacr(mgs) = esr(mgs)*cx(mgs,ls)*vt*
+!     :     qx(mgs,lr)*0.25*pi*
+!     :      (3.02787*xdia(mgs,lr,2) + 
+!     :       3.30669*xdia(mgs,ls,1)*xdia(mgs,lr,1) + 
+!     :       2.*xdia(mgs,ls,2))
+!        qsacr(mgs) = Min( qsacr(mgs), qrmxd(mgs) )
+!        csacr(mgs) = qsacr(mgs)*cx(mgs,lr)/qx(mgs,lr)
+!        csacr(mgs) = min(csacr(mgs),crmxd(mgs))
+      ELSE
+       IF ( lwsm6 .and. ipconc == 0 ) THEN
+         vt = vt2ave(mgs)
+       ELSE
+         vt = vtxbar(mgs,ls,1)
+       ENDIF
+       
+       qsacr(mgs) =   &
+     &   min(   &
+     &   ((0.25)*pi/gf4)*esr(mgs)*qx(mgs,lr)*cx(mgs,ls)   &
+     &  *abs(vtxbar(mgs,lr,1)-vt)   &
+     &  *(  gf6*gf1*xdia(mgs,lr,2)   &
+     &    + 2.0*gf5*gf2*xdia(mgs,lr,1)*xdia(mgs,ls,1)    &
+     &    + gf4*gf3*xdia(mgs,ls,2) )    &
+     &  , qrmxd(mgs))
+      ENDIF
+      ENDIF
       end do
 !
 !
-!  Contact freezing nucleation:  factor is to convert from L-1
-!  T < -2C:  via Meyers et al. JAM July, 1992 (31, 708-721)
 !
-      if (ndebug .gt. 0 ) write(0,*) 'conc 25a'
+      if (ndebug .gt. 0 ) write(0,*) 'Collection: graupel collects xxxxx'
+!
       do mgs = 1,ngscnt
+      qhacw(mgs) = 0.0
+      rarx(mgs,lh) = 0.0
+      vhacw(mgs) = 0.0
+      vhsoak(mgs) = 0.0
+      zhacw(mgs) = 0.0
+      
+      IF ( .false. ) THEN
+        vtmax = (gz(igs(mgs),jgs,kgs(mgs))*dtpinv)
+        vtxbar(mgs,lh,1) = Min( vtmax, vtxbar(mgs,lh,1))
+        vtxbar(mgs,lh,2) = Min( vtmax, vtxbar(mgs,lh,2))
+        vtxbar(mgs,lh,3) = Min( vtmax, vtxbar(mgs,lh,3))
+      ENDIF
+      IF ( ehw(mgs) .gt. 0.0 ) THEN
 
-       ccia(mgs) = 0.0
-
-       cwctfz(mgs) = 0.0
-       qwctfz(mgs) = 0.0
-       ctfzbd(mgs) = 0.0
-       ctfzth(mgs) = 0.0
-       ctfzdi(mgs) = 0.0
-
-       cwctfzc(mgs) = 0.0
-       qwctfzc(mgs) = 0.0
-       cwctfzp(mgs) = 0.0
-       qwctfzp(mgs) = 0.0
-       IF ( icfn .ge. 1 ) THEN
-
-       IF ( temg(mgs) .lt. 271.15  .and. qx(mgs,lc) .gt. qxmin(lc)) THEN
-
-!       find available # of ice nuclei & limit value to max depletion of cloud water
-
-        IF ( icfn .ge. 2 ) THEN
-         ccia(mgs) = exp( 4.11 - (0.262)*temcg(mgs) )  ! in m-3, see Walko et al. 1995
-         !ccia(mgs) = Min(cwctfz(mgs), ccmxd(mgs) )
-
-!       now find how many of these collect cloud water to form IN
-!       Cotton et al 1986
-
-         knud(mgs) = 2.28e-5 * temg(mgs) / ( pres(mgs)*raero ) !Walko et al. 1995
-         knuda(mgs) = 1.257 + 0.4*exp(-1.1/knud(mgs))          !Pruppacher & Klett 1997 eqn 11-16
-         gtp(mgs) = 1. / ( fai(mgs) + fbi(mgs) )               !Byers 65 / Cotton 72b
-         dfar(mgs) = kb*temg(mgs)*(1.+knuda(mgs)*knud(mgs))/(6.*pi*fadvisc(mgs)*raero) !P&K 1997 eqn 11-15
-         fn1(mgs) = 2.*pi*xdia(mgs,lc,1)*cx(mgs,lc)*ccia(mgs)
-         fn2(mgs) = -gtp(mgs)*(ssw(mgs)-1.)*felv(mgs)/pres(mgs)
-         fnft(mgs) = 0.4*(1.+1.45*knud(mgs)+0.4*knud(mgs)*exp(-1./knud(mgs)))*(ftka(mgs)+2.5*knud(mgs)*kaero)      &
-     &              / ( (1.+3.*knud(mgs))*(2*ftka(mgs)+5.*knud(mgs)*kaero+kaero) )
-
-
-!      Brownian diffusion
-         ctfzbd(mgs) = fn1(mgs)*dfar(mgs)
+        IF ( ipconc .ge. 2 ) THEN
 
-!      Thermophoretic contact nucleation
-         ctfzth(mgs) = fn1(mgs)*fn2(mgs)*fnft(mgs)/rho0(mgs)
+        IF ( .false. ) THEN  
+        qhacw(mgs) = (ehw(mgs)*(qx(mgs,lc)-qcwresv(mgs))*cx(mgs,lh)*pi*   &
+     &    abs(vtxbar(mgs,lh,1)-vtxbar(mgs,lc,1))*   &
+     &    (2.0*xdia(mgs,lh,1)*(xdia(mgs,lh,1) +    &
+     &         xdia(mgs,lc,1)*gf73rds) +    &
+     &      xdia(mgs,lc,2)*gf83rds))/4.     
+     
+         ELSE  ! using Seifert coefficients
+            vt = abs(vtxbar(mgs,lh,1)-vtxbar(mgs,lc,1)) 
 
-!      Diffusiophoretic contact nucleation
-         ctfzdi(mgs) = fn1(mgs)*fn2(mgs)*rw*temg(mgs)/(felv(mgs)*rho0(mgs))
-
-         cwctfz(mgs) = max( ctfzbd(mgs) + ctfzth(mgs) + ctfzdi(mgs) , 0.)
+          qhacw(mgs) = 0.25*pi*ehw(mgs)*cx(mgs,lh)*(qx(mgs,lc)-qcwresv(mgs))*vt*   &
+     &         (  da0lh(mgs)*xdia(mgs,lh,3)**2 +     &
+     &            dab1lh(mgs,lc,lh)*xdia(mgs,lh,3)*xdia(mgs,lc,3) +    &
+     &            da1(lc)*xdia(mgs,lc,3)**2 ) 
+         
+         ENDIF
+          qhacw(mgs) = Min( qhacw(mgs), 0.5*qx(mgs,lc)*dtpinv )
+        
+         IF ( lzh .gt. 1 ) THEN
+          tmp = qx(mgs,lh)/cx(mgs,lh)
+          
+!!          g1 = (6.0 + alpha(mgs,lh))*(5.0 + alpha(mgs,lh))*(4.0 + alpha(mgs,lh))/
+!!     :         ((3.0 + alpha(mgs,lh))*(2.0 + alpha(mgs,lh))*(1.0 + alpha(mgs,lh)))
+!          alp = Max( 1.0, alpha(mgs,lh)+1. )
+!          g1 = (6.0 + alp)*(5.0 + alp)*(4.0 + alp)/
+!     :         ((3.0 + alp)*(2.0 + alp)*(1.0 + alp))
+!          zhacw(mgs) =  g1*(6.*rho0(mgs)/(pi*1000.))**2*( 2.*( qx(mgs,lh)/cx(mgs,lh)) * qhacw(mgs) )
+         ENDIF
+        
+        ELSE
+         qhacw(mgs) =    &
+     &   min(   &
+     &   ((0.25)*pi)*ehw(mgs)*(qx(mgs,lc)-qcwresv(mgs))*cx(mgs,lh)   &
+     &  *abs(vtxbar(mgs,lh,1)-vtxbar(mgs,lc,1))   &
+     &  *(  gf3*xdia(mgs,lh,2)    &
+     &    + 2.0*gf2*xdia(mgs,lh,1)*xdia(mgs,lc,1)    &
+     &    + gf1*xdia(mgs,lc,2) )     &
+     &    , 0.5*(qx(mgs,lc)-qcwresv(mgs))*dtpinv)
+!     <  , qxmxd(mgs,lc))
+!     <  , qcmxd(mgs))
+       
+       
+         IF ( lwsm6 .and. qsacw(mgs) > 0.0 .and.  qhacw(mgs) > 0.0) THEN
+           qaacw = ( qx(mgs,ls)*qsacw(mgs) + qx(mgs,lh)*qhacw(mgs) )/(qx(mgs,ls) + qx(mgs,lh))
+!           qaacw = Min( qaacw, 0.5*(qsacw(mgs) + qhacw(mgs) ) )
+           qsacw(mgs) = qaacw
+           qhacw(mgs) = qaacw
+         ENDIF
+         
+       ENDIF
 
-!      Sum of the contact nucleation processes
-!         IF ( cx(mgs,lc) .gt. 50.e6) write(6,*) 'ctfzbd,etc = ',ctfzbd(mgs),ctfzth(mgs),ctfzdi(mgs)
-!         IF ( wvel(mgs) .lt. -0.05 ) write(6,*) 'ctfzbd,etc = ',ctfzbd(mgs),ctfzth(mgs),ctfzdi(mgs),cx(mgs,lc)*1e-6,wvel(mgs)
-!         IF ( ssw(mgs) .lt. 1.0 .and. cx(mgs,lc) .gt. 1.e6 .and. cwctfz(mgs) .gt. 1. ) THEN
-!          write(6,*) 'ctfzbd,etc = ',ctfzbd(mgs),ctfzth(mgs),ctfzdi(mgs),cx(mgs,lc)*1e-6,wvel(mgs),fn1(mgs),fn2(mgs)
-!          write(6,*) 'more = ',nstep,ssw(mgs),dfar(mgs),gtp(mgs),felv(mgs),pres(mgs)
-!         ENDIF
+          IF ( lvol(lh) .gt. 1 .or. lhl .gt. 1 ) THEN ! calculate rime density for graupel volume and/or for graupel conversion to hail
+             
+             IF ( temg(mgs) .lt. 273.15) THEN
+               IF ( irimdenopt == 1 ) THEN ! Heymsfield and Pflaum (1985)
+             rimdn(mgs,lh) = rimc1*(-((0.5)*(1.e+06)*xdia(mgs,lc,1))   &
+     &                *((0.60)*vtxbar(mgs,lh,1))   &
+     &                /(temg(mgs)-273.15))**(rimc2)
+!             rimdn(mgs,lh) = Min( Max( hdnmn, rimc3, rimdn(mgs,lh) ), rimc4 )
+             rimdn(mgs,lh) = Min( Max( rimc3, rimdn(mgs,lh) ), rimc4 )
 
-        ELSEIF ( icfn .eq. 1 ) THEN
-         IF ( wvel(mgs) .lt. -0.05 ) THEN ! older kludgy version
-           cwctfz(mgs) = cfnfac*exp( (-2.80) - (0.262)*temcg(mgs) )
-           cwctfz(mgs) = Min((1.0e3)*cwctfz(mgs), ccmxd(mgs) )  !convert to m-3
-         ENDIF
-        ENDIF   ! icfn
+               ELSEIF ( irimdenopt == 2 ) THEN ! Cober and List (1993)
 
-        IF ( ipconc .ge. 2 ) THEN
-         cwctfz(mgs) = Min( cwctfz(mgs)/dtp, ccmxd(mgs) )
-         qwctfz(mgs) = xmas(mgs,lc)*cwctfz(mgs)/rho0(mgs)
-        ELSE
-         qwctfz(mgs) = (cimasn)*cwctfz(mgs)/(dtp*rho0(mgs))
-         qwctfz(mgs) = max(qwctfz(mgs), 0.0)
-         qwctfz(mgs) = min(qwctfz(mgs),qcmxd(mgs))
-        ENDIF
+                tmp = (-((0.5)*(1.e+06)*xdia(mgs,lc,1))   &
+     &                *(vtxbar(mgs,lh,1))   &
+     &                /(temg(mgs)-273.15))
+                tmp = Min( 5.5/0.6, Max( 0.3/0.6, tmp ) ) ! have to limit range of "R" because quadratic function starts to decrease (unphysically) at higher values
+                
+                rimdn(mgs,lh) = 1000.*(0.051 + 0.114*tmp - 0.005*tmp**2)
 
-!
-        if ( xplate(mgs) .eq. 1 ) then
-         qwctfzp(mgs) = qwctfz(mgs)
-         cwctfzp(mgs) = cwctfz(mgs)
-        end if
-!
-        if ( xcolmn(mgs) .eq. 1 ) then
-         qwctfzc(mgs) = qwctfz(mgs)
-         cwctfzc(mgs) = cwctfz(mgs)
-        end if
-       
-!
-!     qwctfzc(mgs) = qwctfz(mgs)
-!     qwctfzp(mgs) = 0.0
-!
-       end if
+               ELSEIF ( irimdenopt == 3 ) THEN ! Macklin
 
-       ENDIF ! icfn
+                tmp = (-((0.5)*(1.e+06)*xdia(mgs,lc,1))   &
+     &                *(vtxbar(mgs,lh,1))   &
+     &                /(temg(mgs)-273.15))
+              !  tmp = Min( 5.5/0.6, Max( 0.3/0.6, tmp ) )
+                
+                rimdn(mgs,lh) =  Min(900., Max( 170., 110.*tmp**0.76 ) )
+               
+               ENDIF
+             ELSE
+             rimdn(mgs,lh) = 1000.
+             ENDIF
+             
+             IF ( lvol(lh) > 1 ) vhacw(mgs) = rho0(mgs)*qhacw(mgs)/rimdn(mgs,lh)
 
-      end do
-!
-!
+          ENDIF
+      
+        IF ( qx(mgs,lh) .gt. qxmin(lh) .and. ipelec .ge. 1 ) THEN
+         rarx(mgs,lh) =     &
+     &    qhacw(mgs)*1.0e3*rho0(mgs)/((pi/2.0)*xdia(mgs,lh,2)*cx(mgs,lh))
+        ENDIF
+      
+      ENDIF  
+      end do   
 !
-! Hobbs-Rangno ice enhancement (Ferrier, 1994)
 !
-      if (ndebug .gt. 0 ) write(0,*) 'conc 23a'
-      dtrh = 300.0
-      hrifac = (1.e-3)*((0.044)*(0.01**3))
       do mgs = 1,ngscnt
-      ciihr(mgs) = 0.0
-      qiihr(mgs) = 0.0
-      cicichr(mgs) = 0.0
-      qicichr(mgs) = 0.0
-      cipiphr(mgs) = 0.0
-      qipiphr(mgs) = 0.0
-      IF ( ihrn .ge. 1 ) THEN
-      if ( qx(mgs,lc) .gt. qxmin(lc) ) then
-      if ( temg(mgs) .lt. 273.15 ) then
-!      write(iunit,'(3(1x,i3),3(1x,1pe12.5))')
-!     : igs(mgs),jgs,kgs(mgs),cx(mgs,lc),rho0(mgs),qx(mgs,lc)
-!      write(iunit,'(1pe15.6)')
-!     :  log(cx(mgs,lc)*(1.e-6)/(3.0)),
-!     :  ((1.e-3)*rho0(mgs)*qx(mgs,lc)),
-!     :  (cx(mgs,lc)*(1.e-6)),
-!     : ((1.e-3)*rho0(mgs)*qx(mgs,lc))/(cx(mgs,lc)*(1.e-6)),
-!     : (alog(cx(mgs,lc)*(1.e-6)/(3.0)) *
-!     >  ((1.e-3)*rho0(mgs)*qx(mgs,lc))/(cx(mgs,lc)*(1.e-6)))
+      qhaci(mgs) = 0.0
+      qhaci0(mgs) = 0.0
+      IF ( ehi(mgs) .gt. 0.0 ) THEN
+       IF (  ipconc .ge. 5 ) THEN
 
-      IF ( Log(cx(mgs,lc)*(1.e-6)/(3.0)) .gt. 0.0 ) THEN
-      ciihr(mgs) = ((1.69e17)/dtrh)   &
-     & *(log(cx(mgs,lc)*(1.e-6)/(3.0)) *   &
-     &  ((1.e-3)*rho0(mgs)*qx(mgs,lc))/(cx(mgs,lc)*(1.e-6)))**(7./3.)
-      ciihr(mgs) = ciihr(mgs)*(1.0e6)
-      qiihr(mgs) = hrifac*ciihr(mgs)/rho0(mgs)
-      qiihr(mgs) = max(qiihr(mgs), 0.0)
-      qiihr(mgs) = min(qiihr(mgs),qcmxd(mgs))
+       vt = Sqrt((vtxbar(mgs,lh,1)-vtxbar(mgs,li,1))**2 +    &
+     &            0.04*vtxbar(mgs,lh,1)*vtxbar(mgs,li,1) )
+
+          qhaci0(mgs) = 0.25*pi*ehiclsn(mgs)*cx(mgs,lh)*qx(mgs,li)*vt*   &
+     &         (  da0lh(mgs)*xdia(mgs,lh,3)**2 +     &
+     &            dab1lh(mgs,li,lh)*xdia(mgs,lh,3)*xdia(mgs,li,3) +    &
+     &            da1(li)*xdia(mgs,li,3)**2 ) 
+          qhaci(mgs) = Min( ehi(mgs)*qhaci0(mgs), qimxd(mgs) )
+       ELSE
+        qhaci(mgs) =    &
+     &  min(   &
+     &  ((0.25)*pi)*ehi(mgs)*ehiclsn(mgs)*qx(mgs,li)*cx(mgs,lh)   &
+     &  *abs(vtxbar(mgs,lh,1)-vtxbar(mgs,li,1))   &
+     &  *(  gf3*xdia(mgs,lh,2)    &
+     &    + 2.0*gf2*xdia(mgs,lh,1)*xdia(mgs,li,1)    &
+     &    + gf1*xdia(mgs,li,2) )     &
+     &  , qimxd(mgs))
+       ENDIF
       ENDIF
-!
-      if ( xplate(mgs) .eq. 1 ) then
-      qipiphr(mgs) = qiihr(mgs)
-      cipiphr(mgs) = ciihr(mgs)
-      end if
-!
-      if ( xcolmn(mgs) .eq. 1 ) then
-      qicichr(mgs) = qiihr(mgs)
-      cicichr(mgs) = ciihr(mgs)
-      end if
-!
-!     qipiphr(mgs) = 0.0
-!     qicichr(mgs) = qiihr(mgs)
-!
-      end if
-      end if
-      ENDIF ! ihrn
-      end do
-!
-!
-!
-!  simple frozen rain to hail conversion.  All of the
-!  frozen rain larger than 5.0e-3 m in diameter are converted
-!  to hail.  This is done by considering the equation for
-!  frozen rain mixing ratio:
-!
-!
-!  qfw = [ cno(lf) * pi * fwdn / (6 rhoair) ]
-!
-!         /inf
-!      *  |     fwdia*3 exp(-dia/fwdia) d(dia)
-!         /Do
-!
-!  The amount to be reclassified as hail is the integral above from
-!  Do to inf where Do is 5.0e-3 m.
-!
-!
-!  qfauh = [ cno(lf) * pi * fwdn / (6 rhoair) ]
-!
-!
+      end do   
 
 
-      hdia0 = 300.0e-6
+      IF ( lis > 1 .and. ipconc >= 5 ) THEN
       do mgs = 1,ngscnt
-      qscnvi(mgs) = 0.0
-      cscnvi(mgs) = 0.0
-      cscnvis(mgs) = 0.0
-!      IF ( .false. ) THEN
-!      IF ( temg(mgs) .lt. tfr .and. ssi(mgs) .gt. 1.01 .and. qx(mgs,li) .gt. qxmin(li) ) THEN
-      IF ( temg(mgs) .lt. tfr .and. qx(mgs,li) .gt. qxmin(li) ) THEN
-        IF ( ipconc .ge. 4 .and. .false. ) THEN
-         if ( cx(mgs,li) .gt. 10. .and. xdia(mgs,li,1) .gt. 50.e-6 ) then !{
-         cirdiatmp =   &
-     &  (qx(mgs,li)*rho0(mgs)   &
-     & /(pi*xdn(mgs,li)*cx(mgs,li)))**(1./3.)
-          IF ( cirdiatmp .gt. 100.e-6 ) THEN !{
-          qscnvi(mgs) =   &
-     &  ((pi*xdn(mgs,li)*cx(mgs,li)) / (6.0*rho0(mgs)*dtp))   &
-     & *exp(-hdia0/cirdiatmp)   &
-     & *( (hdia0**3) + 3.0*(hdia0**2)*cirdiatmp   &
-     &  + 6.0*(hdia0)*(cirdiatmp**2) + 6.0*(cirdiatmp**3) )
-      qscnvi(mgs) =   &
-     &  min(qscnvi(mgs),qimxd(mgs))
-          IF ( ipconc .ge. 4 ) THEN
-            cscnvi(mgs) = Min( cimxd(mgs), cx(mgs,li)*Exp(-hdia0/cirdiatmp))
-          ENDIF
-         ENDIF  ! }
-        end if ! }
-
-       ELSEIF ( ipconc .lt. 4 ) THEN
+      qhacis(mgs) = 0.0
+      qhacis0(mgs) = 0.0
+      IF ( ehis(mgs) .gt. 0.0 ) THEN
 
-        qscnvi(mgs) = 0.001*eii(mgs)*max((qx(mgs,li)-1.e-3),0.0)
-        qscnvi(mgs) = min(qscnvi(mgs),qxmxd(mgs,li))
-        cscnvi(mgs) = qscnvi(mgs)*rho0(mgs)/xmas(mgs,li)
-        cscnvis(mgs) = 0.5*cscnvi(mgs)
+       vt = Sqrt((vtxbar(mgs,lh,1)-vtxbar(mgs,lis,1))**2 +    &
+     &            0.04*vtxbar(mgs,lh,1)*vtxbar(mgs,lis,1) )
 
-       ENDIF
+          qhacis0(mgs) = 0.25*pi*ehisclsn(mgs)*cx(mgs,lh)*qx(mgs,lis)*vt*   &
+     &         (  da0lh(mgs)*xdia(mgs,lh,3)**2 +     &
+     &            dab1lh(mgs,lis,lh)*xdia(mgs,lh,3)*xdia(mgs,lis,3) +    &
+     &            da1(li)*xdia(mgs,lis,3)**2 ) 
+          qhacis(mgs) = Min( ehis(mgs)*qhacis0(mgs), qxmxd(mgs,lis) )
       ENDIF
-!      ENDIF
       end do
+      ENDIF
 
 !
-!  Ventilation coeficients
 !
       do mgs = 1,ngscnt
-      fvent(mgs) = (fschm(mgs)**(1./3.)) * (fakvisc(mgs)**(-0.5))
-      end do
-!
-!
-      if ( ndebug .gt. 0 ) write(0,*) 'civent'
-!
-      civenta = 1.258e4
-      civentb = 2.331
-      civentc = 5.662e4
-      civentd = 2.373
-      civente = 0.8241
-      civentf = -0.042
-      civentg = 1.70
-
-      do mgs = 1,ngscnt
-      IF ( icond .eq. 1 .or. temg(mgs) .le. tfrh    &
-     &      .or. (qx(mgs,lr) .le. qxmin(lr) .and. qx(mgs,lc) .le. qxmin(lc)) ) THEN
-      IF ( qx(mgs,li) .gt. qxmin(li) ) THEN
-      cireyn =   &
-     &  (civenta*xdia(mgs,li,1)**civentb   &
-     &  +civentc*xdia(mgs,li,1)**civentd)   &
-     &  /   &
-     &  (civente*xdia(mgs,li,1)**civentf+civentg)
-      xcivent = (fschm(mgs)**(1./3.))*((cireyn/fakvisc(mgs))**0.5)
-      if ( xcivent .lt. 1.0 ) then
-      civent(mgs) = 1.0 + 0.14*xcivent**2
-      end if
-      if ( xcivent .ge. 1.0 ) then
-      civent(mgs) = 0.86 + 0.28*xcivent
-      end if
-      ELSE
-       civent(mgs) = 0.0
-      ENDIF
+      qhacs(mgs) = 0.0
+      qhacs0(mgs) = 0.0
+      IF ( ehs(mgs) .gt. 0.0 ) THEN
+       IF ( ipconc .ge. 5 ) THEN
 
+       vt = Sqrt((vtxbar(mgs,lh,1)-vtxbar(mgs,ls,1))**2 +    &
+     &            0.04*vtxbar(mgs,lh,1)*vtxbar(mgs,ls,1) )
 
-      ENDIF ! icond .eq. 1
-      end do
+          qhacs0(mgs) = 0.25*pi*ehsclsn(mgs)*cx(mgs,lh)*qx(mgs,ls)*vt*   &
+     &         (  da0lh(mgs)*xdia(mgs,lh,3)**2 +     &
+     &            dab1lh(mgs,ls,lh)*xdia(mgs,lh,3)*xdia(mgs,ls,3) +    &
+     &            da1(ls)*xdia(mgs,ls,3)**2 ) 
+      
+          qhacs(mgs) = Min( ehs(mgs)*qhacs0(mgs), qsmxd(mgs) )
 
+       ELSE
+         qhacs(mgs) =   &
+     &   min(   &
+     &   ((0.25)*pi/gf4)*ehs(mgs)*ehsclsn(mgs)*qx(mgs,ls)*cx(mgs,lh)   &
+     &  *abs(vtxbar(mgs,lh,1)-vtxbar(mgs,ls,1))   &
+     &  *(  gf6*gf1*xdia(mgs,ls,2)   &
+     &    + 2.0*gf5*gf2*xdia(mgs,ls,1)*xdia(mgs,lh,1)   &
+     &    + gf4*gf3*xdia(mgs,lh,2) )   &
+     &  , qsmxd(mgs))
+        ENDIF
+      ENDIF
+      end do   
 !
-!
-      igmrwa = 100.0*2.0
-      igmrwb = 100.*((5.0+br)/2.0)
-      rwventa = (0.78)*gmoi(igmrwa)  ! 0.78
-      rwventb = (0.308)*gmoi(igmrwb) ! 0.562825
       do mgs = 1,ngscnt
-      IF ( qx(mgs,lr) .gt. qxmin(lr) ) THEN
-        IF ( ipconc .ge. 3 ) THEN
-          IF ( imurain == 3 ) THEN
-           IF ( izwisventr == 1 ) THEN
-            rwvent(mgs) = ventrx(mgs)*(1.6 + 124.9*(1.e-3*rho0(mgs)*qx(mgs,lr))**.2046)
-           ELSE ! izwisventr = 2
-!  Following Wisner et al. (1972) but using gamma of volume. Note that Ferrier's rain fall speed does not integrate with gamma of volume, so using Vr = ar*d^br
-          rwvent(mgs) =   &
-     &  (0.78*ventrx(mgs) + 0.308*ventrxn(mgs)*fvent(mgs)   &
-     &   *Sqrt((ar*rhovt(mgs)))   &
-     &    *(xdia(mgs,lr,1)**((1.0+br)/2.0)) )
-           ENDIF
-
-          ELSE ! imurain == 1
-       ! linear interpolation of complete gamma function
-!        tmp = 2. + alpha(mgs,lr)
-!        i = Int(dgami*(tmp))
-!        del = tmp - dgam*i
-!        x = gmoi(i) + (gmoi(i+1) - gmoi(i))*del*dgami
-
-        IF ( iferwisventr == 1 ) THEN
+      qhacr(mgs) = 0.0
+      qhacrmlr(mgs) = 0.0
+      vhacr(mgs) = 0.0
+      chacr(mgs) = 0.0
+      zhacr(mgs) = 0.0
+      IF ( temg(mgs) .gt. tfr ) raindn(mgs,lh) = 1000.0
 
-  ! Ferrier fall speed in the ventillation term [uses fx(lr) ]
-  
-        alpr = Min(alpharmax,alpha(mgs,lr) )
+      IF ( ehr(mgs) .gt. 0.0 ) THEN
+      IF ( ipconc .ge. 3 ) THEN
+       vt = Sqrt((vtxbar(mgs,lh,1)-vtxbar(mgs,lr,1))**2 +    &
+     &            0.04*vtxbar(mgs,lh,1)*vtxbar(mgs,lr,1) )
+!       qhacr(mgs) = ehr(mgs)*cx(mgs,lh)*vt*
+!     :     qx(mgs,lr)*0.25*pi*
+!     :      (3.02787*xdia(mgs,lr,2) + 
+!     :       3.30669*xdia(mgs,lh,1)*xdia(mgs,lr,1) + 
+!     :       2.*xdia(mgs,lh,2))
+     
+       qhacr(mgs) = 0.25*pi*ehr(mgs)*cx(mgs,lh)*qx(mgs,lr)*vt*   &
+     &         (  da0lh(mgs)*xdia(mgs,lh,3)**2 +     &
+     &            dab1lh(mgs,lr,lh)*xdia(mgs,lh,3)*xdia(mgs,lr,3) +    &
+     &            da1(lr)*xdia(mgs,lr,3)**2 )
+!       IF ( qhacr(mgs) .gt. 0. .or. tmp .gt. 0.0 ) write(0,*) 'qhacr= ',qhacr(mgs),tmp
+!!        qhacr(mgs) = Min( qhacr(mgs), qrmxd(mgs) )
+!!        chacr(mgs) = qhacr(mgs)*cx(mgs,lr)/qx(mgs,lr)
+!!        chacr(mgs) = min(chacr(mgs),crmxd(mgs))
 
-        x =  1. + alpha(mgs,lr)
+        qhacr(mgs) = Min( qhacr(mgs), qxmxd(mgs,lr) )
 
-        IF ( lzr > 1 ) THEN ! 3 moment
+        qhacrmlr(mgs) = qhacr(mgs)
+        IF ( temg(mgs) > tfr .and. iehr0c == 0 ) THEN
+          qhacr(mgs) = 0.0
         ELSE
-         y = ventrxn(mgs)
-        ENDIF
+!        chacr(mgs) = Min( qhacr(mgs)*rho0(mgs)/xmas(mgs,lr), cxmxd(mgs,lr) )
 
-!         vent1 = dble(xdia(mgs,lr,1))**(-2. - alpr) ! Actually OK
-!         vent2 = dble(1./xdia(mgs,lr,1) + 0.5*fx(lr))**dble(2.5+alpr+0.5*bx(lr))  ! Actually OK
-         vent1 = dble(xdia(mgs,lr,1))**(0.5 + 0.5*bx(lr)) ! 2016.2.26 Changed for consistency with derivation (recast formula -- should be equivalent)
-         vent2 = dble(1. + 0.5*fx(lr)*xdia(mgs,lr,1))**dble(2.5+alpr+0.5*bx(lr))
-        
-        
-        rwvent(mgs) =    &
-     &    0.78*x +    &
-     &    0.308*fvent(mgs)*y*   &
-     &            Sqrt(ax(lr)*rhovt(mgs))*(vent1/vent2)
-       
+!       chacr(mgs) = ehr(mgs)*cx(mgs,lh)*vt*
+!     :     cx(mgs,lr)*0.25*pi*
+!     :      (0.69874*xdia(mgs,lr,2) +
+!     :       1.24001*xdia(mgs,lh,1)*xdia(mgs,lr,1) +
+!     :       2.*xdia(mgs,lh,2))
 
-        ELSEIF ( iferwisventr == 2 ) THEN
-          
-!  Following Wisner et al. (1972) but using gamma of volume. Note that Ferrier's rain fall speed does not integrate with gamma of volume, so using Vr = ar*d^br
-         x =  1. + alpha(mgs,lr)
+!        chacr(mgs) = 0.25*pi*ehr(mgs)*cx(mgs,lh)*cx(mgs,lr)*vt*
+!     :         (  da0lh(mgs)*xdia(mgs,lh,3)**2 +
+!     :            dab0lh(mgs,lr)*xdia(mgs,lh,3)*xdia(mgs,lr,3) +
+!     :            da0(lr)*xdia(mgs,lr,3)**2 )
 
-           rwvent(mgs) =   &
-     &  (0.78*x + 0.308*ventrxn(mgs)*fvent(mgs)   &
-     &   *Sqrt((ar*rhovt(mgs)))   &
-     &    *(xdia(mgs,lr,1)**((1.0+br)/2.0)) )
+!       IF ( qhacr(mgs) .gt. 0. .or. tmp .gt. 0.0 ) write(0,*) 'chacr= ',chacr(mgs),tmp
 
+        chacr(mgs) = qhacr(mgs)*cx(mgs,lr)/qx(mgs,lr)
+        chacr(mgs) = min(chacr(mgs),crmxd(mgs))
 
-          
-          ENDIF ! iferwisventr
-          
-          ENDIF ! imurain
-        ELSE
-         rwvent(mgs) =   &
-     &  (rwventa + rwventb*fvent(mgs)   &
-     &   *Sqrt((ar*rhovt(mgs)))   &
-     &    *(xdia(mgs,lr,1)**((1.0+br)/2.0)) )
-        ENDIF
-      ELSE
-       rwvent(mgs) = 0.0
+      IF ( lzh .gt. 1 ) THEN
+          tmp = qx(mgs,lh)/cx(mgs,lh)
+
+!          g1 = (6.0 + alpha(mgs,lh))*(5.0 + alpha(mgs,lh))*(4.0 + alpha(mgs,lh))/
+!     :         ((3.0 + alpha(mgs,lh))*(2.0 + alpha(mgs,lh))*(1.0 + alpha(mgs,lh)))
+!          alp = Max( 1.0, alpha(mgs,lh)+1. )
+!          g1 = (6.0 + alp)*(5.0 + alp)*(4.0 + alp)/
+!     :         ((3.0 + alp)*(2.0 + alp)*(1.0 + alp))
+!        zhacr(mgs) =  g1*(6.*rho0(mgs)/(pi*1000.))**2*( 2.*( tmp ) * qhacr(mgs) - tmp**2 * chacr(mgs) )
+!        zhacr(mgs) =  g1*(6.*rho0(mgs)/(pi*xdn(mgs,lh)))**2*( 2.*( tmp ) * qhacr(mgs) )
       ENDIF
-      end do
-!
-      igmswa = 100.0*2.0
-      igmswb = 100.*((5.0+ds)/2.0)
-      swventa = (0.78)*gmoi(igmswa)
-      swventb = (0.308)*gmoi(igmswb)
-      do mgs = 1,ngscnt
-      IF ( qx(mgs,ls) .gt. qxmin(ls) ) THEN
-      IF ( ipconc .ge. 4 ) THEN
-      swvent(mgs) = 0.65 + 0.44*fvent(mgs)*Sqrt(vtxbar(mgs,ls,1)*xdia(mgs,ls,1))
+      ENDIF ! temg > tfr
+      
       ELSE
-! 10-ice version:
-       swvent(mgs) =   &
-     &  (swventa + swventb*fvent(mgs)   &
-     &   *Sqrt((cs*rhovt(mgs)))   &
-     &   *(xdia(mgs,ls,1)**((1.0+ds)/2.0)) )
+       IF ( lwsm6 .and. ipconc == 0 ) THEN
+         vt = vt2ave(mgs)
+       ELSE
+         vt = vtxbar(mgs,lh,1)
+       ENDIF
+
+      qhacr(mgs) =   &
+     &   min(   &
+     &   ((0.25)*pi/gf4)*ehr(mgs)*qx(mgs,lr)*cx(mgs,lh)   &
+     &  *abs(vt-vtxbar(mgs,lr,1))   &
+     &  *(  gf6*gf1*xdia(mgs,lr,2)   &
+     &    + 2.0*gf5*gf2*xdia(mgs,lr,1)*xdia(mgs,lh,1)   &
+     &    + gf4*gf3*xdia(mgs,lh,2) )   &
+     &  , qrmxd(mgs))
+      
+        IF ( temg(mgs) > tfr ) THEN
+          qhacrmlr(mgs) = qhacr(mgs)
+          qhacr(mgs) = 0.0
+        ENDIF
+      
       ENDIF
-      ELSE
-      swvent(mgs) = 0.0
+          IF ( lvol(lh) .gt. 1 .or. lhl .gt. 1 ) THEN ! calculate rime density for graupel volume and/or for graupel conversion to hail
+             
+             IF ( temg(mgs) .lt. 273.15) THEN
+             raindn(mgs,lh) = rimc1*(-((0.5)*(1.e+06)*xdia(mgs,lr,1))   &
+     &                *((0.60)*vt)   &
+     &                /(temg(mgs)-273.15))**(rimc2)
+
+             raindn(mgs,lh) = Min( Max( rimc3, rimdn(mgs,lh) ), rimc4 )
+             ELSE
+             raindn(mgs,lh) = 1000.
+             ENDIF
+             
+             IF ( lvol(lh) > 1 )  vhacr(mgs) = rho0(mgs)*qhacr(mgs)/raindn(mgs,lh)
+        ENDIF
       ENDIF
       end do
+
 !
+!
+      if (ndebug .gt. 0 ) write(0,*) 'Collection: hail collects xxxxx'
 !
 
-      igmhwa = 100.0*2.0
-      igmhwb = 100.0*2.75
-      hwventa = (0.78)*gmoi(igmhwa)
-      hwventb = (0.308)*gmoi(igmhwb)
-      hwventc = (4.0*gr/(3.0*cdx(lh)))**(0.25)
       do mgs = 1,ngscnt
-      IF ( qx(mgs,lh) .gt. qxmin(lh) ) THEN
-       IF ( .false. .or. alpha(mgs,lh) .eq. 0.0 ) THEN
-        hwvent(mgs) =   &
-     &  ( hwventa + hwventb*hwventc*fvent(mgs)   &
-     &    *((xdn(mgs,lh)/rho0(mgs))**(0.25))   &
-     &    *(xdia(mgs,lh,1)**(0.75)))
-       ELSE ! Ferrier 1994, eq. B.36
-       ! linear interpolation of complete gamma function
-!        tmp = 2. + alpha(mgs,lh)
-!        i = Int(dgami*(tmp))
-!        del = tmp - dgam*i
-!        x = gmoi(i) + (gmoi(i+1) - gmoi(i))*del*dgami
-        
-! note that hwvent includes a division by Gamma(1+alpha), so Gamma(2+alpha)/Gamma(1+alpha) = 1 + alpha
-! and g1palp = Gamma(1+alpha) divides into y
-        x =  1. + alpha(mgs,lh)
+      qhlacw(mgs) = 0.0
+      vhlacw(mgs) = 0.0
+      vhlsoak(mgs) = 0.0
+      IF ( lhl > 1 .and. .true.) THEN
+        vtmax = (gz(igs(mgs),jgs,kgs(mgs))*dtpinv)
+        vtxbar(mgs,lhl,1) = Min( vtmax, vtxbar(mgs,lhl,1))
+        vtxbar(mgs,lhl,2) = Min( vtmax, vtxbar(mgs,lhl,2))
+        vtxbar(mgs,lhl,3) = Min( vtmax, vtxbar(mgs,lhl,3))
+      ENDIF
 
-        tmp = 1 + alpha(mgs,lh)
-        i = Int(dgami*(tmp))
-        del = tmp - dgam*i
-        g1palp = gmoi(i) + (gmoi(i+1) - gmoi(i))*del*dgami
+      IF ( lhl > 0 ) THEN
+      rarx(mgs,lhl) = 0.0
+      ENDIF
 
-        tmp = 2.5 + alpha(mgs,lh) + 0.5*bxh(mgs)
-        i = Int(dgami*(tmp))
-        del = tmp - dgam*i
-        y = (gmoi(i) + (gmoi(i+1) - gmoi(i))*del*dgami)/g1palp
-        
-        
-        hwventy(mgs) = 0.308*fvent(mgs)*(xdia(mgs,lh,1)**(0.5 + 0.5*bxh(mgs)))*Sqrt(axh(mgs)*rhovt(mgs)) 
-        hwvent(mgs) =    &
-     &  ( 0.78*x +  y*hwventy(mgs) ) !   &
-!     &    0.308*fvent(mgs)*y*(xdia(mgs,lh,1)**(0.5 + 0.5*bxh(mgs)))*   &
-!     &            Sqrt(axh(mgs)*rhovt(mgs)) )
-       
-       ENDIF
-      ELSE
-      hwvent(mgs) = 0.0
-      hwventy(mgs) = 0.0
-      ENDIF
-      end do
-      
-      hlvent(:) = 0.0
-      hlventy(:) = 0.0
+      IF ( lhl .gt. 1 .and. ehlw(mgs) .gt. 0.0 ) THEN
 
-      IF ( lhl .gt. 1 ) THEN
-      igmhwa = 100.0*2.0
-      igmhwb = 100.0*2.75
-      hwventa = (0.78)*gmoi(igmhwa)
-      hwventb = (0.308)*gmoi(igmhwb)
-      hwventc = (4.0*gr/(3.0*cdx(lhl)))**(0.25)
-      do mgs = 1,ngscnt
-      IF ( qx(mgs,lhl) .gt. qxmin(lhl) ) THEN
 
-       IF ( .false. .or. alpha(mgs,lhl) .eq. 0.0 ) THEN
-        hlvent(mgs) =   &
-     &  ( hwventa + hwventb*hwventc*fvent(mgs)   &
-     &    *((xdn(mgs,lhl)/rho0(mgs))**(0.25))   &
-     &    *(xdia(mgs,lhl,1)**(0.75)))
-       ELSE ! Ferrier 1994, eq. B.36
-       ! linear interpolation of complete gamma function
-!        tmp = 2. + alpha(mgs,lhl)
-!        i = Int(dgami*(tmp))
-!        del = tmp - dgam*i
-!        x = gmoi(i) + (gmoi(i+1) - gmoi(i))*del*dgami
+!        IF ( ipconc .ge. 2 ) THEN
 
-! note that hlvent includes a division by Gamma(1+alpha), so x = Gamma(2+alpha)/Gamma(1+alpha) = 1 + alpha
-! and g1palp = Gamma(1+alpha) divides into y
+            vt = abs(vtxbar(mgs,lhl,1)-vtxbar(mgs,lc,1))
 
-        x =  1. + alpha(mgs,lhl)
+          qhlacw(mgs) = 0.25*pi*ehlw(mgs)*cx(mgs,lhl)*(qx(mgs,lc)-qcwresv(mgs))*vt*   &
+     &         (  da0lhl(mgs)*xdia(mgs,lhl,3)**2 +     &
+     &            dab1lh(mgs,lc,lhl)*xdia(mgs,lhl,3)*xdia(mgs,lc,3) +    &
+     &            da1(lc)*xdia(mgs,lc,3)**2 )
 
-        tmp = 1 + alpha(mgs,lhl)
-        i = Int(dgami*(tmp))
-        del = tmp - dgam*i
-        g1palp = gmoi(i) + (gmoi(i+1) - gmoi(i))*del*dgami
 
-        tmp = 2.5 + alpha(mgs,lhl) + 0.5*bxhl(mgs)
-        i = Int(dgami*(tmp))
-        del = tmp - dgam*i
-        y = (gmoi(i) + (gmoi(i+1) - gmoi(i))*del*dgami)/g1palp ! ratio of gamma functions
+          qhlacw(mgs) = Min( qhlacw(mgs), 0.5*qx(mgs,lc)*dtpinv )
 
-        hlventy(mgs) = 0.308*fvent(mgs)*(xdia(mgs,lhl,1)**(0.5 + 0.5*bxhl(mgs)))*Sqrt(axhl(mgs)*rhovt(mgs)) 
-        
-        hlvent(mgs) =  0.78*x + y*hlventy(mgs)  !   &
-!     &    0.308*fvent(mgs)*y*(xdia(mgs,lhl,1)**(0.5 + 0.5*bxhl(mgs)))*   &
-!     &            Sqrt(axhl(mgs)*rhovt(mgs)))
-!     :            Sqrt(xdn(mgs,lhl)*ax(lhl)*rhovt(mgs)/rg0))/tmp
+          IF ( lvol(lhl) .gt. 1 ) THEN
 
-        ENDIF
-       ENDIF
-      end do
-      ENDIF
+             IF ( temg(mgs) .lt. 273.15) THEN
+               IF ( irimdenopt == 1 ) THEN ! Rasmussen and Heymsfeld (1985)
+             rimdn(mgs,lhl) = rimc1*(-((0.5)*(1.e+06)*xdia(mgs,lc,1))   &
+     &                *((0.60)*vtxbar(mgs,lhl,1))   &
+     &                /(temg(mgs)-273.15))**(rimc2)
+             rimdn(mgs,lhl) = Min( Max( hldnmn, rimc3, rimdn(mgs,lhl) ), rimc4 )
+               
+               ELSEIF ( irimdenopt == 2 ) THEN ! Cober and List (1993)
+                tmp = -0.5*(1.e+06)*xdia(mgs,lc,1)   &
+     &                *vtxbar(mgs,lhl,1)   &
+     &                /(temg(mgs)-273.15)
+                tmp = Min( 5.5/0.6, Max( 0.3/0.6, tmp ) )
+                
+                rimdn(mgs,lhl) = 1000.*(0.051 + 0.114*tmp - 0.005*tmp**2)
+               
+               ELSEIF ( irimdenopt == 3 ) THEN ! Macklin
+                tmp = -0.5*(1.e+06)*xdia(mgs,lc,1)   &
+     &                *vtxbar(mgs,lhl,1)   &
+     &                /(temg(mgs)-273.15)
+              !  tmp = Min( 5.5/0.6, Max( 0.3/0.6, tmp ) )
+                
+                rimdn(mgs,lhl) = Min(900., Max( 170., 110.*tmp**0.76 ) )
+               
+               ENDIF
+             ELSE
+             rimdn(mgs,lhl) = 1000.
+             ENDIF
 
-!
-!
-!
-!  Wet growth constants
-!
-      do mgs = 1,ngscnt
-      fwet1(mgs) =   &
-     & (2.0*pi)*   &
-     & ( felv(mgs)*fwvdf(mgs)*rho0(mgs)*(qss0(mgs)-qx(mgs,lv))   &
-     &  -ftka(mgs)*temcg(mgs) )   &
-     & / ( rho0(mgs)*(felf(mgs)+fcw(mgs)*temcg(mgs)) )
-      fwet2(mgs) =   &
-     &  (1.0)-fci(mgs)*temcg(mgs)   &
-     & / ( felf(mgs)+fcw(mgs)*temcg(mgs) )
-      end do
-!
-!  Melting constants
-!
-      do mgs = 1,ngscnt
-      fmlt1(mgs) = (2.0*pi)*   &
-     &  ( felv(mgs)*fwvdf(mgs)*(qss0(mgs)-qx(mgs,lv))   &
-     &   -ftka(mgs)*temcg(mgs)/rho0(mgs) )    &
-     &  / (felf(mgs))
-      fmlt2(mgs) = -fcw(mgs)*temcg(mgs)/felf(mgs)
-      end do
-!
-!  Vapor Deposition constants
-!
-      do mgs = 1,ngscnt
-      fvds(mgs) =    &
-     &  (4.0*pi/rho0(mgs))*(ssi(mgs)-1.0)*   &
-     &  (1.0/(fai(mgs)+fbi(mgs)))
-      end do
-      do mgs = 1,ngscnt
-      fvce(mgs) =    &
-     &  (4.0*pi/rho0(mgs))*(ssw(mgs)-1.0)*   &
-     &  (1.0/(fav(mgs)+fbv(mgs)))
-      end do
+             vhlacw(mgs) = rho0(mgs)*qhlacw(mgs)/rimdn(mgs,lhl)
 
-!
-!  deposition, sublimation, and melting of snow, graupel and hail
-!
-      qsmlr(:) = 0.0
-      qimlr(:) = 0.0 ! this is not used. qi melts to qc way down in the code.
-      qhmlr(:) = 0.0
-      qhlmlr(:) = 0.0
-      qhmlrlg(:) = 0.0
-      qhlmlrlg(:) = 0.0
-      qhfzh(:) = 0.0
-      qhlfzhl(:) = 0.0
-      vhfzh(:) = 0.0
-      vhlfzhl(:) = 0.0
-      qsfzs(:) = 0.0
-      zsmlr(:) = 0.0
-      zhmlr(:) = 0.0
-      zhmlrr(:) = 0.0
-      zhshr(:) = 0.0
-      zhlmlr(:) = 0.0
-      zhlshr(:) = 0.0
+          ENDIF
 
-      zhshrr(:) = 0.0
-      zhlmlrr(:) = 0.0
-      zhlshrr(:) = 0.0
 
-      csmlr(:) = 0.0
-      chmlr(:) = 0.0
-      chmlrr(:) = 0.0
-      chlmlr(:) = 0.0
-      chlmlrr(:) = 0.0
+        IF ( qx(mgs,lhl) .gt. qxmin(lhl) .and. ipelec .ge. 1 ) THEN
+         rarx(mgs,lhl) =     &
+     &    qhlacw(mgs)*1.0e3*rho0(mgs)/((pi/2.0)*xdia(mgs,lhl,2)*cx(mgs,lhl))
+        ENDIF
 
-      if ( .not. mixedphase ) then !{
-      do mgs = 1,ngscnt
-!
-      IF ( temg(mgs) .gt. tfr ) THEN
-      
-      IF (  qx(mgs,ls) .gt. qxmin(ls) ) THEN
-      qsmlr(mgs) =   &
-     &   min(   &
-     &  (c1sw*fmlt1(mgs)*cx(mgs,ls)*swvent(mgs)*xdia(mgs,ls,1) ) & ! /rhosm    &
-     &   , 0.0 )
       ENDIF
-      
-!       IF ( qx(mgs,ls) .gt. 0.1e-4 ) write(0,*) 'qsmlr: ',qsmlr(mgs),qx(mgs,ls),cx(mgs,ls),fmlt1(mgs),
-!     :        temcg(mgs),swvent(mgs),xdia(mgs,ls,1),qss0(mgs)-qx(mgs,lv)
-!      ELSE
-!       qsmlr(mgs) = 0.0
-!      ENDIF
-! 10ice version:
-!     >   min(
-!     >  (fmlt1(mgs)*cx(mgs,ls)*swvent(mgs)*xdia(mgs,ls,1) +
-!     >   fmlt2(mgs)*(qsacr(mgs)+qsacw(mgs)) )
-!     <   , 0.0 )
-
-      IF (  qx(mgs,lh) .gt. qxmin(lh) ) THEN
+      end do
 
-      IF ( ibinhmlr == 0 .or. lzh < 1 ) THEN
-       qhmlr(mgs) =   &
-     &   min(   &
-     &  fmlt1(mgs)*cx(mgs,lh)*hwvent(mgs)*xdia(mgs,lh,1)   &
-     &  + fmlt2(mgs)*(qhacrmlr(mgs)+qhacw(mgs))    &
-     &   , 0.0 )
-       ELSEIF ( ibinhmlr == 1 ) THEN ! use incomplete gamma functions to approximate the bin results
+      qhlaci(:) = 0.0
+      qhlaci0(:) = 0.0
+      IF ( lhl .gt. 1  ) THEN
+      do mgs = 1,ngscnt
+      IF ( ehli(mgs) .gt. 0.0 ) THEN
+       IF (  ipconc .ge. 5 ) THEN
 
-         write(0,*) 'ibinhmlr = 1 not available for 2-moment'
-         STOP
-         
-       ELSEIF ( ibinhmlr == 2 ) THEN
+       vt = Sqrt((vtxbar(mgs,lhl,1)-vtxbar(mgs,li,1))**2 +    &
+     &            0.04*vtxbar(mgs,lhl,1)*vtxbar(mgs,li,1) )
 
+          qhlaci0(mgs) = 0.25*pi*ehliclsn(mgs)*cx(mgs,lhl)*qx(mgs,li)*vt*   &
+     &         (  da0lhl(mgs)*xdia(mgs,lhl,3)**2 +     &
+     &            dab1lh(mgs,li,lhl)*xdia(mgs,lhl,3)*xdia(mgs,li,3) +    &
+     &            da1(li)*xdia(mgs,li,3)**2 )
+        ! qhlaci(mgs) = Min( qhlaci(mgs), qimxd(mgs) )
+          qhlaci(mgs) = Min( ehli(mgs)*qhlaci0(mgs), qimxd(mgs) )
        ENDIF
-       
-       
-       IF ( ivhmltsoak > 0 .and. qhmlr(mgs) < 0.0 .and. lvol(lh) > 1 .and. xdn(mgs,lh) .lt. xdnmx(lh) ) THEN
-         ! act as if 100% of the meltwater were soaked into the graupel
-           v1 = (1. - xdn(mgs,lh)/xdnmx(lh))*(vx(mgs,lh) + rho0(mgs)*qhmlr(mgs)/xdn(mgs,lh) )/(dtp) ! volume available for filling
-           v2 = -1.0*rho0(mgs)*qhmlr(mgs)/xdnmx(lh)  ! volume of melted ice if it were refrozen in the matrix
-           
-           vhsoak(mgs) = Min(v1,v2)
-           
-       ENDIF
+      ENDIF
+      end do
+      ENDIF
+!
+      qhlacs(:) = 0.0
+      qhlacs0(:) = 0.0
+      IF ( lhl .gt. 1 ) THEN
+      do mgs = 1,ngscnt
+      IF ( ehls(mgs) .gt. 0.0) THEN
+       IF ( ipconc .ge. 5 ) THEN
 
-      ENDIF !  qx(mgs,lh) .gt. qxmin(lh)
+       vt = Sqrt((vtxbar(mgs,lhl,1)-vtxbar(mgs,ls,1))**2 +    &
+     &            0.04*vtxbar(mgs,lhl,1)*vtxbar(mgs,ls,1) )
 
-      
-      IF ( lhl .gt. 1  .and. lhlw < 1 ) THEN
+          qhlacs0(mgs) = 0.25*pi*ehlsclsn(mgs)*cx(mgs,lhl)*qx(mgs,ls)*vt*   &
+     &         (  da0lhl(mgs)*xdia(mgs,lhl,3)**2 +     &
+     &            dab1lh(mgs,ls,lhl)*xdia(mgs,lhl,3)*xdia(mgs,ls,3) +    &
+     &            da1(ls)*xdia(mgs,ls,3)**2 )
 
-       IF ( qx(mgs,lhl) .gt. qxmin(lhl) ) THEN
-         IF ( ibinhlmlr == 0  .or. lzhl < 1) THEN
-       qhlmlr(mgs) =   &
-     &   min(   &
-     &  fmlt1(mgs)*cx(mgs,lhl)*hlvent(mgs)*xdia(mgs,lhl,1)   &
-     &  + fmlt2(mgs)*(qhlacrmlr(mgs)+qhlacw(mgs))    &
-     &   , 0.0 )
+          qhlacs(mgs) = Min( ehls(mgs)*qhlacs0(mgs), qsmxd(mgs) )
+        ENDIF
+      ENDIF
+      end do
+      ENDIF
 
-       ELSEIF ( ibinhlmlr == 1 ) THEN ! use incomplete gamma functions to approximate the bin results
 
+      do mgs = 1,ngscnt
+      qhlacr(mgs) = 0.0
+      qhlacrmlr(mgs) = 0.0
+      chlacr(mgs) = 0.0
+      vhlacr(mgs) = 0.0
+      IF ( lhl .gt. 1 .and. temg(mgs) .gt. tfr ) raindn(mgs,lhl) = 1000.0
 
-       ELSEIF ( ibinhlmlr == -1 ) THEN ! OLD VERSION use incomplete gamma functions to approximate the bin results
+      IF ( lhl .gt. 1 .and. ehlr(mgs) .gt. 0.0 ) THEN
+      IF ( ipconc .ge. 3 ) THEN
+       vt = Sqrt((vtxbar(mgs,lhl,1)-vtxbar(mgs,lr,1))**2 +    &
+     &            0.04*vtxbar(mgs,lhl,1)*vtxbar(mgs,lr,1) )
 
-        ENDIF ! ibinhlmlr
+       qhlacr(mgs) = 0.25*pi*ehlr(mgs)*cx(mgs,lhl)*qx(mgs,lr)*vt*   &
+     &         (  da0lhl(mgs)*xdia(mgs,lhl,3)**2 +     &
+     &            dab1lh(mgs,lr,lhl)*xdia(mgs,lhl,3)*xdia(mgs,lr,3) +    &
+     &            da1(lr)*xdia(mgs,lr,3)**2 )
+!       IF ( qhacr(mgs) .gt. 0. .or. tmp .gt. 0.0 ) write(0,*) 'qhacr= ',qhacr(mgs),tmp
+!!        qhacr(mgs) = Min( qhacr(mgs), qrmxd(mgs) )
+!!        chacr(mgs) = qhacr(mgs)*cx(mgs,lr)/qx(mgs,lr)
+!!        chacr(mgs) = min(chacr(mgs),crmxd(mgs))
 
+        qhlacr(mgs) = Min( qhlacr(mgs), qxmxd(mgs,lr) )
 
-       IF ( ivhmltsoak > 0 .and.  qhlmlr(mgs) < 0.0 .and. lvol(lhl) > 1 .and. xdn(mgs,lhl) .lt. xdnmx(lhl) ) THEN
-         ! act as if 50% of the meltwater were soaked into the graupel
-           v1 = (1. - xdn(mgs,lhl)/xdnmx(lhl))*(vx(mgs,lhl) + rho0(mgs)*qhlmlr(mgs)/xdn(mgs,lhl) )/(dtp) ! volume available for filling
-           v2 = -1.0*rho0(mgs)*qhlmlr(mgs)/xdnmx(lhl)  ! volume of melted ice if it were refrozen in the matrix
-           
-           vhlsoak(mgs) = Min(v1,v2)
-           
-       ENDIF
-        
-        ENDIF
-       ENDIF
-
-      ENDIF
-      
-!
-!      qimlr(mgs)  = max( qimlr(mgs), -qimxd(mgs) ) 
-!      qsmlr(mgs)  = max( qsmlr(mgs),  -qsmxd(mgs) ) 
-! erm 5/10/2007 changed to next line:
-      if ( .not. mixedphase ) qsmlr(mgs)  = max( qsmlr(mgs),  Min( -qsmxd(mgs), -0.7*qx(mgs,ls)*dtpinv ) ) 
-      if ( .not. mixedphase ) qhmlr(mgs)  = max( qhmlr(mgs),  Min( -qhmxd(mgs), -0.5*qx(mgs,lh)*dtpinv ) ) 
-!      qhmlr(mgs)  = max( max( qhmlr(mgs),  -qhmxd(mgs) ) , -0.5*qx(mgs,lh)/dtp ) !limits to 1/2 qh or max depletion
-      qhmlh(mgs)  = 0.
+     
+        qhlacrmlr(mgs) = qhlacr(mgs)
+        IF ( temg(mgs) > tfr .and. iehlr0c == 0) THEN
+        qhlacr(mgs) = 0.0
+        ELSE
+        chlacr(mgs) = 0.25*pi*ehlr(mgs)*cx(mgs,lhl)*cx(mgs,lr)*vt*   &
+     &         (  da0lhl(mgs)*xdia(mgs,lhl,3)**2 +     &
+     &            dab0(lhl,lr)*xdia(mgs,lhl,3)*xdia(mgs,lr,3) +    &
+     &            da0(lr)*xdia(mgs,lr,3)**2 )
 
+        chlacr(mgs) = min(chlacr(mgs),crmxd(mgs))
 
-      ! Rasmussen and Heymsfield say melt water remains on graupel up to 9 mm before shedding
+        IF ( lvol(lhl) .gt. 1 ) THEN
+         vhlacr(mgs) = rho0(mgs)*qhlacr(mgs)/raindn(mgs,lhl)
+        ENDIF
+        ENDIF
+      ENDIF
+      ENDIF
+      end do
 
 
-      IF ( lhl .gt. 1 .and. lhlw < 1 ) qhlmlr(mgs)  = max( qhlmlr(mgs),  Min( -qxmxd(mgs,lhl), -0.5*qx(mgs,lhl)/dtp ) )
 
 !
-      end do
+!
+!
+!
+!      if (ndebug .gt. 0 ) write(0,*) 'Collection: Cloud collects xxxxx'
 
-      endif  ! } not mixedphase
+      if (ndebug .gt. 0 ) write(0,*) 'Collection: cloud ice collects xxxx2'
 !
-      if ( ipconc .ge. 1 ) then
       do mgs = 1,ngscnt
-      cimlr(mgs)  = (cx(mgs,li)/(qx(mgs,li)+1.e-20))*qimlr(mgs)
-      IF ( .not. mixedphase ) THEN !{
-        IF ( xdia(mgs,ls,1) .gt. 1.e-6 .and. -qsmlr(mgs) .ge. 0.5*qxmin(ls) .and. ipconc .ge. 4 ) THEN 
-!         csmlr(mgs)  = rho0(mgs)*qsmlr(mgs)/(xv(mgs,ls)*rhosm)
-         csmlr(mgs)  = (cx(mgs,ls)/(qx(mgs,ls)))*qsmlr(mgs)
-        ELSEIF ( qx(mgs,ls) > qxmin(ls) ) THEN
-         csmlr(mgs)  = (cx(mgs,ls)/(qx(mgs,ls)))*qsmlr(mgs)
-        ENDIF
-
-
-!        IF ( xdia(mgs,lh,1) .gt. 1.e-6 .and. Abs(qhmlr(mgs)) .ge. qxmin(lh) ) THEN
-!          chmlr(mgs) = rho0(mgs)*qhmlr(mgs)/(pi*xdn(mgs,lh)*xdia(mgs,lh,1)**3)  ! out of hail
-!          chmlr(mgs) = Max( chmlr(mgs), -chmxd(mgs) )
-!        ELSE
-         IF ( ibinhmlr == 0 ) THEN
-           chmlr(mgs)  = (cx(mgs,lh)/(qx(mgs,lh)+1.e-20))*qhmlr(mgs)
-           IF ( imltshddmr == 3 .and. qhmlr(mgs) < -qxmin(lh) ) THEN
-            !  tmpdiam = (shedalp+alpha(mgs,lh))*xdia(mgs,lh,1)
-            !  
-            !  IF ( tmpdiam > sheddiam ) THEN ! let size get smaller until it reaches sheddiam
-            !   chmlr(mgs) = 0.0
-            !  ENDIF
-            
-            ! test to remove the part of the melting associated with large ice particles so they get smaller
+      qiacw(mgs) = 0.0
+      IF ( eiw(mgs) .gt. 0.0 ) THEN
 
-            tmp = 1. + alpha(mgs,lh)
-            i = Int(dgami*(tmp))
-            del = tmp - dgam*i
-            g1palp = gmoi(i) + (gmoi(i+1) - gmoi(i))*del*dgami
+       vt = Sqrt((vtxbar(mgs,li,1)-vtxbar(mgs,lc,1))**2 +    &
+     &            0.04*vtxbar(mgs,li,1)*vtxbar(mgs,lc,1) )
 
-            ratio = Min( maxratiolu,  mltdiam1/xdia(mgs,lh,1) )
+          qiacw(mgs) = 0.25*pi*eiw(mgs)*cx(mgs,li)*qx(mgs,lc)*vt*   &
+     &         (  da0(li)*xdia(mgs,li,3)**2 +     &
+     &            dab1(li,lc)*xdia(mgs,li,3)*xdia(mgs,lc,3) +    &
+     &            da1(lc)*xdia(mgs,lc,3)**2 )
 
-            x =  gamxinfdp(2. + alpha(mgs,lh), ratio)/g1palp
-            y =  gamxinfdp(2.5 + alpha(mgs,lh) + 0.5*bxh(mgs), ratio)/g1palp
+       qiacw(mgs) = Min( qiacw(mgs), qxmxd(mgs,lc) )
+      ENDIF
+      end do
 
-            hwvent1 =  0.78*x + y*hwventy(mgs) 
 
-            qhlmlr1 = min( fmlt1(mgs)*cx(mgs,lh)*hwvent1*xdia(mgs,lh,1), 0.0 )
+!
+!
+      if (ndebug .gt. 0 ) write(0,*) 'Collection: cloud ice collects xxxx8'
+!
+      do mgs = 1,ngscnt
+      qiacr(mgs) = 0.0
+      qiacrf(mgs) = 0.0
+      qiacrs(mgs) = 0.0
+      ciacrs(mgs) = 0.0
+      ciacr(mgs) = 0.0
+      ciacrf(mgs) = 0.0
+      viacrf(mgs) = 0.0
+      csplinter(mgs) = 0.0
+      qsplinter(mgs) = 0.0
+      csplinter2(mgs) = 0.0
+      qsplinter2(mgs) = 0.0
+      IF ( iacr .ge. 1 .and. eri(mgs) .gt. 0.0    &
+     &     .and. temg(mgs) .le. 270.15 ) THEN
+      IF ( ipconc .ge. 3 ) THEN
+       ni = 0.0
+         IF ( xdia(mgs,li,1) .ge. 10.e-6 ) THEN
+          ni = ni + cx(mgs,li)*Exp(- (40.e-6/xdia(mgs,li,1))**3 )
+         ENDIF
+       IF ( imurain == 1 ) THEN ! gamma of diameter
+           IF ( iacrsize /= 4 ) THEN
+           IF ( iacrsize .eq. 1 ) THEN
+             ratio = 500.e-6/xdia(mgs,lr,1)
+           ELSEIF ( iacrsize .eq. 2 ) THEN
+             ratio = 300.e-6/xdia(mgs,lr,1)
+           ELSEIF ( iacrsize .eq. 3 ) THEN
+             ratio = 40.e-6/xdia(mgs,lr,1)
+           ELSEIF ( iacrsize .eq. 5 ) THEN
+             ratio = 150.e-6/xdia(mgs,lr,1)
+           ENDIF
+           i = Min(nqiacrratio,Int(ratio*dqiacrratioinv))
+           j = Int(Max(0.0,Min(15.,alpha(mgs,lr)))*dqiacralphainv)
+           delx = ratio - float(i)*dqiacrratio
+           dely = alpha(mgs,lr) - float(j)*dqiacralpha
+           ip1 = Min( i+1, nqiacrratio )
+           jp1 = Min( j+1, nqiacralpha )
 
-            chmlr(mgs)  = (cx(mgs,lh)/(qx(mgs,lh)+1.e-20))*(qhmlr(mgs) - qhlmlr1)
+           ! interpolate along x, i.e., ratio
+           tmp1 = ciacrratio(i,j) + delx*dqiacrratioinv*(ciacrratio(ip1,j) - ciacrratio(i,j))
+           tmp2 = ciacrratio(i,jp1) + delx*dqiacrratioinv*(ciacrratio(ip1,jp1) - ciacrratio(i,jp1))
+           
+           ! interpolate along alpha
+           
+           nr = (tmp1 + dely*dqiacralphainv*(tmp2 - tmp1))*cx(mgs,lr)
+           
+           ! interpolate along x, i.e., ratio; 
+           tmp1 = qiacrratio(i,j) + delx*dqiacrratioinv*(qiacrratio(ip1,j) - qiacrratio(i,j))
+           tmp2 = qiacrratio(i,jp1) + delx*dqiacrratioinv*(qiacrratio(ip1,jp1) - qiacrratio(i,jp1))
+           
+           ! interpolate along alpha; 
            
+           qr = (tmp1 + dely*dqiacralphainv*(tmp2 - tmp1))*qx(mgs,lr)
            
+           ELSE ! iacrsize == 4 : use all
+             nr = cx(mgs,lr)
+             qr = qx(mgs,lr)
            ENDIF
-!           IF ( igs(mgs) == 40 ) THEN
-!             write(0,*) 'is this running? chmlr = ',kgs(mgs), chmlr(mgs)
-!           ENDIF
-         ENDIF
-!        ENDIF
 
+          vt = Sqrt((vtxbar(mgs,lr,1)-vtxbar(mgs,li,1))**2 +     &
+     &            0.04*vtxbar(mgs,lr,1)*vtxbar(mgs,li,1) )
 
+          qiacr(mgs) = 0.25*pi*eri(mgs)*ni*qr*vt*   &
+     &         (  da0(li)*xdia(mgs,li,3)**2 +     &
+     &            dab1lh(mgs,lr,li)*xdia(mgs,lh,3)*xdia(mgs,li,3) +    &
+     &            da1(lr)*xdia(mgs,lr,3)**2 ) 
+          
+          qiacr(mgs) = Min( qrmxd(mgs), qiacr(mgs) )
+          
 
-     IF ( chmlr(mgs) < 0.0 .and. ibinhmlr < 1) THEN ! { already done if ibinhmlr > 0
-      
-      IF ( ibinhmlr == 0 ) THEN
-      IF ( ihmlt .eq. 1 ) THEN
-        chmlrr(mgs)  = Min( chmlr(mgs), rho0(mgs)*qhmlr(mgs)/(xdn(mgs,lr)*vmlt) ) ! into rain 
-      ELSEIF ( ihmlt .eq. 2 ) THEN
-        IF ( xv(mgs,lh) .gt. 0.0 .and. chmlr(mgs) .lt. 0.0 ) THEN
-!        chmlrr(mgs) = Min( chmlr(mgs), rho0(mgs)*qhmlr(mgs)/(xdn(mgs,lh)*xv(mgs,lh)) ) ! into rain 
-! guess what, this is the same as chmlr: rho0*qhmlr/xmas(lh) --> cx/qx = rho0/xmas
-          IF(imltshddmr == 1) THEN
-            ! DTD: If Dmg < sheddiam, then assume complete melting into
-            ! maximal raindrop.  Between sheddiam and sheddiam0 mm, linearly ramp down to a 3 mm shed drop
-            tmp = -rho0(mgs)*qhmlr(mgs)/(Min(xdn(mgs,lr)*xvmx(lr), xdn(mgs,lh)*xv(mgs,lh))) ! Min of Maximum raindrop size/mean hail size
-            tmp2 = -rho0(mgs)*qhmlr(mgs)/(xdn(mgs,lr)*vr3mm) ! conc. change for a 3 mm mean drop diameter
-            
-            chmlrr(mgs) = tmp*(sheddiam0-xdia(mgs,lh,3))/(sheddiam0-sheddiam)+tmp2*(xdia(mgs,lh,3)-sheddiam)/(sheddiam0-sheddiam)  ! old version
-            chmlrr(mgs) = -Max(tmp,Min(tmp2,chmlrr(mgs)))
-          ELSEIF ( imltshddmr == 2 .or. imltshddmr == 3 ) THEN
-            ! 8/26/2015 ERM updated to use shedalp and tmpdiam
-            ! tmpdiam = (shedalp+alpha(mgs,lh))*xdia(mgs,lh,1)
-            chmlrr(mgs) =  rho0(mgs)*qhmlr(mgs)/(xdn(mgs,lr)*vshdgs(mgs,lh))  ! into rain 
-          ELSE ! Old method
-            chmlrr(mgs) =  rho0(mgs)*qhmlr(mgs)/(Min(xdn(mgs,lr)*xvmx(lr), xdn(mgs,lh)*xv(mgs,lh)))  ! into rain 
-          ENDIF
-        ELSE
-        chmlrr(mgs) = chmlr(mgs)
-        ENDIF
-      ELSEIF ( ihmlt .eq. 0 ) THEN
-        chmlrr(mgs) = chmlr(mgs)
-      ENDIF
+          ciacr(mgs) = 0.25*pi*eri(mgs)*ni*nr*vt*   &
+     &         (  da0(li)*xdia(mgs,li,3)**2 +     &
+     &            dab0lh(mgs,lr,li)*xdia(mgs,lr,3)*xdia(mgs,li,3) +    &
+     &            da0(lr)*xdia(mgs,lr,3)**2 ) 
 
-      ELSE ! ibinhmlr < 0? Already have an outer IF test for ibinhmlr < 1
-        chmlrr(mgs)  = Min( chmlrr(mgs), rho0(mgs)*qhmlr(mgs)/(xdn(mgs,lr)*xvmx(lr)) ) ! into rain 
+          ciacr(mgs) = Min( crmxd(mgs), ciacr(mgs) )
+          
+!          write(iunit,*) 'qiacr: ',cx(mgs,lr),nr,qx(mgs,lr),qr,qiacr(mgs),ciacr(mgs)
+!          write(iunit,*) 'xdia r li = ',xdia(mgs,lr,3),xdia(mgs,li,3),xdia(mgs,lr,1),xdia(mgs,li,1)
+!          write(iunit,*) 'i,j,ratio = ',i,j,ciacrratio(i,j),qiacrratio(i,j)
+!          write(iunit,*) 'ni,ci = ',ni,cx(mgs,li),qx(mgs,li)
+
+       ELSEIF ( imurain == 3 ) THEN ! gamma of volume
+!   Set nr to the number of drops greater than 40 microns.
+         arg = 1000.*xdia(mgs,lr,3)
+!         nr = cx(mgs,lr)*gaml02( arg )
+!        IF ( iacr .eq. 1 ) THEN
+         IF ( ipconc .ge. 3 ) THEN
+           IF ( iacrsize .eq. 1 ) THEN
+            nr = cx(mgs,lr)*gaml02d500( arg )  ! number greater than 500 microns in diameter
+           ELSEIF ( iacrsize .eq. 2 .or. iacrsize .eq. 5 ) THEN
+            nr = cx(mgs,lr)*gaml02d300( arg )  ! number greater than 300 microns in diameter
+           ELSEIF ( iacrsize .eq. 3 ) THEN
+            nr = cx(mgs,lr)*gaml02( arg ) ! number greater than 40 microns in diameter
+           ELSEIF ( iacrsize .eq. 4 ) THEN
+            nr = cx(mgs,lr) ! all raindrops
+           ENDIF
+         ELSE
+         nr = cx(mgs,lr)*gaml02( arg )
+         ENDIF
+!        ELSEIF ( iacr .eq. 2 ) THEN
+!         nr = cx(mgs,lr)*gaml02d300( arg )  ! number greater than 300 microns in diameter
+!        ENDIF
+       IF ( ni .gt. 0.0 .and. nr .gt. 0.0 ) THEN
+       d0 = xdia(mgs,lr,3)
+       qiacr(mgs) = xdn(mgs,lr)*rhoinv(mgs)*   &
+     &     (0.217239*(0.522295*(d0**5) +    &
+     &      49711.81*(d0**6) -    &
+     &      1.673016e7*(d0**7)+    &
+     &      2.404471e9*(d0**8) -    &
+     &      1.22872e11*(d0**9))*ni*nr)
+      qiacr(mgs) = Min( qrmxd(mgs), qiacr(mgs) )
+      ciacr(mgs) =   &
+     &   (0.217239*(0.2301947*(d0**2) +    &
+     &      15823.76*(d0**3) -    &
+     &      4.167685e6*(d0**4) +    &
+     &      4.920215e8*(d0**5) -    &
+     &      2.133344e10*(d0**6))*ni*nr)
+      ciacr(mgs) = Min( crmxd(mgs), ciacr(mgs) )
+!      ciacr(mgs) = qiacr(mgs)*cx(mgs,lr)/qx(mgs,lr)
       ENDIF
+      ENDIF
+       IF ( iacr .eq. 1 .or. iacr .eq. 3 ) THEN
+         ciacrf(mgs) = Min(ciacr(mgs), qiacr(mgs)/(1.0*vr1mm*1000.0)*rho0(mgs) ) ! *rzxh(mgs)
+       ELSEIF ( iacr .eq. 2 ) THEN
+         ciacrf(mgs) = ciacr(mgs) ! *rzxh(mgs)
+       ELSEIF ( iacr .eq. 4 ) THEN
+         ciacrf(mgs) = Min(ciacr(mgs), qiacr(mgs)/(1.0*vfrz*1000.0)*rho0(mgs) ) ! *rzxh(mgs)
+       ELSEIF ( iacr .eq. 5 ) THEN
+         ciacrf(mgs) = ciacr(mgs)*rzxh(mgs)
+       ENDIF 
+!      crfrzf(mgs) = Min(crfrz(mgs), qrfrz(mgs)/(bfnu*27.0*vr1mm*1000.0)*rho0(mgs) ) ! rzxh(mgs)*crfrz(mgs)
+       ENDIF
       
-      ENDIF ! } ( chmlr(mgs) < 0.0 .and. ibinhmlr < 1)
-
-      IF ( lhl .gt. 1 .and. lhlw < 1 .and. .not. mixedphase .and. qhlmlr(mgs) < 0.0 ) THEN ! {
       
-      IF ( ibinhlmlr == 0 ) THEN
-!      IF ( xdia(mgs,lhl,1) .gt. 1.e-6 .and. Abs(qhlmlr(mgs)) .ge. qxmin(lhl) ) THEN
-!      chlmlr(mgs) = rho0(mgs)*qhlmlr(mgs)/(pi*xdn(mgs,lhl)*xdia(mgs,lhl,1)**3)  ! out of hail
-!      chlmlr(mgs) = Max( chlmlr(mgs), -cxmxd(mgs,lhl) )
-!      ELSE
-      chlmlr(mgs)  = (cx(mgs,lhl)/(qx(mgs,lhl)+1.e-20))*qhlmlr(mgs)
-           IF ( imltshddmr == 3 .and. qhlmlr(mgs) < -qxmin(lhl) ) THEN
-!           IF ( .false. .and. imltshddmr == 3  ) THEN
-!              tmpdiam = (shedalp+alpha(mgs,lhl))*xdia(mgs,lhl,1)
-!              
-!              IF ( tmpdiam > sheddiam ) THEN ! let size get smaller until it reaches sheddiam
-!                chlmlr(mgs) = 0.0
-!              ENDIF
- 
-            ! test to remove the part of the melting associated with large ice particles so they get smaller
-!
-            tmp = 1. + alpha(mgs,lhl)
-            i = Int(dgami*(tmp))
-            del = tmp - dgam*i
-            g1palp = gmoi(i) + (gmoi(i+1) - gmoi(i))*del*dgami
-
-            ratio = Min( maxratiolu,  mltdiam1/xdia(mgs,lhl,1) )
-
-            x =  gamxinfdp(2. + alpha(mgs,lhl), ratio)/g1palp
-            y =  gamxinfdp(2.5 + alpha(mgs,lhl) + 0.5*bxhl(mgs), ratio)/g1palp
-
-            hwvent1 =  0.78*x + y*hlventy(mgs) 
-
-            qhlmlr1 = min( fmlt1(mgs)*cx(mgs,lhl)*hwvent1*xdia(mgs,lhl,1), 0.0 )
-
-            chlmlr(mgs)  = (cx(mgs,lhl)/(qx(mgs,lhl)+1.e-20))*Min(0.0, qhlmlr(mgs) - qhlmlr1)
-
-            ENDIF
-!      ENDIF
+      ELSE ! single-moment rain
+      qiacr(mgs) =    &
+     &  min(        &
+     &   ((0.25/gf4)*pi)*eri(mgs)*cx(mgs,li)*qx(mgs,lr)   &
+     &  *abs(vtxbar(mgs,lr,1)-vtxbar(mgs,li,1))   &
+     &  *(  gf6*gf1*xdia(mgs,lr,2)    &
+     &    + 2.0*gf5*gf2*xdia(mgs,lr,1)*xdia(mgs,li,1)    &
+     &    + gf4*gf3*xdia(mgs,li,2) )     &
+     &  , qrmxd(mgs))
       ENDIF
-      
-      IF ( ibinhlmlr == 0 ) THEN !{
-      IF ( ihmlt .eq. 1 ) THEN
-        chlmlrr(mgs)  = Min( chlmlr(mgs), rho0(mgs)*qhlmlr(mgs)/(xdn(mgs,lr)*vmlt) ) ! into rain 
-      ELSEIF ( ihmlt .eq. 2 ) THEN
-        IF ( xv(mgs,lhl) .gt. 0.0 .and. chlmlr(mgs) .lt. 0.0 ) THEN
-!        chlmlrr(mgs) = rho0(mgs)*qhlmlr(mgs)/(Min(xdn(mgs,lr)*xvmx(lr), xdn(mgs,lhl)*xv(mgs,lhl)))  ! into rain 
-!        chlmlrr(mgs) = Min( chlmlr(mgs), rho0(mgs)*qhlmlr(mgs)/(xdn(mgs,lhl)*xv(mgs,lhl)) ) ! into rain 
-          IF(imltshddmr == 1 ) THEN
-            tmp = -rho0(mgs)*qhlmlr(mgs)/(Min(xdn(mgs,lr)*xvmx(lr), xdn(mgs,lhl)*xv(mgs,lhl))) ! Min of Maximum raindrop size/mean hail size
-            tmp2 = -rho0(mgs)*qhlmlr(mgs)/(xdn(mgs,lr)*vr3mm) ! conc. change for a 3 mm mean drop diameter
-            chlmlrr(mgs) = tmp*(20.e-3-xdia(mgs,lhl,3))/(20.e-3-sheddiam)+tmp2*(xdia(mgs,lhl,3)-sheddiam)/(20.e-3-sheddiam)
-            chlmlrr(mgs) = -Max(tmp,Min(tmp2,chlmlrr(mgs)))
-          ELSEIF ( imltshddmr == 2 .or. imltshddmr == 3 ) THEN
-            ! 8/26/2015 ERM updated to use shedalp and tmpdiam
-            ! tmpdiam = (shedalp+alpha(mgs,lh))*xdia(mgs,lh,1)
-            chlmlrr(mgs) =  rho0(mgs)*qhlmlr(mgs)/(xdn(mgs,lr)*vshdgs(mgs,lhl))  ! into rain 
-          ELSE
-            chlmlrr(mgs) = rho0(mgs)*qhlmlr(mgs)/(Min(xdn(mgs,lr)*xvmx(lr), xdn(mgs,lhl)*xv(mgs,lhl)))  ! into rain 
-          ENDIF
+!      if ( temg(mgs) .gt. 268.15 ) then
+!      qiacr(mgs) = 0.0
+!      ciacr(mgs) = 0.0
+!      end if
+
+      IF ( ipconc .ge. 1 ) THEN
+        IF ( nsplinter .ge. 1000 ) THEN
+        ! Lawson et al. 2015 JAS
+         ! ave. diam of freezing drops in microns
+           IF ( qiacr(mgs)*dtp > qxmin(lh) .and. ciacr(mgs) > 1.e-3 ) THEN
+             tmpdiam = 1.e6*( 6.*qiacr(mgs)/(1000.*pi*ciacr(mgs) ) )**(1./3.) ! avg. diameter of newly frozen drops in microns
+             csplinter(mgs) = lawson_splinter_fac*tmpdiam**4*ciacr(mgs)
+           ENDIF
+        ELSEIF ( nsplinter .ge. 0 ) THEN
+          csplinter(mgs) = nsplinter*ciacr(mgs)
         ELSE
-        chlmlrr(mgs) = chlmlr(mgs)
+          csplinter(mgs) = -nsplinter*ciacrf(mgs)
         ENDIF
-      ELSEIF ( ihmlt .eq. 0 ) THEN
-        chlmlrr(mgs) = chlmlr(mgs)
+        qsplinter(mgs) = Min(0.1*qiacr(mgs), csplinter(mgs)*splintermass/rho0(mgs) ) ! makes splinters smaller if too much mass is taken from graupel
       ENDIF
+      
+      frach = 1.0
+           IF ( ibiggsnow == 2 .or. ibiggsnow == 3 ) THEN
+           IF ( ciacr(mgs) > qxmin(lh) ) THEN
+           xvfrz = rho0(mgs)*qiacr(mgs)/(ciacr(mgs)*900.) ! mean volume of frozen drops; 900. for frozen drop density
+           frach = 0.5 *(1. +  Tanh(0.2e12 *( xvfrz - 1.15*xvmn(lh))))
 
-      ELSE ! } { ibinhlmlr > 0
-        chlmlrr(mgs)  = Min( chlmlrr(mgs), rho0(mgs)*qhlmlr(mgs)/(xdn(mgs,lr)*xvmx(lr)) ) ! into rain 
-      ENDIF !}
-        
-      ENDIF ! }
+             qiacrs(mgs) = (1.-frach)*qiacr(mgs)
+             ciacrs(mgs) = (1.-frach)*ciacr(mgs) ! *rzxh(mgs)
+           
+           ENDIF
+           ENDIF
 
-      ENDIF ! }.not. mixedphase 
+      qiacrf(mgs) = frach*qiacr(mgs)
+      ciacrf(mgs) = frach*ciacrf(mgs)
 
-! 10ice versions:
-!      chmlr(mgs)  = (cx(mgs,lh)/(qx(mgs,lh)+1.e-20))*qhmlr(mgs)
-!      chmlrr(mgs) = chmlr(mgs)
+      IF ( lvol(lh) > 1 ) THEN
+         viacrf(mgs) = rho0(mgs)*qiacrf(mgs)/rhofrz
+      ENDIF
+      
       end do
-      end if
-
-!
-!  deposition/sublimation of ice
-!
-      DO mgs = 1,ngscnt
-
-      rwcap(mgs) = (0.5)*xdia(mgs,lr,1)
-      swcap(mgs) = (0.5)*xdia(mgs,ls,1)
-      hwcap(mgs) = (0.5)*xdia(mgs,lh,1)
-      IF ( lhl .gt. 1 ) hlcap(mgs) = (0.5)*xdia(mgs,lhl,1)
-
-      if ( qx(mgs,li).gt.qxmin(li) .and. xdia(mgs,li,1) .gt. 0.0 ) then
 !
-! from Cotton, 1972 (Part II)
 !
-        cilen(mgs)   = 0.4764*(xdia(mgs,li,1))**(0.958)
-        cval = xdia(mgs,li,1)
-        aval = cilen(mgs)
-        eval = Sqrt(1.0-(aval**2)/(cval**2))
-        fval = min(0.99,eval)
-        gval = alog( abs( (1.+fval)/(1.-fval) ) )
-        cicap(mgs) = cval*fval / gval
-      ELSE
-       cicap(mgs) = 0.0
-      end if
-      ENDDO
 !
 !
-      qhldsv(:) = 0.0
-
-      do mgs = 1,ngscnt
-      IF ( icond .eq. 1 .or. temg(mgs) .le. tfrh    &
-     &      .or. (qx(mgs,lr) .le. qxmin(lr) .and. qx(mgs,lc) .le. qxmin(lc)) ) THEN
-        qidsv(mgs) =   &
-     &    fvds(mgs)*cx(mgs,li)*civent(mgs)*cicap(mgs)
-        qsdsv(mgs) =   &
-     &    fvds(mgs)*cx(mgs,ls)*swvent(mgs)*swcap(mgs)
-!        IF ( ny .eq. 2 .and. igs(mgs) .eq. 302 .and. temg(mgs) .le. tfrh+10 .and. qx(mgs,lv) .gt. qis(mgs)
-!     :       .and. qx(mgs,li) .gt. qxmin(li) ) THEN
-!         write(0,*) 'qidsv = ',nstep,kgs(mgs),qidsv(mgs),temg(mgs)-tfrh,100.*(qx(mgs,lv)/qis(mgs) - 1.),1.e6*xdia(mgs,li,1),
-!     :            fvds(mgs),civent(mgs),cicap(mgs)
-!        ENDIF
-      ELSE
-        qidsv(mgs) = 0.0
-        qsdsv(mgs) = 0.0
-      ENDIF
-        qhdsv(mgs) =   &
-     &    fvds(mgs)*cx(mgs,lh)*hwvent(mgs)*hwcap(mgs)*depfac
 
-        IF ( lhl .gt. 1 ) qhldsv(mgs) = fvds(mgs)*cx(mgs,lhl)*hlvent(mgs)*hlcap(mgs)*depfac
-!
-!
-      end do
-!
+! snow aggregation here
+      if ( ipconc .ge. 4 ) then !
       do mgs = 1,ngscnt
-      qisbv(mgs) = 0.0
-      qssbv(mgs) = 0.0
-      qidpv(mgs) = 0.0
-      qsdpv(mgs) = 0.0
-      IF ( icond .eq. 1 .or. temg(mgs) .le. tfrh    &
-     &      .or. (qx(mgs,lr) .le. qxmin(lr) .and. qx(mgs,lc) .le. qxmin(lc)) ) THEN
-!        qisbv(mgs) = max( min(qidsv(mgs), 0.0), -qimxd(mgs) )
-!        qssbv(mgs) = max( min(qsdsv(mgs), 0.0), -qsmxd(mgs) )
-! erm 5/10/2007:
-        qisbv(mgs) = max( min(qidsv(mgs), 0.0),  Min( -qimxd(mgs), -0.7*qx(mgs,li)/dtp ) )
-        qssbv(mgs) = max( min(qsdsv(mgs), 0.0),  Min( -qsmxd(mgs), -0.7*qx(mgs,ls)/dtp ) )
-        qidpv(mgs) = Max(qidsv(mgs), 0.0)
-        qsdpv(mgs) = Max(qsdsv(mgs), 0.0)
-      ELSE
-        qisbv(mgs) = 0.0
-        qssbv(mgs) = 0.0
-        qidpv(mgs) = 0.0
-        qsdpv(mgs) = 0.0
-      ENDIF
-
-      qhsbv(mgs) = max( min(qhdsv(mgs), 0.0), -qhmxd(mgs) )
-
-
-      qhdpv(mgs) = Max(qhdsv(mgs), 0.0)
-
-      qhlsbv(mgs) = 0.0
-      qhldpv(mgs) = 0.0
-      IF ( lhl .gt. 1 ) THEN
-        qhlsbv(mgs) = max( min(qhldsv(mgs), 0.0), -qxmxd(mgs,lhl) )
-        qhldpv(mgs) = Max(qhldsv(mgs), 0.0)
-      ENDIF
-      
-      temp1 = qidpv(mgs) + qsdpv(mgs) + qhdpv(mgs) + qhldpv(mgs)
-
-      IF ( temp1 .gt. qvimxd(mgs) ) THEN
-
-      frac = qvimxd(mgs)/temp1
-
-      qidpv(mgs) = frac*qidpv(mgs)
-      qsdpv(mgs) = frac*qsdpv(mgs)
-      qhdpv(mgs) = frac*qhdpv(mgs)
-      qhldpv(mgs) = frac*qhldpv(mgs)
-
-!        IF ( ny .eq. 2 .and. igs(mgs) .eq. 302 .and. temg(mgs) .le. tfrh+10 .and. qx(mgs,lv) .gt. qis(mgs)
-!     :       .and. qx(mgs,li) .gt. qxmin(li) ) THEN
-!         write(0,*) 'qidpv,frac = ',kgs(mgs),qidpv(mgs),frac
-!        ENDIF
-
+      csacs(mgs) = 0.0
+      IF ( qx(mgs,ls) > qxmin(ls) .and. ess(mgs) .gt. 0.0 .and. xv(mgs,ls) < 0.25*xvmx(ls)*Max(1.,100./Min(100.,xdn(mgs,ls)))  ) THEN
+      csacs(mgs) = rvt*aa2*ess(mgs)*cx(mgs,ls)**2*xv(mgs,ls) *Min(1.,xdn(mgs,ls)/100. ) ! Min func tries to recalibrate for low diagnosed density 
+      csacs(mgs) = min(csacs(mgs),csmxd(mgs))
       ENDIF
-
       end do
+      end if
 !
 !
-      if ( ipconc .ge. 1 ) then
+      if (ndebug .gt. 0 ) write(0,*) 'ICEZVD_GS: conc 11'
+      if ( ipconc .ge. 2 .or. ipelec .ge. 9 ) then
       do mgs = 1,ngscnt
-      cssbv(mgs)  = (cx(mgs,ls)/(qx(mgs,ls)+1.e-20))*qssbv(mgs)
-      cisbv(mgs)  = (cx(mgs,li)/(qx(mgs,li)+1.e-20))*qisbv(mgs)
-      chsbv(mgs)  = (cx(mgs,lh)/(qx(mgs,lh)+1.e-20))*qhsbv(mgs)
-      IF ( lhl .gt. 1 ) chlsbv(mgs)  = (cx(mgs,lhl)/(qx(mgs,lhl)+1.e-20))*qhlsbv(mgs)
-      csdpv(mgs)  = 0.0 ! (cx(mgs,ls)/(qx(mgs,ls)+1.e-20))*qsdpv(mgs)
-      cidpv(mgs) =  0.0 ! (cx(mgs,li)/(qx(mgs,li)+1.e-20))*qidpv(mgs)
-      cisdpv(mgs) = 0.0
-      chdpv(mgs)  = 0.0 ! (cx(mgs,lh)/(qx(mgs,lh)+1.e-20))*qhdpv(mgs)
-      chldpv(mgs) = 0.0
+      ciacw(mgs) = 0.0
+      IF ( eiw(mgs) .gt. 0.0 ) THEN
+        ciacw(mgs) = qiacw(mgs)*rho0(mgs)/xmas(mgs,lc)
+        ciacw(mgs) = min(ciacw(mgs),ccmxd(mgs))
+      ENDIF
       end do
+
       end if
 
-!
-!  Aggregation or size conversion of small crystals to snow
-!
-      if (ndebug .gt. 0 ) write(0,*) 'conc 29a'
+      if (ndebug .gt. 0 ) write(0,*) 'ICEZVD_GS: conc 18'
+      if ( ipconc .ge. 2 .or. ipelec .ge. 1 ) then
       do mgs = 1,ngscnt
-      qscni(mgs) =  0.0
-      cscni(mgs) = 0.0
-      cscnis(mgs) = 0.0
-      if ( ipconc .ge. 4 .and. iscni .ge. 1 .and. qx(mgs,li) .gt. qxmin(li) ) then
-        IF ( iscni .eq. 1 ) THEN
-         qscni(mgs) =    &
-     &      pi*rho0(mgs)*((0.25)/(6.0))   &
-     &      *eii(mgs)*(qx(mgs,li)**2)*(xdia(mgs,li,2))   &
-     &      *vtxbar(mgs,li,1)/xmas(mgs,li)
-         cscni(mgs) = Min(cimxd(mgs),qscni(mgs)*rho0(mgs)/xmas(mgs,li))
-         cscnis(mgs) = 0.5*cscni(mgs)
-        ELSEIF ( iscni .eq. 2 .or. iscni .eq. 4 .or. iscni .eq. 5 ) THEN  ! Zeigler 1985/Zrnic 1993, sort of
-          IF ( iscni .ne. 5 .and. qidpv(mgs) .gt. 0.0 .and.  xdia(mgs,li,3) .ge. 100.e-6 ) THEN
-          ! convert larger crystals to snow
-!            IF ( xdia(mgs,ls,3) .gt. xdia(mgs,li,3) ) THEN
-!              qscni(mgs) = Max(0.1,xdia(mgs,li,3)/xdia(mgs,ls,3))*qidpv(mgs)
-! erm 9/5/08 changed max to min
-              qscni(mgs) = Min(0.5, xdia(mgs,li,3)/200.e-6)*qidpv(mgs)
-!            ELSE
-!              qscni(mgs) = 0.1*qidpv(mgs)
-!            ENDIF
-            cscni(mgs) = fscni*qscni(mgs)*rho0(mgs)/Max(xdn(mgs,ls)*xvmn(ls),xmas(mgs,li))
-!            cscni(mgs) = fscni*Min(cimxd(mgs),qscni(mgs)*rho0(mgs)/Max(xdn(mgs,ls)*xvmn(ls),xmas(mgs,li)))
-!            cscni(mgs) = Min(cimxd(mgs),qscni(mgs)*rho0(mgs)/xmas(mgs,li) )
-!            IF ( xdia(mgs,ls,3) .le. 200.e-6 ) THEN
-              cscnis(mgs) = cscni(mgs)
-!            ELSE
-!              cscnis(mgs) = 0.0
-!            ENDIF
-          ENDIF
-
-           IF ( iscni .ne. 4 ) THEN
-           ! crystal aggregation to become snow
-! erm 9/5/08 commented second line and added xv to 1st line (zrnic et al 1993)
-             tmp = ess(mgs)*rvt*aa2*cx(mgs,li)*cx(mgs,li)*xv(mgs,li)
-!     :         ((cinu + 2.)*xv(mgs,li)/(cinu + 1.) + xv(mgs,li))
-
-!           csacs(mgs) = rvt*aa2*ess(mgs)*cx(mgs,ls)**2*xv(mgs,ls)
+       cracw(mgs) = 0.0
+       cracr(mgs) = 0.0
+       ec0(mgs) = 1.e9
+      IF ( qx(mgs,lc) .gt. qxmin(lc) .and. qx(mgs,lr) .gt. qxmin(lr)    &
+     &      .and. qracw(mgs) .gt. 0.0 ) THEN
 
-             qscni(mgs) = qscni(mgs) + Min( qxmxd(mgs,li), 2.0*tmp*xmas(mgs,li)*rhoinv(mgs) )
-             cscni(mgs) = cscni(mgs) + Min( cxmxd(mgs,li), 2.0*tmp )
-             cscnis(mgs) = cscnis(mgs) + Min( cxmxd(mgs,li), tmp )
-           ENDIF
-        ELSEIF ( iscni .eq. 3 ) THEN ! LFO
-           qscni(mgs) = 0.001*eii(mgs)*max((qx(mgs,li)-1.e-3),0.0)
-           qscni(mgs) = min(qscni(mgs),qxmxd(mgs,li))
-           cscni(mgs) = qscni(mgs)*rho0(mgs)/xmas(mgs,li)
-           cscnis(mgs) = 0.5*cscni(mgs)
-!           write(iunit,*) 'qscni, qi = ',qscni(mgs),qx(mgs,li),igs(mgs),kgs(mgs)
+       IF ( ipconc .lt. 3 ) THEN
+        IF ( erw(mgs) .gt. 0.0 ) THEN
+        cracw(mgs) =   &
+     &   ((0.25)*pi)*erw(mgs)*(cx(mgs,lc) - ccwresv(mgs))*cx(mgs,lr)   &
+     &  *abs(vtxbar(mgs,lr,1)-vtxbar(mgs,lc,1))   &
+     &  *(  gf1*xdia(mgs,lc,2)   &
+     &    + 2.0*gf2*xdia(mgs,lc,1)*xdia(mgs,lr,1)   &
+     &    + gf3*xdia(mgs,lr,2) )
         ENDIF
+       ELSE ! IF ( ipconc .ge. 3 .and. 
+        IF ( dmrauto <= 0 .or.  rho0(mgs)*qx(mgs,lr) > 1.2*xl2p(mgs) ) THEN  !{
+        IF ( 0.5*xdia(mgs,lr,3) .gt. rh(mgs) ) THEN ! { .or. cx(mgs,lr) .gt. nh(mgs) 
+!        IF ( qx(mgs,lc) .gt. qxmin(lc) .and. qx(mgs,lr) .gt. qxmin(lr) ) THEN
+          IF ( 0.5*xdia(mgs,lr,3) .gt. rwradmn ) THEN ! r > 50.e-6 
+!          DM0CCC=A2*XNC*XNR*(XVC+XVR)                               ! (A11)
+!         NOTE: murain drops out, so same result for imurain = 1 and 3
+            cracw(mgs) = aa2*cx(mgs,lr)*(cx(mgs,lc) - ccwresv(mgs))*(xv(mgs,lc) + xv(mgs,lr))
+          ELSE
+            IF ( imurain == 3 ) THEN
+!          DM0CCC=A1*XNC*XNR*(((CNU+2.)/(CNU+1.))*XVC**2+((RNU+2.)/(RNU+1.))*XVR**2) ! (A13)
+            cracw(mgs) = aa1*cx(mgs,lr)*(cx(mgs,lc) - ccwresv(mgs))*   &
+     &          ((cnu + 2.)*xv(mgs,lc)**2/(cnu + 1.) +    &
+     &          (alpha(mgs,lr) + 2.)*xv(mgs,lr)**2/(alpha(mgs,lr) + 1.))
+            ELSE ! imurain == 1 USE CP00 for rain DSD in diameter
+            cracw(mgs) = aa1*cx(mgs,lr)*(cx(mgs,lc) - ccwresv(mgs))*   &
+     &          ((cnu + 2.)*xv(mgs,lc)**2/(cnu + 1.) +    &
+     &          (alpha(mgs,lr) + 6.)*(alpha(mgs,lr) + 5.)*(alpha(mgs,lr) + 4.)*xv(mgs,lr)**2/  &
+     &             ((alpha(mgs,lr) + 3.)*(alpha(mgs,lr) + 2.)*(alpha(mgs,lr) + 1.)) )
+            ENDIF ! imurain
+          ENDIF
+        ENDIF ! } rh
+        ENDIF ! } dmrauto
+       ENDIF ! ipconc
+      ENDIF ! qc > qcmin & qr > qrmin
+        
+! Rain self collection (cracr) and break-up (factor of ec0)
+!
+!       
+        ec0(mgs) = 2.e9
+        IF ( qx(mgs,lr) .gt. qxmin(lr) ) THEN
+        rwrad = 0.5*xdia(mgs,lr,3)
+        IF ( xdia(mgs,lr,3) .gt. 2.0e-3 ) THEN
+          ec0(mgs) = 0.0
+          cracr(mgs) = 0.0
+        ELSE
+         IF ( dmrauto <= 0 .or.  rho0(mgs)*qx(mgs,lr) > 1.2*xl2p(mgs) ) THEN 
+          IF ( xdia(mgs,lr,3) .lt. 6.1e-4 ) THEN
+            ec0(mgs) = 1.0
+          ELSE
+            ec0(mgs) = Exp(-50.0*(50.0*(xdia(mgs,lr,3) - 6.0e-4)))
+          ENDIF
+          
 
-      ELSEIF ( ipconc < 4 ) THEN ! LFO
-           IF ( lwsm6 ) THEN
-             qimax = rhoinv(mgs)*roqimax
-             qscni(mgs) = Min(0.90*qx(mgs,li), Max( 0.0, (qx(mgs,li) - qimax)*dtpinv ) )
-           ELSE
-             qscni(mgs) = 0.001*eii(mgs)*max((qx(mgs,li)-1.e-3),0.0)
-             qscni(mgs) = min(qscni(mgs),qxmxd(mgs,li))
-           ENDIF
-      else ! 10-ice version
-      if ( iscni > 0 .and. qx(mgs,li) .gt. qxmin(li) ) then
-          qscni(mgs) =    &
-     &    pi*rho0(mgs)*((0.25)/(6.0))   &
-     &    *eii(mgs)*(qx(mgs,li)**2)*(xdia(mgs,li,2))   &
-     &    *vtxbar(mgs,li,1)/xmas(mgs,li)
-         cscni(mgs) = Min(cimxd(mgs),qscni(mgs)*rho0(mgs)/xmas(mgs,li))
-        end if
+          IF ( rwrad .ge. 50.e-6 ) THEN
+              cracr(mgs) = ec0(mgs)*aa2*cx(mgs,lr)**2*xv(mgs,lr)
+          ELSE
+            IF ( imurain == 3 ) THEN
+             cracr(mgs) = ec0(mgs)*aa1*(cx(mgs,lr)*xv(mgs,lr))**2*   &
+     &                   (alpha(mgs,lr) + 2.)/(alpha(mgs,lr) + 1.)
+            ELSE ! imurain == 1
+             cracr(mgs) = ec0(mgs)*aa1*(cx(mgs,lr)*xv(mgs,lr))**2*   &
+     &                   (alpha(mgs,lr) + 6.)*(alpha(mgs,lr) + 5.)*(alpha(mgs,lr) + 4.)/ &
+     &                  ((alpha(mgs,lr) + 3.)*(alpha(mgs,lr) + 2.)*(alpha(mgs,lr) + 1.))
+              
+            ENDIF
+          ENDIF
+!          cracr(mgs) = Min(cracr(mgs),crmxd(mgs))
+         ENDIF
+        ENDIF
+        ENDIF
 
-      end if
+!      cracw(mgs) = min(cracw(mgs),cxmxd(mgs,lc)) 
       end do
-
-!
-!
-!  compute dry growth rate of snow, graupel, and hail
+      end if
 !
-      do mgs = 1,ngscnt
 !
-      qsdry(mgs)  = qsacr(mgs)    + qsacw(mgs)   &
-     &            + qsaci(mgs)
 !
-      qhdry(mgs)  = qhaci(mgs)    + qhacs(mgs)   &
-     &            + qhacr(mgs)   &
-     &            + qhacw(mgs)
+!  Graupel
 !
-      qhldry(mgs) = 0.0
-      IF ( lhl .gt. 1 ) THEN
-      qhldry(mgs)  = qhlaci(mgs)    + qhlacs(mgs)   &
-     &               + qhlacr(mgs)   &
-     &               + qhlacw(mgs)
+      if (ndebug .gt. 0 ) write(0,*) 'ICEZVD_GS: conc 22ii'
+      chacw(:) = 0.0
+      if ( ipconc .ge. 1 .or. ipelec .ge. 1 ) then
+      do mgs = 1,ngscnt
+
+      IF ( ipconc .ge. 5 ) THEN
+       IF ( qhacw(mgs) .gt. 0.0 .and. xmas(mgs,lc) .gt. 0.0 ) THEN
+
+!  This is the explict version of chacw, which turns out to be very close to the
+!  approximation that the droplet size does not change, to within a few percent.
+!  This may _not_ be the case for cnu other than zero!
+!          chacw(mgs) = (ehw(mgs)*cx(mgs,lc)*cx(mgs,lh)*(pi/4.)*
+!     :    abs(vtxbar(mgs,lh,1)-vtxbar(mgs,lc,1))*
+!     :    (2.0*xdia(mgs,lh,1)*(xdia(mgs,lh,1) +
+!     :         xdia(mgs,lc,1)*gf43rds) +
+!     :      xdia(mgs,lc,2)*gf53rds))
+
+!          chacw(mgs) = Min( chacw(mgs), 0.6*cx(mgs,lc)*dtpinv )
+
+!        chacw(mgs) = qhacw(mgs)*rho0(mgs)/xmas(mgs,lc)
+        chacw(mgs) = qhacw(mgs)*rho0(mgs)/xmascw(mgs)
+!        chacw(mgs) = min(chacw(mgs),cxmxd(mgs,lc))
+        chacw(mgs) = Min( chacw(mgs), 0.5*(cx(mgs,lc) - ccwresv(mgs))*dtpinv )
+       ELSE
+        qhacw(mgs) = 0.0
+       ENDIF
+      ELSE
+      ! single-moment
+      chacw(mgs) =   &
+     &   ((0.25)*pi)*ehw(mgs)*cx(mgs,lc)*cx(mgs,lh)   &
+     &  *abs(vtxbar(mgs,lh,1)-vtxbar(mgs,lc,1))   &
+     &  *(  gf1*xdia(mgs,lc,2)   &
+     &    + 2.0*gf2*xdia(mgs,lc,1)*xdia(mgs,lh,1)   &
+     &    + gf3*xdia(mgs,lh,2) )
+      chacw(mgs) = min(chacw(mgs),0.5*cx(mgs,lc)*dtpinv)
+!      chacw(mgs) = min(chacw(mgs),cxmxd(mgs,lc))
+!      chacw(mgs) = min(chacw(mgs),ccmxd(mgs))
       ENDIF
       end do
+      end if
 !
-!  set wet growth and shedding
-!
+      if (ndebug .gt. 0 ) write(0,*) 'ICEZVD_GS: conc 22kk'
+      chaci(:) = 0.0
+      if ( ipconc .ge. 1 .or. ipelec .ge. 1 ) then
       do mgs = 1,ngscnt
-      
-      IF ( temg(mgs) < tfr ) THEN
-!
-!      qswet(mgs) =
-!     >  ( xdia(mgs,ls,1)*swvent(mgs)*cx(mgs,ls)*fwet1(mgs)
-!     >  + fwet2(mgs)*(qsaci(mgs)+qsacir(mgs)
-!     >               +qsacip(mgs)) )
-!      qswet(mgs) = max( 0.0, qswet(mgs))
-!
-!      IF ( dnu(lh) .ne. 0. ) THEN
-!        qhwet(mgs) = qhdry(mgs)
-!      ELSE
-        qhwet(mgs) =   &
-     &    ( xdia(mgs,lh,1)*hwvent(mgs)*cx(mgs,lh)*fwet1(mgs)   &
-     &   + fwet2(mgs)*(qhaci(mgs) + qhacs(mgs)) )
-       qhwet(mgs) = max( 0.0, qhwet(mgs))
-!      ENDIF
+      IF ( ehi(mgs) .gt. 0.0 .or. ( ehiclsn(mgs) > 0.0 .and. ipelec > 0 )) THEN
+       IF ( ipconc .ge. 5 ) THEN
+
+       vt = Sqrt((vtxbar(mgs,lh,1)-vtxbar(mgs,li,1))**2 +    &
+     &            0.04*vtxbar(mgs,lh,1)*vtxbar(mgs,li,1) )
+
+          chaci0(mgs) = 0.25*pi*ehiclsn(mgs)*cx(mgs,lh)*cx(mgs,li)*vt*   &
+     &         (  da0lh(mgs)*xdia(mgs,lh,3)**2 +     &
+     &            dab0lh(mgs,li,lh)*xdia(mgs,lh,3)*xdia(mgs,li,3) +    &
+     &            da0(li)*xdia(mgs,li,3)**2 )
 
-       qhlwet(mgs) = 0.0
-       IF ( lhl .gt. 1 ) THEN
-       qhlwet(mgs) =   &
-     &    ( xdia(mgs,lhl,1)*hlvent(mgs)*cx(mgs,lhl)*fwet1(mgs)   &
-     &   + fwet2(mgs)*(qhlaci(mgs) + qhlacs(mgs)) )
-       qhlwet(mgs) = max( 0.0, qhlwet(mgs))
-       ENDIF
-       
        ELSE
-       
-        qhwet(mgs) = qhdry(mgs)
-        qhlwet(mgs) = qhldry(mgs)
-        
-       ENDIF
-!
-!      qhlwet(mgs) = qhldry(mgs)
+        chaci0(mgs) =   &
+     &   ((0.25)*pi)*ehiclsn(mgs)*cx(mgs,li)*cx(mgs,lh)   &
+     &  *abs(vtxbar(mgs,lh,1)-vtxbar(mgs,li,1))   &
+     &  *(  gf1*xdia(mgs,li,2)   &
+     &    + 2.0*gf2*xdia(mgs,li,1)*xdia(mgs,lh,1)   &
+     &    + gf3*xdia(mgs,lh,2) )
+        ENDIF
 
+        chaci(mgs) = min(ehi(mgs)*chaci0(mgs),cimxd(mgs))
+       ENDIF
       end do
-!
-! shedding rate
-!
-      qsshr(:)  =  0.0
-      qhshr(:)  =  0.0
-      qhlshr(:) =  0.0
-      qhshh(:)  =  0.0
-      csshr(:)  =  0.0
-      chshr(:)  =  0.0
-      chlshr(:)  =  0.0
-      chshrr(:)  =  0.0
-      chlshrr(:)  =  0.0
-      vhshdr(:)  = 0.0
-      vhlshdr(:)  = 0.0
-      wetsfc(:)  = .false.
-      wetgrowth(:)  = .false.
-      wetsfchl(:)  = .false.
-      wetgrowthhl(:)  = .false.
+      end if
 
 
+      chacis(:) = 0.0
+      if ( lis > 1 .and. ipconc .ge. 5 .or. ipelec .ge. 1 ) then
       do mgs = 1,ngscnt
-!
-!
-!
-      qhshr(mgs)  = Min( 0.0, qhwet(mgs) - qhdry(mgs) )  ! water that freezes should never be more than what sheds
-      
+      IF ( ehis(mgs) .gt. 0.0 .or. ( ehisclsn(mgs) > 0.0 .and. ipelec > 0 )) THEN
 
+       vt = Sqrt((vtxbar(mgs,lh,1)-vtxbar(mgs,lis,1))**2 +    &
+     &            0.04*vtxbar(mgs,lh,1)*vtxbar(mgs,lis,1) )
 
-      qhlshr(mgs)  =  Min( 0.0, qhlwet(mgs) - qhldry(mgs) )
+          chacis0(mgs) = 0.25*pi*ehisclsn(mgs)*cx(mgs,lh)*cx(mgs,lis)*vt*   &
+     &         (  da0lh(mgs)*xdia(mgs,lh,3)**2 +     &
+     &            dab0lh(mgs,lis,lh)*xdia(mgs,lh,3)*xdia(mgs,lis,3) +    &
+     &            da0(lis)*xdia(mgs,lis,3)**2 )
 
-!
-! limit wet growth to only higher density particles
-!
-      qsshr(mgs)  =  0.0
-!
-!
-!  no shedding for temperatures < 243.15 
-!
-      if ( temg(mgs) .lt. 243.15 ) then
-       qsshr(mgs)  =  0.0
-       qhshr(mgs)  =  0.0
-       qhlshr(mgs) =  0.0
-       vhshdr(mgs)  = 0.0
-       vhlshdr(mgs)  = 0.0
-       wetsfc(mgs) = .false.
-       wetgrowth(mgs) = .false.
-       wetsfchl(mgs) = .false.
-       wetgrowthhl(mgs) = .false.
+
+        chacis(mgs) = min(ehis(mgs)*chacis0(mgs),cxmxd(mgs,lis))
+       ENDIF
+      end do
       end if
 !
-!  shed all at temperatures > 273.15
 !
-      if ( temg(mgs) .gt. tfr ) then
+      if (ndebug .gt. 0 ) write(0,*) 'ICEZVD_GS: conc 22nn'
+      chacs(:) = 0.0
+      if ( ipconc .ge. 1 .or. ipelec .ge. 1 ) then
+      do mgs = 1,ngscnt
+      IF ( ehs(mgs) .gt. 0 ) THEN
+       IF ( ipconc .ge. 5 .or. ( ehsclsn(mgs) > 0.0 .and. ipelec > 0 ) ) THEN
 
-       qsshr(mgs)   = -qsdry(mgs)
-       qhlshr(mgs)  = -qhldry(mgs)
+       vt = Sqrt((vtxbar(mgs,lh,1)-vtxbar(mgs,ls,1))**2 +    &
+     &            0.04*vtxbar(mgs,lh,1)*vtxbar(mgs,ls,1) )
 
-       qhshr(mgs)  = -qhdry(mgs)
-       vhshdr(mgs)  = -vhacw(mgs) - vhacr(mgs)
-       vhlshdr(mgs)  = -vhlacw(mgs)
-       qhwet(mgs)  = 0.0
-       qhlwet(mgs) = 0.0
+          chacs0(mgs) = 0.25*pi*ehsclsn(mgs)*cx(mgs,lh)*cx(mgs,ls)*vt*   &
+     &         (  da0lh(mgs)*xdia(mgs,lh,3)**2 +     &
+     &            dab0lh(mgs,ls,lh)*xdia(mgs,lh,3)*xdia(mgs,ls,3) +    &
+     &            da0(ls)*xdia(mgs,ls,3)**2 )
+
+       ELSE
+      chacs0(mgs) =   &
+     &   ((0.25)*pi)*ehsclsn(mgs)*cx(mgs,ls)*cx(mgs,lh)   &
+     &  *abs(vtxbar(mgs,lh,1)-vtxbar(mgs,ls,1))   &
+     &  *(  gf3*gf1*xdia(mgs,ls,2)   &
+     &    + 2.0*gf2*gf2*xdia(mgs,ls,1)*xdia(mgs,lh,1)   &
+     &    + gf1*gf3*xdia(mgs,lh,2) )
+      ENDIF
+      chacs(mgs) = min(ehs(mgs)*chacs0(mgs),csmxd(mgs))
+      ENDIF
+      end do
       end if
+
+
 !
-!      if (qhshr(mgs) .lt. 0.0 .and. temg(mgs) < tfr  ) THEN
-        wetsfc(mgs) =  (qhshr(mgs) .lt. 0.0 .and. temg(mgs) < tfr ) .or. ( qhmlr(mgs) < -qxmin(lh) .and.  temg(mgs) > tfr )
-        wetgrowth(mgs) = (qhshr(mgs) .lt. 0.0 .and. temg(mgs) < tfr )
-!      ENDIF
+!
+!  Hail
+!
+      if (ndebug .gt. 0 ) write(0,*) 'ICEZVD_GS: conc 22ii'
+      chlacw(:) = 0.0
+      if ( ipconc .ge. 1 .or. ipelec .ge. 1 ) then
+      do mgs = 1,ngscnt
 
-      if (qhlshr(mgs) .lt. 0.0 .and. temg(mgs) < tfr ) THEN
-        wetsfchl(mgs) = (qhlshr(mgs) .lt. 0.0 .and. temg(mgs) < tfr ) .or. ( qhlmlr(mgs) < -qxmin(lhl) .and.  temg(mgs) > tfr )
-        wetgrowthhl(mgs) = (qhlshr(mgs) .lt. 0.0 .and. temg(mgs) < tfr )
-      ENDIF
+      IF ( lhl .gt. 1 .and. ipconc .ge. 5 ) THEN
+       IF ( qhlacw(mgs) .gt. 0.0 .and. xmas(mgs,lc) .gt. 0.0 ) THEN
+
+!  This is the explict version of chacw, which turns out to be very close to the
+!  approximation that the droplet size does not change, to within a few percent.
+!  This may _not_ be the case for cnu other than zero!
+!          chlacw(mgs) = (ehlw(mgs)*cx(mgs,lc)*cx(mgs,lhl)*(pi/4.)*
+!     :    abs(vtxbar(mgs,lhl,1)-vtxbar(mgs,lc,1))*
+!     :    (2.0*xdia(mgs,lhl,1)*(xdia(mgs,lhl,1) +
+!     :         xdia(mgs,lc,1)*gf43rds) +
+!     :      xdia(mgs,lc,2)*gf53rds))
 
+!          chlacw(mgs) = Min( chlacw(mgs), 0.6*cx(mgs,lc)*dtpinv )
+
+!        chlacw(mgs) = qhlacw(mgs)*rho0(mgs)/xmas(mgs,lc)
+        chlacw(mgs) = qhlacw(mgs)*rho0(mgs)/xmascw(mgs)
+!        chlacw(mgs) = min(chlacw(mgs),cxmxd(mgs,lc))
+        chlacw(mgs) = Min( chlacw(mgs), 0.5*cx(mgs,lc)*dtpinv )
+       ELSE
+        qhlacw(mgs) = 0.0
+       ENDIF
+!      ELSE
+!      chlacw(mgs) =
+!     >   ((0.25)*pi)*ehlw(mgs)*cx(mgs,lc)*cx(mgs,lhl)
+!     >  *abs(vtxbar(mgs,lhl,1)-vtxbar(mgs,lc,1))
+!     >  *(  gf1*xdia(mgs,lc,2)
+!     >    + 2.0*gf2*xdia(mgs,lc,1)*xdia(mgs,lhl,1)
+!     >    + gf3*xdia(mgs,lhl,2) )
+!      chlacw(mgs) = min(chlacw(mgs),0.5*cx(mgs,lc)*dtpinv)
+!      chlacw(mgs) = min(chlacw(mgs),cxmxd(mgs,lc))
+!      chlacw(mgs) = min(chlacw(mgs),ccmxd(mgs))
+      ENDIF
       end do
+      end if
 !
-      if ( ipconc .ge. 1 ) then
+      if (ndebug .gt. 0 ) write(0,*) 'ICEZVD_GS: conc 22kk'
+      chlaci(:) = 0.0
+      chlaci0(:) = 0.0
+      if ( ipconc .ge. 1 .or. ipelec .ge. 1 ) then
       do mgs = 1,ngscnt
-      csshr(mgs)  = 0.0 ! (cx(mgs,ls)/(qx(mgs,ls)+1.e-20))*Min(0.0,qsshr(mgs))
-      ! why is there a number loss for graupel for shedding? NEED TO CHECK THIS
-       ! chshr(mgs)  = (cx(mgs,lh)/(qx(mgs,lh)+1.e-20))*qhshr(mgs)
-       ! IF ( temg(mgs) < tfr ) chshr(mgs) = 0.0 ! no change to graupel number concentration for wet-growth shedding
-       
-       chshr(mgs) = 0.0 ! no change to graupel number concentration for wet-growth shedding
-       
-      !   tmpdiam = (shedalp+alpha(mgs,lh))*xdia(mgs,lh,1)
-        ! Base the drop size on the shedding regime
-            ! 8/26/2015 ERM updated to use shedalp and tmpdiam
-            ! tmpdiam = (shedalp+alpha(mgs,lh))*xdia(mgs,lh,1)
-            chshrr(mgs) =  rho0(mgs)*qhshr(mgs)/(xdn(mgs,lr)*vshdgs(mgs,lh))  ! into rain 
-      
-      IF ( .false. ) THEN
-      IF ( temg(mgs) < tfr ) THEN
-         chshrr(mgs) = Min( chshr(mgs), rho0(mgs)*qhshr(mgs)/(xdn0(lr)*vshd) ) ! maximum of dshd from shedding
-      ELSE
-        IF(imltshddmr > 0) THEN
-          ! DTD: If Dmg < sheddiam, then assume complete melting into
-          ! maximal raindrop.  Between sheddiam and sheddiam0, linearly ramp down to a 3 mm shed drop
-          tmp = -Min( chshr(mgs), rho0(mgs)*qhshr(mgs)/(xdn(mgs,lr)*xvmx(lr)) ) ! limit to maximum size allowed for rain
-          tmp2 = -rho0(mgs)*qhshr(mgs)/(xdn(mgs,lr)*vr3mm) ! conc. change for a 3 mm mean drop diameter
-          chshrr(mgs) = tmp*(sheddiam0-xdia(mgs,lh,3))/(sheddiam0-sheddiam)+tmp2*(xdia(mgs,lh,3)-sheddiam)/(sheddiam0-sheddiam)
-          chshrr(mgs) = -Max(tmp,Min(tmp2,chshrr(mgs)))
-        ELSE
-         chshrr(mgs) = Min( chshr(mgs), rho0(mgs)*qhshr(mgs)/(xdn(mgs,lr)*Min(vr4p5mm,xvmx(lr))) ) ! limit to maximum size allowed for rain or 4.5mm diameter, whichever is smaller
-!        chlmlrr(mgs) = rho0(mgs)*qhlmlr(mgs)/(Min(xdn(mgs,lr)*xvmx(lr), xdn(mgs,lhl)*xv(mgs,lhl)))  ! into rain 
-        ENDIF
-      ENDIF
-      ENDIF
-      
-      
-      chlshr(mgs) = 0.0
-      chlshrr(mgs) = 0.0
-      IF ( lhl .gt. 1 ) THEN 
-!         chlshr(mgs)  = (cx(mgs,lhl)/(qx(mgs,lhl)+1.e-20))*qhlshr(mgs)
-
+      IF ( lhl .gt. 1 .and. ( ehli(mgs) .gt. 0.0 .or. (ipelec > 0 .and. ehliclsn(mgs) > 0.0) )  ) THEN
+       IF ( ipconc .ge. 5 ) THEN
 
-       chlshr(mgs) = 0.0 ! no change to hail number concentration for wet-growth shedding
-       
-      !   tmpdiam = (shedalp+alpha(mgs,lh))*xdia(mgs,lh,1)
-        ! Base the drop size on the shedding regime
-            ! 8/26/2015 ERM updated to use shedalp and tmpdiam
-            ! tmpdiam = (shedalp+alpha(mgs,lh))*xdia(mgs,lh,1)
-            chlshrr(mgs) =  rho0(mgs)*qhlshr(mgs)/(xdn(mgs,lr)*vshdgs(mgs,lhl))  ! into rain 
+       vt = Sqrt((vtxbar(mgs,lhl,1)-vtxbar(mgs,li,1))**2 +    &
+     &            0.04*vtxbar(mgs,lhl,1)*vtxbar(mgs,li,1) )
 
+          chlaci0(mgs) = 0.25*pi*ehliclsn(mgs)*cx(mgs,lhl)*cx(mgs,li)*vt*   &
+     &         (  da0lhl(mgs)*xdia(mgs,lhl,3)**2 +     &
+     &            dab0(lhl,li)*xdia(mgs,lhl,3)*xdia(mgs,li,3) +    &
+     &            da0(li)*xdia(mgs,li,3)**2 )
 
-      IF ( .false. ) THEN
-        IF ( temg(mgs) < tfr ) THEN
-          chlshrr(mgs) = Min( chlshr(mgs), rho0(mgs)*qhlshr(mgs)/(xdn0(lr)*vshd) ) ! maximum of dshd from shedding
-!         chlshrr(mgs) = Min( chlshr(mgs), rho0(mgs)*qhlshr(mgs)/(xdn0(lr)*vr1mm) ) ! maximum of 1mm drops from shedding
-        ELSE
-          IF(imltshddmr > 0) THEN
-            ! DTD: If Dmg < sheddiam, then assume complete melting into
-            ! maximal raindrop.  Between sheddiam and sheddiam0, linearly ramp down to a 3 mm shed drop
-            tmp = -Min( chlshr(mgs), rho0(mgs)*qhlshr(mgs)/(xdn(mgs,lr)*xvmx(lr)) ) ! limit to maximum size allowed for rain
-            tmp2 = -rho0(mgs)*qhlshr(mgs)/(xdn(mgs,lr)*vr3mm) ! conc. change for a 3 mm mean drop diameter
-            chlshrr(mgs) = tmp*(sheddiam0-xdia(mgs,lhl,3))/(sheddiam0-sheddiam)+tmp2*(xdia(mgs,lhl,3)-sheddiam)/(sheddiam0-sheddiam)
-            chlshrr(mgs) = -Max(tmp,Min(tmp2,chlshrr(mgs)))
-          ELSE
-           chlshrr(mgs) = Min( chlshr(mgs), rho0(mgs)*qhlshr(mgs)/(xdn(mgs,lr)*Min(vr4p5mm,xvmx(lr))) ) ! limit to 4.5mm diameter or maximum size allowed for rain, whichever is smaller
-!        chlmlrr(mgs) = rho0(mgs)*qhlmlr(mgs)/(Min(xdn(mgs,lr)*xvmx(lr), xdn(mgs,lhl)*xv(mgs,lhl)))  ! into rain 
-          ENDIF
+!       ELSE
+!        chlaci(mgs) =
+!     >   ((0.25)*pi)*ehli(mgs)*cx(mgs,li)*cx(mgs,lhl)
+!     >  *abs(vtxbar(mgs,lhl,1)-vtxbar(mgs,li,1))
+!     >  *(  gf1*xdia(mgs,li,2)
+!     >    + 2.0*gf2*xdia(mgs,li,1)*xdia(mgs,lhl,1)
+!     >    + gf3*xdia(mgs,lhl,2) )
         ENDIF
-      ENDIF
 
-      ENDIF ! ( lhl > 1 )
-      
+        chlaci(mgs) = min(ehli(mgs)*chlaci0(mgs),cimxd(mgs))
+       ENDIF
       end do
       end if
 
 
+      IF ( lis > 1 .and. ipconc .ge. 5) THEN
+      
+      if (ndebug .gt. 0 ) write(0,*) 'ICEZVD_GS: conc 22kk'
+      chlacis(:) = 0.0
+      chlacis0(:) = 0.0
+       do mgs = 1,ngscnt
+      IF ( lhl .gt. 1 .and. ( ehlis(mgs) .gt. 0.0 .or. (ipelec > 0 .and. ehlisclsn(mgs) > 0.0) )  ) THEN
 
-!
-!  final decisions
-!
-      do mgs = 1,ngscnt
-!
-!  Snow
-!
-      if ( qsshr(mgs) .lt. 0.0 ) then
-      qsdpv(mgs) = 0.0
-      qssbv(mgs) = 0.0
-      else
-      qsshr(mgs) = 0.0
-      end if
-!
-!     if ( qsdry(mgs) .lt. qswet(mgs) ) then
-!     qswet(mgs) = 0.0
-!     else
-!     qsdry(mgs) = 0.0
-!     end if
-!
+       vt = Sqrt((vtxbar(mgs,lhl,1)-vtxbar(mgs,lis,1))**2 +    &
+     &            0.04*vtxbar(mgs,lhl,1)*vtxbar(mgs,lis,1) )
 
-! zero the shedding rates when wet snow/graupel included.
-! shedding of wet snow/graupel is calculated after summing other sources/sinks.
-      if (mixedphase) then
-        qsshr(mgs) = 0.0
-        qhshr(mgs) = 0.0
-        csshr(mgs) = 0.0
-        chshr(mgs) = 0.0
-        chshrr(mgs) = 0.0
-        vhshdr(mgs) = 0.0
-        IF ( lhlw > 1 ) THEN
-          qhlshr(mgs) = 0.0
-          vhlshdr(mgs) = 0.0
-          chlshr(mgs) = 0.0
-          chlshrr(mgs) = 0.0
-        ENDIF
-      end if
+          chlacis0(mgs) = 0.25*pi*ehlisclsn(mgs)*cx(mgs,lhl)*cx(mgs,lis)*vt*   &
+     &         (  da0lhl(mgs)*xdia(mgs,lhl,3)**2 +     &
+     &            dab0(lhl,lis)*xdia(mgs,lhl,3)*xdia(mgs,lis,3) +    &
+     &            da0(lis)*xdia(mgs,lis,3)**2 )
+
+
+        chlacis(mgs) = min(ehlis(mgs)*chlacis0(mgs),cxmxd(mgs,lis))
+       ENDIF
+      end do
+      ENDIF
 
-!  graupel
 !
 !
-      if ( wetgrowth(mgs) .or. (mixedphase .and. fhw(mgs) .gt. 0.05 .and. temg(mgs) .gt. 243.15) ) then
-      
+      if (ndebug .gt. 0 ) write(0,*) 'ICEZVD_GS: conc 22jj'
+      chlacs(:) = 0.0
+      chlacs0(:) = 0.0
+      if ( ipconc .ge. 1 .or. ipelec .ge. 1 ) then
+      do mgs = 1,ngscnt
+      IF ( lhl .gt. 1 .and. ( ehls(mgs) .gt. 0.0 .or. (ipelec > 0 .and. ehlsclsn(mgs) > 0.0) ) ) THEN
+       IF ( ipconc .ge. 5 ) THEN
 
-! soaking (when not advected liquid water film with graupel)
+       vt = Sqrt((vtxbar(mgs,lhl,1)-vtxbar(mgs,ls,1))**2 +    &
+     &            0.04*vtxbar(mgs,lhl,1)*vtxbar(mgs,ls,1) )
 
-        IF ( lvol(lh) .gt. 1 .and. .not. mixedphase) THEN
-        ! rescale volumes to maximum density
-         rimdn(mgs,lh) = xdnmx(lh)
-         raindn(mgs,lh) = xdnmx(lh)
-         vhacw(mgs) = qhacw(mgs)*rho0(mgs)/rimdn(mgs,lh)
-         vhacr(mgs) = qhacr(mgs)*rho0(mgs)/raindn(mgs,lh)
-!        IF ( lvol(lh) .gt. 1 .and. wetgrowth(mgs) ) THEN
-         IF ( xdn(mgs,lh) .lt. xdnmx(lh) ) THEN
-         ! soak some liquid into the graupel
-!           v1 = xdnmx(lh)*vx(mgs,lh)/(xdn(mgs,lh)*dtp) ! volume available for filling
-           v1 = (1. - xdn(mgs,lh)/xdnmx(lh))*vx(mgs,lh)/(dtp) ! volume available for filling
-!            tmp = (vx(mgs,lh)/rho0(mgs))*(xdnmx(lh) - xdn(mgs,lh)) ! max mixing ratio of liquid water that can be added
-           v2 = rho0(mgs)*qhwet(mgs)/xdnmx(lh)  ! volume of frozen accretion
-           
-           vhsoak(mgs) = Min(v1,v2)
-           
-         ENDIF
-
-         vhshdr(mgs) = Min(0.0, rho0(mgs)*qhwet(mgs)/xdnmx(lh) - vhacw(mgs) - vhacr(mgs) )
-         
-        ELSEIF ( lvol(lh) .gt. 1  .and. mixedphase ) THEN
-!         vhacw(mgs) = rho0(mgs)*qhacw(mgs)/xdn0(lr)
-!         vhacr(mgs) = rho0(mgs)*qhacr(mgs)/xdn0(lr)
-        ENDIF
-        
-
-      qhdpv(mgs) = 0.0
-!      qhsbv(mgs) = 0.0
-      chdpv(mgs) = 0.0
-!      chsbv(mgs) = 0.0
-
-! collection efficiency modification
+          chlacs0(mgs) = 0.25*pi*ehlsclsn(mgs)*cx(mgs,lhl)*cx(mgs,ls)*vt*   &
+     &         (  da0lhl(mgs)*xdia(mgs,lhl,3)**2 +     &
+     &            dab0(lhl,ls)*xdia(mgs,lhl,3)*xdia(mgs,ls,3) +    &
+     &            da0(ls)*xdia(mgs,ls,3)**2 )
 
-      IF ( ehi(mgs) .gt. 0.0 ) THEN
-        qhaci(mgs) = Min(qimxd(mgs),qhaci0(mgs))  ! effectively sets collection eff to 1
-        chaci(mgs) = Min(cimxd(mgs),chaci0(mgs))  ! effectively sets collection eff to 1
+!       ELSE
+!      chlacs(mgs) =
+!     >   ((0.25)*pi)*ehls(mgs)*cx(mgs,ls)*cx(mgs,lhl)
+!     >  *abs(vtxbar(mgs,lhl,1)-vtxbar(mgs,ls,1))
+!     >  *(  gf3*gf1*xdia(mgs,ls,2)
+!     >    + 2.0*gf2*gf2*xdia(mgs,ls,1)*xdia(mgs,lhl,1)
+!     >    + gf1*gf3*xdia(mgs,lhl,2) )
       ENDIF
-      IF ( ehs(mgs) .gt. 0.0 ) THEN
-!        qhacs(mgs) = Min(qsmxd(mgs),qhacs(mgs)/ehs(mgs))  ! effectively sets collection eff to 1
-        qhacs(mgs) = Min(qsmxd(mgs),qhacs0(mgs)) !/ehs(mgs)                   ! divide out the collection efficiency
-        chacs(mgs) = Min(csmxd(mgs),chacs0(mgs)) !/ehs(mgs)                   ! divide out the collection efficiency
-        ehs(mgs) = ehsmax ! 1.0 ! min(ehsfrac*ehs(mgs),ehsmax)            ! modify it
-        qhacs(mgs) = Min(qsmxd(mgs),qhacs(mgs))   ! plug it back in
+      chlacs(mgs) = min(ehls(mgs)*chlacs0(mgs),csmxd(mgs))
       ENDIF
-
-! be sure to catch particles with wet surfaces but not in wet growth to turn off Hallett-Mossop
-      wetsfc(mgs) = .true.
-
-      else
-!        qhshr(mgs) = 0.0
+      end do
       end if
+
 !
+! Ziegler (1985) autoconversion
 !
-!  hail
 !
-!      if ( lhl .gt. 1 .and. qhlshr(mgs) .lt. 0.0 ) then
-      if ( lhl > 1 .and. ( wetgrowthhl(mgs) .or. (mixedphase .and. fhlw(mgs) .gt. 0.05 .and. temg(mgs) .gt. 243.15) ) ) then
-!      if ( wetgrowthhl(mgs) ) then
-       
-
-      qhldpv(mgs) = 0.0
-!      qhlsbv(mgs) = 0.0
-      chldpv(mgs) = 0.0
-!      chlsbv(mgs) = 0.0
-
-
-
-
-        IF ( lvol(lhl) .gt. 1  .and. .not. mixedphase ) THEN
-!        IF ( lvol(lhl) .gt. 1 .and. wetgrowthhl(mgs) ) THEN
-
-         rimdn(mgs,lhl) = xdnmx(lhl) 
-         raindn(mgs,lhl) = xdnmx(lhl) 
-         vhlacw(mgs) = qhlacw(mgs)*rho0(mgs)/rimdn(mgs,lhl)
-         vhlacr(mgs) = qhlacr(mgs)*rho0(mgs)/raindn(mgs,lhl)
-
-         IF ( xdn(mgs,lhl) .lt. xdnmx(lhl) ) THEN
-         ! soak some liquid into the hail
-!           v1 = xdnmx(lhl)*vx(mgs,lhl)/(xdn(mgs,lhl)*dtp) ! volume available for filling
-           v1 = (1. - xdn(mgs,lhl)/xdnmx(lhl))*vx(mgs,lhl)/(dtp) ! volume available for filling
-!            tmp = (vx(mgs,lhl)/rho0(mgs))*(xdnmx(lhl) - xdn(mgs,lhl)) ! max mixing ratio of liquid water that can be added
-           v2 = rho0(mgs)*qhlwet(mgs)/xdnmx(lhl)  ! volume of frozen accretion
-           IF ( v1 > v2 ) THEN ! all the frozen stuff fits in
-             vhlsoak(mgs) = v2
-           ELSE  ! fill up the available space
-             vhlsoak(mgs) = v1
-           ENDIF
-!           vhlacw(mgs) = 0.0
-!           vhlacr(mgs) = Max( 0.0, v2 - v1 )
+      IF ( ipconc .ge. 2 .and. ircnw /= -1) THEN ! DTD: added flag for autoconversion.  If -1, turns off autoconversion
+      if (ndebug .gt. 0 ) write(0,*) 'conc 26a'
+      
+      DO mgs = 1,ngscnt
+        zrcnw(mgs) = 0.0
+        qrcnw(mgs) = 0.0
+        crcnw(mgs) = 0.0
+        cautn(mgs) = 0.0
+      ENDDO
+      
+      DO mgs = 1,ngscnt
+!      qracw(mgs) = 0.0
+!      cracw(mgs) = 0.0
+       IF ( qx(mgs,lc) .gt. qxmin(lc) .and. cx(mgs,lc) .gt. 1000. .and. temg(mgs) .gt. tfrh+4.) THEN
+       ! .and. w(igs(mgs),jgs,kgs(mgs)) > 5.0) THEN ! DTD: added w threshold for testing                                                                                                            
+         volb = xv(mgs,lc)*(1./(1.+CNU))**(1./2.)
+         cautn(mgs) = Min(ccmxd(mgs),   &
+     &      ((CNU+2.)/(CNU+1.))*aa1*cx(mgs,lc)**2*xv(mgs,lc)**2)
+         cautn(mgs) = Max( 0.0d0, cautn(mgs) )
+         IF ( rb(mgs) .le. 7.51d-6 ) THEN
+           t2s = 1.d30
+!           cautn(mgs) = 0.0
          ELSE
-           vhlsoak(mgs) = 0.0
-!           vhlacw(mgs) = 0.0
-!           vhlacr(mgs) = rho0(mgs)*qhlwet(mgs)/raindn(mgs,lhl)
+!         XL2P=2.7E-2*XNC*XVC*((1.E12*RB**3*RC)-0.4)
          
-         ENDIF
+!        T2S=3.72E-3/(((1.E4*RB)-7.5)*XNC*XVC) 
+!           t2s = 3.72E-3/(((1.e6*rb)-7.5)*cx(mgs,lc)*xv(mgs,lc))
+!           t2s = 3.72/(((1.e6*rb(mgs))-7.5)*rho0(mgs)*qx(mgs,lc))
+           t2s = 3.72/(1.e6*(rb(mgs)-7.500d-6)*rho0(mgs)*qx(mgs,lc))
 
-         vhlshdr(mgs) = Min(0.0, rho0(mgs)*qhlwet(mgs)/xdnmx(lhl) - vhlacw(mgs) - vhlacr(mgs) )
+           qrcnw(mgs) = Max( 0.0d0, xl2p(mgs)/(t2s*rho0(mgs)) )
+           crcnw(mgs) = Max( 0.0d0, Min(3.5e9*xl2p(mgs)/t2s,0.5*cautn(mgs)) )
+           
+           IF ( dmrauto == 0 ) THEN
+             IF ( qx(mgs,lr)*rho0(mgs) > 1.2*xl2p(mgs) .and. cx(mgs,lr) > cxmin ) THEN ! Cohard and Pinty (2000a) switch over from (18) to (19)
+               crcnw(mgs) = cx(mgs,lr)/qx(mgs,lr)*qrcnw(mgs)
+             ENDIF
+           ELSEIF ( dmrauto == 1  .and. cx(mgs,lr) > cxmin) THEN
+             IF ( qx(mgs,lr) > qxmin(lr) ) THEN
+               tmp = qrcnw(mgs)*cx(mgs,lr)/qx(mgs,lr)
+               crcnw(mgs) = Min(tmp,crcnw(mgs) )
+             ENDIF
+           ELSEIF ( dmrauto == 2  .and. cx(mgs,lr) > cxmin) THEN
+               tmp = crcnw(mgs)
+               tmp2 = qrcnw(mgs)*cx(mgs,lr)/qx(mgs,lr)
+               ! try mass-weighted average of old and new Dmr
+               crcnw(mgs) = (tmp*qrcnw(mgs)+tmp2*qx(mgs,lr))/(qrcnw(mgs)+qx(mgs,lr))
+           ELSEIF ( dmrauto == 3  .and. cx(mgs,lr) > cxmin) THEN ! adapted from MY/CP code
+              tmp = Max( 2.d0*rh(mgs), dble( xdia(mgs,lr,3) ) )
+              crcnw(mgs) = rho0(mgs)*qrcnw(mgs)/(pi/6.*1000.*tmp**3)
+           ENDIF
+           
+           IF ( crcnw(mgs) < 1.e-30 ) qrcnw(mgs) = 0.0
 
+!           IF (  crcnw(mgs) .gt. cautn(mgs) .and. crcnw(mgs) .gt. 1.0 )
+!     :          THEN
+!             write(0,*)  'crcnw,cautn ',crcnw(mgs)/cautn(mgs),
+!     :          crcnw(mgs),cautn(mgs),igs(mgs),kgs(mgs),t2s,qx(mgs,lr)
+!             write(0,*)  '            ',qx(mgs,lc),cx(mgs,lc),0.5e6*xdia(mgs,lc,1)
+!             write(0,*)  '            ',rho0(mgs)*qrcnw(mgs)/crcnw(mgs),
+!     :         1.e6*(( 3/(4.*pi))*rho0(mgs)*qrcnw(mgs)/
+!     :       (crcnw(mgs)*xdn(mgs,lr)))**(1./3.),rh(mgs)*1.e6,rwrad(mgs)
+!           ELSEIF ( crcnw(mgs) .gt. 1.0 .and. cautn(mgs) .gt. 0.) THEN
+!             write(0,*)  'crcnw,cautn ',crcnw(mgs)/cautn(mgs),
+!     :          crcnw(mgs),cautn(mgs),igs(mgs),kgs(mgs),t2s
+!             write(0,*)  '            ',rho0(mgs)*qrcnw(mgs)/crcnw(mgs),
+!     :  1.e6*(( 3*pi/4.)*rho0(mgs)*qrcnw(mgs)/
+!     :   (crcnw(mgs)*xdn(mgs,lr)))**(1./3.)
+!           ENDIF
+!           crcnw(mgs) = Min(cautn(mgs),3.5e9*xl2p(mgs)/t2s)
 
-        ELSEIF ( lvol(lhl) .gt. 1  .and. mixedphase ) THEN
-!         vhlacw(mgs) = rho0(mgs)*qhlacw(mgs)/xdn0(lr)
-!         vhlacr(mgs) = rho0(mgs)*qhlacr(mgs)/xdn0(lr)
-        ENDIF
+!           IF ( qrcnw(mgs) .gt. 0.3e-2 ) THEN
+!            write(0,*)  'QRCNW'
+!            write(0,*)  qrcnw(mgs),crcnw(mgs),cautn(mgs)
+!            write(0,*)  xl2p,t2s,rho0(mgs),xv(mgs,lc),cx(mgs,lc),qx(mgs,lc)
+!            write(0,*)  rb,0.5*xdia(mgs,lc,1),mgs,igs(mgs),kgs(mgs)
+!           ENDIF
+!           qrcnw(mgs) = Min(qrcnw(mgs),qcmxd(mgs))
+         ENDIF
 
-      IF ( ehli(mgs) .gt. 0.0 ) THEN
-        qhlaci(mgs) = Min(qimxd(mgs),qhlaci0(mgs))  ! effectively sets collection eff to 1
-        chlaci(mgs) = Min(cimxd(mgs),chlaci0(mgs))  ! effectively sets collection eff to 1
-      ENDIF
 
-!      IF ( ehls(mgs) .gt. 0.0 ) THEN
-!        qhlacs(mgs) = Min(qsmxd(mgs),qhlacs(mgs)/ehls(mgs))
-!      ENDIF
-      IF ( ehls(mgs) .gt. 0.0 ) THEN
-        qhlacs(mgs) = Min(qsmxd(mgs),qhlacs0(mgs)) !/ehls(mgs)                   ! divide out the collection efficiency
-        chlacs(mgs) = Min(csmxd(mgs),chlacs0(mgs)) !/ehls(mgs)                   ! divide out the collection efficiency
-        ehls(mgs) = ehsmax ! 1.0 ! min(ehsfrac*ehs(mgs),ehsmax)            ! modify it
-!        qhlacs(mgs) = Min(qsmxd(mgs),qhlacs(mgs))   ! plug it back in
-      ENDIF
+       ENDIF
+      ENDDO
 
-      
-!      qhlwet(mgs) = 1.0
 
-! be sure to catch particles with wet surfaces but not in wet growth to turn off Hallett-Mossop
-      wetsfchl(mgs) = .true.
 
+      ELSE
 
-      else
-!      qhlshr(mgs) = 0.0
-!      qhlwet(mgs) = 0.0
+!
+!  Berry 1968 auto conversion for rain (Orville & Kopp 1977)
+!
+!
+      if ( ircnw .eq. 4 ) then
+      do mgs = 1,ngscnt
+!      sconvmix(lcw,mgs) = 0.0
+      qrcnw(mgs) =  0.0
+      qdiff = max((qx(mgs,lc)-qminrncw),0.0)
+      if ( qdiff .gt. 0.0 .and. xdia(mgs,lc,1) .gt. 20.0e-6 ) then
+      argrcnw =   &
+     &  ((1.2e-4)+(1.596e-12)*(cx(mgs,lc)*1.0e-6)   &
+     &  /(cwdisp*qdiff*1.0e-3*rho0(mgs)))
+      qrcnw(mgs) = (rho0(mgs)*1e-3)*(qdiff**2)/argrcnw
+!      sconvmix(lcw,mgs) = max(sconvmix(lcw,mgs),0.0)
+      qrcnw(mgs) = (max(qrcnw(mgs),0.0))
       end if
+      end do
 
+      ENDIF
+!
+!
+!
+!  Berry 1968 auto conversion for rain (Ferrier 1994)
+!
+!
+      if ( ircnw .eq. 5 ) then
+      do mgs = 1,ngscnt
+      qrcnw(mgs) = 0.0
+      qrcnw(mgs) =  0.0
+      qccrit = (pi/6.)*(cx(mgs,lc)*cwdiap**3)*xdn(mgs,lc)/rho0(mgs)
+      qdiff = max((qx(mgs,lc)-qccrit),0.)
+      if ( qdiff .gt. 0.0 .and. cx(mgs,lc) .gt. 1.0 ) then
+      argrcnw = &
+!     >  ((1.2e-4)+(1.596e-12)*cx(mgs,lc)/(cwdisp*rho0(mgs)*qdiff))   &
+     &  ((1.2e-4)+(1.596e-12)*cx(mgs,lc)*1.0e-3/(cwdisp*rho0(mgs)*qdiff))
+      qrcnw(mgs) = &
+!     >  timflg(mgs)*rho0(mgs)*(qdiff**2)/argrcnw   &
+     &  1.0e-3*rho0(mgs)*(qdiff**2)/argrcnw
+      qrcnw(mgs) = Min(qxmxd(mgs,lc), (max(qrcnw(mgs),0.0)) )
 
+!      write(iunit,*) 'qrcnw,cx =',qrcnw(mgs),cx(mgs,lc),mgs,1.e3*qx(mgs,lc),cno(lr)
+      end if
       end do
+      end if
+
 !
-! Ice -> graupel conversion
 !
-      DO mgs = 1,ngscnt
-      
-      qhcni(mgs) = 0.0
-      chcni(mgs) = 0.0
-      chcnih(mgs) = 0.0
-      vhcni(mgs) = 0.0
-      
-      IF ( iglcnvi .ge. 1 ) THEN
-      IF ( temg(mgs) .lt. 273.0 .and. qiacw(mgs) - qidpv(mgs) .gt. 0.0 ) THEN
-      
-        
-        tmp = rimc1*(-((0.5)*(1.e+06)*xdia(mgs,lc,1))   &
-     &                *((0.60)*vtxbar(mgs,li,1))   &
-     &                /(temg(mgs)-273.15))**(rimc2)
-        tmp = Min( Max( rimc3, tmp ), 900.0 )
-        
-        !  Assume that half the volume of the embryo is rime with density 'tmp'
-        !  m = rhoi*(V/2) + rhorime*(V/2) = (rhoi + rhorime)*V/2
-        !  V = 2*m/(rhoi + rhorime)
-        
-!        write(0,*)  'rime dens = ',tmp
-        
-        IF ( tmp .ge. 200.0 .or. iglcnvi >= 2 ) THEN
-          r = Max( 0.5*(xdn(mgs,li) + tmp), xdnmn(lh) )
-!          r = Max( r, 400. )
-          qhcni(mgs) = (qiacw(mgs) - qidpv(mgs)) ! *float(iglcnvi)
-          chcni(mgs) = cx(mgs,li)*qhcni(mgs)/qx(mgs,li)
-!          chcnih(mgs) = rho0(mgs)*qhcni(mgs)/(1.6e-10)
-          chcnih(mgs) = Min(chcni(mgs), rho0(mgs)*qhcni(mgs)/(r*xvmn(lh)) )
-!          vhcni(mgs) = rho0(mgs)*2.0*qhcni(mgs)/(xdn(mgs,li) + tmp)
-          vhcni(mgs) = rho0(mgs)*qhcni(mgs)/r
-        ENDIF
-      
-      ELSEIF ( iglcnvi == 3 ) THEN
-
-       IF ( temg(mgs) .lt. 273.0 .and. qiacw(mgs)*dtp > 2.*qxmin(lh) .and. gamice73fac*xmas(mgs,li) > xdnmn(lh)*xvmn(lh) ) THEN
-      
-        
-        tmp = rimc1*(-((0.5)*(1.e+06)*xdia(mgs,lc,1))   &
-     &                *((0.60)*vtxbar(mgs,li,1))   &
-     &                /(temg(mgs)-273.15))**(rimc2)
-        tmp = Min( Max( rimc3, tmp ), 900.0 )
-        
-        !  Assume that half the volume of the embryo is rime with density 'tmp'
-        !  m = rhoi*(V/2) + rhorime*(V/2) = (rhoi + rhorime)*V/2
-        !  V = 2*m/(rhoi + rhorime)
-        
-!        write(0,*)  'rime dens = ',tmp
-        ! convert to particles with the mass of the mass-weighted diameter
-      !  massofmwr = gamice73fac*xmas(mgs,li)
-        
-        IF ( tmp .ge. xdnmn(lh)  ) THEN
-          r = Max( 0.5*(xdn(mgs,li) + tmp), xdnmn(lh) )
-!          r = Max( r, 400. )
-          qhcni(mgs) = 0.5*qiacw(mgs)
-          chcni(mgs) = qhcni(mgs)/(gamice73fac*xmas(mgs,li))
-          chcnih(mgs) = Min(chcni(mgs), rho0(mgs)*qhcni(mgs)/(r*xvmn(lh)) )
-!          vhcni(mgs) = rho0(mgs)*2.0*qhcni(mgs)/(xdn(mgs,li) + tmp)
-          vhcni(mgs) = rho0(mgs)*qhcni(mgs)/r
-        ENDIF
-      
-      ENDIF
-
-      
-      ENDIF
-      ENDIF
-      
-      
-      ENDDO
-      
-      
-      qhlcnh(:) = 0.0
-      chlcnh(:) = 0.0
-      vhlcnh(:) = 0.0
-      vhlcnhl(:) = 0.0
-      zhlcnh(:) = 0.0
-
-      qhcnhl(:) = 0.0
-      chcnhl(:) = 0.0
-      vhcnhl(:) = 0.0
-      zhcnhl(:) = 0.0
-      
-
-      IF ( lhl .gt. 1  ) THEN
-      
-      IF ( ihlcnh == 1 ) THEN
-
-!
-!  Graupel (h) conversion to hail (hl) based on Milbrandt and Yau 2005b
+!  kessler auto conversion for rain.
 !
-      DO mgs = 1,ngscnt
-
-!        IF ( lhl .gt. 1 .and. ipconc .ge. 5 .and. qx(mgs,lh) .gt. 1.0e-3 .and.
-!     :        xdn(mgs,lh) .gt. 750. .and. qhshr(mgs) .lt. 0.0 .and.
-!     :        xdia(mgs,lh,3) .gt. 1.e-3 ) THEN
-        IF (  wetgrowth(mgs) .and. (xdn(mgs,lh) .gt. hldnmn .or. lvh < 1 ) .and.  & ! correct this when hail gets turned on
-!        IF (  ( qhshr(mgs) .lt. 0.0 .or. rimdn(mgs,lh) .gt. 800. ) .and.   &
-     &        rimdn(mgs,lh) .gt. 800. .and.   &
-     &        xdia(mgs,lh,3) .gt. hlcnhdia .and. qx(mgs,lh) .gt. hlcnhqmin ) THEN
-!     :        xdia(mgs,lh,3) .gt. 2.e-3 .and. qx(mgs,lh) .gt. 1.0e-3 ) THEN ! 0823.2008 erm test
-!        IF ( xdia(mgs,lh,3) .gt. 1.e-3 ) THEN
-        IF ( qhacw(mgs) .gt. 0.0 .and. qhacw(mgs) .gt. qhaci(mgs) .and. temg(mgs) .le. tfr-2.0 ) THEN
-        ! dh0 is the diameter dividing wet growth from dry growth (Ziegler 1985), modified by MY05
-!          dh0 = 0.01*(exp(temcg(mgs)/(1.1e4*(qx(mgs,lc)+qx(mgs,lr)) - 
-!     :           1.3e3*qx(mgs,li) + 1.0e-3 ) ) - 1.0)
-          x = (1.1e4*(rho0(mgs)*qx(mgs,lc)) - 1.3e3*rho0(mgs)*qx(mgs,li) + 1.0e-3 )
-          IF ( x > 1.e-20 ) THEN
-          arg = Min(70.0, (-temcg(mgs)/x )) ! prevent overflow of the exp function in 32 bit
-          dh0 = 0.01*(exp(arg) - 1.0)
-          ELSE
-           dh0 = 1.e30
-          ENDIF
-!          dh0 = Max( dh0, 5.e-3 )
-          
-!         IF ( dh0 .gt. 0.0 ) write(0,*) 'dh0 = ',dh0
-!         IF ( dh0 .gt. 1.0e-4 ) THEN
-         IF ( xdia(mgs,lh,3)/dh0 .gt. 0.1 ) THEN 
-!         IF ( xdia(mgs,lh,3) .lt. 20.*dh0 .and. dh0 .lt. 2.0*xdia(mgs,lh,3) ) THEN 
-           tmp = qhacw(mgs) + qhacr(mgs) + qhaci(mgs) + qhacs(mgs)
-!           qtmp = Min( 1.0, xdia(mgs,lh,3)/(2.0*dh0) )*(tmp)
-           qtmp = Min( 100.0, xdia(mgs,lh,3)/(2.0*dh0) )*(tmp)
-           IF ( .false. .and. qx(mgs,lhl) + qtmp*dtp .lt. 0.5e-3 ) THEN
-             hdia1 = Max(dh0, xdia(mgs,lh,3) )
-            qtmp = qtmp + Min(qxmxd(mgs,lh), Max( 0.0,   &
-     &      ((pi*xdn(mgs,lh)*cx(mgs,lh)) / (6.0*rho0(mgs)*dtp))   &
-     &      *exp(-hdia1/xdia(mgs,lh,1))   &
-     &      *( (hdia1**3) + 3.0*(hdia1**2)*xdia(mgs,lh,1)   &
-     &      + 6.0*(hdia1)*(xdia(mgs,lh,1)**2) + 6.0*(xdia(mgs,lh,1)**3) ) ) )
-
-!c           qtmp = Min( qxmxd(mgs,lh), qtmp )
-!c           tmp = tmp + Min( 0.5e-3/dtp, qtmp )
-           ENDIF
-!           write(0,*) 'dh0 = ',dh0,tmp,qx(mgs,lh)*1000.
-!           qhlcnh(mgs) = Min( 0.5*(qx(mgs,lh))+tmp, xdia(mgs,lh,3)/(2.0*dh0)*(tmp) )
-!           qhlcnh(mgs) = Min(  qxmxd(mgs,lh), xdia(mgs,lh,3)/(2.0*dh0)*(tmp) )
-           qhlcnh(mgs) = Min(  qxmxd(mgs,lh), qtmp )
-           
-           IF ( ipconc .ge. 5 ) THEN
-!           dh0 = Max( xdia(mgs,lh,3), Min( dh0, 5.e-3 ) ) ! don't create hail greater than 5mm diam. unless the graupel is larger
-           dh0 = Min( dh0, 10.e-3 ) ! don't create hail greater than 10mm diam., which is the max graupel size
-!           IF ( qx(mgs,lhl) > 0.1e-3 ) dh0 = xdia(mgs,lhl,3) ! when enough hail is established, don't dilute the size
-           chlcnh(mgs) = Min( cxmxd(mgs,lh), rho0(mgs)*qhlcnh(mgs)/(pi*xdn(mgs,lh)*dh0**3/6.0) )
-!           chlcnh(mgs) = Min( chlcnh(mgs), (1./8.)*rho0(mgs)*qhlcnh(mgs)/(xdn(mgs,lh)*xv(mgs,lh)) )
-!           chlcnh(mgs) = Min( chlcnh(mgs), (1./2.)*rho0(mgs)*qhlcnh(mgs)/(xdn(mgs,lh)*xv(mgs,lh)) )
-           r = rho0(mgs)*qhlcnh(mgs)/(xdn(mgs,lh)*xv(mgs,lh))  ! number of graupel particles at mean volume diameter
-!           chlcnh(mgs) = Min( Max( 1./8.*r , chlcnh(mgs)), r )
-!           chlcnh(mgs) = Min( chlcnh(mgs), r )
-           chlcnh(mgs) = Max( chlcnh(mgs), r )
-!           chlcnh(mgs) =  r 
-           ENDIF
-           
-           vhlcnh(mgs) = rho0(mgs)*qhlcnh(mgs)/xdn(mgs,lh)
-           vhlcnhl(mgs) = rho0(mgs)*qhlcnh(mgs)/Max(xdnmn(lhl), xdn(mgs,lh))
-!           write(0,*) 'qhlcnh = ',qhlcnh(mgs)*1000.,chlcnh(mgs)
-          ENDIF
-!         write(0,*) 'graupel to hail conversion not complete! STOP!'
-!         STOP
-        ENDIF
-        ENDIF
-      
-      ENDDO
-      
-      ELSEIF ( ihlcnh == 2 ) THEN ! 10-ice type conversion 
-
+      if ( ircnw .eq. 2 ) then
+      do mgs = 1,ngscnt
+      qrcnw(mgs) = 0.0
+      qrcnw(mgs) = (0.001)*max((qx(mgs,lc)-qminrncw),0.0)
+      end do
+      end if
 !
-! Staka and Mansell (2005) type conversion -- assuming alphah = 0 for now!
+!  c4 = pi/6
+!  c1 = 0.12-0.32 for colorado storms...typically 0.3-0.4
+!  berry reinhart type conversion (proctor 1988)
 !
-!      hldia1 is set in micro_module and namelist
+      if ( ircnw .eq. 1 ) then
       do mgs = 1,ngscnt
-!      qhlcnh(mgs) = 0.0
-!      chlcnh(mgs) = 0.0
-      if ( wetgrowth(mgs) .and. temg(mgs) .lt. tfr-5. .and. qx(mgs,lh) > qxmin(lh) ) then
-      if ( qhacw(mgs).gt.1.e-6 .and. xdn(mgs,lh) > 700. ) then
-      qhlcnh(mgs) =                                                   &
-        ((pi*xdn(mgs,lh)*cx(mgs,lh)) / (6.0*rho0(mgs)*dtp))           &
-       *exp(-hldia1/xdia(mgs,lh,1))                                    &
-       *( (hldia1**3) + 3.0*(hldia1**2)*xdia(mgs,lh,1)                  &
-        + 6.0*(hldia1)*(xdia(mgs,lh,1)**2) + 6.0*(xdia(mgs,lh,1)**3) )
-      qhlcnh(mgs) =   min(qhlcnh(mgs),qhmxd(mgs))
-      IF ( ipconc .ge. 5 ) THEN
-        chlcnh(mgs) = Min( cxmxd(mgs,lh), cx(mgs,lh)*Exp(-hldia1/xdia(mgs,lh,1)))
-!        chlcnh(mgs) = Min( cxmxd(mgs,lh), rho0(mgs)*qhlcnh(mgs)/(2.0*xmas(mgs,lh) ))
-      ENDIF
-           vhlcnh(mgs) = rho0(mgs)*qhlcnh(mgs)/xdn(mgs,lh)
-           vhlcnhl(mgs) = rho0(mgs)*qhlcnh(mgs)/Max(xdnmn(lhl), xdn(mgs,lh))
-      end if
+      qrcnw(mgs) = 0.0
+      c1 = 0.2
+      c4 = pi/(6.0)
+      bradp =    &
+     & (1.e+06) * ((c1/(0.38))**(1./3.)) * (xdia(mgs,lc,1)*(0.5))
+      bl2 =   &
+     & (0.027) * ((100.0)*(bradp**3)*(xdia(mgs,lc,1)*(0.5)) - (0.4))
+      bt2 = (bradp -7.5) / (3.72)
+      qrcnw(mgs) = 0.0
+      if ( bl2 .gt. 0.0 .and. bt2 .gt. 0.0 ) then
+      qrcnw(mgs) = bl2 * bt2 * rho0(mgs)   &
+     &  * qx(mgs,lc) * qx(mgs,lc)
       end if
       end do
-      
-      ENDIF
-      
-     ! convert low-density hail to graupel
-      IF ( icvhl2h >= 1 ) THEN
-      DO mgs = 1,ngscnt
-        IF (  qx(mgs,lhl) > qxmin(lhl) .and. xdn(mgs,lhl) < 0.5*(xdnmn(lhl) + xdnmx(lhl)) ) THEN
-          tmp = Min(0.95, 1. - 0.5*(1. + tanh(0.125*(xdn(mgs,lhl) - 1.01*xdnmn(lhl) )) ))
-          qhcnhl(mgs) = tmp*qx(mgs,lhl)/dtp
-          chcnhl(mgs) = cx(mgs,lhl)*qhcnhl(mgs)/qx(mgs,lhl)
-          vhcnhl(mgs) = vx(mgs,lhl)*qhcnhl(mgs)/qx(mgs,lhl)
-          
-        ENDIF
-      ENDDO
-      
-      ENDIF
-      
-      
-      ENDIF ! lhl > 1
-
-
-!
-! Ziegler snow conversion to graupel
-!
-      DO mgs = 1,ngscnt
-
-      qhcns(mgs) = 0.0
-      chcns(mgs) = 0.0
-      chcnsh(mgs) = 0.0
-      vhcns(mgs) = 0.0
-
-      qscnh(mgs) = 0.0
-      cscnh(mgs) = 0.0
-      vscnh(mgs) = 0.0
-
-      IF ( ipconc .ge. 5 ) THEN
-
-        ! test attempt at converting graupel to snow when not riming but growing by deposition
-        IF ( temg(mgs) < tfr .and. qx(mgs,lh) .gt. qxmin(lh) .and. qhdpv(mgs) > qxmin(lh)*dtpinv  &
-     &       .and. qhacw(mgs) < qxmin(lh)*dtpinv ) THEN
-          IF ( xdn(mgs,lh) < 290. ) THEN
-!          qscnh(mgs) = 2.*qhdpv(mgs)
-!          cscnh(mgs) = cx(mgs,lh)*qscnh(mgs)/qx(mgs,lh)
-!          vscnh(mgs) = rho0(mgs)*qscnh(mgs)/xdn(mgs,lh)
-          ENDIF
-        ENDIF
+      end if
 
 
-        IF ( qx(mgs,ls) .gt. qxmin(ls) .and. qsacw(mgs) .gt. 0.0 ) THEN
 
-!      DATA VGRA/1.413E-2/  ! this is the volume (cm**3) of a 3mm diam. sphere
-!    vgra = 1.4137e-8 m**3
+      ENDIF  !  ( ipconc .ge. 2 )
 
-!      DNNET=DNCNV-DNAGG
-!      DQNET=QXCON+QSACC+SDEP
 !
-!      DNSCNV=EXP(-(ROS*XNS*VGRA/(RO*QI)))*((1.-(XNS*VGRA*ROS/
-!     / (RO*QI)))*DNNET + (XNS**2*VGRA*ROS/(RO*QI**2))*DQNET)
-!      IF(DNSCNV.LT.0.) DNSCNV=0.
 !
-!      QIHC=(ROS*VGRA/RO)*DNSCNV
 !
-!      QH=QH+DT*QIHC
-!      QI=QI-DT*QIHC
-!      XNH=XNH+DT*DNSCNV
-!      XNS=XNS-DT*DNSCNV
-
-        IF ( iglcnvs .eq. 1 ) THEN  ! Zrnic, Ziegler et al (1993)
-
-        dnnet = cscnvis(mgs) + cscnis(mgs) - csacs(mgs)
-        dqnet = qscnvi(mgs) + qscni(mgs) + qsacw(mgs) + qsdpv(mgs) + qssbv(mgs)
-
-        a3 = 1./(rho0(mgs)*qx(mgs,ls))
-        a1 = Exp( - xdn(mgs,ls)*cx(mgs,ls)*vgra*a3 )  ! EXP(-(ROS*XNS*VGRA/(RO*QI)))
-! (1.-(XNS*VGRA*ROS/(RO*QI)))*DNNET
-        a2 =  (1.-(cx(mgs,ls)*vgra*xdn(mgs,ls)*a3))*dnnet
-! (XNS**2*VGRA*ROS/(RO*QI**2))*DQNET
-        a4 = cx(mgs,ls)**2*vgra*xdn(mgs,ls)*a3/qx(mgs,ls)*dqnet
-
-        chcns(mgs) = Max( 0.0, a1*(a2 + a4) )
-        chcns(mgs) = Min( chcns(mgs), cxmxd(mgs,ls) )
-        chcnsh(mgs) = chcns(mgs)
-
-        qhcns(mgs) = Min( xdn(mgs,ls)*vgra*rhoinv(mgs)*chcns(mgs), qxmxd(mgs,ls) )
-        vhcns(mgs) = rho0(mgs)*qhcns(mgs)/Max(xdn(mgs,ls),xdnmn(lh))
-!        vhcns(mgs) = rho0(mgs)*qhcns(mgs)/Max(xdn(mgs,ls),400.)
-
-        ELSEIF ( iglcnvs .ge. 2  ) THEN  ! treat like ice crystals, i.e., check for rime density (ERM)
+!  Bigg Freezing of Rain
+!
+      if (ndebug .gt. 0 ) write(0,*) 'conc 27a'
+      qrfrz(:) = 0.0
+      qrfrzs(:) = 0.0
+      qrfrzf(:) = 0.0
+      vrfrzf(:) = 0.0
+      crfrz(:) = 0.0
+      crfrzs(:) = 0.0
+      crfrzf(:) = 0.0
+      zrfrz(:)  = 0.0
+      zrfrzs(:)  = 0.0
+      zrfrzf(:)  = 0.0
+      qwcnr(:) = 0.0
+      
+      IF ( .not. ( ipconc == 0 .and. lwsm6 ) ) THEN
+      
+      do mgs = 1,ngscnt 
+      if ( qx(mgs,lr) .gt. qxmin(lr) .and. temcg(mgs) .lt. -5. .and. ibiggopt > 0 ) then
+!      brz = 100.0
+!      arz = 0.66
+       IF ( ipconc .lt. 3 ) THEN
+       qrfrz(mgs) =    &
+     &  min(   &
+     &  (20.0)*(pi**2)*brz*(xdn(mgs,lr)/rho0(mgs))   &
+     &   *cx(mgs,lr)*(xdia(mgs,lr,1)**6)   &
+     &   *(exp(max(-arz*temcg(mgs), 0.0))-1.0)   &
+     &  , qrmxd(mgs))
+        qrfrzf(mgs) = qrfrz(mgs)
 
-          IF ( temg(mgs) .lt. 273.0 .and. ( qsacw(mgs) - qsdpv(mgs) .gt. 0.0 .or. &
-              ( iglcnvs >= 3 .and. qsacw(mgs) > 2.*qxmin(lh) .and. gamsnow73fac*xmas(mgs,ls) > xdnmn(lh)*xvmn(lh)  ) ) ) THEN !{
+!       ELSEIF ( ipconc .ge. 3 .and. xv(mgs,lr) .gt. 1.1*xvmn(lr) ) THEN
+       ELSEIF ( ipconc .ge. 3 ) THEN
+!         tmp = brz*cx(mgs,lr)*(Exp(Max( -arz*temcg(mgs), 0.0 )) - 1.0)
+!         crfrz(mgs) = xv(mgs,lr)*tmp
 
+         frach = 1.0d0
+         
+!         IF ( ibiggopt == 2 .and. imurain == 1 .and. lzr < 1 ) THEN ! lzr check because results are weird for 3-moment
+         IF ( ibiggopt == 2 .and. imurain == 1 ) THEN !
+         ! integrate from Bigg diameter (for given supercooling Ts) to infinity
+           
+           volt = exp( 16.2 + 1.0*temcg(mgs) )* 1.0e-6 !  Ts == -temcg ; volt comes from the fit in Fig. 1 in Bigg 1953 
+                                               ! for mean temperature for freezing: -ln (V) = a*Ts - b, where a = 6.9/6.8, or approx a = 1.0, and b = 16.2
+                                               ! volt is given in cm**3, so convert to m**3
+           dbigg = (6./pi* volt )**(1./3.) 
+           
+           ! perhaps should also test that W > V_t_dbigg, i.e., that drops the size of dbigg are being lifted and cooled. 
+           
+             ratio = Min(maxratiolu, dbigg/xdia(mgs,lr,1) )
+           
+           i = Min(nqiacrratio,Int(ratio*dqiacrratioinv))
+!           j = Int(Max(0.0,Min(15.,alpha(mgs,lr))))
+           j = Int(Max(0.0,Min(15.,alpha(mgs,lr)))*dqiacralphainv)
+           delx = ratio - float(i)*dqiacrratio
+           dely = alpha(mgs,lr) - float(j)*dqiacralpha
+           ip1 = Min( i+1, nqiacrratio )
+           jp1 = Min( j+1, nqiacralpha )
 
-        tmp = rimc1*(-((0.5)*(1.e+06)*xdia(mgs,lc,1))   &
-     &                *((0.60)*vtxbar(mgs,ls,1))   &
-     &                /(temg(mgs)-273.15))**(rimc2)
-!        tmp = Min( Max( rimc3, tmp ), 900.0 )
-        tmp = Min( tmp , 900.0 )
+           ! interpolate along x, i.e., ratio; 
+           tmp1 = ciacrratio(i,j) + delx*dqiacrratioinv*(ciacrratio(ip1,j) - ciacrratio(i,j))
+           tmp2 = ciacrratio(i,jp1) + delx*dqiacrratioinv*(ciacrratio(ip1,jp1) - ciacrratio(i,jp1))
+           
+           ! interpolate along alpha; 
+           
+           crfrz(mgs) = (tmp1 + dely*dqiacralphainv*(tmp2 - tmp1))*cx(mgs,lr)*dtpinv
+           crfrzf(mgs) = crfrz(mgs)
+           ! interpolate along x, i.e., ratio; 
+           tmp1 = qiacrratio(i,j) + delx*dqiacrratioinv*(qiacrratio(ip1,j) - qiacrratio(i,j))
+           tmp2 = qiacrratio(i,jp1) + delx*dqiacrratioinv*(qiacrratio(ip1,jp1) - qiacrratio(i,jp1))
+           
+           ! interpolate along alpha; 
+           
+           qrfrz(mgs) = (tmp1 + dely*dqiacralphainv*(tmp2 - tmp1))*qx(mgs,lr)*dtpinv
+           qrfrzf(mgs) = qrfrz(mgs)
+           
+           
+            IF ( ibiggsmallrain > 0 .and. xv(mgs,lr) < 2.*xvmn(lr) .and. ( ibiggsnow == 1 .or. ibiggsnow == 3 ) ) THEN
+             ! rain drops are so small that they cannot be pushed smaller, so put into snow (or cloud ice, depending on ifrzs)
+              crfrzf(mgs) = 0.0
+              qrfrzf(mgs) = 0.0
+              crfrzs(mgs) = crfrz(mgs)
+              qrfrzs(mgs) = qrfrz(mgs)
 
-        !  Assume that half the volume of the embryo is rime with density 'tmp'
-        !  m = rhoi*(V/2) + rhorime*(V/2) = (rhoi + rhorime)*V/2
-        !  V = 2*m/(rhoi + rhorime)
+              IF ( lzr > 1 ) THEN
+                zrfrzs(mgs) = zrfrz(mgs)
+                zrfrzf(mgs) = 0.
+              ENDIF
+           ELSEIF ( dbigg < Max(dfrz,dhmn) .and. ( ibiggsnow == 1 .or. ibiggsnow == 3 ) ) THEN ! { convert some to snow or ice crystals
+            ! temporarily store qrfrz and crfrz in snow terms and caclulate new crfrzf, qrfrzf, and zrfrzf. Leave crfrz etc. alone!
+            
+            crfrzs(mgs) = crfrz(mgs)
+            qrfrzs(mgs) = qrfrz(mgs)
+            
+            IF ( ibiggsmallrain > 0 .and. xv(mgs,lr) < 1.2*xvmn(lr) ) THEN
+             ! rain drops are so small that they cannot be pushed smaller, so put into snow (or cloud ice, depending on ifrzs)
+            crfrzf(mgs) = 0.0
+            qrfrzf(mgs) = 0.0
 
-!        write(0,*)  'rime dens = ',tmp
+             
+            ELSE !{
+            
+           ! recalculate using dhmn for ratio
+           ratio = Min( maxratiolu, Max(dfrz,dhmn)/xdia(mgs,lr,1) )
+           
+           i = Min(nqiacrratio,Int(ratio*dqiacrratioinv))
+!           j = Int(Max(0.0,Min(15.,alpha(mgs,lr))))
+           j = Int(Max(0.0,Min(15.,alpha(mgs,lr)))*dqiacralphainv)
+           delx = ratio - float(i)*dqiacrratio
+           dely = alpha(mgs,lr) - float(j)*dqiacralpha
+           ip1 = Min( i+1, nqiacrratio )
+           jp1 = Min( j+1, nqiacralpha )
 
-        IF ( iglcnvs == 2 ) THEN !{
-        IF ( tmp .ge. 200.0  ) THEN
-          r = Max( 0.5*(xdn(mgs,ls) + tmp), xdnmn(lh) )
-!          r = Max( r, 400. )
-          qhcns(mgs) = (qsacw(mgs) - qsdpv(mgs))
-          chcns(mgs) = cx(mgs,ls)*qhcns(mgs)/qx(mgs,ls)
-!          chcnih(mgs) = rho0(mgs)*qhcni(mgs)/(1.6e-10)
-          chcnsh(mgs) = Min(chcns(mgs), rho0(mgs)*qhcns(mgs)/(r*xvmn(lh)) )
-!          vhcni(mgs) = rho0(mgs)*2.0*qhcni(mgs)/(xdn(mgs,li) + tmp)
-          vhcns(mgs) = rho0(mgs)*qhcns(mgs)/r
-        ENDIF
-        
-        ELSEIF ( iglcnvs == 3 ) THEN
- 
-         ! convert to particles with the mass of the mass-weighted diameter
-      !  massofmwr = gamice73fac*xmas(mgs,li)
-        
-        IF ( tmp > xdnmn(lh) ) THEN
-          r = Max( 0.5*(xdn(mgs,ls) + tmp), xdnmn(lh) )
-!          r = Max( r, 400. )
-          qhcns(mgs) = 0.5*qsacw(mgs)
-          chcns(mgs) = qhcns(mgs)/(gamsnow73fac*xmas(mgs,ls))
-          chcns(mgs) = Min( chcns(mgs), cx(mgs,ls)*qhcns(mgs)/qx(mgs,ls))
-          chcnsh(mgs) = Min(chcns(mgs), rho0(mgs)*qhcns(mgs)/(r*xvmn(lh)) )
-          vhcns(mgs) = rho0(mgs)*qhcns(mgs)/r
-        ENDIF
+           ! interpolate along x, i.e., ratio; 
+           tmp1 = ciacrratio(i,j) + delx*dqiacrratioinv*(ciacrratio(ip1,j) - ciacrratio(i,j))
+           tmp2 = ciacrratio(i,jp1) + delx*dqiacrratioinv*(ciacrratio(ip1,jp1) - ciacrratio(i,jp1))
 
-        ENDIF !}
 
-      ENDIF !}
+           ! interpolate along alpha; 
+           
+           crfrzf(mgs) = (tmp1 + dely*dqiacralphainv*(tmp2 - tmp1))*cx(mgs,lr)*dtpinv
+           
+           ! interpolate along x, i.e., ratio; 
+           tmp1 = qiacrratio(i,j) + delx*dqiacrratioinv*(qiacrratio(ip1,j) - qiacrratio(i,j))
+           tmp2 = qiacrratio(i,jp1) + delx*dqiacrratioinv*(qiacrratio(ip1,jp1) - qiacrratio(i,jp1))
+           
+           ! interpolate along alpha; 
+           
+           qrfrzf(mgs) = (tmp1 + dely*dqiacralphainv*(tmp2 - tmp1))*qx(mgs,lr)*dtpinv
 
-        ENDIF
+           ! now subtract off the difference
+            crfrzs(mgs) = crfrzs(mgs) - crfrzf(mgs)
+            qrfrzs(mgs) = qrfrzs(mgs) - qrfrzf(mgs)
 
+            ENDIF ! }
+           ELSE
+            crfrzs(mgs) = 0.0
+            qrfrzs(mgs) = 0.0
+           ENDIF ! }
+           
+           IF ( (qrfrz(mgs))*dtp > qx(mgs,lr) ) THEN
+             fac = ( qrfrz(mgs) )*dtp/qx(mgs,lr)
+             qrfrz(mgs) = fac*qrfrz(mgs)
+             qrfrzs(mgs) = fac*qrfrzs(mgs)
+             qrfrzf(mgs) = fac*qrfrzf(mgs)
+             crfrz(mgs) = fac*crfrz(mgs)
+             crfrzs(mgs) = fac*crfrzs(mgs)
+             crfrzf(mgs) = fac*crfrzf(mgs)
+           ENDIF
+!           IF ( (crfrzs(mgs) + crfrz(mgs))*dtp > cx(mgs,lr) ) THEN
+!             fac = ( crfrzs(mgs) + crfrz(mgs) )*dtp/cx(mgs,lr)
+!             crfrz(mgs) = fac*crfrz(mgs)
+!             crfrzs(mgs) = fac*crfrzs(mgs)
+!           ENDIF
+           
+!           qrfrzf(mgs) = qrfrz(mgs)
+!           crfrzf(mgs) = crfrz(mgs)
+           
+   !        qrfrz(mgs) = qrfrzf(mgs) + qrfrzs(mgs)
+   !        crfrz(mgs) = crfrzf(mgs) + crfrzs(mgs)
 
-        ENDIF
+           
+         ELSE ! ibiggopt == 1 
+         
+         tmp = xv(mgs,lr)*brz*cx(mgs,lr)*(Exp(Max( -arz*temcg(mgs), 0.0 )) - 1.0)
+         IF ( .false. .and. tmp .gt. cxmxd(mgs,lr) ) THEN ! {
+!           write(iunit,*) 'Bigg Freezing problem!',mgs,igs(mgs),kgs(mgs)
+!           write(iunit,*)  'tmp, cx(lr), xv = ',tmp, cx(mgs,lr), xv(mgs,lr), (Exp(Max( -arz*temcg(mgs), 0.0 )) - 1.0)
+!           write(iunit,*)  'qr,temcg = ',qx(mgs,lr)*1000.,temcg(mgs)
+           crfrz(mgs) = cxmxd(mgs,lr) ! cx(mgs,lr)*dtpinv
+           qrfrz(mgs) = qxmxd(mgs,lr) ! qx(mgs,lr)*dtpinv
+!           STOP
+         ELSE ! } {
+         crfrz(mgs) = tmp
+ !        crfrzfmx = cx(mgs,lr)*Exp(-4./3.*pi*(40.e-6)**3/xv(mgs,lr))
+ !        IF ( crfrz(mgs) .gt. crfrzmx ) THEN
+ !          crfrz(mgs) = crfrzmx
+ !          qrfrz(mgs) = bfnu*xmas(mgs,lr)*rhoinv(mgs)*crfrzmx
+ !          qwcnr(mgs) = cx(mgs,lr) - crfrzmx
+ !        ELSE
+         IF ( lzr < 1 ) THEN
+           IF ( imurain == 3 ) THEN
+             bfnu = bfnu0
+           ELSE !imurain == 1
+             bfnu = bfnu1
+           ENDIF
+         ELSE
+ !         bfnu = 1.0 ! (alpha(mgs,lr)+2.0)/(alpha(mgs,lr)+1.)
+           IF ( imurain == 3 ) THEN
+             bfnu = (alpha(mgs,lr)+2.0)/(alpha(mgs,lr)+1.)
+           ELSE !imurain == 1
+!             bfnu = bfnu1
+            bfnu = (4. + alpha(mgs,lr))*(5. + alpha(mgs,lr))*(6. + alpha(mgs,lr))/  &
+     &            ((1. + alpha(mgs,lr))*(2. + alpha(mgs,lr))*(3. + alpha(mgs,lr)))
+!            bfnu = 1.
+           ENDIF
+         ENDIF 
+         qrfrz(mgs) = bfnu*xmas(mgs,lr)*rhoinv(mgs)*crfrz(mgs)
 
-       ELSE ! single moment lfo
+         qrfrz(mgs) = Min( qrfrz(mgs), 1.*qx(mgs,lr)*dtpinv ) ! qxmxd(mgs,lr) 
+         crfrz(mgs) = Min( crfrz(mgs), 1.*cx(mgs,lr)*dtpinv ) !cxmxd(mgs,lr) 
+         qrfrz(mgs) = Min( qrfrz(mgs), qx(mgs,lr) )
+         qrfrzf(mgs) = qrfrz(mgs)
+         ENDIF !}
 
-        qhcns(mgs) = 0.001*ehscnv(mgs)*max((qx(mgs,ls)-6.e-4),0.0)
-        qhcns(mgs) = min(qhcns(mgs),qxmxd(mgs,ls))
-        IF ( lvol(lh) .ge. 1 ) vhcns(mgs) = rho0(mgs)*qhcns(mgs)/Max(xdn(mgs,ls),400.)
+         
+         
+         
+         IF ( crfrz(mgs) .gt. qxmin(lh) ) THEN !{ Yes, it compares cx and qxmin, but this is just to be sure that 
+                                                  ! crfrz is greater than zero in the division
+!          IF ( xdia(mgs,lr,1) .lt. 200.e-6 ) THEN
+!           IF ( xv(mgs,lr) .lt. xvmn(lh) ) THEN
+           
+           IF ( (ibiggsnow == 1 .or. ibiggsnow == 3 ) .and. ibiggopt /= 2 ) THEN
+           xvfrz = rho0(mgs)*qrfrz(mgs)/(crfrz(mgs)*900.) ! mean volume of frozen drops; 900. for frozen drop density
+           frach = 0.5 *(1. +  Tanh(0.2e12 *( xvfrz - 1.15*xvmn(lh))))
 
-       ENDIF
-      ENDDO
-!
-!
-!  heat budget for rain---not all rain that collects ice can freeze
-!
-!
-!
-      if ( irwfrz .gt. 0 .and. .not. mixedphase) then
-!
-      do mgs = 1,ngscnt
-!
-!  compute total rain that freeze when it interacts with cloud ice
-!
-      qrztot(mgs) = qrfrz(mgs) + qiacr(mgs) + qsacr(mgs)
-!
-!  compute the maximum amount of rain that can freeze
-!  Used to limit freezing to 4*qrmxd, but now allow all rain to freeze if possible
-!
-      qrzmax(mgs) =   &
-     &  ( xdia(mgs,lr,1)*rwvent(mgs)*cx(mgs,lr)*fwet1(mgs) )
-      qrzmax(mgs) = max(qrzmax(mgs), 0.0)
-      qrzmax(mgs) = min(qrztot(mgs), qrzmax(mgs))
-      qrzmax(mgs) = min(qx(mgs,lr)/dtp, qrzmax(mgs))
+             qrfrzs(mgs) = (1.-frach)*qrfrz(mgs)
+             crfrzs(mgs) = (1.-frach)*crfrz(mgs) ! *rzxh(mgs)
+!             qrfrzf(mgs) = frach*qrfrz(mgs)
+           
+           ENDIF
+           
+           IF ( ipconc .ge. 14 .and. 1.e-3*rho0(mgs)*qrfrz(mgs)/crfrz(mgs) .lt. xvmn(lh) ) THEN
+             qrfrzs(mgs) = qrfrz(mgs)
+             crfrzs(mgs) = crfrz(mgs) ! *rzxh(mgs)
+           ELSE
+!           crfrz(mgs) = Min( crfrz(mgs), 0.1*cx(mgs,lr)*dtpinv ) ! cxmxd(mgs,lr) 
+!           qrfrz(mgs) = Min( qrfrz(mgs), 0.1*qx(mgs,lr)*dtpinv ) ! qxmxd(mgs,lr) 
+             qrfrzf(mgs) = frach*qrfrz(mgs)
+!             crfrzf(mgs) = Min( qrfrz(mgs)*rho0(mgs)/(xdn(mgs,lh)*vgra), crfrz(mgs) )
+            IF ( ibfr .le. 1 ) THEN
+             crfrzf(mgs) = frach*Min(crfrz(mgs), qrfrz(mgs)/(bfnu*1.0*vr1mm*1000.0)*rho0(mgs) ) ! rzxh(mgs)*crfrz(mgs)
+            ELSEIF ( ibfr .eq. 5 ) THEN
+             crfrzf(mgs) = frach*Min(crfrz(mgs), qrfrz(mgs)/(bfnu*vfrz*1000.0)*rho0(mgs) )*rzxh(mgs)  !*crfrz(mgs)
+            ELSEIF ( ibfr .eq. 2 ) THEN
+             crfrzf(mgs) = frach*Min(crfrz(mgs), qrfrz(mgs)/(bfnu*vfrz*1000.0)*rho0(mgs) ) ! rzxh(mgs)*crfrz(mgs)
+            ELSEIF ( ibfr .eq. 6 ) THEN
+             crfrzf(mgs) = frach*Max(crfrz(mgs), qrfrz(mgs)/(bfnu*9.*xv(mgs,lr)*1000.0)*rho0(mgs) ) ! rzxh(mgs)*crfrz(mgs)
+            ELSE
+             crfrzf(mgs) = frach*crfrz(mgs)
+            ENDIF 
+!             crfrzf(mgs) = Min(crfrz(mgs), qrfrz(mgs)/(bfnu*xvmn(lh)*1000.0)*rho0(mgs) ) ! rzxh(mgs)*crfrz(mgs)
+!            IF ( lz(lr) > 1 .and. lz(lh) > 1 ) THEN
+!              crfrzf(mgs) = crfrz(mgs)
+!            ENDIF
+            
+           ENDIF
+!         crfrz(mgs) = Min( cxmxd(mgs,lr), rho0(mgs)*qrfrz(mgs)/xmas(mgs,lr) )
+         ELSE
+          crfrz(mgs) = 0.0
+          qrfrz(mgs) = 0.0
+         ENDIF !}
 
-      IF ( temcg(mgs) < -30. ) THEN ! allow all to freeze if T < -30 because fwet becomes invalid (negative)
-        qrzmax(mgs) = qx(mgs,lr)/dtp
-      ENDIF
-!      qrzmax(mgs) = min(4.*qrmxd(mgs), qrzmax(mgs))
-!
-!  compute the correction factor
-!
-!      IF ( qrztot(mgs) .gt. qxmin(lr) ) THEN
-      IF ( qrztot(mgs) .gt. qrzmax(mgs) .and. qrztot(mgs) .gt. qxmin(lr) ) THEN
-        qrzfac(mgs) = qrzmax(mgs)/(qrztot(mgs))
-      ELSE
-        qrzfac(mgs) = 1.0
-      ENDIF
-      qrzfac(mgs) = min(1.0, qrzfac(mgs))
-!
+         ENDIF ! ibiggopt
+
+          IF ( lvol(lh) .gt. 1 ) THEN
+           vrfrzf(mgs) = rho0(mgs)*qrfrzf(mgs)/rhofrz
+          ENDIF
+
+        
+        IF ( nsplinter .ne. 0 ) THEN
+          IF ( nsplinter .ge. 1000 ) THEN
+           ! Lawson et al. 2015 JAS
+           ! ave. diam of freezing drops in microns
+            tmp = 0
+            IF ( qrfrz(mgs)*dtp > qxmin(lh) .and. crfrz(mgs) > 1.e-3 ) THEN
+              tmpdiam = 1.e6*( 6.*qrfrz(mgs)/(1000.*pi*crfrz(mgs) ))**(1./3.)  ! avg. diameter of newly frozen drops in microns
+              tmp = lawson_splinter_fac*tmpdiam**4*crfrz(mgs)
+            ENDIF
+          ELSEIF ( nsplinter .gt. 0 ) THEN
+            tmp = nsplinter*crfrz(mgs)
+          ELSE
+            tmp = -nsplinter*crfrzf(mgs)
+          ENDIF
+          csplinter2(mgs) = tmp
+          qsplinter2(mgs) = Min(0.1*qrfrz(mgs), tmp*splintermass/rho0(mgs) ) ! makes splinters smaller if too much mass is taken from graupel
+
+!          csplinter(mgs) = csplinter(mgs) + tmp
+!          qsplinter(mgs) = qsplinter(mgs) + Min(0.1*qrfrz(mgs), tmp*splintermass/rho0(mgs) ) ! makes splinters smaller if too much mass is taken from graupel
+        ENDIF
+!         IF ( temcg(mgs) .lt. -31.0 ) THEN
+!           qrfrz(mgs) = qx(mgs,lr)*dtpinv + qrcnw(mgs)
+!           qrfrzf(mgs) = qrfrz(mgs)
+!           crfrz(mgs) = cx(mgs,lr)*dtpinv + crcnw(mgs)
+!           crfrzf(mgs) = Min(crfrz(mgs), qrfrz(mgs)/(bfnu*1.0*vr1mm*1000.0)*rho0(mgs) ) ! rzxh(mgs)*crfrz(mgs)
+!         ENDIF
+!         qrfrz(mgs) = 6.0*xdn(mgs,lr)*xv(mgs,lr)**2*tmp*rhoinv(mgs)
+!         qrfrz(mgs) = Min( qrfrz(mgs), ffrz*qrmxd(mgs) )
+!         crfrz(mgs) = Min( crmxd(mgs), ffrz*crfrz(mgs))
+!         crfrz(mgs) = Min(crmxd(mgs),qrfrz(mgs)*rho0(mgs)/xmas(mgs,lr))
+       ENDIF
+!      if ( temg(mgs) .gt. 268.15 ) then
+      else
+!      end if
+      end if
       end do
+      
+      ENDIF
 !
+!  Homogeneous freezing of cloud drops to ice crystals
+!  following Bigg (1953) and Ferrier (1994).
 !
-! now correct the above sources
-!
-!
+      if (ndebug .gt. 0 ) write(0,*) 'conc 25b'
       do mgs = 1,ngscnt
-      if ( temg(mgs) .le. 273.15 .and. qrzfac(mgs) .lt. 1.0 ) then
-      qrfrz(mgs)   = qrzfac(mgs)*qrfrz(mgs)
-      qrfrzs(mgs)  = qrzfac(mgs)*qrfrzs(mgs)
-      qrfrzf(mgs)  = qrzfac(mgs)*qrfrzf(mgs)
-      qiacr(mgs)   = qrzfac(mgs)*qiacr(mgs)
-      qsacr(mgs)   = qrzfac(mgs)*qsacr(mgs)
-      qiacrf(mgs)  = qrzfac(mgs)*qiacrf(mgs)
-      qiacrs(mgs)  = qrzfac(mgs)*qiacrs(mgs)
-      crfrz(mgs)   = qrzfac(mgs)*crfrz(mgs)
-      crfrzf(mgs)  = qrzfac(mgs)*crfrzf(mgs)
-      crfrzs(mgs)  = qrzfac(mgs)*crfrzs(mgs)
-      ciacr(mgs)   = qrzfac(mgs)*ciacr(mgs)
-      ciacrf(mgs)  = qrzfac(mgs)*ciacrf(mgs)
-      ciacrs(mgs)  = qrzfac(mgs)*ciacrs(mgs)
+      qwfrz(mgs) = 0.0
+      cwfrz(mgs) = 0.0
+      qwfrzc(mgs) = 0.0
+      cwfrzc(mgs) = 0.0
+      qwfrzp(mgs) = 0.0
+      cwfrzp(mgs) = 0.0
+      IF ( ibfc .ge. 1 .and. ibfc /= 3 .and. temg(mgs) < 268.15 ) THEN
+!      if ( qx(mgs,lc) .gt. qxmin(lc) .and. cx(mgs,lc) .gt. 1.  .and.   &
+!     &     .not. (ipconc .ge. 2 .and. xdia(mgs,lc,1) .lt. 10.e-6) ) then
+      if ( qx(mgs,lc) .gt. qxmin(lc) .and. cx(mgs,lc) .gt. cxmin ) THEN
+      IF ( ipconc < 2 ) THEN
+      qwfrz(mgs) = ((2.0)*(brz)/(xdn(mgs,lc)*cx(mgs,lc)))   &
+     &  *(exp(max(-arz*temcg(mgs), 0.0))-1.0)   &
+     &  *rho0(mgs)*(qx(mgs,lc)**2)
+      qwfrz(mgs) = max(qwfrz(mgs), 0.0)
+      qwfrz(mgs) = min(qwfrz(mgs),qcmxd(mgs))
+         cwfrz(mgs) = qwfrz(mgs)*rho0(mgs)/xmas(mgs,li)
+       ELSEIF ( ipconc .ge. 2 ) THEN
+         IF ( xdia(mgs,lc,3) > 0.e-6 ) THEN
+          volt = exp( 16.2 + 1.0*temcg(mgs) )* 1.0e-6 !  Ts == -temcg ; volt comes from the fit in Fig. 1 in Bigg 1953 
+                                               ! for mean temperature for freezing: -ln (V) = a*Ts - b
+                                               ! volt is given in cm**3, so factor of 1.e-6 to convert to m**3
+!           dbigg = (6./pi* volt )**(1./3.) 
 
-      
-       vrfrzf(mgs)  = qrzfac(mgs)*vrfrzf(mgs)
-       viacrf(mgs)  = qrzfac(mgs)*viacrf(mgs)
+         IF (  cnu == 0.0 ) THEN
+         cwfrz(mgs) = cx(mgs,lc)*Exp(-volt/xv(mgs,lc))*dtpinv ! number of droplets with volume greater than volt
+!turn off limit so that all can freeze at low temp
+!!!       cwfrz(mgs) = Min(cwfrz(mgs),ccmxd(mgs))
+
+         qwfrz(mgs) = cwfrz(mgs)*xdn0(lc)*rhoinv(mgs)*(volt + xv(mgs,lc))
+!         cwfrz(mgs) = cx(mgs,lc)*qwfrz(mgs)/qx(mgs,lc) ! reset number frozen to same fraction as mass. This makes 
+                                                       ! sure that cwfrz and qwfrz are consistent and prevents 
+                                                       ! spurious creation of ice crystals.
+!            IF ( qwfrz(mgs) > qxmin(lc) ) THEN
+!            
+!              write(0,*) 'droplet freeze: c,q,cfrz,qfrz = ',cx(mgs,lc),qx(mgs,lc),cwfrz(mgs),qwfrz(mgs)
+!                ratio = (1. + cnu)*volt/xv(mgs,lc)
+!                tmp = cx(mgs,lc)*Gamxinf(1.+cnu, ratio)/(dtp*gcnup1)
+!                frac = cx(mgs,lc)*xdn0(lc)*xv(mgs,lc)*rhoinv(mgs)*Gamxinf(2.+cnu, ratio)/(dtp*gcnup2)
+!               write(0,*) 'general cfrz,qfrz = ',tmp,frac
+!                tmp = Exp(-volt/xv(mgs,lc))
+!                frac = Gamxinf(1.+cnu, ratio)/(gcnup1)
+!               write(0,*) 'exp,gam,ratio = ',tmp,frac,ratio
+!
+!                tmp = Exp(-volt/xv(mgs,lc))*(volt + xv(mgs,lc))
+!                frac = Gamxinf(2.+cnu, ratio)/(gcnup2)*xv(mgs,lc)
+!               write(0,*) 'exp_q,gam_q = ',tmp,frac
+!            
+!            ENDIF
+
+          ELSE
+            ratio = (1. + cnu)*volt/xv(mgs,lc)
+            cwfrz(mgs) = cx(mgs,lc)*Gamxinf(1.+cnu, ratio)/(dtp*gcnup1)
+          
+            qwfrz(mgs) = cx(mgs,lc)*xdn0(lc)*xv(mgs,lc)*rhoinv(mgs)*Gamxinf(2.+cnu, ratio)/(dtp*gcnup2)
+          
+          ENDIF
+
+!         IF ( temg(mgs) < tfrh - 3 ) THEN
+!          cwfrz(mgs) = cx(mgs,lc)
+!          qwfrz(mgs) = qx(mgs,lc)
+!         ENDIF
+!         IF ( qwfrz(mgs) > 0.5*qx(mgs,lc) ) THEN
+!           write(0,*) 'Problem with qwfrz(mgs): qwfrz,temcg,volt,xv,cx = ',qwfrz(mgs),qx(mgs,lc),temcg(mgs),volt,xv(mgs,lc),cx(mgs,lc),cwfrz(mgs)
+!           STOP
+!         ENDIF
+!turn off limit so that all can freeze at low temp
+!!!         qwfrz(mgs) = Min( qwfrz(mgs), qxmxd(mgs,lc) )
+         ENDIF
+       ENDIF
+      if ( temg(mgs) .gt. 268.15 ) then
+      qwfrz(mgs) = 0.0
+      cwfrz(mgs) = 0.0
       end if
-      end do
-!
-!
-!
       end if
+      ENDIF
 !
+        if ( xplate(mgs) .eq. 1 ) then
+          qwfrzp(mgs) = qwfrz(mgs)
+          cwfrzp(mgs) = cwfrz(mgs)
+        end if
+!  
+        if ( xcolmn(mgs) .eq. 1 ) then
+          qwfrzc(mgs) = qwfrz(mgs)
+          cwfrzc(mgs) = cwfrz(mgs)
+        end if
+      
 !
+!     qwfrzp(mgs) = 0.0
+!     qwfrzc(mgs) = qwfrz(mgs)
 !
-!  evaporation of rain
+      end do
 !
 !
+!  Contact freezing nucleation:  factor is to convert from L-1
+!  T < -2C:  via Meyers et al. JAM July, 1992 (31, 708-721)
 !
-      qrcev(:) = 0.0
-      crcev(:) = 0.0
+      if (ndebug .gt. 0 ) write(0,*) 'conc 25a'
+      do mgs = 1,ngscnt
 
+       ccia(mgs) = 0.0
 
-      do mgs = 1,ngscnt
-!
-      IF ( qx(mgs,lr) .gt. qxmin(lr) ) THEN
+       cwctfz(mgs) = 0.0
+       qwctfz(mgs) = 0.0
+       ctfzbd(mgs) = 0.0
+       ctfzth(mgs) = 0.0
+       ctfzdi(mgs) = 0.0
 
-      qrcev(mgs) =   &
-     &  fvce(mgs)*cx(mgs,lr)*rwvent(mgs)*rwcap(mgs)*evapfac
-! this line to allow condensation on rain:
-      IF ( rcond .eq. 1 ) THEN
-        qrcev(mgs) = min(qrcev(mgs), qxmxd(mgs,lv))
-! this line to have evaporation only:
-      ELSE
-        qrcev(mgs) = min(qrcev(mgs), 0.0)
-      ENDIF
+       cwctfzc(mgs) = 0.0
+       qwctfzc(mgs) = 0.0
+       cwctfzp(mgs) = 0.0
+       qwctfzp(mgs) = 0.0
+       IF ( icfn .ge. 1 ) THEN
 
-      qrcev(mgs) = max(qrcev(mgs), -qrmxd(mgs))
-!      if ( temg(mgs) .lt. 273.15 ) qrcev(mgs) = 0.0
-      IF ( qrcev(mgs) .lt. 0. .and. lnr > 1 ) THEN
-!        qrcev(mgs) =   -qrmxd(mgs)
-!        crcev(mgs) = (rho0(mgs)/(xmas(mgs,lr)+1.e-20))*qrcev(mgs)
-      crcev(mgs) = (cx(mgs,lr)/(qx(mgs,lr)))*qrcev(mgs)
-      ELSE
-         crcev(mgs) = 0.0
-      ENDIF
-!      if ( temg(mgs) .lt. 273.15 ) crcev(mgs) = 0.0
-!
-      ENDIF
+       IF ( temg(mgs) .lt. 271.15  .and. qx(mgs,lc) .gt. qxmin(lc)) THEN
 
-      end do
-!
-! evaporation/condensation of wet graupel and snow
-!
-      qscev(:) = 0.0
-      cscev(:) = 0.0
-      qhcev(:) = 0.0
-      chcev(:) = 0.0
-      qhlcev(:) = 0.0
-      chlcev(:) = 0.0
+!       find available # of ice nuclei & limit value to max depletion of cloud water
 
-!
-!
-!
-!  ICE MULTIPLICATION: Two modes (rimpa, and rimpb)
-!  (following Cotton et al. 1986)
-!
- 
-      chmul1(:) =  0.0
-      chlmul1(:) =  0.0
-      csmul1(:) = 0.0
-!
-      qhmul1(:) =  0.0
-      qhlmul1(:) =  0.0
-      qsmul1(:) =  0.0
+        IF ( icfn .ge. 2 ) THEN
+         ccia(mgs) = exp( 4.11 - (0.262)*temcg(mgs) )  ! in m-3, see Walko et al. 1995
+         !ccia(mgs) = Min(cwctfz(mgs), ccmxd(mgs) )
 
-      do mgs = 1,ngscnt
- 
-       ltest =  qx(mgs,lh) .gt. qxmin(lh)
-       IF ( lhl > 1 )  ltest =  ltest .or. qx(mgs,lhl) .gt. qxmin(lhl)
-       
-      IF ( (itype1 .ge. 1 .or. itype2 .ge. 1 )   &
-     &              .and. qx(mgs,lc) .gt. qxmin(lc)) THEN
-      if ( temg(mgs) .ge. 265.15 .and. temg(mgs) .le. 271.15 ) then
-       IF ( ipconc .ge. 2 ) THEN
-        IF ( xv(mgs,lc) .gt. 0.0     &
-     &     .and.  ltest &
-!     .and. itype2 .ge. 2    &
-     &       ) THEN
-!
-!  Ziegler et al. 1986 Hallett-Mossop process.  VSTAR = 7.23e-15 (vol of 12micron radius)
-!
-         IF ( .true. .and. cnu == 0.0 ) THEN
-           ex1 = (1./250.)*Exp(-7.23e-15/xv(mgs,lc))
-         ELSE
-            ratio = (1. + cnu)*(7.23e-15)/xv(mgs,lc)
-            ex1 = (1./250.)*Gamxinf(1.+cnu, ratio)/(gcnup1)
+!       now find how many of these collect cloud water to form IN
+!       Cotton et al 1986
+
+         knud(mgs) = 2.28e-5 * temg(mgs) / ( pres(mgs)*raero ) !Walko et al. 1995
+         knuda(mgs) = 1.257 + 0.4*exp(-1.1/knud(mgs))          !Pruppacher & Klett 1997 eqn 11-16
+         gtp(mgs) = 1. / ( fai(mgs) + fbi(mgs) )               !Byers 65 / Cotton 72b
+         dfar(mgs) = kb*temg(mgs)*(1.+knuda(mgs)*knud(mgs))/(6.*pi*fadvisc(mgs)*raero) !P&K 1997 eqn 11-15
+         fn1(mgs) = 2.*pi*xdia(mgs,lc,1)*cx(mgs,lc)*ccia(mgs)
+         fn2(mgs) = -gtp(mgs)*(ssw(mgs)-1.)*felv(mgs)/pres(mgs)
+         fnft(mgs) = 0.4*(1.+1.45*knud(mgs)+0.4*knud(mgs)*exp(-1./knud(mgs)))*(ftka(mgs)+2.5*knud(mgs)*kaero)      &
+     &              / ( (1.+3.*knud(mgs))*(2*ftka(mgs)+5.*knud(mgs)*kaero+kaero) )
+
+
+!      Brownian diffusion
+         ctfzbd(mgs) = fn1(mgs)*dfar(mgs)
+
+!      Thermophoretic contact nucleation
+         ctfzth(mgs) = fn1(mgs)*fn2(mgs)*fnft(mgs)/rho0(mgs)
+
+!      Diffusiophoretic contact nucleation
+         ctfzdi(mgs) = fn1(mgs)*fn2(mgs)*rw*temg(mgs)/(felv(mgs)*rho0(mgs))
+
+         cwctfz(mgs) = max( ctfzbd(mgs) + ctfzth(mgs) + ctfzdi(mgs) , 0.)
+
+!      Sum of the contact nucleation processes
+!         IF ( cx(mgs,lc) .gt. 50.e6) write(6,*) 'ctfzbd,etc = ',ctfzbd(mgs),ctfzth(mgs),ctfzdi(mgs)
+!         IF ( wvel(mgs) .lt. -0.05 ) write(6,*) 'ctfzbd,etc = ',ctfzbd(mgs),ctfzth(mgs),ctfzdi(mgs),cx(mgs,lc)*1e-6,wvel(mgs)
+!         IF ( ssw(mgs) .lt. 1.0 .and. cx(mgs,lc) .gt. 1.e6 .and. cwctfz(mgs) .gt. 1. ) THEN
+!          write(6,*) 'ctfzbd,etc = ',ctfzbd(mgs),ctfzth(mgs),ctfzdi(mgs),cx(mgs,lc)*1e-6,wvel(mgs),fn1(mgs),fn2(mgs)
+!          write(6,*) 'more = ',nstep,ssw(mgs),dfar(mgs),gtp(mgs),felv(mgs),pres(mgs)
+!         ENDIF
+
+        ELSEIF ( icfn .eq. 1 ) THEN
+         IF ( wvel(mgs) .lt. -0.05 ) THEN ! older kludgy version
+           cwctfz(mgs) = cfnfac*exp( (-2.80) - (0.262)*temcg(mgs) )
+           cwctfz(mgs) = Min((1.0e3)*cwctfz(mgs), ccmxd(mgs) )  !convert to m-3
          ENDIF
-       IF ( itype2 .le. 2 ) THEN
-         ft = Max(0.0,Min(1.0,-0.11*temcg(mgs)**2 - 1.1*temcg(mgs)-1.7))
-       ELSE
-        IF ( temg(mgs) .ge. 265.15 .and. temg(mgs) .le. 267.15 ) THEN
-          ft = 0.5
-        ELSEIF (temg(mgs) .ge. 267.15 .and. temg(mgs) .le. 269.15 ) THEN
-          ft = 1.0
-        ELSEIF (temg(mgs) .ge. 269.15 .and. temg(mgs) .le. 271.15 ) THEN
-          ft = 0.5
-        ELSE 
-          ft = 0.0
+        ENDIF   ! icfn
+
+        IF ( ipconc .ge. 2 ) THEN
+         cwctfz(mgs) = Min( cwctfz(mgs)*dtpinv, ccmxd(mgs) )
+         qwctfz(mgs) = xmas(mgs,lc)*cwctfz(mgs)/rho0(mgs)
+        ELSE
+         qwctfz(mgs) = (cimasn)*cwctfz(mgs)/(dtp*rho0(mgs))
+         qwctfz(mgs) = max(qwctfz(mgs), 0.0)
+         qwctfz(mgs) = min(qwctfz(mgs),qcmxd(mgs))
         ENDIF
-       ENDIF
-!        rhoinv = 1./rho0(mgs)
-!        DNSTAR = ex1*cglacw(mgs)
-        
-       IF ( ft > 0.0 ) THEN
-        
-        IF ( itype2 > 0 ) THEN
-         IF ( qx(mgs,lh) .gt. qxmin(lh) .and. (.not. wetsfc(mgs))  ) THEN
-          chmul1(mgs) = ft*ex1*chacw(mgs)
-!          chmul1(mgs) = Min( ft*ex1*chacw(mgs), ft*(30.*1.e+06)*rho0(mgs)*qhacw(mgs) ) ! 1.e+6 converts kg to mg; Saunders & Hosseini (2001) average of about 30 crystals per mg
-          qhmul1(mgs) = cimas0*chmul1(mgs)*rhoinv(mgs)
-         ENDIF
-         IF ( lhl .gt. 1 ) THEN
-           IF ( qx(mgs,lhl) .gt. qxmin(lhl) .and. (.not. wetsfchl(mgs))  ) THEN
-            chlmul1(mgs) = (ft*ex1*chlacw(mgs))
-            qhlmul1(mgs) = cimas0*chlmul1(mgs)*rhoinv(mgs)
-           ENDIF
-         ENDIF
-        ENDIF ! itype2
 
-        IF ( itype1 > 0 ) THEN
-         IF ( qx(mgs,lh) .gt. qxmin(lh) .and. (.not. wetsfc(mgs))  ) THEN
-          tmp = ft*(3.5e+08)*rho0(mgs)*qhacw(mgs)
-          chmul1(mgs) = chmul1(mgs) + tmp
-          qhmul1(mgs) = qhmul1(mgs) + cimas0*tmp*rhoinv(mgs)
-         ENDIF
-         IF ( lhl .gt. 1 ) THEN
-           IF ( qx(mgs,lhl) .gt. qxmin(lhl) .and. (.not. wetsfchl(mgs)) ) THEN
-            tmp = ft*(3.5e+08)*rho0(mgs)*qhlacw(mgs)
-            chlmul1(mgs) = chlmul1(mgs) + tmp
-            qhlmul1(mgs) = qhlmul1(mgs) + cimas0*tmp*rhoinv(mgs)
-           ENDIF
-         ENDIF
-        ENDIF ! itype1
-        
-        ENDIF ! ft
+!
+        if ( xplate(mgs) .eq. 1 ) then
+         qwctfzp(mgs) = qwctfz(mgs)
+         cwctfzp(mgs) = cwctfz(mgs)
+        end if
+!
+        if ( xcolmn(mgs) .eq. 1 ) then
+         qwctfzc(mgs) = qwctfz(mgs)
+         cwctfzc(mgs) = cwctfz(mgs)
+        end if
+       
+!
+!     qwctfzc(mgs) = qwctfz(mgs)
+!     qwctfzp(mgs) = 0.0
+!
+       end if
 
-        ENDIF ! xv(mgs,lc) .gt. 0.0 .and.
+       ENDIF ! icfn
 
-       ELSE ! ipconc .lt. 2
+      end do
 !
-!  define the temperature function
 !
-      fimt1(mgs) = 0.0
 !
-! Cotton et al. (1986) version
+! Hobbs-Rangno ice enhancement (Ferrier, 1994)
 !
-      if ( temg(mgs) .ge. 268.15 .and. temg(mgs) .le. 270.15 ) then
-        fimt1(mgs) = 1.0 -(temg(mgs)-268.15)/2.0
-      elseif (temg(mgs) .le. 268.15 .and. temg(mgs) .ge. 265.15 ) then
-        fimt1(mgs) = 1.0 +(temg(mgs)-268.15)/3.0
-      ELSE 
-        fimt1(mgs) = 0.0
+      if (ndebug .gt. 0 ) write(0,*) 'conc 23a'
+      dtrh = 300.0
+      hrifac = (1.e-3)*((0.044)*(0.01**3))
+      do mgs = 1,ngscnt
+      ciihr(mgs) = 0.0
+      qiihr(mgs) = 0.0
+      cicichr(mgs) = 0.0
+      qicichr(mgs) = 0.0
+      cipiphr(mgs) = 0.0
+      qipiphr(mgs) = 0.0
+      IF ( ihrn .ge. 1 ) THEN
+      if ( qx(mgs,lc) .gt. qxmin(lc) ) then
+      if ( temg(mgs) .lt. 273.15 ) then
+!      write(iunit,'(3(1x,i3),3(1x,1pe12.5))')
+!     : igs(mgs),jgs,kgs(mgs),cx(mgs,lc),rho0(mgs),qx(mgs,lc)
+!      write(iunit,'(1pe15.6)')
+!     :  log(cx(mgs,lc)*(1.e-6)/(3.0)),
+!     :  ((1.e-3)*rho0(mgs)*qx(mgs,lc)),
+!     :  (cx(mgs,lc)*(1.e-6)),
+!     : ((1.e-3)*rho0(mgs)*qx(mgs,lc))/(cx(mgs,lc)*(1.e-6)),
+!     : (alog(cx(mgs,lc)*(1.e-6)/(3.0)) *
+!     >  ((1.e-3)*rho0(mgs)*qx(mgs,lc))/(cx(mgs,lc)*(1.e-6)))
+
+      IF ( Log(cx(mgs,lc)*(1.e-6)/(3.0)) .gt. 0.0 ) THEN
+      ciihr(mgs) = ((1.69e17)/dtrh)   &
+     & *(log(cx(mgs,lc)*(1.e-6)/(3.0)) *   &
+     &  ((1.e-3)*rho0(mgs)*qx(mgs,lc))/(cx(mgs,lc)*(1.e-6)))**(7./3.)
+      ciihr(mgs) = ciihr(mgs)*(1.0e6)
+      qiihr(mgs) = hrifac*ciihr(mgs)/rho0(mgs)
+      qiihr(mgs) = max(qiihr(mgs), 0.0)
+      qiihr(mgs) = min(qiihr(mgs),qcmxd(mgs))
+      ENDIF
+!
+      if ( xplate(mgs) .eq. 1 ) then
+      qipiphr(mgs) = qiihr(mgs)
+      cipiphr(mgs) = ciihr(mgs)
       end if
 !
-! Ferrier (1994) version
+      if ( xcolmn(mgs) .eq. 1 ) then
+      qicichr(mgs) = qiihr(mgs)
+      cicichr(mgs) = ciihr(mgs)
+      end if
 !
-      if ( temg(mgs) .ge. 265.15 .and. temg(mgs) .le. 267.15 ) then
-        fimt1(mgs) = 0.5
-      elseif (temg(mgs) .ge. 267.15 .and. temg(mgs) .le. 269.15 ) then
-        fimt1(mgs) = 1.0
-      elseif (temg(mgs) .ge. 269.15 .and. temg(mgs) .le. 271.15 ) then
-        fimt1(mgs) = 0.5
-      ELSE 
-        fimt1(mgs) = 0.0
+!     qipiphr(mgs) = 0.0
+!     qicichr(mgs) = qiihr(mgs)
+!
+      end if
       end if
+      ENDIF ! ihrn
+      end do
 !
 !
-!   type I:  350 splinters are formed for every 1e-3 grams of cloud
-!            water accreted by graupel/hail (note converted to MKS units)
-!            3.5e+8 has units of 1/kg
 !
-      IF ( itype1 .ge. 1 ) THEN
-       fimta(mgs) = (3.5e+08)*rho0(mgs)
-      ELSE
-       fimta(mgs) = 0.0
-      ENDIF
-
+!  simple frozen rain to hail conversion.  All of the
+!  frozen rain larger than 5.0e-3 m in diameter are converted
+!  to hail.  This is done by considering the equation for
+!  frozen rain mixing ratio:
 !
 !
-!   type II:  1 splinter formed for every 250 cloud droplets larger than
-!             24 micons in diameter (12 microns in radius) accreted by
-!             graupel/hail
+!  qfw = [ cno(lf) * pi * fwdn / (6 rhoair) ]
 !
+!         /inf
+!      *  |     fwdia*3 exp(-dia/fwdia) d(dia)
+!         /Do
 !
-      fimt2(mgs) = 0.0
-      xcwmas = xmas(mgs,lc) * 1000.
+!  The amount to be reclassified as hail is the integral above from
+!  Do to inf where Do is 5.0e-3 m.
 !
-      IF ( itype2 .ge. 1 ) THEN
-      if ( xcwmas.lt.1.26e-9 ) then
-        fimt2(mgs) = 0.0
-      end if
-      if ( xcwmas .le. 3.55e-9 .and. xcwmas .ge. 1.26e-9 ) then
-        fimt2(mgs) = (2.27)*alog(xcwmas) + 13.39
-      end if
-      if ( xcwmas .gt. 3.55e-9 ) then
-        fimt2(mgs) = 1.0
-      end if
-
-      fimt2(mgs) = min(fimt2(mgs),1.0)
-      fimt2(mgs) = max(fimt2(mgs),0.0)
-      
-      ENDIF
 !
-!     qhmul2 = 0.0
-!     qsmul2 = 0.0
+!  qfauh = [ cno(lf) * pi * fwdn / (6 rhoair) ]
 !
-!     qhmul2 =
-!    >  (4.0e-03)*fimt1(mgs)*fimt2(mgs)*qhacw(mgs)
-!     qsmul2 =
-!    >  (4.0e-03)*fimt1(mgs)*fimt2(mgs)*qsacw(mgs)
 !
-!      cimas0 = (1.0e-12)
-!      cimas0 = 2.5e-10
-      IF ( .not. wetsfc(mgs) ) THEN
-      chmul1(mgs) =  fimt1(mgs)*(fimta(mgs) +   &
-     &                           (4.0e-03)*fimt2(mgs))*qhacw(mgs)
+
+
+      hdia0 = 300.0e-6
+      do mgs = 1,ngscnt
+      qscnvi(mgs) = 0.0
+      cscnvi(mgs) = 0.0
+      cscnvis(mgs) = 0.0
+!      IF ( .false. ) THEN
+!      IF ( temg(mgs) .lt. tfr .and. ssi(mgs) .gt. 1.01 .and. qx(mgs,li) .gt. qxmin(li) ) THEN
+      IF ( temg(mgs) .lt. tfr .and. qx(mgs,li) .gt. qxmin(li) ) THEN
+        IF ( ipconc .ge. 4 .and. .false. ) THEN
+         if ( cx(mgs,li) .gt. 10. .and. xdia(mgs,li,1) .gt. 50.e-6 ) then !{
+         cirdiatmp =   &
+     &  (qx(mgs,li)*rho0(mgs)   &
+     & /(pi*xdn(mgs,li)*cx(mgs,li)))**(1./3.)
+          IF ( cirdiatmp .gt. 100.e-6 ) THEN !{
+          qscnvi(mgs) =   &
+     &  ((pi*xdn(mgs,li)*cx(mgs,li)) / (6.0*rho0(mgs)*dtp))   &
+     & *exp(-hdia0/cirdiatmp)   &
+     & *( (hdia0**3) + 3.0*(hdia0**2)*cirdiatmp   &
+     &  + 6.0*(hdia0)*(cirdiatmp**2) + 6.0*(cirdiatmp**3) )
+      qscnvi(mgs) =   &
+     &  min(qscnvi(mgs),qimxd(mgs))
+          IF ( ipconc .ge. 4 ) THEN
+            cscnvi(mgs) = Min( cimxd(mgs), cx(mgs,li)*Exp(-hdia0/cirdiatmp))
+          ENDIF
+         ENDIF  ! }
+        end if ! }
+
+       ELSEIF ( ipconc .lt. 4 ) THEN
+
+        qscnvi(mgs) = 0.001*eii(mgs)*max((qx(mgs,li)-1.e-3),0.0)
+        qscnvi(mgs) = min(qscnvi(mgs),qxmxd(mgs,li))
+        cscnvi(mgs) = qscnvi(mgs)*rho0(mgs)/xmas(mgs,li)
+        cscnvis(mgs) = 0.5*cscnvi(mgs)
+
+       ENDIF
       ENDIF
-!
-      qhmul1(mgs) =  chmul1(mgs)*(cimas0/rho0(mgs))
+!      ENDIF
+      end do
 
 
-         IF ( lhl .gt. 1 ) THEN
-           IF ( qx(mgs,lhl) .gt. qxmin(lhl) .and. (.not. wetsfchl(mgs)) ) THEN
-            tmp = fimt1(mgs)*(fimta(mgs) +   &
-     &                           (4.0e-03)*fimt2(mgs))*qhlacw(mgs)
-            chlmul1(mgs) =  tmp
-            qhlmul1(mgs) = cimas0*tmp*rhoinv(mgs)
-           ENDIF
-         ENDIF
 
-!      qsmul1(mgs) =  csmul1(mgs)*(cimas0/rho0(mgs))
+      IF ( ipelec >= 1 .or. idonic ) THEN
 !
-      ENDIF ! ( ipconc .ge. 2 )
+!  set rates to zero
+!
+      scxacy(:,:,:) = 0.0
+
+      scsacw(:) = 0.0
+      scsaci(:) = 0.0
+      IF ( lis > 1 ) scsacis(:) = 0.0
+      scsacr(:) = 0.0
+
+      schacw(:) = 0.0
+      schaci(:) = 0.0
+      IF ( lis > 1 ) schacis(:) = 0.0
+      schacs(:) = 0.0
+      schacr(:) = 0.0
+
+      IF ( lhl .gt. 1 ) THEN
+      schlacw(:) = 0.0
+      schlaci(:) = 0.0
+      IF ( lis > 1 ) schlacis(:) = 0.0
+      schlacs(:) = 0.0
+      schlacr(:) = 0.0
+      ENDIF
+
       
-      end if ! (in temperature range)
+      ENDIF
+
+
+
+      altelecfac = 1.0
+      elecfac = 1.0
+
+
+      IF ( ipelec .ge. 2 .or. idonic ) THEN
+
+!      write(*,*) 'icezvd_gs: time_real, elec_on_time = ',time_real,elec_on_time
+      IF ( jyslab.gt.(jds+2) .and. jyslab.lt.(jde-2) ) THEN
       
-      ENDIF ! ( itype1 .eq. 1 .or. itype2 .eq. 1)
+!      elecfac = 1.0
+      
+      
+      
+      DO mgs = 1,ngscnt
+
+
+      exy(mgs,ls,lc) = esw(mgs)
+      exy(mgs,ls,li) = esi(mgs)
+      exy(mgs,lh,lc) = ehw(mgs)
+      exy(mgs,lh,li) = ehi(mgs)
+      exy(mgs,lh,ls) = ehs(mgs)
+      IF ( lis > 1 ) exy(mgs,lh,lis) = ehis(mgs)
+
+      IF ( lhl .gt. 1 ) THEN
+        exy(mgs,lhl,lc) = ehlw(mgs)
+        exy(mgs,lhl,li) = ehli(mgs)
+        exy(mgs,lhl,ls) = ehls(mgs)
+        IF ( lis > 1 ) exy(mgs,lhl,lis) = ehlis(mgs)
+      ENDIF
+
+      cxacy(mgs,ls,lc) = csacw(mgs)
+      cxacy(mgs,lh,lc) = chacw(mgs)
+      
+         ! use ni as the fraction of ice crystals greater than some given diameter
+         ni = 1.0
+         nis = 1.0
+         IF ( cidiamin > 0.0 ) THEN
+           ni = Exp(- (cidiamin/xdia(mgs,li,1))**3 )
+           IF ( lis > 1 ) nis = Exp(- (cidiamin/xdia(mgs,lis,1))**3 )
+         ENDIF
+
+      
+      IF ( .true. ) THEN
+      cxacy(mgs,ls,li) = ni*csaci0(mgs)
+      cxacy(mgs,lh,li) = ni*chaci0(mgs)
+      cxacy(mgs,lh,ls) = chacs0(mgs)
+      IF ( lis > 1 ) cxacy(mgs,lh,lis) = nis*chacis0(mgs)
+      ELSE
+      cxacy(mgs,ls,li) = csaci(mgs) ! csaci0(mgs)
+      cxacy(mgs,lh,li) = chaci(mgs) ! chaci0(mgs)
+      cxacy(mgs,lh,ls) = chacs(mgs) ! chacs0(mgs)
+      ENDIF
+
+      IF ( lhl .gt. 1 ) THEN
+      cxacy(mgs,lhl,lc) = chlacw(mgs)
+      cxacy(mgs,lhl,li) = ni*chlaci0(mgs)
+      cxacy(mgs,lhl,ls) = chlacs0(mgs)
+      IF ( lis > 1 ) cxacy(mgs,lhl,lis) = nis*chlacis0(mgs)
+      ENDIF
+
+      ENDDO
+
+
 !
-      end do
+!  First do loop between large ice and small ice
 !
+      DO il=ls,lhab ! loop through all ice habits
+      DO ic=li,ls ! loop through all mixed phase particles
+
+!      IF ( iexy(il,ic) .eq. 1 .and. il .ne. ic ) THEN ! prevent snow-snow
+      IF ( iexy(il,ic) .eq. 1  ) THEN
+
+      do mgs = 1,ngscnt
+
+!        IF (qx(mgs,il) .gt. qxmin(il)  .and. qx(mgs,ic) .gt. qxmin(ic)  .and. exy(mgs,il,ic) .gt. 0.0) THEN  ! make sure there are particle and that they do not stick
+        IF (qx(mgs,il) .gt. qxmin(il)  .and. qx(mgs,ic) .gt. qxmin(ic) ) THEN  ! make sure there are particle and that they do not stick
+        IF ( temg(mgs) .lt. tfr .and. temg(mgs) .gt. thnuc ) THEN  ! 0.0=tfreezing and -38C= assumed T for homogeneous ice nucleation
+!        IF ( .true. ) THEN
+        IF ( iremoveqwfrz == 1 ) THEN
+          qcwtmp(mgs) = Max(0.0, qx(mgs,lc) - dtp*qwfrz(mgs) )
+        ELSE
+          qcwtmp(mgs) = qx(mgs,lc)
+        ENDIF
+
+!  del cglarge
 !
 !
-!     end if
+      IF (nonigrd .eq. -1 ) THEN ! {
+
+       vt = vtxbar(mgs,il,1) - vtxbar(mgs,ic,1)
+       CALL takax(isaund,ntem,nlwc,takalu,temcg(mgs),qcwtmp(mgs),vt,   &
+     &     xdia(mgs,ic,1),rho0(mgs),ftelwc,exy(mgs,il,lc),qx(mgs,lr),rarfac)
+       scxacy(mgs,il,ic) = ftelwc
+
+        if ( scxacy(mgs,il,ic) .gt. 0.0 ) then
+          scxacy(mgs,il,ic) = min(delqxxa(ic),scxacy(mgs,il,ic))
+        end if
+        if ( scxacy(mgs,il,ic) .lt. 0.0 ) then
+          scxacy(mgs,il,ic) = max(delqnxa(ic),scxacy(mgs,il,ic))
+        end if
+      ! }
+      ELSEIF ( nonigrd .eq. 1 .or. nonigrd .eq. 0 ) THEN ! {
+
+      IF (nonigrd .eq. 0) THEN
+
+      qconkq = 0.0
+      qconm = 1.0
+      qconn = 1.0
+      ftelwc = 0.0
+
+      vt = vtxbar(mgs,il,1) - vtxbar(mgs,lc,1)
+      call saundx(isaund,temcg(mgs),qcwtmp(mgs),exy(mgs,il,lc),vt,xdia(mgs,ic,1),   &
+     &   rho0(mgs),qsign,ftelwc,qconkq,qconm,qconn,idelq,rarfac)
+!      IF ( ftelwc /= 0.0 ) THEN
+!      IF ( igs(mgs) == 42 .and. kgs(mgs) == 43 ) THEN
+!      write(0,*) 'called saundx: ',igs(mgs),kgs(mgs),il,lc,isaund,temcg(mgs),qcwtmp(mgs),exy(mgs,il,lc),vt,xdia(mgs,ic,1),   &
+!     &   rho0(mgs),qsign,ftelwc,qconkq,qconm,qconn,idelq,rarfac
+!      ENDIF
+      
+!      IF ( lis > 1 .and. ic == lis .and. il == lh ) THEN
+!       IF ( cxacy(mgs,il,ic) > 1. .and. qcwtmp(mgs) > 0.05e-3 ) THEN
+!       write(0,*) 'called saundx: ',igs(mgs),kgs(mgs),il,lc,isaund,temcg(mgs),qcwtmp(mgs),exy(mgs,il,lc),vt,xdia(mgs,ic,1),   &
+!     &   rho0(mgs),qsign,ftelwc,qconkq,qconm,qconn,idelq,rarfac
+!       ENDIF
+!      ENDIF
+
+      ELSE
+        vt = vtxbar(mgs,il,1) - vtxbar(mgs,lc,1)
+        
+      call saundy(isaund,temcg(mgs),qcwtmp(mgs),rarx(mgs,il),vt,xdia(mgs,ic,1),   &
+     &   rho0(mgs),qsign,ftelwc,qconkq,qconm,qconn,idelq)
+
+!      call saund(temcg(mgs),qcwtmp(mgs),eglw(mgs),xdia(mgs,ic,1),
+!     >     rho0(mgs),qsign,ftelwc,qconkq,qconm,qconn,idelq)
+      ENDIF
+
+      cfce15 = 1.0e-15
+      scxacy(mgs,il,ic) = qconkq*(xdia(mgs,ic,1)**qconm)   &
+     &  *((abs(vtxbar(mgs,il,1)-vtxbar(mgs,ic,1)))**qconn)   &
+     &  *ftelwc*cfce15
+      if ( scxacy(mgs,il,ic) .gt. 0.0 ) then ! {
+      scxacy(mgs,il,ic) = min(delqxxa(ic),scxacy(mgs,il,ic))
+      end if
+      if ( scxacy(mgs,il,ic) .lt. 0.0 ) then
+      scxacy(mgs,il,ic) = max(delqnxa(ic),scxacy(mgs,il,ic))
+      end if ! }
+      end if ! }
+!
+      if ( nonigrd .ge. 2 ) then
+      IF ( dellwc(mgs) /= 0.0 ) THEN
+      scxacy(mgs,il,ic) =    &
+     & ( (7.3)*rgard1   &
+     & * dellwc(mgs)*sctem(mgs)*(xdia(mgs,ic,1)**4)   &
+     & * (abs(vtxbar(mgs,il,1)-vtxbar(mgs,ic,1))**3) )
+      ELSE
+       scxacy(mgs,il,ic) = 0.0
+      ENDIF
+      
+      if ( scxacy(mgs,il,ic) .gt. 0.0 ) then
+      scxacy(mgs,il,ic) = min(delqxxa(ic),scxacy(mgs,il,ic))
+      end if
+      if ( scxacy(mgs,il,ic) .lt. 0.0 ) then
+      scxacy(mgs,il,ic) = max(delqnxa(ic),scxacy(mgs,il,ic))
+      end if
+      end if
 !
-!     end do
+      if ( nonigrd .eq. 3 ) then
+      if ( scxacy(mgs,il,ic) .gt. 0 )  scxacy(mgs,il,ic) = delqxxa(ic)
+      if ( scxacy(mgs,il,ic) .lt. 0 )  scxacy(mgs,il,ic) = delqnxa(ic)
+      end if
 !
+!      sxxacy(mgs,il,ic) = scxacy(mgs,il,ic)
 !
-! ICE MULTIPLICATION FROM SNOW
-!   Lo and Passarelli 82 / Willis and Heymsfield 89 / Schuur and Rutledge 00b
-!   using kfrag as fragmentation rate (s-1) / 500 microns as char mean diam for max snow mix ratio
+! Formula 7 in M05 to get total space charge per collisions within a grid box
+      IF ( .true. ) THEN
+      tmp = scxacy(mgs,il,ic)
+      scxacy(mgs,il,ic) =   &
+     &  cxacy(mgs,il,ic)*ecollmx*(1.0-exy(mgs,il,ic))*scxacy(mgs,il,ic) !   &
+!     &  *exy(mgs,il,ic)*(1./(exy(mgs,il,ic)+eps))
+!      IF ( igs(mgs) == 43 .and. kgs(mgs) == 47 ) THEN
+!      write(0,*) 'scxacy: ',igs(mgs),kgs(mgs),il,ic,isaund,tmp,scxacy(mgs,il,ic),temcg(mgs), &
+!     & qcwtmp(mgs),exy(mgs,il,ic),vt,xdia(mgs,ic,1),   &
+!     &   rho0(mgs),qsign,ftelwc,qconkq,qconm,qconn,idelq,rarfac
+!      ENDIF
+      ELSE
+      scxacy(mgs,il,ic) =   &
+     &  cxacy(mgs,il,ic)*Min(ecollmx,1.0-exy(mgs,il,ic))*scxacy(mgs,il,ic)   &
+     &  *(1./(exy(mgs,il,ic)+eps))
+      ENDIF
+
+     
+      IF ( Abs( scxacy(mgs,il,ic) ) .gt. scxacymax ) THEN
+           scxacy(mgs,il,ic) = Min(scxacymax, Max( -scxacymax, scxacy(mgs,il,ic) ) )
+      ENDIF
 !
-      csmul(:) = 0.0
-      qsmul(:) = 0.0
+      end if ! } temperture allows mixed phase
+
+!
+! charging with no liquid water (Mitzeva).  Only allow when ssi >= 1, i.e., for the case of deposition growth
+!
+      IF ( nic_noliq .ne. 0 .and. scxacy(mgs,il,ic) .eq. 0.0 .and. temg(mgs) .lt. tfr ) THEN  ! will overwrite pre-existing charge sep rate if no scxacy test
+        IF ( ssi(mgs) .ge. 1.0 ) THEN
+
+         vt = vtxbar(mgs,il,1) - vtxbar(mgs,ic,1)
+        
+         call saundmst(temcg(mgs),ssi(mgs),vt,xdia(mgs,ic,1),rho0(mgs),   &
+     &     qsign,ftelwc,qcwtmp(mgs),exy(mgs,il,lc),   &
+     &     qconkq,qconm,qconn,idelq,rarfac)
+
+!      subroutine saundmst(temcg,ssi(mgs),vt,awdia,rho0,
+!                          qsign,ftrar,qcw,exw,
+!                          qconkq,qconm,qconn,idelq,rarfac)
+
+        cfce15 = 1.0e-15
+        ftelwc = qsign*qc_noliq ! qmst
       
-      IF ( isnwfrac /= 0 ) THEN
-      do mgs = 1,ngscnt
-       IF (temg(mgs) .gt. 265.0) THEN !{
-        if (xdia(mgs,ls,1) .gt. 100.e-6 .and. xdia(mgs,ls,1) .lt. 2.0e-3) then  ! equiv diameter 100microns to 2mm
+        scxacy(mgs,il,ic) = qconkq*(xdia(mgs,ic,1)**qconm)   &
+     &                            *((abs(vt))**qconn)*ftelwc*cfce15     ! MST, eqn 1
+        if ( scxacy(mgs,il,ic) .gt. 0.0 ) then
+         scxacy(mgs,il,ic) = min(delqxxa(ic),scxacy(mgs,il,ic))
+        end if
+        if ( scxacy(mgs,il,ic) .lt. 0.0 ) then
+         scxacy(mgs,il,ic) = max(delqnxa(ic),scxacy(mgs,il,ic))
+        end if
 
-        tmp = rhoinv(mgs)*pi*xdn(mgs,ls)*cx(mgs,ls)*(500.e-6)**3
-        qsmul(mgs) = Max( kfrag*( qx(mgs,ls) - tmp ) , 0.0 )
+!        scxacy(mgs,il,ic) =   &
+!     &    cxacy(mgs,il,ic)*Min(ecollmx,1.0-exy(mgs,il,ic))*scxacy(mgs,il,ic)   &
+!     &    *(1./(exy(mgs,il,ic)+eps))
+        scxacy(mgs,il,ic) =   &
+     &    cxacy(mgs,il,ic)*ecollmx*(1.0-exy(mgs,il,ic))*scxacy(mgs,il,ic) 
 
-        qsmul(mgs) = Min( qxmxd(mgs,li), qsmul(mgs) )
-        csmul(mgs) = Min( cxmxd(mgs,li), rho0(mgs)*qsmul(mgs)/mfrag )
+          
+        IF ( ny .eq. 2 .and. scxacy(mgs,il,ic) .ne. 0.0 ) THEN
+           cntnic_noliq = cntnic_noliq + 1
+           q_noliqmn = Min( q_noliqmn, scxacy(mgs,il,ic) )
+           q_noliqmx = Max( q_noliqmx, scxacy(mgs,il,ic) )
+           
+           IF ( il == ls .and. ic == li ) THEN
+             scsacimn = Min( scsacimn, scxacy(mgs,il,ic) )
+             scsacimx = Max( scsacimx, scxacy(mgs,il,ic) )
+           ENDIF
+           
+        ENDIF
 
-        endif
-       ENDIF !}
-      enddo
-      ENDIF
+        ENDIF !ssi
+
+      ENDIF !nic_noliq
+
+      end if ! } qx(mgs,il) .gt. qxmin(il) .and. qx(mgs,ic) .gt. qxmin(ic)
 
 !
-!  frozen rain-rain interaction....
-!
-!
+      end do !mgs
+      
+      ENDIF ! iexy(il,ic) .eq. 1 .and. il .ne. ic 
+      
+      ENDDO !ic
+      ENDDO !il
+
 !
+!  End of ice-ice loop
 !
-!  rain-ice interaction
+
+
+
+!     FILL SCX Arrays otherwise ALLOC can screw things up. Cannot set them to 0 as they are used.
+!   total space charge ! dont forget to repass array back to AN( as this is used in the driver
+
+
+
 !
+! Loop for graupel-droplet inductive charging
+!  Mansell et al 2005, adapted from Ziegler et al 1991
+
+      IF ( erbnd .gt. 0.0 .and. fdgt .gt. 0.0 .and. ipelec .ge. 3 ) THEN
+      
+      DO il=ls,lhab
 !
+      IF ( iexy(il,lc) .eq. 1 ) THEN
+
+      if ( ndebug .ge. 1 ) write(iunit,*) 'elec 19'
+
       do mgs = 1,ngscnt
-      qracif(mgs) = qraci(mgs)
-      cracif(mgs) = craci(mgs)
-!      ciacrf(mgs) = ciacr(mgs)
-      end do
 !
-! 
-!  vapor to pristine ice crystals   UP
+      if ( qx(mgs,il) .gt. qxmin(il) .and. qcwtmp(mgs) .gt. qxmin(lc)    &
+     &     .and. exy(mgs,il,lc) .gt. 0.0 .and. cx(mgs,il) > 1.e-6 ) THEN
+      IF ( temg(mgs) .gt. tindmn .and. temg(mgs) .lt. tindmx ) then
 !
+      scxacy(mgs,il,lc) =  &
+     &  0.125*pi**3*exy(mgs,il,lc)*erbnd*fdgt*(cx(mgs,il))   &
+     &  *cx(mgs,lc)*vtxbar(mgs,il,1)*6.0/gf4p5*(xdia(mgs,lc,1)**2)   &
+     &  *( pi*eperao*costhe*dezcomp(mgs)   &
+     &      *gf3p5*(xdia(mgs,il,1)**2)   &
+     &     - (1.0/3.0)*gf1p5*scx(mgs,il)/cx(mgs,il) ) ! must use from previous time step
+        
+        
+!        scxacy(mgs,il,lc) = 0.0
+        
+!    !     makes sure scxacy does nto go over |delqxw|.
+
+      if ( scxacy(mgs,il,lc) .gt. 0.0 ) then
+        scxacy(mgs,il,lc) = min(delqxw,scxacy(mgs,il,lc))
+      elseif ( scxacy(mgs,il,lc) .lt. 0.0 ) then
+!        IF ( scxacy(mgs,il,lc) < delqnw ) THEN
+!          write(0,*) 'big inductive: il = ',il,scxacy(mgs,il,lc),temcg(mgs),kgs(mgs)
+!          write(0,*) 'cx,vtxbar,scx = ',cx(mgs,il),vtxbar(mgs,il,1),scx(mgs,il),xdia(mgs,lc,1)
+!        ENDIF
+        scxacy(mgs,il,lc) = max(delqnw,scxacy(mgs,il,lc))
+      end if
+
+!       if (abs(scxacy(mgs,il,lc)).gt.0.) write(0,*) 'GT0',cx(mgs,il),cx(mgs,lc),vtxbar(mgs,il,1),xdia(mgs,lc,1),dezcomp(mgs),xdia(mgs,il,1),scx(mgs,il) 
+
+      ELSE
+
+       scxacy(mgs,il,lc) = 0.0
+
+      end if
+      ENDIF
 !
+!      end if
+!      end if
+
+      end do  ! mgs
+
+      ENDIF
+
+      ENDDO  ! il
+
+      ENDIF ! erbnd
+
+     ENDIF ! boundary check on y
+
+!      if (MAXVAL(scxacy(:,ls,lc)).gt.0.) write(0,*)'dezcomp',MAXVAL(dezcomp),MAXLOC(dezcomp),MINVAL(dezcomp),MINLOC(dezcomp)
+!      if (MAXVAL(scxacy(:,ls,lc)).gt.0.) write(0,*) 'scxacy(mgs,ls,lc)',MAXVAL(scxacy(:,ls,lc)),MAXLOC(scxacy(:,ls,lc)),MINVAL(scxacy(:,ls,lc)),MINLOC(scxacy(:,ls,lc))
+
+
+!  SET INDUC to ZERO:
+
+!      DO il=ls,lhab
+!      DO mgs = 1,ngscnt
+!      if (abs(scxacy(mgs,il,lc)).le.delqxw) scxacy(mgs,il,lc)=0.
+!      ENDDO
+!      ENDDO
+
+
+      DO mgs = 1,ngscnt
+
+      IF ( igs(mgs)+its-1.gt.(ids+2) .and. igs(mgs)+its-1.lt.(ide-2)  ) THEN
+      
+      scsacw(mgs) = elecfac*scxacy(mgs,ls,lc)
+      scsaci(mgs) = elecfac*scxacy(mgs,ls,li)
+      scsacr(mgs) = elecfac*scxacy(mgs,ls,lr)
+
+      schacw(mgs) = elecfac*scxacy(mgs,lh,lc)
+      schaci(mgs) = elecfac*scxacy(mgs,lh,li)
+      IF ( lis > 1 ) schacis(mgs) = elecfac*scxacy(mgs,lh,lis)
+!      IF ( lis > 1 ) THEN
+!        IF ( qx(mgs,lis) > qxmin(lis) .and. qx(mgs,lh) > qxmin(lh) .and. qcwtmp(mgs) > qxmin(lc) ) THEN
+!          write(0,*) 'schacis,i,j,k= ',schacis(mgs),igs(mgs)+ixbeg-1,jgs+jybeg-1,kgs(mgs),qx(mgs,lis),qx(mgs,lh),chacis0(mgs),cxacy(mgs,lh,lis),iexy(lh,lis)
+!        ENDIF
+!      ENDIF
+      schacs(mgs) = elecfac*scxacy(mgs,lh,ls)
+      schacr(mgs) = elecfac*scxacy(mgs,lh,lr)
+      
+      
+      IF ( lhl .gt. 1 ) THEN
+      schlacw(mgs) = elecfac*scxacy(mgs,lhl,lc)
+      schlaci(mgs) = elecfac*scxacy(mgs,lhl,li)
+      IF ( lis  > 1 ) schlacis(mgs) = elecfac*scxacy(mgs,lhl,lis)
+      schlacs(mgs) = elecfac*scxacy(mgs,lhl,ls)
+      schlacr(mgs) = elecfac*scxacy(mgs,lhl,lr)
+      ENDIF
+      
+      ELSE
+      
+      scsacw(mgs) = 0.0
+      scsaci(mgs) = 0.0
+      scsacr(mgs) = 0.0
+
+      schacw(mgs) = 0.0
+      schaci(mgs) = 0.0
+      IF ( lis > 1 ) schacis(mgs) = 0.0
+      schacs(mgs) = 0.0
+      schacr(mgs) = 0.0
+      
+      IF ( lhl .gt. 1 ) THEN
+      schlacw(mgs) = 0.0
+      schlaci(mgs) = 0.0
+      IF ( lis > 1 ) schlacis(mgs) = 0.0
+      schlacs(mgs) = 0.0
+      schlacr(mgs) = 0.0
+      ENDIF
+      
+      ENDIF ! x boundary check
+
+      ENDDO  ! ngscnt
+
+
+      ENDIF  ! ipelec >= 1
+
+
 !
-!  compute the nucleation rate
+!  Ventilation coeficients
 !
-!     do mgs = 1,ngscnt
-!     idqis = 0
-!     if ( ssi(mgs) .gt. 1.0 ) idqis = 1
-!     fiinit(mgs) = (felv(mgs)**2)/(cp*rw)
-!     dqisdt(mgs) = (qx(mgs,lv)-qis(mgs))/
-!    >  (1.0 + fiinit(mgs)*qis(mgs)/tsqr(mgs))
-!     qidsvp(mgs) = dqisdt(mgs)
-!     cnnt = min(cnit*exp(-temcg(mgs)*bta1),1.0e+09)
-!     qiint(mgs) = 
-!    >  il5(mgs)*idqis*(1.0/dtp)
-!    <  *min((6.88e-13)*cnnt/rho0(mgs), 0.25*dqisdt(mgs)) 
-!     end do
+      do mgs = 1,ngscnt
+      fvent(mgs) = (fschm(mgs)**(1./3.)) * (fakvisc(mgs)**(-0.5))
+      end do
 !
-!  Meyers et al. (1992; JAS) and Ferrier (1994) primary ice nucleation
 !
-      cmassin = cimasn  ! 6.88e-13
+      if ( ndebug .gt. 0 ) write(0,*) 'civent'
+!
+      civenta = 1.258e4
+      civentb = 2.331
+      civentc = 5.662e4
+      civentd = 2.373
+      civente = 0.8241
+      civentf = -0.042
+      civentg = 1.70
+
       do mgs = 1,ngscnt
-      qiint(mgs) = 0.0
-      ciint(mgs) = 0.0
-      qicicnt(mgs) = 0.0
-      cicint(mgs) = 0.0
-      qipipnt(mgs) = 0.0
-      cipint(mgs) = 0.0
-      ccitmp = 0.0
-      IF ( icenucopt == 1 .or. icenucopt == -10 .or. icenucopt == -11 ) THEN
-      if ( ( temg(mgs) .lt. 268.15 .or.  &
-!     : ( imeyers5 .and. temg(mgs) .lt.  273.0) ) .and.    &
-     & ( imeyers5 .and. temg(mgs) .lt.  272.0 .and. temgkm2(mgs) .lt. tfr) ) .and.    &
-     &    ciintmx .gt. (cx(mgs,li)+ccitmp)  &
-!     :    .and. cninm(mgs) .gt. 0.   &
-     &     ) then
-      fiinit(mgs) = (felv(mgs)**2)/(cp*rw)
-      dqisdt(mgs) = (qx(mgs,lv)-qis(mgs))/   &
-     &  (1.0 + fiinit(mgs)*qis(mgs)/tsqr(mgs))
-!      qidsvp(mgs) = dqisdt(mgs)
-      idqis = 0
-      if ( ssi(mgs) .gt. 1.0 ) THEN
-      idqis = 1 
-      dzfacp = max( float(kgsp(mgs)-kgs(mgs)), 0.0 )
-      dzfacm = max( float(kgs(mgs)-kgsm(mgs)), 0.0 )
-      qiint(mgs) =   &
-     &  idqis*il5(mgs)   &
-     &  *(cmassin/rho0(mgs))   &
-     &  *max(0.0,wvel(mgs))   &
-     &  *max((cninp(mgs)-cninm(mgs)),0.0)/gz(igs(mgs),jgs,kgs(mgs))   &
-     &  /((dzfacp+dzfacm))
+      IF ( icond .eq. 1 .or. temg(mgs) .le. tfrh    &
+     &      .or. (qx(mgs,lr) .le. qxmin(lr) .and. qx(mgs,lc) .le. qxmin(lc)) ) THEN
+      IF ( qx(mgs,li) .gt. qxmin(li) ) THEN
+      cireyn =   &
+     &  (civenta*xdia(mgs,li,1)**civentb   &
+     &  +civentc*xdia(mgs,li,1)**civentd)   &
+     &  /   &
+     &  (civente*xdia(mgs,li,1)**civentf+civentg)
+      xcivent = (fschm(mgs)**(1./3.))*((cireyn/fakvisc(mgs))**0.5)
+      if ( xcivent .lt. 1.0 ) then
+      civent(mgs) = 1.0 + 0.14*xcivent**2
+      end if
+      if ( xcivent .ge. 1.0 ) then
+      civent(mgs) = 0.86 + 0.28*xcivent
+      end if
+      ELSE
+       civent(mgs) = 0.0
+      ENDIF
+
+
+      ENDIF ! icond .eq. 1
+      end do
 
-      qiint(mgs) = min(qiint(mgs), max(0.25*dqisdt(mgs),0.0)) 
-      ciint(mgs) = qiint(mgs)*rho0(mgs)/cmassin
 !
-! limit new crystals so it does not increase the current concentration
-!  above ciintmx 20,000 per liter (2.e7 per m**3)
 !
-!      ciintmx = 1.e9
-!      ciintmx = 1.e9
-      IF ( icenucopt /= -10 ) THEN
-      
-        IF ( lcin > 1 ) THEN
-          ciint(mgs) = Min(ciint(mgs), ccin(mgs))
-          ccin(mgs) = ccin(mgs) - ciint(mgs)
-          qiint(mgs) = ciint(mgs)*cmassin/rho0(mgs)
-        ELSEIF ( lcina > 1 ) THEN
-          ciint(mgs) = Max(0.0, Min( ciint(mgs), Min( cnina(mgs), ciintmx ) - cina(mgs) ))
-          qiint(mgs) = ciint(mgs)*cmassin/rho0(mgs)
-      
-        ELSEIF ( icenucopt == 1 .and. ciint(mgs) .gt. Max(0.0, ciintmx - cx(mgs,li) - ccitmp )*dtpinv  ) THEN
-          ciint(mgs) = Max(0.0, ciintmx - (cx(mgs,li)) )*dtpinv 
-          qiint(mgs) = ciint(mgs)*cmassin/rho0(mgs)
+      igmrwa = 100.0*2.0
+      igmrwb = 100.*((5.0+br)/2.0)
+      rwventa = (0.78)*gmoi(igmrwa)  ! 0.78
+      rwventb = (0.308)*gmoi(igmrwb) ! 0.562825
+      do mgs = 1,ngscnt
+      IF ( qx(mgs,lr) .gt. qxmin(lr) ) THEN
+        IF ( ipconc .ge. 3 ) THEN
+          IF ( imurain == 3 ) THEN
+           IF ( izwisventr == 1 ) THEN
+            rwvent(mgs) = ventrx(mgs)*(1.6 + 124.9*(1.e-3*rho0(mgs)*qx(mgs,lr))**.2046)
+           ELSE ! izwisventr = 2
+!  Following Wisner et al. (1972) but using gamma of volume. Note that Ferrier rain fall speed does not integrate with gamma of volume, so using Vr = ar*d^br
+          rwvent(mgs) =   &
+     &  (0.78*ventrx(mgs) + 0.308*ventrxn(mgs)*fvent(mgs)   &
+     &   *Sqrt((ar*rhovt(mgs)))   &
+     &    *(xdia(mgs,lr,1)**((1.0+br)/2.0)) )
+           ENDIF
 
-        ELSEIF ( icenucopt == -11 .and. dtp*ciint(mgs) .gt. ( cnina(mgs) - (cx(mgs,li) - ccitmp))) THEN
-          ciint(mgs) = Max(0.0,  cnina(mgs) - (cx(mgs,li)+ccitmp)*dtpinv )
-          qiint(mgs) = ciint(mgs)*cmassin/rho0(mgs)
+          ELSE ! imurain == 1
+       ! linear interpolation of complete gamma function
+!        tmp = 2. + alpha(mgs,lr)
+!        i = Int(dgami*(tmp))
+!        del = tmp - dgam*i
+!        x = gmoi(i) + (gmoi(i+1) - gmoi(i))*del*dgami
 
-        ENDIF
-      ENDIF
-      
-      end if
-      endif
+        IF ( iferwisventr == 1 ) THEN
 
-      ELSEIF ( icenucopt == 2 .or. icenucopt == -1 .or. icenucopt == -2 ) THEN
-      
-        IF ( ( temg(mgs) .lt. 268.15 .and. ssw(mgs) > 1.0 ) .or. ssi(mgs) > 1.25 ) THEN
-          IF ( lcin > 1 ) THEN
-           ciint(mgs) = Min(cnina(mgs), ccin(mgs))
-           ciint(mgs) = Min( ciint(mgs), Max(0.0, ciintmx - (cx(mgs,li) - ccitmp) ) ) ! do not initiate ice beyond concentration of ciintmx
-           ccin(mgs) = ccin(mgs) - ciint(mgs)
-           ciint(mgs) = ciint(mgs)*dtpinv ! convert total initiation to a rate
-          ELSE
-           ciint(mgs) = Max( 0.0, cnina(mgs) - cina(mgs) )*dtpinv
-          ENDIF
-          qiint(mgs) = ciint(mgs)*cmassin/rho0(mgs)
+  ! Ferrier fall speed in the ventillation term [uses fx(lr) ]
+  
+        alpr = Min(alpharmax,alpha(mgs,lr) )
 
-          fiinit(mgs) = (felv(mgs)**2)/(cp*rw)
-          dqisdt(mgs) = (qx(mgs,lv)-qis(mgs))/(1.0 + fiinit(mgs)*qis(mgs)/tsqr(mgs))
-          qiint(mgs) = min(qiint(mgs), max(0.25*dqisdt(mgs),0.0))
-          ciint(mgs) = qiint(mgs)*rho0(mgs)/cmassin
-        ENDIF
-      
-      
-      
-      ELSEIF ( icenucopt == 3 ) THEN
-        IF (  temg(mgs) .lt. 268.15 ) THEN
-          IF ( lcin > 1 ) THEN
-           ciint(mgs) = Min(cnina(mgs), ccin(mgs))
-           ciint(mgs) = Min( ciint(mgs), Max(0.0, ciintmx - (cx(mgs,li) + ccitmp) ) ) ! do not initiate ice beyond concentration of ciintmx
-           ccin(mgs) = ccin(mgs) - ciint(mgs)
-           ciint(mgs) = ciint(mgs)*dtpinv ! convert total initiation to a rate
-          ELSE
-           ciint(mgs) = Max( 0.0, cnina(mgs) - cina(mgs) )*dtpinv
-          ENDIF
-          qiint(mgs) = ciint(mgs)*cmassin/rho0(mgs)
+        x =  1. + alpha(mgs,lr)
+
+        IF ( lzr > 1 ) THEN ! 3 moment
+! 
+        ELSE
+         y = ventrxn(mgs)
         ENDIF
 
+!         vent1 = dble(xdia(mgs,lr,1))**(-2. - alpr) ! Actually OK
+!         vent2 = dble(1./xdia(mgs,lr,1) + 0.5*fx(lr))**dble(2.5+alpr+0.5*bx(lr))  ! Actually OK
+         vent1 = dble(xdia(mgs,lr,1))**(0.5 + 0.5*bx(lr)) ! 2016.2.26 Changed for consistency with derivation (recast formula -- should be equivalent)
+         vent2 = dble(1. + 0.5*fx(lr)*xdia(mgs,lr,1))**dble(2.5+alpr+0.5*bx(lr))
+        
+        
+        rwvent(mgs) =    &
+     &    0.78*x +    &
+     &    0.308*fvent(mgs)*y*   &
+     &            Sqrt(ax(lr)*rhovt(mgs))*(vent1/vent2)
+       
+
+        ELSEIF ( iferwisventr == 2 ) THEN
+          
+!  Following Wisner et al. (1972) but using gamma of volume. Note that Ferrier rain fall speed does not integrate with gamma of volume, so using Vr = ar*d^br
+         x =  1. + alpha(mgs,lr)
+
+           rwvent(mgs) =   &
+     &  (0.78*x + 0.308*ventrxn(mgs)*fvent(mgs)   &
+     &   *Sqrt((ar*rhovt(mgs)))   &
+     &    *(xdia(mgs,lr,1)**((1.0+br)/2.0)) )
+
+
+          
+          ENDIF ! iferwisventr
+          
+          ENDIF ! imurain
+        ELSE
+         rwvent(mgs) =   &
+     &  (rwventa + rwventb*fvent(mgs)   &
+     &   *Sqrt((ar*rhovt(mgs)))   &
+     &    *(xdia(mgs,lr,1)**((1.0+br)/2.0)) )
+        ENDIF
+      ELSE
+       rwvent(mgs) = 0.0
       ENDIF
-!
-      if ( xplate(mgs) .eq. 1 ) then
-      qipipnt(mgs) = qiint(mgs)
-      cipint(mgs) = ciint(mgs)
-      end if
-!
-      if ( xcolmn(mgs) .eq. 1 ) then
-      qicicnt(mgs) = qiint(mgs)
-      cicint(mgs) = ciint(mgs)
-      end if
-!
-!     qipipnt(mgs) = 0.0
-!     qicicnt(mgs) = qiint(mgs)
-!
       end do
 !
-! 
-
-!
-!  vapor to cloud droplets   UP
-!
-      if (ndebug .gt. 0 ) write(0,*) 'dbg = 8'
-!
-!
-      if (ndebug .gt. 0 ) write(0,*) 'Collection: set 3-component'
-!
-!  time for riming....
-!
-!     rimtim = 240.0
-!     dtrim = rimtim
-!     xacrtim  = 120.0
-!     tranfr = 0.50
-!     tranfw = 0.50
-!
-!  coefficients for riming
-!
-!     rimc1 = 300.00
-!     rimc2 = 0.44
-!
-! 
-!  zero som arrays
-!
-!
+      igmswa = 100.0*2.0
+      igmswb = 100.*((5.0+ds)/2.0)
+      swventa = (0.78)*gmoi(igmswa)
+      swventb = (0.308)*gmoi(igmswb)
       do mgs = 1,ngscnt
-      qrshr(mgs) = 0.0
-      qsshrp(mgs) = 0.0
-      qhshrp(mgs) = 0.0
+      IF ( qx(mgs,ls) .gt. qxmin(ls) ) THEN
+      IF ( ipconc .ge. 4 ) THEN
+      swvent(mgs) = 0.65 + 0.44*fvent(mgs)*Sqrt(vtxbar(mgs,ls,1)*xdia(mgs,ls,1))
+      ELSE
+! 10-ice version:
+       swvent(mgs) =   &
+     &  (swventa + swventb*fvent(mgs)   &
+     &   *Sqrt((cs*rhovt(mgs)))   &
+     &   *(xdia(mgs,ls,1)**((1.0+ds)/2.0)) )
+      ENDIF
+      ELSE
+      swvent(mgs) = 0.0
+      ENDIF
       end do
 !
 !
-!  first sum all of the shed rain
-!
-!
+
+      igmhwa = 100.0*2.0
+      igmhwb = 100.0*2.75
+      hwventa = (0.78)*gmoi(igmhwa)
+      hwventb = (0.308)*gmoi(igmhwb)
+      hwventc = (4.0*gr/(3.0*cdx(lh)))**(0.25)
       do mgs = 1,ngscnt
-      qrshr(mgs) = qsshr(mgs) + qhshr(mgs) + qhlshr(mgs)
-      crshr(mgs) = chshrr(mgs)/rzxh(mgs) + chlshrr(mgs)/rzxhl(mgs)
-      IF ( ipconc .ge. 3 ) THEN
-!       crshr(mgs) = Max(crshr(mgs), rho0(mgs)*qrshr(mgs)/(xdn(mgs,lr)*vr1mm) )
-      ENDIF
-      end do 
-!
-!
-!
+      IF ( qx(mgs,lh) .gt. qxmin(lh) ) THEN
+       IF ( .false. .or. alpha(mgs,lh) .eq. 0.0 ) THEN
+        hwvent(mgs) =   &
+     &  ( hwventa + hwventb*hwventc*fvent(mgs)   &
+     &    *((xdn(mgs,lh)/rho0(mgs))**(0.25))   &
+     &    *(xdia(mgs,lh,1)**(0.75)))
+       ELSE ! Ferrier 1994, eq. B.36
+       ! linear interpolation of complete gamma function
+!        tmp = 2. + alpha(mgs,lh)
+!        i = Int(dgami*(tmp))
+!        del = tmp - dgam*i
+!        x = gmoi(i) + (gmoi(i+1) - gmoi(i))*del*dgami
+        
+! note that hwvent includes a division by Gamma(1+alpha), so Gamma(2+alpha)/Gamma(1+alpha) = 1 + alpha
+! and g1palp = Gamma(1+alpha) divides into y
+        x =  1. + alpha(mgs,lh)
 
-!
-!
-!
-!
-      IF ( ipconc .ge. 1 ) THEN
-!
-!
-!  concentration production terms
-!
-!  YYY
-!
-!
-!       DO mgs = 1,ngscnt
-       pccwi(:) = 0.0
-       pccwd(:) = 0.0
-       pccii(:) = 0.0
-       pccin(:) = 0.0
-       pccid(:) = 0.0
-       pcisi(:) = 0.0
-       pcisd(:) = 0.0
-       pcrwi(:) = 0.0
-       pcrwd(:) = 0.0
-       pcswi(:) = 0.0
-       pcswd(:) = 0.0
-       pchwi(:) = 0.0
-       pchwd(:) = 0.0
-       pchli(:) = 0.0
-       pchld(:) = 0.0
-!       ENDDO
-!
-!  Cloud ice
-!
-!      IF ( ipconc .ge. 1 ) THEN
+        tmp = 1 + alpha(mgs,lh)
+        i = Int(dgami*(tmp))
+        del = tmp - dgam*i
+        g1palp = gmoi(i) + (gmoi(i+1) - gmoi(i))*del*dgami
 
-      IF ( warmonly < 0.5 ) THEN
-      IF ( ffrzs < 1.0 ) THEN
-      do mgs = 1,ngscnt
-      pccii(mgs) =   &
-     &   il5(mgs)*cicint(mgs)  &
-     &  +il5(mgs)*(cwfrzc(mgs)+cwctfzc(mgs)   &
-     &  +cicichr(mgs))   &
-     &  +chmul1(mgs)   &
-     &  +chlmul1(mgs)    &
-     &  + csplinter(mgs) + csplinter2(mgs)   &
-     &  +csmul(mgs)
-     
-       pccii(mgs) = pccii(mgs)*(1.0 - ffrzs)
+        tmp = 2.5 + alpha(mgs,lh) + 0.5*bxh(mgs)
+        i = Int(dgami*(tmp))
+        del = tmp - dgam*i
+        y = (gmoi(i) + (gmoi(i+1) - gmoi(i))*del*dgami)/g1palp
+        
+        
+        hwventy(mgs) = 0.308*fvent(mgs)*(xdia(mgs,lh,1)**(0.5 + 0.5*bxh(mgs)))*Sqrt(axh(mgs)*rhovt(mgs)) 
+        hwvent(mgs) =    &
+     &  ( 0.78*x +  y*hwventy(mgs) ) !   &
+!     &    0.308*fvent(mgs)*y*(xdia(mgs,lh,1)**(0.5 + 0.5*bxh(mgs)))*   &
+!     &            Sqrt(axh(mgs)*rhovt(mgs)) )
        
-!     >  + nsplinter*(crfrzf(mgs) + crfrz(mgs))
-      pccid(mgs) =   &
-     &   il5(mgs)*(-cscni(mgs) - cscnvi(mgs) & ! - cwaci(mgs)   &
-     &  -craci(mgs)    &
-     &  -csaci(mgs)   &
-     &  -chaci(mgs) - chlaci(mgs)   &
-     &  -chcni(mgs))   &
-     &  +il5(mgs)*cisbv(mgs)   &
-     &  -(1.-il5(mgs))*cimlr(mgs)
-
-      pccin(mgs) = ciint(mgs)
-      
-
+       ENDIF
+      ELSE
+      hwvent(mgs) = 0.0
+      hwventy(mgs) = 0.0
+      ENDIF
       end do
-      ENDIF ! ffrzs
-      ELSEIF ( warmonly < 0.8 ) THEN
-      do mgs = 1,ngscnt
-      
-!      qiint(mgs) = 0.0
-!      cicint(mgs) = 0.0
-!      qicicnt(mgs) = 0.0
       
-      pccii(mgs) =   &
-     &   il5(mgs)*cicint(mgs)   &
-     &  +il5(mgs)*(cwfrzc(mgs)+cwctfzc(mgs)   &
-     &  +cicichr(mgs))   &
-     &  +chmul1(mgs)   &
-     &  +chlmul1(mgs)    &
-     &  + csplinter(mgs) + csplinter2(mgs)   &
-     &  +csmul(mgs)
-     
-       pccii(mgs) = pccii(mgs)*(1. - ffrzs)
-      pccid(mgs) =   &
-!     &   il5(mgs)*(-cscni(mgs) - cscnvi(mgs) & ! - cwaci(mgs)   &
-!     &  -craci(mgs)    &
-!     &  -csaci(mgs)   &
-!     &  -chaci(mgs) - chlaci(mgs)   &
-!     &  -chcni(mgs))   &
-     &  +il5(mgs)*cisbv(mgs)   &
-     &  -(1.-il5(mgs))*cimlr(mgs)
-
-      pccin(mgs) = ciint(mgs)
-
-      end do
-      ENDIF ! warmonly
+      hlvent(:) = 0.0
+      hlventy(:) = 0.0
 
-      
-!      ENDIF ! ( ipconc .ge. 1 )
-!
-!  Cloud water
-!
-      IF ( ipconc .ge. 2 ) THEN
-      
+      IF ( lhl .gt. 1 ) THEN
+      igmhwa = 100.0*2.0
+      igmhwb = 100.0*2.75
+      hwventa = (0.78)*gmoi(igmhwa)
+      hwventb = (0.308)*gmoi(igmhwb)
+      hwventc = (4.0*gr/(3.0*cdx(lhl)))**(0.25)
       do mgs = 1,ngscnt
-      pccwi(mgs) =  (0.0) ! + (1-il5(mgs))*(-cirmlw(mgs))
-      
-      IF ( warmonly < 0.5 ) THEN
-      pccwd(mgs) =    &
-     &  - cautn(mgs) +   &
-     &  il5(mgs)*(-ciacw(mgs)-cwfrzp(mgs)-cwctfzp(mgs)   &
-     &  -cwfrzc(mgs)-cwctfzc(mgs)   &
-     &   )   &
-     &  -cracw(mgs) -csacw(mgs)  -chacw(mgs) - chlacw(mgs)
-      ELSEIF ( warmonly < 0.8 ) THEN
-      pccwd(mgs) =    &
-     &  - cautn(mgs) +   &
-     &  il5(mgs)*(  &
-     & -ciacw(mgs)-cwfrzp(mgs)-cwctfzp(mgs)   &
-     &  -cwfrzc(mgs)-cwctfzc(mgs)   &
-     &   )   &
-     &  -cracw(mgs) -chacw(mgs) -chlacw(mgs) 
-      ELSE
-      
-!       tmp3d(igs(mgs),jy,kgs(mgs)) = crcnw(mgs)
+      IF ( qx(mgs,lhl) .gt. qxmin(lhl) ) THEN
 
-!       cracw(mgs) = 0.0 ! turn off accretion
-!       qracw(mgs) = 0.0
-!       crcev(mgs) = 0.0 ! turn off evap
-!       qrcev(mgs) = 0.0 ! turn off evap
-!       cracr(mgs) = 0.0 ! turn off self collection
-       
-       
-!       cautn(mgs) = 0.0 
-!       crcnw(mgs) = 0.0
-!       qrcnw(mgs) = 0.0
+       IF ( .false. .or. alpha(mgs,lhl) .eq. 0.0 ) THEN
+        hlvent(mgs) =   &
+     &  ( hwventa + hwventb*hwventc*fvent(mgs)   &
+     &    *((xdn(mgs,lhl)/rho0(mgs))**(0.25))   &
+     &    *(xdia(mgs,lhl,1)**(0.75)))
+       ELSE ! Ferrier 1994, eq. B.36
+       ! linear interpolation of complete gamma function
+!        tmp = 2. + alpha(mgs,lhl)
+!        i = Int(dgami*(tmp))
+!        del = tmp - dgam*i
+!        x = gmoi(i) + (gmoi(i+1) - gmoi(i))*del*dgami
 
-      pccwd(mgs) =    &
-     &  - cautn(mgs) -cracw(mgs)
-      ENDIF
+! note that hlvent includes a division by Gamma(1+alpha), so x = Gamma(2+alpha)/Gamma(1+alpha) = 1 + alpha
+! and g1palp = Gamma(1+alpha) divides into y
 
+        x =  1. + alpha(mgs,lhl)
 
-      IF ( -pccwd(mgs)*dtp .gt. cx(mgs,lc) ) THEN
-!       write(0,*) 'OUCH! pccwd(mgs)*dtp .gt. ccw(mgs) ',pccwd(mgs),cx(mgs,lc)
-!       write(0,*) 'qc = ',qx(mgs,lc)
-!       write(0,*) -ciacw(mgs)-cwfrzp(mgs)-cwctfzp(mgs)-cwfrzc(mgs)-cwctfzc(mgs)
-!       write(0,*)  -cracw(mgs) -csacw(mgs)  -chacw(mgs)
-!       write(0,*) - cautn(mgs)
+        tmp = 1 + alpha(mgs,lhl)
+        i = Int(dgami*(tmp))
+        del = tmp - dgam*i
+        g1palp = gmoi(i) + (gmoi(i+1) - gmoi(i))*del*dgami
 
-       frac = -cx(mgs,lc)/(pccwd(mgs)*dtp)
-       pccwd(mgs) = -cx(mgs,lc)/dtp
+        tmp = 2.5 + alpha(mgs,lhl) + 0.5*bxhl(mgs)
+        i = Int(dgami*(tmp))
+        del = tmp - dgam*i
+        y = (gmoi(i) + (gmoi(i+1) - gmoi(i))*del*dgami)/g1palp ! ratio of gamma functions
 
-        ciacw(mgs)   = frac*ciacw(mgs)
-        cwfrzp(mgs)  = frac*cwfrzp(mgs)
-        cwctfzp(mgs) = frac*cwctfzp(mgs)
-        cwfrzc(mgs)  = frac*cwfrzc(mgs)
-        cwctfzc(mgs) = frac*cwctfzc(mgs)
-        cwctfz(mgs) = frac*cwctfz(mgs)
-        cracw(mgs)   = frac*cracw(mgs)
-        csacw(mgs)   = frac*csacw(mgs)
-        chacw(mgs)   = frac*chacw(mgs)
-        cautn(mgs)   = frac*cautn(mgs)
-       
-        pccii(mgs) = pccii(mgs) - (1.-frac)*il5(mgs)*(cwfrzc(mgs)+cwctfzc(mgs))*(1. - ffrzs)
-        IF ( lhl .gt. 1 ) chlacw(mgs)   = frac*chlacw(mgs)
+        hlventy(mgs) = 0.308*fvent(mgs)*(xdia(mgs,lhl,1)**(0.5 + 0.5*bxhl(mgs)))*Sqrt(axhl(mgs)*rhovt(mgs)) 
+        
+        hlvent(mgs) =  0.78*x + y*hlventy(mgs)  !   &
+!     &    0.308*fvent(mgs)*y*(xdia(mgs,lhl,1)**(0.5 + 0.5*bxhl(mgs)))*   &
+!     &            Sqrt(axhl(mgs)*rhovt(mgs)))
+!     :            Sqrt(xdn(mgs,lhl)*ax(lhl)*rhovt(mgs)/rg0))/tmp
 
-!       STOP
+        ENDIF
+       ENDIF
+      end do
       ENDIF
 
+!
+!
+!
+!  Wet growth constants
+!
+      do mgs = 1,ngscnt
+      fwet1(mgs) =   &
+     & (2.0*pi)*   &
+     & ( felv(mgs)*fwvdf(mgs)*rho0(mgs)*(qss0(mgs)-qx(mgs,lv))   &
+     &  -ftka(mgs)*temcg(mgs) )   &
+     & / ( rho0(mgs)*(felf(mgs)+fcw(mgs)*temcg(mgs)) )
+      fwet2(mgs) =   &
+     &  (1.0)-fci(mgs)*temcg(mgs)   &
+     & / ( felf(mgs)+fcw(mgs)*temcg(mgs) )
       end do
-
-      ENDIF ! ipconc
-
 !
-!  Rain
+!  Melting constants
 !
-      IF ( ipconc .ge. 3 ) THEN
-
       do mgs = 1,ngscnt
+      fmlt1(mgs) = (2.0*pi)*   &
+     &  ( felv(mgs)*fwvdf(mgs)*(qss0(mgs)-qx(mgs,lv))   &
+     &   -ftka(mgs)*temcg(mgs)/rho0(mgs) )    &
+     &  / (felf(mgs))
+      fmlt2(mgs) = -fcw(mgs)*temcg(mgs)/felf(mgs)
+      end do
+!
+!  Vapor Deposition constants
+!
+      do mgs = 1,ngscnt
+      fvds(mgs) =    &
+     &  (4.0*pi/rho0(mgs))*(ssi(mgs)-1.0)*   &
+     &  (1.0/(fai(mgs)+fbi(mgs)))
+      end do
+      do mgs = 1,ngscnt
+      fvce(mgs) =    &
+     &  (4.0*pi/rho0(mgs))*(ssw(mgs)-1.0)*   &
+     &  (1.0/(fav(mgs)+fbv(mgs)))
+      end do
 
-      IF ( warmonly < 0.5 ) THEN
-      pcrwi(mgs) = &
-!     >   cracw(mgs) +    &
-     &   crcnw(mgs)   &
-     &  +(1-il5(mgs))*(   &
-     &    -chmlrr(mgs)/rzxh(mgs)   &
-     &    -chlmlrr(mgs)/rzxhl(mgs)   &
-     &    -csmlr(mgs)/rzxs(mgs)     &
-     &   - cimlr(mgs) )   &
-     &  -crshr(mgs)             !null at this point when wet snow/graupel included
-      pcrwd(mgs) =   &
-     &   il5(mgs)*(-ciacr(mgs) - crfrz(mgs) ) & ! - cipacr(mgs))
-!     >  -csacr(mgs)   &
-     &  - chacr(mgs) - chlacr(mgs)   &
-     &  +crcev(mgs)   &
-     &  - cracr(mgs)
-!     >  -il5(mgs)*ciracr(mgs)
-      ELSEIF ( warmonly < 0.8 ) THEN
-       pcrwi(mgs) = &
-     &   crcnw(mgs)   &
-     &  +(1-il5(mgs))*(   &
-     &    -chmlrr(mgs)/rzxh(mgs)    &
-     &    -chlmlrr(mgs)/rzxhl(mgs)   &
-     &    -csmlr(mgs)     &
-     &   - cimlr(mgs) )   &
-     &  -crshr(mgs)             !null at this point when wet snow/graupel included
-      pcrwd(mgs) =   &
-     &   il5(mgs)*( - crfrz(mgs) ) & ! - cipacr(mgs))
-     &  - chacr(mgs)    &
-     &  - chlacr(mgs)    &
-     &  +crcev(mgs)   &
-     &  - cracr(mgs)
-      ELSE
-      pcrwi(mgs) =   &
-     &   crcnw(mgs)
-      pcrwd(mgs) =   &
-     &  +crcev(mgs)   &
-     &  - cracr(mgs)
+!
+!  deposition, sublimation, and melting of snow, graupel and hail
+!
+      qsmlr(:) = 0.0
+      qimlr(:) = 0.0 ! this is not used. qi melts to qc way down in the code.
+      qhmlr(:) = 0.0
+      qhlmlr(:) = 0.0
+      qhmlrlg(:) = 0.0
+      qhlmlrlg(:) = 0.0
+      qhfzh(:) = 0.0
+      qhlfzhl(:) = 0.0
+      vhfzh(:) = 0.0
+      vhlfzhl(:) = 0.0
+      qsfzs(:) = 0.0
+      zsmlr(:) = 0.0
+      zhmlr(:) = 0.0
+      zhmlrr(:) = 0.0
+      zhshr(:) = 0.0
+      zhlmlr(:) = 0.0
+      zhlshr(:) = 0.0
 
-!        tmp3d(igs(mgs),jy,kgs(mgs)) = vtxbar(mgs,lr,1) ! crcnw(mgs) ! (pcrwi(mgs) + pcrwd(mgs))
-!        pcrwi(mgs) = 0.0
-!        pcrwd(mgs) = 0.0
-!        qrcnw(mgs) = 0.0
+      zhshrr(:) = 0.0
+      zhlmlrr(:) = 0.0
+      zhlshrr(:) = 0.0
+
+      csmlr(:) = 0.0
+      csmlrr(:) = 0.0
+      chmlr(:) = 0.0
+      chmlrr(:) = 0.0
+      chlmlr(:) = 0.0
+      chlmlrr(:) = 0.0
 
+      if ( .not. mixedphase ) then !{
+      do mgs = 1,ngscnt
+!
+      IF ( temg(mgs) .gt. tfr ) THEN
+      
+      IF (  qx(mgs,ls) .gt. qxmin(ls) ) THEN
+      qsmlr(mgs) =   &
+     &   min(   &
+     &  (c1sw*fmlt1(mgs)*cx(mgs,ls)*swvent(mgs)*xdia(mgs,ls,1) ) & ! /rhosm    &
+     &   , 0.0 )
       ENDIF
+      
+!       IF ( qx(mgs,ls) .gt. 0.1e-4 ) write(0,*) 'qsmlr: ',qsmlr(mgs),qx(mgs,ls),cx(mgs,ls),fmlt1(mgs),
+!     :        temcg(mgs),swvent(mgs),xdia(mgs,ls,1),qss0(mgs)-qx(mgs,lv)
+!      ELSE
+!       qsmlr(mgs) = 0.0
+!      ENDIF
+! 10ice version:
+!     >   min(
+!     >  (fmlt1(mgs)*cx(mgs,ls)*swvent(mgs)*xdia(mgs,ls,1) +
+!     >   fmlt2(mgs)*(qsacr(mgs)+qsacw(mgs)) )
+!     <   , 0.0 )
 
+      IF (  qx(mgs,lh) .gt. qxmin(lh) ) THEN
 
-      frac = 0.0
-      IF ( -pcrwd(mgs)*dtp .gt. cx(mgs,lr) ) THEN
-!       write(0,*) 'OUCH! pcrwd(mgs)*dtp .gt. crw(mgs) ',pcrwd(mgs)*dtp,cx(mgs,lr),mgs,igs(mgs),kgs(mgs)
-!       write(0,*) -ciacr(mgs)
-!       write(0,*) -crfrz(mgs)
-!       write(0,*) -chacr(mgs)
-!       write(0,*)  crcev(mgs)
-!       write(0,*)  -cracr(mgs)
+      IF ( ibinhmlr == 0 .or. lzh < 1 ) THEN
+       qhmlr(mgs) =   &
+     &   min(   &
+     &  fmlt1(mgs)*cx(mgs,lh)*hwvent(mgs)*xdia(mgs,lh,1)   &
+     &  + fmlt2(mgs)*(qhacrmlr(mgs)+qhacw(mgs))    &
+     &   , 0.0 )
+       ELSEIF ( ibinhmlr == 1 ) THEN ! use incomplete gamma functions to approximate the bin results
 
-       frac =  -cx(mgs,lr)/(pcrwd(mgs)*dtp)
-       pcrwd(mgs) = -cx(mgs,lr)/dtp
+         write(0,*) 'ibinhmlr = 1 not available for 2-moment'
+         STOP
+         
+       ELSEIF ( ibinhmlr == 2 .or. ibinhmlr == 3 ) THEN
 
-        ciacr(mgs) = frac*ciacr(mgs)
-        ciacrf(mgs) = frac*ciacrf(mgs)
-        ciacrs(mgs) = frac*ciacrs(mgs)
-        crfrz(mgs) = frac*crfrz(mgs)
-        crfrzf(mgs) = frac*crfrzf(mgs)
-        crfrzs(mgs) = frac*crfrzs(mgs)
-        chacr(mgs) = frac*chacr(mgs)
-        crcev(mgs) = frac*crcev(mgs)
-        cracr(mgs) = frac*cracr(mgs)
+       ENDIF
+       
+       
+       IF ( ivhmltsoak > 0 .and. qhmlr(mgs) < 0.0 .and. lvol(lh) > 1 .and. xdn(mgs,lh) .lt. xdnmx(lh) ) THEN
+         ! act as if 100% of the meltwater were soaked into the graupel
+           v1 = (1. - xdn(mgs,lh)/xdnmx(lh))*(vx(mgs,lh) + rho0(mgs)*qhmlr(mgs)/xdn(mgs,lh) )/(dtp) ! volume available for filling
+           v2 = -1.0*rho0(mgs)*qhmlr(mgs)/xdnmx(lh)  ! volume of melted ice if it were refrozen in the matrix
+           
+           vhsoak(mgs) = Min(v1,v2)
+           
+       ENDIF
 
-!       STOP
-      ENDIF
+      ENDIF !  qx(mgs,lh) .gt. qxmin(lh)
 
-      end do
+      
+      IF ( lhl .gt. 1  .and. lhlw < 1 ) THEN
 
-      ENDIF
+       IF ( qx(mgs,lhl) .gt. qxmin(lhl) ) THEN
+         IF ( ibinhlmlr == 0  .or. lzhl < 1) THEN
+       qhlmlr(mgs) =   &
+     &   min(   &
+     &  fmlt1(mgs)*cx(mgs,lhl)*hlvent(mgs)*xdia(mgs,lhl,1)   &
+     &  + fmlt2(mgs)*(qhlacrmlr(mgs)+qhlacw(mgs))    &
+     &   , 0.0 )
 
+       ELSEIF ( ibinhlmlr == 1 ) THEN ! use incomplete gamma functions to approximate the bin results
 
-      IF ( warmonly < 0.5 ) THEN
 
-!
-!  Snow
-!
-      IF ( ipconc .ge. 4 ) THEN !
+       ELSEIF ( ibinhlmlr == -1 ) THEN ! OLD VERSION use incomplete gamma functions to approximate the bin results
 
-      do mgs = 1,ngscnt
-      pcswi(mgs) =   &
-     &   il5(mgs)*(cscnis(mgs) + cscnvis(mgs) )    &
-     &  + cscnh(mgs)
-      
-      IF (  ffrzs > 0.0 ) THEN
-       pcswi(mgs) =  pcswi(mgs) + ffrzs* (  &
-     &   il5(mgs)*cicint(mgs)   &
-     &  +il5(mgs)*(cwfrzc(mgs)+cwctfzc(mgs)   &
-     &  +cicichr(mgs))  &
-     &  +chmul1(mgs)   &
-     &  +chlmul1(mgs)    &
-     &  + csplinter(mgs) + csplinter2(mgs)   &
-     &  +csmul(mgs) )
-      ENDIF
+        ENDIF ! ibinhlmlr
 
-      
-      IF ( ess0 < 0.0 ) THEN
-         csacs(mgs) = Max(0.0, csacs(mgs) - (ifrzs)*(crfrzs(mgs) + ciacrs(mgs)))
-      ENDIF
-      
-      pcswd(mgs) = &
-!     :  cracs(mgs)     &
-     &  -chacs(mgs) - chlacs(mgs)   &
-     &  -chcns(mgs)   &
-     &  +(1-il5(mgs))*csmlr(mgs) + csshr(mgs) & ! + csshrp(mgs)
-!     >  +il5(mgs)*(cssbv(mgs))   &
-     &   + cssbv(mgs)   &
-     &  - csacs(mgs)
 
-      frac = 0.0
-      IF ( imixedphase == 0 ) THEN
-        IF ( cx(mgs,ls) + dtp*(pcswi(mgs) + pcswd(mgs)) < 0.0 ) THEN
-         frac = (-cx(mgs,ls) + pcswi(mgs)*dtp)/(pcswd(mgs)*dtp)
-         
-           pqswd(mgs) = frac*pqswd(mgs)
+       IF ( ivhmltsoak > 0 .and.  qhlmlr(mgs) < 0.0 .and. lvol(lhl) > 1 .and. xdn(mgs,lhl) .lt. xdnmx(lhl) ) THEN
+         ! act as if 50% of the meltwater were soaked into the graupel
+           v1 = (1. - xdn(mgs,lhl)/xdnmx(lhl))*(vx(mgs,lhl) + rho0(mgs)*qhlmlr(mgs)/xdn(mgs,lhl) )/(dtp) ! volume available for filling
+           v2 = -1.0*rho0(mgs)*qhlmlr(mgs)/xdnmx(lhl)  ! volume of melted ice if it were refrozen in the matrix
            
-           chacs(mgs)  = frac*chacs(mgs) 
-           chlacs(mgs) = frac*chlacs(mgs)
-           chcns(mgs)  = frac*chcns(mgs) 
-           csmlr(mgs)  = frac*csmlr(mgs) 
-           csshr(mgs)  = frac*csshr(mgs) 
-           cssbv(mgs)  = frac*cssbv(mgs) 
-           csacs(mgs)  = frac*csacs(mgs)
-      
+           vhlsoak(mgs) = Min(v1,v2)
+           
+       ENDIF
+        
         ENDIF
-      ENDIF
-
+       ENDIF
 
+      ENDIF
       
-      pccii(mgs) =  pccii(mgs) &
-     &  + (1. - ifrzs)*crfrzs(mgs) &
-     &  + (1. - ifrzs)*ciacrs(mgs)
+!
+!      qimlr(mgs)  = max( qimlr(mgs), -qimxd(mgs) ) 
+!      qsmlr(mgs)  = max( qsmlr(mgs),  -qsmxd(mgs) ) 
+! erm 5/10/2007 changed to next line:
+      if ( .not. mixedphase ) qsmlr(mgs)  = max( qsmlr(mgs),  Min( -qsmxd(mgs), -0.7*qx(mgs,ls)*dtpinv ) ) 
+      if ( .not. mixedphase ) qhmlr(mgs)  = max( qhmlr(mgs),  Min( -qhmxd(mgs), -0.5*qx(mgs,lh)*dtpinv ) ) 
+!      qhmlr(mgs)  = max( max( qhmlr(mgs),  -qhmxd(mgs) ) , -0.5*qx(mgs,lh)*dtpinv ) !limits to 1/2 qh or max depletion
+      qhmlh(mgs)  = 0.
 
-      pcswi(mgs) =  pcswi(mgs) &
-     &  + (ifrzs)*crfrzs(mgs) &
-     &  + (ifrzs)*ciacrs(mgs)
 
-      end do
+      ! Rasmussen and Heymsfield say melt water remains on graupel up to 9 mm before shedding
 
-      ENDIF
+
+      IF ( lhl .gt. 1 .and. lhlw < 1 ) qhlmlr(mgs)  = max( qhlmlr(mgs),  Min( -qxmxd(mgs,lhl), -0.5*qx(mgs,lhl)*dtpinv ) )
 
 !
-!  Graupel
+      end do
+
+      endif  ! } not mixedphase
 !
-      IF ( ipconc .ge. 5 ) THEN !
+      if ( ipconc .ge. 1 ) then
       do mgs = 1,ngscnt
-      pchwi(mgs) =   &
-     &  +ifrzg*(crfrzf(mgs)   &
-     & +il5(mgs)*(ciacrf(mgs) ))    &
-     & + chcnsh(mgs) + chcnih(mgs) + chcnhl(mgs)
-
-      pchwd(mgs) =   &
-     &  (1-il5(mgs))*chmlr(mgs) &
-!     >  + il5(mgs)*chsbv(mgs)   &
-     &  + chsbv(mgs)   &
-     &  - il5(mgs)*chlcnh(mgs) &
-     &  - cscnh(mgs)
-      end do
-!
+      cimlr(mgs)  = (cx(mgs,li)/(qx(mgs,li)+1.e-20))*qimlr(mgs)
+      IF ( .not. mixedphase ) THEN !{
+        IF ( xdia(mgs,ls,1) .gt. 1.e-6 .and. -qsmlr(mgs) .ge. 0.5*qxmin(ls) .and. ipconc .ge. 4 ) THEN 
+!         csmlr(mgs)  = rho0(mgs)*qsmlr(mgs)/(xv(mgs,ls)*rhosm)
+         csmlr(mgs)  = (cx(mgs,ls)/(qx(mgs,ls)))*qsmlr(mgs)
+        ELSEIF ( qx(mgs,ls) > qxmin(ls) ) THEN
+         csmlr(mgs)  = (cx(mgs,ls)/(qx(mgs,ls)))*qsmlr(mgs)
+        ENDIF
+        
+        csmlrr(mgs) = csmlr(mgs)/rzxs(mgs)
+         IF ( -csmlrr(mgs)*dtp > cxmin .and. -qsmlr(mgs)*dtp > qxmin(lr) .and. snowmeltdia > 0.0 ) THEN
+           rmas = rho0(mgs)*qsmlr(mgs)/csmlrr(mgs)
+           IF ( rmas > snowmeltmass ) THEN
+             csmlrr(mgs) = rho0(mgs)*qsmlr(mgs)/snowmeltmass
+           ENDIF
+         ENDIF
+           
 
-!
-!  Hail
-!
-      IF ( lhl .gt. 1 ) THEN !
-      do mgs = 1,ngscnt
-      pchli(mgs) = (1.0-ifrzg)*(crfrzf(mgs) +il5(mgs)*(ciacrf(mgs) ))  &
-     & + chlcnh(mgs) *rzxhlh(mgs)
 
-      pchld(mgs) =   &
-     &  (1-il5(mgs))*chlmlr(mgs)   &
-!     >  + il5(mgs)*chlsbv(mgs)   &
-     &  + chlsbv(mgs) - chcnhl(mgs)
-      
-!      IF ( pchli(mgs) .ne. 0. .or. pchld(mgs) .ne. 0 ) THEN
-!       write(0,*) 'dr: pchli,pchld = ', pchli(mgs),pchld(mgs), igs(mgs),kgs(mgs)
-!      ENDIF
-      end do
+!        IF ( xdia(mgs,lh,1) .gt. 1.e-6 .and. Abs(qhmlr(mgs)) .ge. qxmin(lh) ) THEN
+!          chmlr(mgs) = rho0(mgs)*qhmlr(mgs)/(pi*xdn(mgs,lh)*xdia(mgs,lh,1)**3)  ! out of hail
+!          chmlr(mgs) = Max( chmlr(mgs), -chmxd(mgs) )
+!        ELSE
+         IF ( ibinhmlr == 0 ) THEN
+           chmlr(mgs)  = (cx(mgs,lh)/(qx(mgs,lh)+1.e-20))*qhmlr(mgs)
+           IF ( imltshddmr == 3 .and. qhmlr(mgs) < -qxmin(lh) ) THEN
+            !  tmpdiam = (shedalp+alpha(mgs,lh))*xdia(mgs,lh,1)
+            !  
+            !  IF ( tmpdiam > sheddiam ) THEN ! let size get smaller until it reaches sheddiam
+            !   chmlr(mgs) = 0.0
+            !  ENDIF
+            
+            ! test to remove the part of the melting associated with large ice particles so they get smaller
+
+            tmp = 1. + alpha(mgs,lh)
+            i = Int(dgami*(tmp))
+            del = tmp - dgam*i
+            g1palp = gmoi(i) + (gmoi(i+1) - gmoi(i))*del*dgami
+
+            ratio = Min( maxratiolu,  mltdiam1/xdia(mgs,lh,1) )
+
+            x =  gamxinfdp(2. + alpha(mgs,lh), ratio)/g1palp
+            y =  gamxinfdp(2.5 + alpha(mgs,lh) + 0.5*bxh(mgs), ratio)/g1palp
+
+            hwvent1 =  0.78*x + y*hwventy(mgs) 
+
+            qhlmlr1 = min( fmlt1(mgs)*cx(mgs,lh)*hwvent1*xdia(mgs,lh,1), 0.0 )
+
+            chmlr(mgs)  = (cx(mgs,lh)/(qx(mgs,lh)+1.e-20))*(qhmlr(mgs) - qhlmlr1)
+           
+           
+           ENDIF
+!           IF ( igs(mgs) == 40 ) THEN
+!             write(0,*) 'is this running? chmlr = ',kgs(mgs), chmlr(mgs)
+!           ENDIF
+         ENDIF
+!        ENDIF
+
+
+
+     IF ( chmlr(mgs) < 0.0 .and. ibinhmlr < 1) THEN ! { already done if ibinhmlr > 0
       
+      IF ( ibinhmlr == 0 ) THEN
+      IF ( ihmlt .eq. 1 ) THEN
+        chmlrr(mgs)  = Min( chmlr(mgs), rho0(mgs)*qhmlr(mgs)/(xdn(mgs,lr)*vmlt) ) ! into rain 
+      ELSEIF ( ihmlt .eq. 2 ) THEN
+        IF ( xv(mgs,lh) .gt. 0.0 .and. chmlr(mgs) .lt. 0.0 ) THEN
+!        chmlrr(mgs) = Min( chmlr(mgs), rho0(mgs)*qhmlr(mgs)/(xdn(mgs,lh)*xv(mgs,lh)) ) ! into rain 
+! guess what, this is the same as chmlr: rho0*qhmlr/xmas(lh) --> cx/qx = rho0/xmas
+          IF(imltshddmr == 1) THEN
+            ! DTD: If Dmg < sheddiam, then assume complete melting into
+            ! maximal raindrop.  Between sheddiam and sheddiam0 mm, linearly ramp down to a 3 mm shed drop
+            tmp = -rho0(mgs)*qhmlr(mgs)/(Min(xdn(mgs,lr)*xvmx(lr), xdn(mgs,lh)*xv(mgs,lh))) ! Min of Maximum raindrop size/mean hail size
+            tmp2 = -rho0(mgs)*qhmlr(mgs)/(xdn(mgs,lr)*vr3mm) ! conc. change for a 3 mm mean drop diameter
+            
+            chmlrr(mgs) = tmp*(sheddiam0-xdia(mgs,lh,3))/(sheddiam0-sheddiam)+tmp2*(xdia(mgs,lh,3)-sheddiam)/(sheddiam0-sheddiam)  ! old version
+            chmlrr(mgs) = -Max(tmp,Min(tmp2,chmlrr(mgs)))
+          ELSEIF ( imltshddmr == 2 .or. imltshddmr == 3 ) THEN
+            ! 8/26/2015 ERM updated to use shedalp and tmpdiam
+            ! tmpdiam = (shedalp+alpha(mgs,lh))*xdia(mgs,lh,1)
+            chmlrr(mgs) =  rho0(mgs)*qhmlr(mgs)/(xdn(mgs,lr)*vshdgs(mgs,lh))  ! into rain 
+          ELSE ! Old method
+            chmlrr(mgs) =  rho0(mgs)*qhmlr(mgs)/(Min(xdn(mgs,lr)*xvmx(lr), xdn(mgs,lh)*xv(mgs,lh)))  ! into rain 
+          ENDIF
+        ELSE
+        chmlrr(mgs) = chmlr(mgs)
+        ENDIF
+      ELSEIF ( ihmlt .eq. 0 ) THEN
+        chmlrr(mgs) = chmlr(mgs)
+      ENDIF
+
+      ELSE ! ibinhmlr < 0? Already have an outer IF test for ibinhmlr < 1
+        chmlrr(mgs)  = Min( chmlrr(mgs), rho0(mgs)*qhmlr(mgs)/(xdn(mgs,lr)*xvmx(lr)) ) ! into rain 
       ENDIF
+      
+      ENDIF ! } ( chmlr(mgs) < 0.0 .and. ibinhmlr < 1)
+
+      IF ( lhl .gt. 1 .and. lhlw < 1 .and. .not. mixedphase .and. qhlmlr(mgs) < 0.0 ) THEN ! {
+      
+      IF ( ibinhlmlr == 0 ) THEN
+!      IF ( xdia(mgs,lhl,1) .gt. 1.e-6 .and. Abs(qhlmlr(mgs)) .ge. qxmin(lhl) ) THEN
+!      chlmlr(mgs) = rho0(mgs)*qhlmlr(mgs)/(pi*xdn(mgs,lhl)*xdia(mgs,lhl,1)**3)  ! out of hail
+!      chlmlr(mgs) = Max( chlmlr(mgs), -cxmxd(mgs,lhl) )
+!      ELSE
+      chlmlr(mgs)  = (cx(mgs,lhl)/(qx(mgs,lhl)+1.e-20))*qhlmlr(mgs)
+           IF ( imltshddmr == 3 .and. qhlmlr(mgs) < -qxmin(lhl) ) THEN
+!           IF ( .false. .and. imltshddmr == 3  ) THEN
+!              tmpdiam = (shedalp+alpha(mgs,lhl))*xdia(mgs,lhl,1)
+!              
+!              IF ( tmpdiam > sheddiam ) THEN ! let size get smaller until it reaches sheddiam
+!                chlmlr(mgs) = 0.0
+!              ENDIF
+ 
+            ! test to remove the part of the melting associated with large ice particles so they get smaller
 !
+            tmp = 1. + alpha(mgs,lhl)
+            i = Int(dgami*(tmp))
+            del = tmp - dgam*i
+            g1palp = gmoi(i) + (gmoi(i+1) - gmoi(i))*del*dgami
 
-      ENDIF ! (ipconc .ge. 5 )
+            ratio = Min( maxratiolu,  mltdiam1/xdia(mgs,lhl,1) )
 
-      ELSEIF ( warmonly < 0.8 ) THEN
+            x =  gamxinfdp(2. + alpha(mgs,lhl), ratio)/g1palp
+            y =  gamxinfdp(2.5 + alpha(mgs,lhl) + 0.5*bxhl(mgs), ratio)/g1palp
 
-!
-!  Graupel
-!
-      IF ( ipconc .ge. 5 ) THEN !
-      do mgs = 1,ngscnt
-      pchwi(mgs) =   &
-     &  +ifrzg*(crfrzf(mgs) )
+            hwvent1 =  0.78*x + y*hlventy(mgs) 
 
-      pchwd(mgs) =   &
-     &  (1-il5(mgs))*chmlr(mgs) &
-     &  - il5(mgs)*chlcnh(mgs)
-      end do
-!
-!  Hail
-!
-      IF ( lhl .gt. 1 ) THEN !
-      do mgs = 1,ngscnt
-      pchli(mgs) = (1.0-ifrzg)*(crfrzf(mgs) +il5(mgs)*(ciacrf(mgs) ))  &
-     & + chlcnh(mgs) *rzxhl(mgs)/rzxh(mgs)
+            qhlmlr1 = min( fmlt1(mgs)*cx(mgs,lhl)*hwvent1*xdia(mgs,lhl,1), 0.0 )
 
-      pchld(mgs) =   &
-     &  (1-il5(mgs))*chlmlr(mgs) !  &
-!     >  + il5(mgs)*chlsbv(mgs)   &
-!     &  + chlsbv(mgs)
+            chlmlr(mgs)  = (cx(mgs,lhl)/(qx(mgs,lhl)+1.e-20))*Min(0.0, qhlmlr(mgs) - qhlmlr1)
 
-!      IF ( pchli(mgs) .ne. 0. .or. pchld(mgs) .ne. 0 ) THEN
-!       write(0,*) 'dr: pchli,pchld = ', pchli(mgs),pchld(mgs), igs(mgs),kgs(mgs)
+            ENDIF
 !      ENDIF
-      end do
-
+      ENDIF
+      
+      IF ( ibinhlmlr == 0 ) THEN !{
+      IF ( ihmlt .eq. 1 ) THEN
+        chlmlrr(mgs)  = Min( chlmlr(mgs), rho0(mgs)*qhlmlr(mgs)/(xdn(mgs,lr)*vmlt) ) ! into rain 
+      ELSEIF ( ihmlt .eq. 2 ) THEN
+        IF ( xv(mgs,lhl) .gt. 0.0 .and. chlmlr(mgs) .lt. 0.0 ) THEN
+!        chlmlrr(mgs) = rho0(mgs)*qhlmlr(mgs)/(Min(xdn(mgs,lr)*xvmx(lr), xdn(mgs,lhl)*xv(mgs,lhl)))  ! into rain 
+!        chlmlrr(mgs) = Min( chlmlr(mgs), rho0(mgs)*qhlmlr(mgs)/(xdn(mgs,lhl)*xv(mgs,lhl)) ) ! into rain 
+          IF(imltshddmr == 1 ) THEN
+            tmp = -rho0(mgs)*qhlmlr(mgs)/(Min(xdn(mgs,lr)*xvmx(lr), xdn(mgs,lhl)*xv(mgs,lhl))) ! Min of Maximum raindrop size/mean hail size
+            tmp2 = -rho0(mgs)*qhlmlr(mgs)/(xdn(mgs,lr)*vr3mm) ! conc. change for a 3 mm mean drop diameter
+            chlmlrr(mgs) = tmp*(20.e-3-xdia(mgs,lhl,3))/(20.e-3-sheddiam)+tmp2*(xdia(mgs,lhl,3)-sheddiam)/(20.e-3-sheddiam)
+            chlmlrr(mgs) = -Max(tmp,Min(tmp2,chlmlrr(mgs)))
+          ELSEIF ( imltshddmr == 2 .or. imltshddmr == 3 ) THEN
+            ! 8/26/2015 ERM updated to use shedalp and tmpdiam
+            ! tmpdiam = (shedalp+alpha(mgs,lh))*xdia(mgs,lh,1)
+            chlmlrr(mgs) =  rho0(mgs)*qhlmlr(mgs)/(xdn(mgs,lr)*vshdgs(mgs,lhl))  ! into rain 
+          ELSE
+            chlmlrr(mgs) = rho0(mgs)*qhlmlr(mgs)/(Min(xdn(mgs,lr)*xvmx(lr), xdn(mgs,lhl)*xv(mgs,lhl)))  ! into rain 
+          ENDIF
+        ELSE
+        chlmlrr(mgs) = chlmlr(mgs)
+        ENDIF
+      ELSEIF ( ihmlt .eq. 0 ) THEN
+        chlmlrr(mgs) = chlmlr(mgs)
       ENDIF
 
-      ENDIF ! ipconc >= 5
-
-      ENDIF ! warmonly
+      ELSE ! } { ibinhlmlr > 0
+        chlmlrr(mgs)  = Min( chlmlrr(mgs), rho0(mgs)*qhlmlr(mgs)/(xdn(mgs,lr)*xvmx(lr)) ) ! into rain 
+      ENDIF !}
+        
+      ENDIF ! }
 
-!
+      ENDIF ! }.not. mixedphase 
 
-!
-!  Balance and checks for continuity.....within machine precision...
-!
-      do mgs = 1,ngscnt
-      pctot(mgs)   = pccwi(mgs) +pccwd(mgs) +   &
-     &               pccii(mgs) +pccid(mgs) +   &
-     &               pcrwi(mgs) +pcrwd(mgs) +   &
-     &               pcswi(mgs) +pcswd(mgs) +   &
-     &               pchwi(mgs) +pchwd(mgs) +   &
-     &               pchli(mgs) +pchld(mgs)
+! 10ice versions:
+!      chmlr(mgs)  = (cx(mgs,lh)/(qx(mgs,lh)+1.e-20))*qhmlr(mgs)
+!      chmlrr(mgs) = chmlr(mgs)
       end do
+      end if
+
 !
+!  deposition/sublimation of ice
 !
-      ENDIF ! ( ipconc .ge. 1 )
-!
-!
-!
+      DO mgs = 1,ngscnt
+
+      rwcap(mgs) = (0.5)*xdia(mgs,lr,1)
+      swcap(mgs) = (0.5)*xdia(mgs,ls,1)
+      hwcap(mgs) = (0.5)*xdia(mgs,lh,1)
+      IF ( lhl .gt. 1 ) hlcap(mgs) = (0.5)*xdia(mgs,lhl,1)
+
+      if ( qx(mgs,li).gt.qxmin(li) .and. xdia(mgs,li,1) .gt. 0.0 ) then
 !
+! from Cotton, 1972 (Part II)
 !
-!  GOGO
-!  production terms for mass
+        cilen(mgs)   = 0.4764*(xdia(mgs,li,1))**(0.958)
+        cval = xdia(mgs,li,1)
+        aval = cilen(mgs)
+        eval = Sqrt(1.0-(aval**2)/(cval**2))
+        fval = min(0.99,eval)
+        gval = alog( abs( (1.+fval)/(1.-fval) ) )
+        cicap(mgs) = cval*fval / gval
+      ELSE
+       cicap(mgs) = 0.0
+      end if
+      ENDDO
 !
 !
-       pqwvi(:) = 0.0
-       pqwvd(:) = 0.0
-       pqcwi(:) = 0.0
-       pqcwd(:) = 0.0
-       pqcii(:) = 0.0
-       pqcid(:) = 0.0
-       pqrwi(:) = 0.0
-       pqrwd(:) = 0.0
-       pqswi(:) = 0.0
-       pqswd(:) = 0.0
-       pqhwi(:) = 0.0
-       pqhwd(:) = 0.0
-       pqhli(:) = 0.0
-       pqhld(:) = 0.0
-       pqlwsi(:) = 0.0
-       pqlwsd(:) = 0.0
-       pqlwhi(:) = 0.0
-       pqlwhd(:) = 0.0
-       pqlwhli(:) = 0.0
-       pqlwhld(:) = 0.0
-!
-!  Vapor
-!
-      IF ( warmonly < 0.5 ) THEN
-      do mgs = 1,ngscnt
-      
-! NOTE: ANY CHANGES HERE ALSO NEED TO GO INTO THE RESUM FARTHER DOWN!
-      pqwvi(mgs) =    &
-     &  -Min(0.0, qrcev(mgs))   &
-     &  -Min(0.0, qhcev(mgs))   &
-     &  -Min(0.0, qhlcev(mgs))   &
-     &  -Min(0.0, qscev(mgs))   &
-!     >  +il5(mgs)*(-qhsbv(mgs) - qhlsbv(mgs) )   &
-     &  -qhsbv(mgs) - qhlsbv(mgs)   &
-     &  -qssbv(mgs)    &
-     &  -il5(mgs)*qisbv(mgs)
-      
-      pqwvd(mgs) =     &
-     &  -Max(0.0, qrcev(mgs))   &
-     &  -Max(0.0, qhcev(mgs))   &
-     &  -Max(0.0, qhlcev(mgs))   &
-     &  -Max(0.0, qscev(mgs))   &
-     &  +il5(mgs)*(-qiint(mgs)   &
-     &  -qhdpv(mgs) -qsdpv(mgs) - qhldpv(mgs))   &
-     &  -il5(mgs)*qidpv(mgs)  
-      
-      end do
+      qhldsv(:) = 0.0
 
-      ELSEIF ( warmonly < 0.8 ) THEN
       do mgs = 1,ngscnt
-      pqwvi(mgs) =    &
-     &  -Min(0.0, qrcev(mgs)) &
-     &  -il5(mgs)*qisbv(mgs)
-      pqwvd(mgs) =     &
-     &  +il5(mgs)*(-qiint(mgs)   &
-!     &  -qhdpv(mgs) ) & !- qhldpv(mgs))   &
-     &  -qhdpv(mgs) - qhldpv(mgs))   &
-!     &  -qhdpv(mgs) -qsdpv(mgs) - qhldpv(mgs))   &
-     &  -Max(0.0, qrcev(mgs))     &
-     &  -il5(mgs)*qidpv(mgs)  
-      end do
-
+      IF ( icond .eq. 1 .or. temg(mgs) .le. tfrh    &
+     &      .or. (qx(mgs,lr) .le. qxmin(lr) .and. qx(mgs,lc) .le. qxmin(lc)) ) THEN
+        qidsv(mgs) =   &
+     &    fvds(mgs)*cx(mgs,li)*civent(mgs)*cicap(mgs)
+        qsdsv(mgs) =   &
+     &    fvds(mgs)*cx(mgs,ls)*swvent(mgs)*swcap(mgs)
+!        IF ( ny .eq. 2 .and. igs(mgs) .eq. 302 .and. temg(mgs) .le. tfrh+10 .and. qx(mgs,lv) .gt. qis(mgs)
+!     :       .and. qx(mgs,li) .gt. qxmin(li) ) THEN
+!         write(0,*) 'qidsv = ',nstep,kgs(mgs),qidsv(mgs),temg(mgs)-tfrh,100.*(qx(mgs,lv)/qis(mgs) - 1.),1.e6*xdia(mgs,li,1),
+!     :            fvds(mgs),civent(mgs),cicap(mgs)
+!        ENDIF
       ELSE
-      do mgs = 1,ngscnt
-      pqwvi(mgs) =    &
-     &  -Min(0.0, qrcev(mgs))
-      pqwvd(mgs) =     &
-     &  -Max(0.0, qrcev(mgs))
-      end do
+        qidsv(mgs) = 0.0
+        qsdsv(mgs) = 0.0
+      ENDIF
+        qhdsv(mgs) =   &
+     &    fvds(mgs)*cx(mgs,lh)*hwvent(mgs)*hwcap(mgs)*depfac
 
-      ENDIF ! warmonly
+        IF ( lhl .gt. 1 ) qhldsv(mgs) = fvds(mgs)*cx(mgs,lhl)*hlvent(mgs)*hlcap(mgs)*depfac
 !
-!  Cloud water
+!
+      end do
 !
       do mgs = 1,ngscnt
-
-      pqcwi(mgs) =  (0.0) + qwcnr(mgs)
-
-      IF ( warmonly < 0.5 ) THEN
-      pqcwd(mgs) =    &
-     &  il5(mgs)*(-qiacw(mgs)-qwfrz(mgs)-qwctfz(mgs))   &
-     &  -il5(mgs)*(qiihr(mgs))   &
-     &  -qracw(mgs) -qsacw(mgs) -qrcnw(mgs) -qhacw(mgs) - qhlacw(mgs)  !&
-!     &  -il5(mgs)*(qwfrzp(mgs))
-      ELSEIF ( warmonly < 0.8 ) THEN
-      pqcwd(mgs) =    &
-     &  il5(mgs)*(-qiacw(mgs)-qwfrz(mgs)-qwctfz(mgs))   &
-     &  -il5(mgs)*(qiihr(mgs))   &
-     &  -qracw(mgs) -qrcnw(mgs) -qhacw(mgs) -qhlacw(mgs)
+      qisbv(mgs) = 0.0
+      qssbv(mgs) = 0.0
+      qidpv(mgs) = 0.0
+      qsdpv(mgs) = 0.0
+      IF ( icond .eq. 1 .or. temg(mgs) .le. tfrh    &
+     &      .or. (qx(mgs,lr) .le. qxmin(lr) .and. qx(mgs,lc) .le. qxmin(lc)) ) THEN
+!        qisbv(mgs) = max( min(qidsv(mgs), 0.0), -qimxd(mgs) )
+!        qssbv(mgs) = max( min(qsdsv(mgs), 0.0), -qsmxd(mgs) )
+! erm 5/10/2007:
+        qisbv(mgs) = max( min(qidsv(mgs), 0.0),  Min( -qimxd(mgs), -0.7*qx(mgs,li)*dtpinv ) )
+        qssbv(mgs) = max( min(qsdsv(mgs), 0.0),  Min( -qsmxd(mgs), -0.7*qx(mgs,ls)*dtpinv ) )
+        qidpv(mgs) = Max(qidsv(mgs), 0.0)
+        qsdpv(mgs) = Max(qsdsv(mgs), 0.0)
       ELSE
-      pqcwd(mgs) =    &
-     &  -qracw(mgs) - qrcnw(mgs)
+        qisbv(mgs) = 0.0
+        qssbv(mgs) = 0.0
+        qidpv(mgs) = 0.0
+        qsdpv(mgs) = 0.0
       ENDIF
 
-      IF ( pqcwd(mgs) .lt. 0.0 .and. -pqcwd(mgs)*dtp .gt. qx(mgs,lc) ) THEN
+      qhsbv(mgs) = max( min(qhdsv(mgs), 0.0), -qhmxd(mgs) )
 
-       frac = -Max(0.0,qx(mgs,lc))/(pqcwd(mgs)*dtp)
-       pqcwd(mgs) = -qx(mgs,lc)/dtp
 
-        qiacw(mgs)   = frac*qiacw(mgs)
-!        qwfrzp(mgs)  = frac*qwfrzp(mgs)
-!        qwctfzp(mgs) = frac*qwctfzp(mgs)
-        qwfrzc(mgs)  = frac*qwfrzc(mgs)
-        qwfrzis(mgs)  = frac*qwfrzis(mgs)
-        qwfrz(mgs)  = frac*qwfrz(mgs)
-        qwctfzc(mgs) = frac*qwctfzc(mgs)
-        qwctfzis(mgs) = frac*qwctfzis(mgs)
-        qwctfz(mgs) = frac*qwctfz(mgs)
-        qracw(mgs)   = frac*qracw(mgs)
-        qsacw(mgs)   = frac*qsacw(mgs)
-        qhacw(mgs)   = frac*qhacw(mgs)
-        vhacw(mgs)   = frac*vhacw(mgs)
-        qrcnw(mgs)   = frac*qrcnw(mgs)
-        qwfrzp(mgs)  = frac*qwfrzp(mgs)
-        IF ( lhl .gt. 1 ) THEN
-          qhlacw(mgs)   = frac*qhlacw(mgs)
-          vhlacw(mgs)   = frac*vhlacw(mgs)
-        ENDIF
-!        IF ( lzh .gt. 1 ) zhacw(mgs) = frac*zhacw(mgs)
+      qhdpv(mgs) = Max(qhdsv(mgs), 0.0)
 
-!       STOP
+      qhlsbv(mgs) = 0.0
+      qhldpv(mgs) = 0.0
+      IF ( lhl .gt. 1 ) THEN
+        qhlsbv(mgs) = max( min(qhldsv(mgs), 0.0), -qxmxd(mgs,lhl) )
+        qhldpv(mgs) = Max(qhldsv(mgs), 0.0)
       ENDIF
       
+      temp1 = qidpv(mgs) + qsdpv(mgs) + qhdpv(mgs) + qhldpv(mgs)
 
-      end do
-!
-!  Cloud ice
-!
-      IF ( warmonly < 0.5 ) THEN
-
-      do mgs = 1,ngscnt
-      IF ( ffrzs < 1.0 ) THEN
-      pqcii(mgs) =     &
-     &   il5(mgs)*qicicnt(mgs)    &
-     &  +il5(mgs)*(qwfrzc(mgs)+qwctfzc(mgs))   &
-     &  +il5(mgs)*(qicichr(mgs))  &
-     &  +qsmul(mgs)               &
-     &  +qhmul1(mgs) + qhlmul1(mgs)   &
-     & + qsplinter(mgs) + qsplinter2(mgs)
-!     > + cimas0*nsplinter*(crfrzf(mgs) + crfrz(mgs))/rho0(mgs)
-      ENDIF
-       
-       pqcii(mgs) = pqcii(mgs)*(1.0 - ffrzs) &
-     &  +il5(mgs)*qidpv(mgs)    &
-     &  +il5(mgs)*qiacw(mgs)
-       
-      pqcid(mgs) =     &
-     &   il5(mgs)*(-qscni(mgs) - qscnvi(mgs)    & ! -qwaci(mgs)    &
-     &  -qraci(mgs)    &
-     &  -qsaci(mgs) )   &
-     &  -qhaci(mgs)   &
-     &  -qhlaci(mgs)    &
-     &  +il5(mgs)*qisbv(mgs)    &
-     &  +(1.-il5(mgs))*qimlr(mgs)   &
-     &  - qhcni(mgs)
-      end do
+      IF ( temp1 .gt. qvimxd(mgs) ) THEN
 
-      
-      ELSEIF ( warmonly < 0.8 ) THEN
+      frac = qvimxd(mgs)/temp1
 
-      do mgs = 1,ngscnt
-      pqcii(mgs) =     &
-     &   il5(mgs)*qicicnt(mgs)*(1. - ffrzs)    &
-     &  +il5(mgs)*(qwfrzc(mgs)+qwctfzc(mgs))*(1. - ffrzs)   &
-     &  +il5(mgs)*(qicichr(mgs))*(1. - ffrzs)   &
-!     &  +il5(mgs)*(qicichr(mgs))   &
-!     &  +qsmul(mgs)               &
-     &  +qhmul1(mgs) + qhlmul1(mgs)   &
-     & + qsplinter(mgs) + qsplinter2(mgs) &
-     &  +il5(mgs)*qidpv(mgs)    &
-     &  +il5(mgs)*qiacw(mgs)  ! & ! (qiacwi(mgs)+qwacii(mgs))   &
-!     &  +il5(mgs)*(qwfrzc(mgs)+qwctfzc(mgs))   &
-!     &  +il5(mgs)*(qicichr(mgs))   &
-!     &  +qsmul(mgs)               &
-!     &  +qhmul1(mgs) + qhlmul1(mgs)   &
-!     & + qsplinter(mgs) + qsplinter2(mgs)
+      qidpv(mgs) = frac*qidpv(mgs)
+      qsdpv(mgs) = frac*qsdpv(mgs)
+      qhdpv(mgs) = frac*qhdpv(mgs)
+      qhldpv(mgs) = frac*qhldpv(mgs)
 
-      pqcid(mgs) =     &
-!     &   il5(mgs)*(-qscni(mgs) - qscnvi(mgs)    & ! -qwaci(mgs)    &
-!     &  -qraci(mgs)    &
-!     &  -qsaci(mgs) )   &
-!     &  -qhaci(mgs)   &
-!     &  -qhlaci(mgs)    &
-     &  +il5(mgs)*qisbv(mgs)    &
-     &  +(1.-il5(mgs))*qimlr(mgs)  ! &
-!     &  - qhcni(mgs)
-      end do
+!        IF ( ny .eq. 2 .and. igs(mgs) .eq. 302 .and. temg(mgs) .le. tfrh+10 .and. qx(mgs,lv) .gt. qis(mgs)
+!     :       .and. qx(mgs,li) .gt. qxmin(li) ) THEN
+!         write(0,*) 'qidpv,frac = ',kgs(mgs),qidpv(mgs),frac
+!        ENDIF
 
       ENDIF
+
+      end do
 !
-!  Rain
 !
-
+      if ( ipconc .ge. 1 ) then
       do mgs = 1,ngscnt
-      IF ( warmonly < 0.5 ) THEN
-      pqrwi(mgs) =     &
-     &   qracw(mgs) + qrcnw(mgs) + Max(0.0, qrcev(mgs))   &
-     &  +(1-il5(mgs))*(   &
-     &    -qhmlr(mgs)                 &            !null at this point when wet snow/graupel included
-     &    -qsmlr(mgs)  - qhlmlr(mgs)     &
-     &    -qimlr(mgs))   &
-     &    -qsshr(mgs)       &                      !null at this point when wet snow/graupel included
-     &    -qhshr(mgs)       &                      !null at this point when wet snow/graupel included
-     &    -qhlshr(mgs)
-      pqrwd(mgs) =     &
-     &  il5(mgs)*(-qiacr(mgs)-qrfrz(mgs))    &
-     &  - qsacr(mgs) - qhacr(mgs) - qhlacr(mgs) - qwcnr(mgs)   &
-     &  + Min(0.0,qrcev(mgs))
-      ELSEIF ( warmonly < 0.8 ) THEN
-      pqrwi(mgs) =     &
-     &   qracw(mgs) + qrcnw(mgs) + Max(0.0, qrcev(mgs))   &
-     &  +(1-il5(mgs))*(   &
-     &    -qhmlr(mgs)                 &            !null at this point when wet snow/graupel included
-     &    -qhshr(mgs)                 &           !null at this point when wet snow/graupel included
-     &    -qhlmlr(mgs)                 &            !null at this point when wet snow/graupel included
-     &    -qhlshr(mgs) )                           !null at this point when wet snow/graupel included
-      pqrwd(mgs) =     &
-     &  il5(mgs)*(-qrfrz(mgs))    &
-     &   - qhacr(mgs)    &
-     &   - qhlacr(mgs)    &
-     &  + Min(0.0,qrcev(mgs))
-      ELSE
-      pqrwi(mgs) =     &
-     &   qracw(mgs) + qrcnw(mgs) + Max(0.0, qrcev(mgs))
-      pqrwd(mgs) =  Min(0.0,qrcev(mgs))
-      ENDIF ! warmonly
-
+      cssbv(mgs)  = (cx(mgs,ls)/(qx(mgs,ls)+1.e-20))*qssbv(mgs)
+      cisbv(mgs)  = (cx(mgs,li)/(qx(mgs,li)+1.e-20))*qisbv(mgs)
+      chsbv(mgs)  = (cx(mgs,lh)/(qx(mgs,lh)+1.e-20))*qhsbv(mgs)
+      IF ( lhl .gt. 1 ) chlsbv(mgs)  = (cx(mgs,lhl)/(qx(mgs,lhl)+1.e-20))*qhlsbv(mgs)
+      csdpv(mgs)  = 0.0 ! (cx(mgs,ls)/(qx(mgs,ls)+1.e-20))*qsdpv(mgs)
+      cidpv(mgs) =  0.0 ! (cx(mgs,li)/(qx(mgs,li)+1.e-20))*qidpv(mgs)
+      cisdpv(mgs) = 0.0
+      chdpv(mgs)  = 0.0 ! (cx(mgs,lh)/(qx(mgs,lh)+1.e-20))*qhdpv(mgs)
+      chldpv(mgs) = 0.0
+      end do
+      end if
+
+!
+!  Aggregation or size conversion of small crystals to snow
+!
+      if (ndebug .gt. 0 ) write(0,*) 'conc 29a'
+      do mgs = 1,ngscnt
+      qscni(mgs) =  0.0
+      cscni(mgs) = 0.0
+      cscnis(mgs) = 0.0
+      if ( ipconc .ge. 4 .and. iscni .ge. 1 .and. qx(mgs,li) .gt. qxmin(li) ) then
+        IF ( iscni .eq. 1 ) THEN
+         qscni(mgs) =    &
+     &      pi*rho0(mgs)*((0.25)/(6.0))   &
+     &      *eii(mgs)*(qx(mgs,li)**2)*(xdia(mgs,li,2))   &
+     &      *vtxbar(mgs,li,1)/xmas(mgs,li)
+         cscni(mgs) = Min(cimxd(mgs),qscni(mgs)*rho0(mgs)/xmas(mgs,li))
+         cscnis(mgs) = 0.5*cscni(mgs)
+        ELSEIF ( iscni .eq. 2 .or. iscni .eq. 4 .or. iscni .eq. 5 ) THEN  ! Zeigler 1985/Zrnic 1993, sort of
+          IF ( iscni .ne. 5 .and. qidpv(mgs) .gt. 0.0 .and.  xdia(mgs,li,3) .ge. 100.e-6 ) THEN
+          ! convert larger crystals to snow
+!            IF ( xdia(mgs,ls,3) .gt. xdia(mgs,li,3) ) THEN
+!              qscni(mgs) = Max(0.1,xdia(mgs,li,3)/xdia(mgs,ls,3))*qidpv(mgs)
+! erm 9/5/08 changed max to min
+              qscni(mgs) = Min(0.5, xdia(mgs,li,3)/200.e-6)*qidpv(mgs)
+!            ELSE
+!              qscni(mgs) = 0.1*qidpv(mgs)
+!            ENDIF
+            cscni(mgs) = fscni*qscni(mgs)*rho0(mgs)/Max(xdn(mgs,ls)*xvmn(ls),xmas(mgs,li))
+!            cscni(mgs) = fscni*Min(cimxd(mgs),qscni(mgs)*rho0(mgs)/Max(xdn(mgs,ls)*xvmn(ls),xmas(mgs,li)))
+!            cscni(mgs) = Min(cimxd(mgs),qscni(mgs)*rho0(mgs)/xmas(mgs,li) )
+!            IF ( xdia(mgs,ls,3) .le. 200.e-6 ) THEN
+              cscnis(mgs) = cscni(mgs)
+!            ELSE
+!              cscnis(mgs) = 0.0
+!            ENDIF
+          ENDIF
+
+           IF ( iscni .ne. 4 ) THEN
+           ! crystal aggregation to become snow
+! erm 9/5/08 commented second line and added xv to 1st line (zrnic et al 1993)
+             tmp = ess(mgs)*rvt*aa2*cx(mgs,li)*cx(mgs,li)*xv(mgs,li)
+!     :         ((cinu + 2.)*xv(mgs,li)/(cinu + 1.) + xv(mgs,li))
+
+!           csacs(mgs) = rvt*aa2*ess(mgs)*cx(mgs,ls)**2*xv(mgs,ls)
+
+             qscni(mgs) = qscni(mgs) + Min( qxmxd(mgs,li), 2.0*tmp*xmas(mgs,li)*rhoinv(mgs) )
+             cscni(mgs) = cscni(mgs) + Min( cxmxd(mgs,li), 2.0*tmp )
+             cscnis(mgs) = cscnis(mgs) + Min( cxmxd(mgs,li), tmp )
+           ENDIF
+        ELSEIF ( iscni .eq. 3 ) THEN ! LFO
+           qscni(mgs) = 0.001*eii(mgs)*max((qx(mgs,li)-1.e-3),0.0)
+           qscni(mgs) = min(qscni(mgs),qxmxd(mgs,li))
+           cscni(mgs) = qscni(mgs)*rho0(mgs)/xmas(mgs,li)
+           cscnis(mgs) = 0.5*cscni(mgs)
+!           write(iunit,*) 'qscni, qi = ',qscni(mgs),qx(mgs,li),igs(mgs),kgs(mgs)
+        ENDIF
+
+      ELSEIF ( ipconc < 4 ) THEN ! LFO
+           IF ( lwsm6 ) THEN
+             qimax = rhoinv(mgs)*roqimax
+             qscni(mgs) = Min(0.90*qx(mgs,li), Max( 0.0, (qx(mgs,li) - qimax)*dtpinv ) )
+           ELSE
+             qscni(mgs) = 0.001*eii(mgs)*max((qx(mgs,li)-1.e-3),0.0)
+             qscni(mgs) = min(qscni(mgs),qxmxd(mgs,li))
+           ENDIF
+      else ! 10-ice version
+      if ( iscni > 0 .and. qx(mgs,li) .gt. qxmin(li) ) then
+          qscni(mgs) =    &
+     &    pi*rho0(mgs)*((0.25)/(6.0))   &
+     &    *eii(mgs)*(qx(mgs,li)**2)*(xdia(mgs,li,2))   &
+     &    *vtxbar(mgs,li,1)/xmas(mgs,li)
+         cscni(mgs) = Min(cimxd(mgs),qscni(mgs)*rho0(mgs)/xmas(mgs,li))
+        end if
+
+      end if
+      end do
+
+!
+!
+!  compute dry growth rate of snow, graupel, and hail
+!
+      do mgs = 1,ngscnt
+!
+      qsdry(mgs)  = qsacr(mgs)    + qsacw(mgs)   &
+     &            + qsaci(mgs)
+!
+      qhdry(mgs)  = qhaci(mgs)    + qhacs(mgs)   &
+     &            + qhacr(mgs)   &
+     &            + qhacw(mgs)
+!
+      qhldry(mgs) = 0.0
+      IF ( lhl .gt. 1 ) THEN
+      qhldry(mgs)  = qhlaci(mgs)    + qhlacs(mgs)   &
+     &               + qhlacr(mgs)   &
+     &               + qhlacw(mgs)
+      ENDIF
+      end do
+!
+!  set wet growth and shedding
+!
+      do mgs = 1,ngscnt
+      
+      IF ( temg(mgs) < tfr ) THEN
+!
+!      qswet(mgs) =
+!     >  ( xdia(mgs,ls,1)*swvent(mgs)*cx(mgs,ls)*fwet1(mgs)
+!     >  + fwet2(mgs)*(qsaci(mgs)+qsacir(mgs)
+!     >               +qsacip(mgs)) )
+!      qswet(mgs) = max( 0.0, qswet(mgs))
+!
+!      IF ( dnu(lh) .ne. 0. ) THEN
+!        qhwet(mgs) = qhdry(mgs)
+!      ELSE
+        qhwet(mgs) =   &
+     &    ( xdia(mgs,lh,1)*hwvent(mgs)*cx(mgs,lh)*fwet1(mgs)   &
+     &   + fwet2(mgs)*(qhaci(mgs) + qhacs(mgs)) )
+       qhwet(mgs) = max( 0.0, qhwet(mgs))
+!      ENDIF
+
+       qhlwet(mgs) = 0.0
+       IF ( lhl .gt. 1 ) THEN
+       qhlwet(mgs) =   &
+     &    ( xdia(mgs,lhl,1)*hlvent(mgs)*cx(mgs,lhl)*fwet1(mgs)   &
+     &   + fwet2(mgs)*(qhlaci(mgs) + qhlacs(mgs)) )
+       qhlwet(mgs) = max( 0.0, qhlwet(mgs))
+       ENDIF
+       
+       ELSE
+       
+        qhwet(mgs) = qhdry(mgs)
+        qhlwet(mgs) = qhldry(mgs)
+        
+       ENDIF
+!
+!      qhlwet(mgs) = qhldry(mgs)
+
+      end do
+!
+! shedding rate
+!
+      qsshr(:)  =  0.0
+      qhshr(:)  =  0.0
+      qhlshr(:) =  0.0
+      qhshh(:)  =  0.0
+      csshr(:)  =  0.0
+      csshrr(:) = 0.0
+      chshr(:)  =  0.0
+      chlshr(:)  =  0.0
+      chshrr(:)  =  0.0
+      chlshrr(:)  =  0.0
+      vhshdr(:)  = 0.0
+      vhlshdr(:)  = 0.0
+      wetsfc(:)  = .false.
+      wetgrowth(:)  = .false.
+      wetsfchl(:)  = .false.
+      wetgrowthhl(:)  = .false.
+
+
+      do mgs = 1,ngscnt
+!
+!
+!
+      qhshr(mgs)  = Min( 0.0, qhwet(mgs) - qhdry(mgs) )  ! water that freezes should never be more than what sheds
+      
+
+
+      qhlshr(mgs)  =  Min( 0.0, qhlwet(mgs) - qhldry(mgs) )
+
+!
+! limit wet growth to only higher density particles
+!
+      qsshr(mgs)  =  0.0
+!
+!
+!  no shedding for temperatures < 243.15 
+!
+      if ( temg(mgs) .lt. 243.15 ) then
+       qsshr(mgs)  =  0.0
+       qhshr(mgs)  =  0.0
+       qhlshr(mgs) =  0.0
+       vhshdr(mgs)  = 0.0
+       vhlshdr(mgs)  = 0.0
+       wetsfc(mgs) = .false.
+       wetgrowth(mgs) = .false.
+       wetsfchl(mgs) = .false.
+       wetgrowthhl(mgs) = .false.
+      end if
+!
+!  shed all at temperatures > 273.15
+!
+      if ( temg(mgs) .gt. tfr ) then
+
+       IF ( .false. ) THEN ! old and incorrect
+       qsshr(mgs)  = -qsdry(mgs)
+       qhshr(mgs)  = -qhdry(mgs)
+       qhlshr(mgs) = -qhldry(mgs)
+
+       ELSE ! new and correct
+       
+       qsshr(mgs)   = - qsacr(mgs) - qsacw(mgs) ! -qsdry(mgs)
+       qhlshr(mgs)  = - qhlacw(mgs) - qhlacr(mgs) ! -qhldry(mgs)
+       qhshr(mgs)  = - qhacw(mgs) - qhacr(mgs) ! -qhdry(mgs)
+
+       ENDIF
+
+       vhshdr(mgs)  = -vhacw(mgs) - vhacr(mgs)
+       vhlshdr(mgs)  = -vhlacw(mgs) - vhlacr(mgs)
+       qhwet(mgs)  = 0.0
+       qhlwet(mgs) = 0.0
+      end if
+!
+!      if (qhshr(mgs) .lt. 0.0 .and. temg(mgs) < tfr  ) THEN
+        wetsfc(mgs) =  (qhshr(mgs) .lt. 0.0 .and. temg(mgs) < tfr ) .or. ( qhmlr(mgs) < -qxmin(lh) .and.  temg(mgs) > tfr )
+        wetgrowth(mgs) = (qhshr(mgs) .lt. 0.0 .and. temg(mgs) < tfr )
+!      ENDIF
+
+      if (qhlshr(mgs) .lt. 0.0 .and. temg(mgs) < tfr ) THEN
+        wetsfchl(mgs) = (qhlshr(mgs) .lt. 0.0 .and. temg(mgs) < tfr ) .or. ( qhlmlr(mgs) < -qxmin(lhl) .and.  temg(mgs) > tfr )
+        wetgrowthhl(mgs) = (qhlshr(mgs) .lt. 0.0 .and. temg(mgs) < tfr )
+      ENDIF
+
+      end do
+!
+      if ( ipconc .ge. 1 ) then
+      do mgs = 1,ngscnt
+      csshr(mgs)  = 0.0 ! (cx(mgs,ls)/(qx(mgs,ls)+1.e-20))*Min(0.0,qsshr(mgs))
+      ! why is there a number loss for graupel for shedding? NEED TO CHECK THIS
+       ! chshr(mgs)  = (cx(mgs,lh)/(qx(mgs,lh)+1.e-20))*qhshr(mgs)
+       ! IF ( temg(mgs) < tfr ) chshr(mgs) = 0.0 ! no change to graupel number concentration for wet-growth shedding
+       
+       chshr(mgs) = 0.0 ! no change to graupel number concentration for wet-growth shedding
+       
+      !   tmpdiam = (shedalp+alpha(mgs,lh))*xdia(mgs,lh,1)
+        ! Base the drop size on the shedding regime
+            ! 8/26/2015 ERM updated to use shedalp and tmpdiam
+            ! tmpdiam = (shedalp+alpha(mgs,lh))*xdia(mgs,lh,1)
+            chshrr(mgs) =  rho0(mgs)*qhshr(mgs)/(xdn(mgs,lr)*vshdgs(mgs,lh))  ! into rain 
+      
+      IF ( .false. ) THEN
+      IF ( temg(mgs) < tfr ) THEN
+         chshrr(mgs) = Min( chshr(mgs), rho0(mgs)*qhshr(mgs)/(xdn0(lr)*vshd) ) ! maximum of dshd from shedding
+      ELSE
+        IF(imltshddmr > 0) THEN
+          ! DTD: If Dmg < sheddiam, then assume complete melting into
+          ! maximal raindrop.  Between sheddiam and sheddiam0, linearly ramp down to a 3 mm shed drop
+          tmp = -Min( chshr(mgs), rho0(mgs)*qhshr(mgs)/(xdn(mgs,lr)*xvmx(lr)) ) ! limit to maximum size allowed for rain
+          tmp2 = -rho0(mgs)*qhshr(mgs)/(xdn(mgs,lr)*vr3mm) ! conc. change for a 3 mm mean drop diameter
+          chshrr(mgs) = tmp*(sheddiam0-xdia(mgs,lh,3))/(sheddiam0-sheddiam)+tmp2*(xdia(mgs,lh,3)-sheddiam)/(sheddiam0-sheddiam)
+          chshrr(mgs) = -Max(tmp,Min(tmp2,chshrr(mgs)))
+        ELSE
+         chshrr(mgs) = Min( chshr(mgs), rho0(mgs)*qhshr(mgs)/(xdn(mgs,lr)*Min(vr4p5mm,xvmx(lr))) ) ! limit to maximum size allowed for rain or 4.5mm diameter, whichever is smaller
+!        chlmlrr(mgs) = rho0(mgs)*qhlmlr(mgs)/(Min(xdn(mgs,lr)*xvmx(lr), xdn(mgs,lhl)*xv(mgs,lhl)))  ! into rain 
+        ENDIF
+      ENDIF
+      ENDIF
+      
+      
+      chlshr(mgs) = 0.0
+      chlshrr(mgs) = 0.0
+      IF ( lhl .gt. 1 ) THEN 
+!         chlshr(mgs)  = (cx(mgs,lhl)/(qx(mgs,lhl)+1.e-20))*qhlshr(mgs)
+
+
+       chlshr(mgs) = 0.0 ! no change to hail number concentration for wet-growth shedding
+       
+      !   tmpdiam = (shedalp+alpha(mgs,lh))*xdia(mgs,lh,1)
+        ! Base the drop size on the shedding regime
+            ! 8/26/2015 ERM updated to use shedalp and tmpdiam
+            ! tmpdiam = (shedalp+alpha(mgs,lh))*xdia(mgs,lh,1)
+            chlshrr(mgs) =  rho0(mgs)*qhlshr(mgs)/(xdn(mgs,lr)*vshdgs(mgs,lhl))  ! into rain 
+
+
+      IF ( .false. ) THEN
+        IF ( temg(mgs) < tfr ) THEN
+          chlshrr(mgs) = Min( chlshr(mgs), rho0(mgs)*qhlshr(mgs)/(xdn0(lr)*vshd) ) ! maximum of dshd from shedding
+!         chlshrr(mgs) = Min( chlshr(mgs), rho0(mgs)*qhlshr(mgs)/(xdn0(lr)*vr1mm) ) ! maximum of 1mm drops from shedding
+        ELSE
+          IF(imltshddmr > 0) THEN
+            ! DTD: If Dmg < sheddiam, then assume complete melting into
+            ! maximal raindrop.  Between sheddiam and sheddiam0, linearly ramp down to a 3 mm shed drop
+            tmp = -Min( chlshr(mgs), rho0(mgs)*qhlshr(mgs)/(xdn(mgs,lr)*xvmx(lr)) ) ! limit to maximum size allowed for rain
+            tmp2 = -rho0(mgs)*qhlshr(mgs)/(xdn(mgs,lr)*vr3mm) ! conc. change for a 3 mm mean drop diameter
+            chlshrr(mgs) = tmp*(sheddiam0-xdia(mgs,lhl,3))/(sheddiam0-sheddiam)+tmp2*(xdia(mgs,lhl,3)-sheddiam)/(sheddiam0-sheddiam)
+            chlshrr(mgs) = -Max(tmp,Min(tmp2,chlshrr(mgs)))
+          ELSE
+           chlshrr(mgs) = Min( chlshr(mgs), rho0(mgs)*qhlshr(mgs)/(xdn(mgs,lr)*Min(vr4p5mm,xvmx(lr))) ) ! limit to 4.5mm diameter or maximum size allowed for rain, whichever is smaller
+!        chlmlrr(mgs) = rho0(mgs)*qhlmlr(mgs)/(Min(xdn(mgs,lr)*xvmx(lr), xdn(mgs,lhl)*xv(mgs,lhl)))  ! into rain 
+          ENDIF
+        ENDIF
+      ENDIF
+
+      ENDIF ! ( lhl > 1 )
+      
+      end do
+      end if
+
+
+
+!
+!  final decisions
+!
+      do mgs = 1,ngscnt
+!
+!  Snow
+!
+      if ( qsshr(mgs) .lt. 0.0 ) then
+      qsdpv(mgs) = 0.0
+      qssbv(mgs) = 0.0
+      else
+      qsshr(mgs) = 0.0
+      end if
+!
+!     if ( qsdry(mgs) .lt. qswet(mgs) ) then
+!     qswet(mgs) = 0.0
+!     else
+!     qsdry(mgs) = 0.0
+!     end if
+!
+
+! zero the shedding rates when wet snow/graupel included.
+! shedding of wet snow/graupel is calculated after summing other sources/sinks.
+      if (mixedphase) then
+        qsshr(mgs) = 0.0
+        qhshr(mgs) = 0.0
+        csshr(mgs) = 0.0
+        csshrr(mgs) = 0.0
+        chshr(mgs) = 0.0
+        chshrr(mgs) = 0.0
+        vhshdr(mgs) = 0.0
+        IF ( lhlw > 1 ) THEN
+          qhlshr(mgs) = 0.0
+          vhlshdr(mgs) = 0.0
+          chlshr(mgs) = 0.0
+          chlshrr(mgs) = 0.0
+        ENDIF
+      end if
+
+!  graupel
+!
+!
+      if ( wetgrowth(mgs) .or. (mixedphase .and. fhw(mgs) .gt. 0.05 .and. temg(mgs) .gt. 243.15) ) then
+      
+
+! soaking (when not advected liquid water film with graupel)
+
+        IF ( lvol(lh) .gt. 1 .and. .not. mixedphase) THEN
+        ! rescale volumes to maximum density
+         rimdn(mgs,lh) = xdnmx(lh)
+         raindn(mgs,lh) = xdnmx(lh)
+         vhacw(mgs) = qhacw(mgs)*rho0(mgs)/rimdn(mgs,lh)
+         vhacr(mgs) = qhacr(mgs)*rho0(mgs)/raindn(mgs,lh)
+!        IF ( lvol(lh) .gt. 1 .and. wetgrowth(mgs) ) THEN
+         IF ( xdn(mgs,lh) .lt. xdnmx(lh) ) THEN
+         ! soak some liquid into the graupel
+!           v1 = xdnmx(lh)*vx(mgs,lh)/(xdn(mgs,lh)*dtp) ! volume available for filling
+           v1 = (1. - xdn(mgs,lh)/xdnmx(lh))*vx(mgs,lh)/(dtp) ! volume available for filling
+!            tmp = (vx(mgs,lh)/rho0(mgs))*(xdnmx(lh) - xdn(mgs,lh)) ! max mixing ratio of liquid water that can be added
+           v2 = rho0(mgs)*qhwet(mgs)/xdnmx(lh)  ! volume of frozen accretion
+           
+           vhsoak(mgs) = Min(v1,v2)
+           
+         ENDIF
+
+         vhshdr(mgs) = Min(0.0, rho0(mgs)*qhwet(mgs)/xdnmx(lh) - vhacw(mgs) - vhacr(mgs) )
+         
+        ELSEIF ( lvol(lh) .gt. 1  .and. mixedphase ) THEN
+!         vhacw(mgs) = rho0(mgs)*qhacw(mgs)/xdn0(lr)
+!         vhacr(mgs) = rho0(mgs)*qhacr(mgs)/xdn0(lr)
+        ENDIF
+        
+
+      qhdpv(mgs) = 0.0
+!      qhsbv(mgs) = 0.0
+      chdpv(mgs) = 0.0
+!      chsbv(mgs) = 0.0
+
+      IF ( ipelec > 0 ) THEN
+      schacs(mgs) = 0.0
+      schaci(mgs) = 0.0
+      IF ( lis > 1 ) schacis(mgs) = 0.0
+      schacw(mgs) = 0.0
+      ENDIF
+! collection efficiency modification
+
+      IF ( ehi(mgs) .gt. 0.0 ) THEN
+        qhaci(mgs) = Min(qimxd(mgs),qhaci0(mgs))  ! effectively sets collection eff to 1
+        chaci(mgs) = Min(cimxd(mgs),chaci0(mgs))  ! effectively sets collection eff to 1
+      ENDIF
+      IF ( ehs(mgs) .gt. 0.0 ) THEN
+!        qhacs(mgs) = Min(qsmxd(mgs),qhacs(mgs)/ehs(mgs))  ! effectively sets collection eff to 1
+        qhacs(mgs) = Min(qsmxd(mgs),qhacs0(mgs)) !/ehs(mgs)                   ! divide out the collection efficiency
+        chacs(mgs) = Min(csmxd(mgs),chacs0(mgs)) !/ehs(mgs)                   ! divide out the collection efficiency
+        ehs(mgs) = ehsmax ! 1.0 ! min(ehsfrac*ehs(mgs),ehsmax)            ! modify it
+        qhacs(mgs) = Min(qsmxd(mgs),qhacs(mgs))   ! plug it back in
+      ENDIF
+
+! be sure to catch particles with wet surfaces but not in wet growth to turn off Hallett-Mossop
+      wetsfc(mgs) = .true.
+
+      else
+!        qhshr(mgs) = 0.0
+      end if
+!
+!
+!  hail
+!
+!      if ( lhl .gt. 1 .and. qhlshr(mgs) .lt. 0.0 ) then
+      if ( lhl > 1 .and. ( wetgrowthhl(mgs) .or. (mixedphase .and. fhlw(mgs) .gt. 0.05 .and. temg(mgs) .gt. 243.15) ) ) then
+!      if ( wetgrowthhl(mgs) ) then
+       
+
+      qhldpv(mgs) = 0.0
+!      qhlsbv(mgs) = 0.0
+      chldpv(mgs) = 0.0
+!      chlsbv(mgs) = 0.0
+
+
+      IF ( ipelec > 0 ) THEN
+      schlacs(mgs) = 0.0
+      schlaci(mgs) = 0.0
+      schlacw(mgs) = 0.0
+      ENDIF
+
+
+        IF ( lvol(lhl) .gt. 1  .and. .not. mixedphase ) THEN
+!        IF ( lvol(lhl) .gt. 1 .and. wetgrowthhl(mgs) ) THEN
+
+         rimdn(mgs,lhl) = xdnmx(lhl) 
+         raindn(mgs,lhl) = xdnmx(lhl) 
+         vhlacw(mgs) = qhlacw(mgs)*rho0(mgs)/rimdn(mgs,lhl)
+         vhlacr(mgs) = qhlacr(mgs)*rho0(mgs)/raindn(mgs,lhl)
+
+         IF ( xdn(mgs,lhl) .lt. xdnmx(lhl) ) THEN
+         ! soak some liquid into the hail
+!           v1 = xdnmx(lhl)*vx(mgs,lhl)/(xdn(mgs,lhl)*dtp) ! volume available for filling
+           v1 = (1. - xdn(mgs,lhl)/xdnmx(lhl))*vx(mgs,lhl)/(dtp) ! volume available for filling
+!            tmp = (vx(mgs,lhl)/rho0(mgs))*(xdnmx(lhl) - xdn(mgs,lhl)) ! max mixing ratio of liquid water that can be added
+           v2 = rho0(mgs)*qhlwet(mgs)/xdnmx(lhl)  ! volume of frozen accretion
+           IF ( v1 > v2 ) THEN ! all the frozen stuff fits in
+             vhlsoak(mgs) = v2
+           ELSE  ! fill up the available space
+             vhlsoak(mgs) = v1
+           ENDIF
+!           vhlacw(mgs) = 0.0
+!           vhlacr(mgs) = Max( 0.0, v2 - v1 )
+         ELSE
+           vhlsoak(mgs) = 0.0
+!           vhlacw(mgs) = 0.0
+!           vhlacr(mgs) = rho0(mgs)*qhlwet(mgs)/raindn(mgs,lhl)
+         
+         ENDIF
+
+         vhlshdr(mgs) = Min(0.0, rho0(mgs)*qhlwet(mgs)/xdnmx(lhl) - vhlacw(mgs) - vhlacr(mgs) )
+
+
+        ELSEIF ( lvol(lhl) .gt. 1  .and. mixedphase ) THEN
+!         vhlacw(mgs) = rho0(mgs)*qhlacw(mgs)/xdn0(lr)
+!         vhlacr(mgs) = rho0(mgs)*qhlacr(mgs)/xdn0(lr)
+        ENDIF
+
+      IF ( ehli(mgs) .gt. 0.0 ) THEN
+        qhlaci(mgs) = Min(qimxd(mgs),qhlaci0(mgs))  ! effectively sets collection eff to 1
+        chlaci(mgs) = Min(cimxd(mgs),chlaci0(mgs))  ! effectively sets collection eff to 1
+      ENDIF
+
+!      IF ( ehls(mgs) .gt. 0.0 ) THEN
+!        qhlacs(mgs) = Min(qsmxd(mgs),qhlacs(mgs)/ehls(mgs))
+!      ENDIF
+      IF ( ehls(mgs) .gt. 0.0 ) THEN
+        qhlacs(mgs) = Min(qsmxd(mgs),qhlacs0(mgs)) !/ehls(mgs)                   ! divide out the collection efficiency
+        chlacs(mgs) = Min(csmxd(mgs),chlacs0(mgs)) !/ehls(mgs)                   ! divide out the collection efficiency
+        ehls(mgs) = ehsmax ! 1.0 ! min(ehsfrac*ehs(mgs),ehsmax)            ! modify it
+!        qhlacs(mgs) = Min(qsmxd(mgs),qhlacs(mgs))   ! plug it back in
+      ENDIF
+
+      
+!      qhlwet(mgs) = 1.0
+
+! be sure to catch particles with wet surfaces but not in wet growth to turn off Hallett-Mossop
+      wetsfchl(mgs) = .true.
+
+
+      else
+!      qhlshr(mgs) = 0.0
+!      qhlwet(mgs) = 0.0
+      end if
+
+
+      end do
+!
+! Ice -> graupel conversion
+!
+      DO mgs = 1,ngscnt
+      
+      qhcni(mgs) = 0.0
+      chcni(mgs) = 0.0
+      chcnih(mgs) = 0.0
+      vhcni(mgs) = 0.0
+      
+      IF ( iglcnvi .ge. 1 ) THEN
+      IF ( temg(mgs) .lt. 273.0 .and. qiacw(mgs) - qidpv(mgs) .gt. 0.0 ) THEN
+      
+        
+        tmp = rimc1*(-((0.5)*(1.e+06)*xdia(mgs,lc,1))   &
+     &                *((0.60)*vtxbar(mgs,li,1))   &
+     &                /(temg(mgs)-273.15))**(rimc2)
+        tmp = Min( Max( rimc3, tmp ), 900.0 )
+        
+        !  Assume that half the volume of the embryo is rime with density 'tmp'
+        !  m = rhoi*(V/2) + rhorime*(V/2) = (rhoi + rhorime)*V/2
+        !  V = 2*m/(rhoi + rhorime)
+        
+!        write(0,*)  'rime dens = ',tmp
+        
+        IF ( tmp .ge. 200.0 .or. iglcnvi >= 2 ) THEN
+          r = Max( 0.5*(xdn(mgs,li) + tmp), xdnmn(lh) )
+!          r = Max( r, 400. )
+          qhcni(mgs) = (qiacw(mgs) - qidpv(mgs)) ! *float(iglcnvi)
+          chcni(mgs) = cx(mgs,li)*qhcni(mgs)/qx(mgs,li)
+!          chcnih(mgs) = rho0(mgs)*qhcni(mgs)/(1.6e-10)
+          chcnih(mgs) = Min(chcni(mgs), rho0(mgs)*qhcni(mgs)/(r*xvmn(lh)) )
+!          vhcni(mgs) = rho0(mgs)*2.0*qhcni(mgs)/(xdn(mgs,li) + tmp)
+          vhcni(mgs) = rho0(mgs)*qhcni(mgs)/r
+        ENDIF
+      
+      ELSEIF ( iglcnvi == 3 ) THEN
+
+       IF ( temg(mgs) .lt. 273.0 .and. qiacw(mgs)*dtp > 2.*qxmin(lh) .and. gamice73fac*xmas(mgs,li) > xdnmn(lh)*xvmn(lh) ) THEN
+      
+        
+        tmp = rimc1*(-((0.5)*(1.e+06)*xdia(mgs,lc,1))   &
+     &                *((0.60)*vtxbar(mgs,li,1))   &
+     &                /(temg(mgs)-273.15))**(rimc2)
+        tmp = Min( Max( rimc3, tmp ), 900.0 )
+        
+        !  Assume that half the volume of the embryo is rime with density 'tmp'
+        !  m = rhoi*(V/2) + rhorime*(V/2) = (rhoi + rhorime)*V/2
+        !  V = 2*m/(rhoi + rhorime)
+        
+!        write(0,*)  'rime dens = ',tmp
+        ! convert to particles with the mass of the mass-weighted diameter
+      !  massofmwr = gamice73fac*xmas(mgs,li)
+        
+        IF ( tmp .ge. xdnmn(lh)  ) THEN
+          r = Max( 0.5*(xdn(mgs,li) + tmp), xdnmn(lh) )
+!          r = Max( r, 400. )
+          qhcni(mgs) = 0.5*qiacw(mgs)
+          chcni(mgs) = qhcni(mgs)/(gamice73fac*xmas(mgs,li))
+          chcnih(mgs) = Min(chcni(mgs), rho0(mgs)*qhcni(mgs)/(r*xvmn(lh)) )
+!          vhcni(mgs) = rho0(mgs)*2.0*qhcni(mgs)/(xdn(mgs,li) + tmp)
+          vhcni(mgs) = rho0(mgs)*qhcni(mgs)/r
+        ENDIF
+      
+      ENDIF
+
+      
+      ENDIF
+      ENDIF
+      
+      
+      ENDDO
+      
+      
+      qhlcnh(:) = 0.0
+      chlcnh(:) = 0.0
+      vhlcnh(:) = 0.0
+      vhlcnhl(:) = 0.0
+      zhlcnh(:) = 0.0
+
+      qhcnhl(:) = 0.0
+      chcnhl(:) = 0.0
+      vhcnhl(:) = 0.0
+      zhcnhl(:) = 0.0
+      
+
+      IF ( lhl .gt. 1  ) THEN
+      
+      IF ( ihlcnh == 1 ) THEN
+
+!
+!  Graupel (h) conversion to hail (hl) based on Milbrandt and Yau 2005b
+!
+      DO mgs = 1,ngscnt
+
+!        IF ( lhl .gt. 1 .and. ipconc .ge. 5 .and. qx(mgs,lh) .gt. 1.0e-3 .and.
+!     :        xdn(mgs,lh) .gt. 750. .and. qhshr(mgs) .lt. 0.0 .and.
+!     :        xdia(mgs,lh,3) .gt. 1.e-3 ) THEN
+        IF ( hlcnhdia > 0 ) THEN
+          ltest = xdia(mgs,lh,3) .gt. hlcnhdia  ! test on mean volume diameter
+        ELSE 
+!          ltest =  xdia(mgs,lh,1)*(3. + alpha(mgs,lh)) > Abs( hlcnhdia ) ! test on maximum mass diameter
+          ltest =  xdia(mgs,lh,1)*(4. + alpha(mgs,lh)) > Abs( hlcnhdia ) ! test on mass-weighted diameter
+        ENDIF
+        
+        IF (  wetgrowth(mgs) .and. (xdn(mgs,lh) .gt. hldnmn .or. lvh < 1 ) .and.  & ! correct this when hail gets turned on
+!        IF (  ( qhshr(mgs) .lt. 0.0 .or. rimdn(mgs,lh) .gt. 800. ) .and.   &
+     &        rimdn(mgs,lh) .gt. 800. .and.   &
+     &        ltest .and. qx(mgs,lh) .gt. hlcnhqmin ) THEN
+!     :        xdia(mgs,lh,3) .gt. 2.e-3 .and. qx(mgs,lh) .gt. 1.0e-3 ) THEN ! 0823.2008 erm test
+!        IF ( xdia(mgs,lh,3) .gt. 1.e-3 ) THEN
+        IF ( qhacw(mgs) .gt. 0.0 .and. qhacw(mgs) .gt. qhaci(mgs) .and. temg(mgs) .le. tfr-2.0 ) THEN
+        ! dh0 is the diameter dividing wet growth from dry growth (Ziegler 1985), modified by MY05
+!          dh0 = 0.01*(exp(temcg(mgs)/(1.1e4*(qx(mgs,lc)+qx(mgs,lr)) - 
+!     :           1.3e3*qx(mgs,li) + 1.0e-3 ) ) - 1.0)
+          x = (1.1e4*(rho0(mgs)*qx(mgs,lc)) - 1.3e3*rho0(mgs)*qx(mgs,li) + 1.0e-3 )
+          IF ( x > 1.e-20 ) THEN
+          arg = Min(70.0, (-temcg(mgs)/x )) ! prevent overflow of the exp function in 32 bit
+          dh0 = 0.01*(exp(arg) - 1.0)
+          ELSE
+           dh0 = 1.e30
+          ENDIF
+!          dh0 = Max( dh0, 5.e-3 )
+          
+!         IF ( dh0 .gt. 0.0 ) write(0,*) 'dh0 = ',dh0
+!         IF ( dh0 .gt. 1.0e-4 ) THEN
+         IF ( xdia(mgs,lh,3)/dh0 .gt. 0.1 ) THEN 
+!         IF ( xdia(mgs,lh,3) .lt. 20.*dh0 .and. dh0 .lt. 2.0*xdia(mgs,lh,3) ) THEN 
+           tmp = qhacw(mgs) + qhacr(mgs) + qhaci(mgs) + qhacs(mgs)
+!           qtmp = Min( 1.0, xdia(mgs,lh,3)/(2.0*dh0) )*(tmp)
+           qtmp = Min( 100.0, xdia(mgs,lh,3)/(2.0*dh0) )*(tmp)
+           IF ( .false. .and. qx(mgs,lhl) + qtmp*dtp .lt. 0.5e-3 ) THEN
+             hdia1 = Max(dh0, xdia(mgs,lh,3) )
+            qtmp = qtmp + Min(qxmxd(mgs,lh), Max( 0.0,   &
+     &      ((pi*xdn(mgs,lh)*cx(mgs,lh)) / (6.0*rho0(mgs)*dtp))   &
+     &      *exp(-hdia1/xdia(mgs,lh,1))   &
+     &      *( (hdia1**3) + 3.0*(hdia1**2)*xdia(mgs,lh,1)   &
+     &      + 6.0*(hdia1)*(xdia(mgs,lh,1)**2) + 6.0*(xdia(mgs,lh,1)**3) ) ) )
+
+!c           qtmp = Min( qxmxd(mgs,lh), qtmp )
+!c           tmp = tmp + Min( 0.5e-3*dtpinv, qtmp )
+           ENDIF
+!           write(0,*) 'dh0 = ',dh0,tmp,qx(mgs,lh)*1000.
+!           qhlcnh(mgs) = Min( 0.5*(qx(mgs,lh))+tmp, xdia(mgs,lh,3)/(2.0*dh0)*(tmp) )
+!           qhlcnh(mgs) = Min(  qxmxd(mgs,lh), xdia(mgs,lh,3)/(2.0*dh0)*(tmp) )
+           qhlcnh(mgs) = Min(  qxmxd(mgs,lh), qtmp )
+           
+           IF ( ipconc .ge. 5 ) THEN
+!           dh0 = Max( xdia(mgs,lh,3), Min( dh0, 5.e-3 ) ) ! do not create hail greater than 5mm diam. unless the graupel is larger
+           dh0 = Min( dh0, 10.e-3 ) ! do not create hail greater than 10mm diam., which is the max graupel size
+!           IF ( qx(mgs,lhl) > 0.1e-3 ) dh0 = xdia(mgs,lhl,3) ! when enough hail is established, do not dilute the size
+           chlcnh(mgs) = Min( cxmxd(mgs,lh), rho0(mgs)*qhlcnh(mgs)/(pi*xdn(mgs,lh)*dh0**3/6.0) )
+!           chlcnh(mgs) = Min( chlcnh(mgs), (1./8.)*rho0(mgs)*qhlcnh(mgs)/(xdn(mgs,lh)*xv(mgs,lh)) )
+!           chlcnh(mgs) = Min( chlcnh(mgs), (1./2.)*rho0(mgs)*qhlcnh(mgs)/(xdn(mgs,lh)*xv(mgs,lh)) )
+           r = rho0(mgs)*qhlcnh(mgs)/(xdn(mgs,lh)*xv(mgs,lh))  ! number of graupel particles at mean volume diameter
+!           chlcnh(mgs) = Min( Max( 1./8.*r , chlcnh(mgs)), r )
+!           chlcnh(mgs) = Min( chlcnh(mgs), r )
+           chlcnh(mgs) = Max( chlcnh(mgs), r )
+!           chlcnh(mgs) =  r 
+           ENDIF
+           
+           vhlcnh(mgs) = rho0(mgs)*qhlcnh(mgs)/xdn(mgs,lh)
+           vhlcnhl(mgs) = rho0(mgs)*qhlcnh(mgs)/Max(xdnmn(lhl), xdn(mgs,lh))
+!           write(0,*) 'qhlcnh = ',qhlcnh(mgs)*1000.,chlcnh(mgs)
+          ENDIF
+!         write(0,*) 'graupel to hail conversion not complete! STOP!'
+!         STOP
+        ENDIF
+        ENDIF
+      
+      ENDDO
+      
+      ELSEIF ( ihlcnh == 2 ) THEN ! 10-ice type conversion 
+
+!
+! Staka and Mansell (2005) type conversion -- assuming alphah = 0 for now!
+!
+!      hldia1 is set in micro_module and namelist
+      do mgs = 1,ngscnt
+!      qhlcnh(mgs) = 0.0
+!      chlcnh(mgs) = 0.0
+      if ( wetgrowth(mgs) .and. temg(mgs) .lt. tfr-5. .and. qx(mgs,lh) > qxmin(lh) ) then
+      if ( qhacw(mgs).gt.1.e-6 .and. xdn(mgs,lh) > 700. ) then
+      qhlcnh(mgs) =                                                   &
+        ((pi*xdn(mgs,lh)*cx(mgs,lh)) / (6.0*rho0(mgs)*dtp))           &
+       *exp(-hldia1/xdia(mgs,lh,1))                                    &
+       *( (hldia1**3) + 3.0*(hldia1**2)*xdia(mgs,lh,1)                  &
+        + 6.0*(hldia1)*(xdia(mgs,lh,1)**2) + 6.0*(xdia(mgs,lh,1)**3) )
+      qhlcnh(mgs) =   min(qhlcnh(mgs),qhmxd(mgs))
+      IF ( ipconc .ge. 5 ) THEN
+        chlcnh(mgs) = Min( cxmxd(mgs,lh), cx(mgs,lh)*Exp(-hldia1/xdia(mgs,lh,1)))
+!        chlcnh(mgs) = Min( cxmxd(mgs,lh), rho0(mgs)*qhlcnh(mgs)/(2.0*xmas(mgs,lh) ))
+      ENDIF
+           vhlcnh(mgs) = rho0(mgs)*qhlcnh(mgs)/xdn(mgs,lh)
+           vhlcnhl(mgs) = rho0(mgs)*qhlcnh(mgs)/Max(xdnmn(lhl), xdn(mgs,lh))
+      end if
+      end if
+      end do
+      
+      ENDIF
+      
+     ! convert low-density hail to graupel
+      IF ( icvhl2h >= 1 ) THEN
+      DO mgs = 1,ngscnt
+        IF (  qx(mgs,lhl) > qxmin(lhl) .and. xdn(mgs,lhl) < 0.5*(xdnmn(lhl) + xdnmx(lhl)) ) THEN
+          tmp = Min(0.95, 1. - 0.5*(1. + tanh(0.125*(xdn(mgs,lhl) - 1.01*xdnmn(lhl) )) ))
+          qhcnhl(mgs) = tmp*qx(mgs,lhl)*dtpinv
+          chcnhl(mgs) = cx(mgs,lhl)*qhcnhl(mgs)/qx(mgs,lhl)
+          vhcnhl(mgs) = vx(mgs,lhl)*qhcnhl(mgs)/qx(mgs,lhl)
+          
+        ENDIF
+      ENDDO
+      
+      ENDIF
+      
+      
+      ENDIF ! lhl > 1
+
+
+!
+! Ziegler snow conversion to graupel
+!
+      DO mgs = 1,ngscnt
+
+      qhcns(mgs) = 0.0
+      chcns(mgs) = 0.0
+      chcnsh(mgs) = 0.0
+      vhcns(mgs) = 0.0
+
+      qscnh(mgs) = 0.0
+      cscnh(mgs) = 0.0
+      vscnh(mgs) = 0.0
+
+      IF ( ipconc .ge. 5 ) THEN
+
+        ! test attempt at converting graupel to snow when not riming but growing by deposition
+        IF ( temg(mgs) < tfr .and. qx(mgs,lh) .gt. qxmin(lh) .and. qhdpv(mgs) > qxmin(lh)*dtpinv  &
+     &       .and. qhacw(mgs) < qxmin(lh)*dtpinv ) THEN
+          IF ( xdn(mgs,lh) < 290. ) THEN
+!          qscnh(mgs) = 2.*qhdpv(mgs)
+!          cscnh(mgs) = cx(mgs,lh)*qscnh(mgs)/qx(mgs,lh)
+!          vscnh(mgs) = rho0(mgs)*qscnh(mgs)/xdn(mgs,lh)
+          ENDIF
+        ENDIF
+
+
+        IF ( qx(mgs,ls) .gt. qxmin(ls) .and. qsacw(mgs) .gt. 0.0 ) THEN
+
+!      DATA VGRA/1.413E-2/  ! this is the volume (cm**3) of a 3mm diam. sphere
+!    vgra = 1.4137e-8 m**3
+
+!      DNNET=DNCNV-DNAGG
+!      DQNET=QXCON+QSACC+SDEP
+!
+!      DNSCNV=EXP(-(ROS*XNS*VGRA/(RO*QI)))*((1.-(XNS*VGRA*ROS/
+!     / (RO*QI)))*DNNET + (XNS**2*VGRA*ROS/(RO*QI**2))*DQNET)
+!      IF(DNSCNV.LT.0.) DNSCNV=0.
+!
+!      QIHC=(ROS*VGRA/RO)*DNSCNV
+!
+!      QH=QH+DT*QIHC
+!      QI=QI-DT*QIHC
+!      XNH=XNH+DT*DNSCNV
+!      XNS=XNS-DT*DNSCNV
+
+        IF ( iglcnvs .eq. 1 ) THEN  ! Zrnic, Ziegler et al (1993)
+
+        dnnet = cscnvis(mgs) + cscnis(mgs) - csacs(mgs)
+        dqnet = qscnvi(mgs) + qscni(mgs) + qsacw(mgs) + qsdpv(mgs) + qssbv(mgs)
+
+        a3 = 1./(rho0(mgs)*qx(mgs,ls))
+        a1 = Exp( - xdn(mgs,ls)*cx(mgs,ls)*vgra*a3 )  ! EXP(-(ROS*XNS*VGRA/(RO*QI)))
+! (1.-(XNS*VGRA*ROS/(RO*QI)))*DNNET
+        a2 =  (1.-(cx(mgs,ls)*vgra*xdn(mgs,ls)*a3))*dnnet
+! (XNS**2*VGRA*ROS/(RO*QI**2))*DQNET
+        a4 = cx(mgs,ls)**2*vgra*xdn(mgs,ls)*a3/qx(mgs,ls)*dqnet
+
+        chcns(mgs) = Max( 0.0, a1*(a2 + a4) )
+        chcns(mgs) = Min( chcns(mgs), cxmxd(mgs,ls) )
+        chcnsh(mgs) = chcns(mgs)
+
+        qhcns(mgs) = Min( xdn(mgs,ls)*vgra*rhoinv(mgs)*chcns(mgs), qxmxd(mgs,ls) )
+        vhcns(mgs) = rho0(mgs)*qhcns(mgs)/Max(xdn(mgs,ls),xdnmn(lh))
+!        vhcns(mgs) = rho0(mgs)*qhcns(mgs)/Max(xdn(mgs,ls),400.)
+
+        ELSEIF ( iglcnvs .ge. 2  ) THEN  ! treat like ice crystals, i.e., check for rime density (ERM)
+
+          IF ( temg(mgs) .lt. 273.0 .and. ( qsacw(mgs) - qsdpv(mgs) .gt. 0.0 .or. &
+              ( iglcnvs >= 3 .and. qsacw(mgs) > 2.*qxmin(lh) .and. gamsnow73fac*xmas(mgs,ls) > xdnmn(lh)*xvmn(lh)  ) ) ) THEN !{
+
+
+        tmp = rimc1*(-((0.5)*(1.e+06)*xdia(mgs,lc,1))   &
+     &                *((0.60)*vtxbar(mgs,ls,1))   &
+     &                /(temg(mgs)-273.15))**(rimc2)
+!        tmp = Min( Max( rimc3, tmp ), 900.0 )
+        tmp = Min( tmp , 900.0 )
+
+        !  Assume that half the volume of the embryo is rime with density 'tmp'
+        !  m = rhoi*(V/2) + rhorime*(V/2) = (rhoi + rhorime)*V/2
+        !  V = 2*m/(rhoi + rhorime)
+
+!        write(0,*)  'rime dens = ',tmp
+
+        IF ( iglcnvs == 2 ) THEN !{
+        IF ( tmp .ge. 200.0  ) THEN
+          r = Max( 0.5*(xdn(mgs,ls) + tmp), xdnmn(lh) )
+!          r = Max( r, 400. )
+          qhcns(mgs) = (qsacw(mgs) - qsdpv(mgs))
+          chcns(mgs) = cx(mgs,ls)*qhcns(mgs)/qx(mgs,ls)
+!          chcnih(mgs) = rho0(mgs)*qhcni(mgs)/(1.6e-10)
+          chcnsh(mgs) = Min(chcns(mgs), rho0(mgs)*qhcns(mgs)/(r*xvmn(lh)) )
+!          vhcni(mgs) = rho0(mgs)*2.0*qhcni(mgs)/(xdn(mgs,li) + tmp)
+          vhcns(mgs) = rho0(mgs)*qhcns(mgs)/r
+        ENDIF
+        
+        ELSEIF ( iglcnvs == 3 ) THEN
+ 
+         ! convert to particles with the mass of the mass-weighted diameter
+      !  massofmwr = gamice73fac*xmas(mgs,li)
+        
+        IF ( tmp > xdnmn(lh) ) THEN
+          r = Max( 0.5*(xdn(mgs,ls) + tmp), xdnmn(lh) )
+!          r = Max( r, 400. )
+          qhcns(mgs) = 0.5*qsacw(mgs)
+          chcns(mgs) = qhcns(mgs)/(gamsnow73fac*xmas(mgs,ls))
+          chcns(mgs) = Min( chcns(mgs), cx(mgs,ls)*qhcns(mgs)/qx(mgs,ls))
+          chcnsh(mgs) = Min(chcns(mgs), rho0(mgs)*qhcns(mgs)/(r*xvmn(lh)) )
+          vhcns(mgs) = rho0(mgs)*qhcns(mgs)/r
+        ENDIF
+
+        ENDIF !}
+
+      ENDIF !}
+
+        ENDIF
+
+
+        ENDIF
+
+       ELSE ! single moment lfo
+
+        qhcns(mgs) = 0.001*ehscnv(mgs)*max((qx(mgs,ls)-6.e-4),0.0)
+        qhcns(mgs) = min(qhcns(mgs),qxmxd(mgs,ls))
+        IF ( lvol(lh) .ge. 1 ) vhcns(mgs) = rho0(mgs)*qhcns(mgs)/Max(xdn(mgs,ls),400.)
+
+       ENDIF
+      ENDDO
+!
+!
+!  heat budget for rain---not all rain that collects ice can freeze
+!
+!
+!
+      if ( irwfrz .gt. 0 .and. .not. mixedphase) then
+!
+      do mgs = 1,ngscnt
+!
+!  compute total rain that freeze when it interacts with cloud ice
+!
+      qrztot(mgs) = qrfrz(mgs) + qiacr(mgs) + qsacr(mgs)
+!
+!  compute the maximum amount of rain that can freeze
+!  Used to limit freezing to 4*qrmxd, but now allow all rain to freeze if possible
+!
+      qrzmax(mgs) =   &
+     &  ( xdia(mgs,lr,1)*rwvent(mgs)*cx(mgs,lr)*fwet1(mgs) )
+      qrzmax(mgs) = max(qrzmax(mgs), 0.0)
+      qrzmax(mgs) = min(qrztot(mgs), qrzmax(mgs))
+      qrzmax(mgs) = min(qx(mgs,lr)*dtpinv, qrzmax(mgs))
+
+      IF ( temcg(mgs) < -30. ) THEN ! allow all to freeze if T < -30 because fwet becomes invalid (negative)
+        qrzmax(mgs) = qx(mgs,lr)*dtpinv
+      ENDIF
+!      qrzmax(mgs) = min(4.*qrmxd(mgs), qrzmax(mgs))
+!
+!  compute the correction factor
+!
+!      IF ( qrztot(mgs) .gt. qxmin(lr) ) THEN
+      IF ( qrztot(mgs) .gt. qrzmax(mgs) .and. qrztot(mgs) .gt. qxmin(lr) ) THEN
+        qrzfac(mgs) = qrzmax(mgs)/(qrztot(mgs))
+      ELSE
+        qrzfac(mgs) = 1.0
+      ENDIF
+      qrzfac(mgs) = min(1.0, qrzfac(mgs))
+!
+      end do
+!
+!
+! now correct the above sources
+!
+!
+      do mgs = 1,ngscnt
+      if ( temg(mgs) .le. 273.15 .and. qrzfac(mgs) .lt. 1.0 ) then
+      qrfrz(mgs)   = qrzfac(mgs)*qrfrz(mgs)
+      qrfrzs(mgs)  = qrzfac(mgs)*qrfrzs(mgs)
+      qrfrzf(mgs)  = qrzfac(mgs)*qrfrzf(mgs)
+      qiacr(mgs)   = qrzfac(mgs)*qiacr(mgs)
+      qsacr(mgs)   = qrzfac(mgs)*qsacr(mgs)
+      qiacrf(mgs)  = qrzfac(mgs)*qiacrf(mgs)
+      qiacrs(mgs)  = qrzfac(mgs)*qiacrs(mgs)
+      crfrz(mgs)   = qrzfac(mgs)*crfrz(mgs)
+      crfrzf(mgs)  = qrzfac(mgs)*crfrzf(mgs)
+      crfrzs(mgs)  = qrzfac(mgs)*crfrzs(mgs)
+      ciacr(mgs)   = qrzfac(mgs)*ciacr(mgs)
+      ciacrf(mgs)  = qrzfac(mgs)*ciacrf(mgs)
+      ciacrs(mgs)  = qrzfac(mgs)*ciacrs(mgs)
+
+      
+       vrfrzf(mgs)  = qrzfac(mgs)*vrfrzf(mgs)
+       viacrf(mgs)  = qrzfac(mgs)*viacrf(mgs)
+      end if
+      end do
+!
+!
+!
+      end if
+!
+!
+!
+!  evaporation of rain
+!
+!
+!
+      qrcev(:) = 0.0
+      crcev(:) = 0.0
+
+
+      do mgs = 1,ngscnt
+!
+      IF ( qx(mgs,lr) .gt. qxmin(lr) ) THEN
+
+      qrcev(mgs) =   &
+     &  fvce(mgs)*cx(mgs,lr)*rwvent(mgs)*rwcap(mgs)*evapfac
+! this line to allow condensation on rain:
+      IF ( rcond .eq. 1 ) THEN
+        qrcev(mgs) = min(qrcev(mgs), qxmxd(mgs,lv))
+! this line to have evaporation only:
+      ELSE
+        qrcev(mgs) = min(qrcev(mgs), 0.0)
+      ENDIF
+
+      qrcev(mgs) = max(qrcev(mgs), -qrmxd(mgs))
+!      if ( temg(mgs) .lt. 273.15 ) qrcev(mgs) = 0.0
+      IF ( qrcev(mgs) .lt. 0. .and. lnr > 1 ) THEN
+!        qrcev(mgs) =   -qrmxd(mgs)
+!        crcev(mgs) = (rho0(mgs)/(xmas(mgs,lr)+1.e-20))*qrcev(mgs)
+      crcev(mgs) = (cx(mgs,lr)/(qx(mgs,lr)))*qrcev(mgs)
+      ELSE
+         crcev(mgs) = 0.0
+      ENDIF
+!      if ( temg(mgs) .lt. 273.15 ) crcev(mgs) = 0.0
+!
+      ENDIF
+
+      end do
+!
+! evaporation/condensation of wet graupel and snow
+!
+      qscev(:) = 0.0
+      cscev(:) = 0.0
+      qhcev(:) = 0.0
+      chcev(:) = 0.0
+      qhlcev(:) = 0.0
+      chlcev(:) = 0.0
+
+!
+!
+!
+!  ICE MULTIPLICATION: Two modes (rimpa, and rimpb)
+!  (following Cotton et al. 1986)
+!
+ 
+      chmul1(:) =  0.0
+      chlmul1(:) =  0.0
+      csmul1(:) = 0.0
+!
+      qhmul1(:) =  0.0
+      qhlmul1(:) =  0.0
+      qsmul1(:) =  0.0
+
+      do mgs = 1,ngscnt
+ 
+       ltest =  qx(mgs,lh) .gt. qxmin(lh)
+       IF ( lhl > 1 )  ltest =  ltest .or. qx(mgs,lhl) .gt. qxmin(lhl)
+       
+      IF ( (itype1 .ge. 1 .or. itype2 .ge. 1 )   &
+     &              .and. qx(mgs,lc) .gt. qxmin(lc)) THEN
+      if ( temg(mgs) .ge. 265.15 .and. temg(mgs) .le. 271.15 ) then
+       IF ( ipconc .ge. 2 ) THEN
+        IF ( xv(mgs,lc) .gt. 0.0     &
+     &     .and.  ltest &
+!     .and. itype2 .ge. 2    &
+     &       ) THEN
+!
+!  Ziegler et al. 1986 Hallett-Mossop process.  VSTAR = 7.23e-15 (vol of 12micron radius)
+!
+         IF ( cnu == 0.0 ) THEN
+           ex1 = (1./250.)*Exp(-7.23e-15/xv(mgs,lc))
+         ELSE
+            ratio = (1. + cnu)*(7.23e-15)/xv(mgs,lc)
+            ex1 = (1./250.)*Gamxinf(1.+cnu, ratio)/(gcnup1)
+         ENDIF
+       IF ( itype2 .le. 2 ) THEN
+         ft = Max(0.0,Min(1.0,-0.11*temcg(mgs)**2 - 1.1*temcg(mgs)-1.7))
+       ELSE
+        IF ( temg(mgs) .ge. 265.15 .and. temg(mgs) .le. 267.15 ) THEN
+          ft = 0.5
+        ELSEIF (temg(mgs) .ge. 267.15 .and. temg(mgs) .le. 269.15 ) THEN
+          ft = 1.0
+        ELSEIF (temg(mgs) .ge. 269.15 .and. temg(mgs) .le. 271.15 ) THEN
+          ft = 0.5
+        ELSE 
+          ft = 0.0
+        ENDIF
+       ENDIF
+!        rhoinv = 1./rho0(mgs)
+!        DNSTAR = ex1*cglacw(mgs)
+        
+       IF ( ft > 0.0 ) THEN
+        
+        IF ( itype2 > 0 ) THEN
+         IF ( qx(mgs,lh) .gt. qxmin(lh) .and. (.not. wetsfc(mgs))  ) THEN
+          chmul1(mgs) = ft*ex1*chacw(mgs)
+!          chmul1(mgs) = Min( ft*ex1*chacw(mgs), ft*(30.*1.e+06)*rho0(mgs)*qhacw(mgs) ) ! 1.e+6 converts kg to mg; Saunders & Hosseini (2001) average of about 30 crystals per mg
+          qhmul1(mgs) = cimas0*chmul1(mgs)*rhoinv(mgs)
+         ENDIF
+         IF ( lhl .gt. 1 ) THEN
+           IF ( qx(mgs,lhl) .gt. qxmin(lhl) .and. (.not. wetsfchl(mgs))  ) THEN
+            chlmul1(mgs) = (ft*ex1*chlacw(mgs))
+            qhlmul1(mgs) = cimas0*chlmul1(mgs)*rhoinv(mgs)
+           ENDIF
+         ENDIF
+        ENDIF ! itype2
+
+        IF ( itype1 > 0 ) THEN
+         IF ( qx(mgs,lh) .gt. qxmin(lh) .and. (.not. wetsfc(mgs))  ) THEN
+          tmp = ft*(3.5e+08)*rho0(mgs)*qhacw(mgs)
+          chmul1(mgs) = chmul1(mgs) + tmp
+          qhmul1(mgs) = qhmul1(mgs) + cimas0*tmp*rhoinv(mgs)
+         ENDIF
+         IF ( lhl .gt. 1 ) THEN
+           IF ( qx(mgs,lhl) .gt. qxmin(lhl) .and. (.not. wetsfchl(mgs)) ) THEN
+            tmp = ft*(3.5e+08)*rho0(mgs)*qhlacw(mgs)
+            chlmul1(mgs) = chlmul1(mgs) + tmp
+            qhlmul1(mgs) = qhlmul1(mgs) + cimas0*tmp*rhoinv(mgs)
+           ENDIF
+         ENDIF
+        ENDIF ! itype1
+
+        
+        ENDIF ! ft
+
+        ENDIF ! xv(mgs,lc) .gt. 0.0 .and.
+
+       ELSE ! ipconc .lt. 2
+!
+!  define the temperature function
+!
+      fimt1(mgs) = 0.0
+!
+! Cotton et al. (1986) version
+!
+      if ( temg(mgs) .ge. 268.15 .and. temg(mgs) .le. 270.15 ) then
+        fimt1(mgs) = 1.0 -(temg(mgs)-268.15)/2.0
+      elseif (temg(mgs) .le. 268.15 .and. temg(mgs) .ge. 265.15 ) then
+        fimt1(mgs) = 1.0 +(temg(mgs)-268.15)/3.0
+      ELSE 
+        fimt1(mgs) = 0.0
+      end if
+!
+! Ferrier (1994) version
+!
+      if ( temg(mgs) .ge. 265.15 .and. temg(mgs) .le. 267.15 ) then
+        fimt1(mgs) = 0.5
+      elseif (temg(mgs) .ge. 267.15 .and. temg(mgs) .le. 269.15 ) then
+        fimt1(mgs) = 1.0
+      elseif (temg(mgs) .ge. 269.15 .and. temg(mgs) .le. 271.15 ) then
+        fimt1(mgs) = 0.5
+      ELSE 
+        fimt1(mgs) = 0.0
+      end if
+!
+!
+!   type I:  350 splinters are formed for every 1e-3 grams of cloud
+!            water accreted by graupel/hail (note converted to MKS units)
+!            3.5e+8 has units of 1/kg
+!
+      IF ( itype1 .ge. 1 ) THEN
+       fimta(mgs) = (3.5e+08)*rho0(mgs)
+      ELSE
+       fimta(mgs) = 0.0
+      ENDIF
+
+!
+!
+!   type II:  1 splinter formed for every 250 cloud droplets larger than
+!             24 micons in diameter (12 microns in radius) accreted by
+!             graupel/hail
+!
+!
+      fimt2(mgs) = 0.0
+      xcwmas = xmas(mgs,lc) * 1000.
+!
+      IF ( itype2 .ge. 1 ) THEN
+      if ( xcwmas.lt.1.26e-9 ) then
+        fimt2(mgs) = 0.0
+      end if
+      if ( xcwmas .le. 3.55e-9 .and. xcwmas .ge. 1.26e-9 ) then
+        fimt2(mgs) = (2.27)*alog(xcwmas) + 13.39
+      end if
+      if ( xcwmas .gt. 3.55e-9 ) then
+        fimt2(mgs) = 1.0
+      end if
+
+      fimt2(mgs) = min(fimt2(mgs),1.0)
+      fimt2(mgs) = max(fimt2(mgs),0.0)
+      
+      ENDIF
+!
+!     qhmul2 = 0.0
+!     qsmul2 = 0.0
+!
+!     qhmul2 =
+!    >  (4.0e-03)*fimt1(mgs)*fimt2(mgs)*qhacw(mgs)
+!     qsmul2 =
+!    >  (4.0e-03)*fimt1(mgs)*fimt2(mgs)*qsacw(mgs)
+!
+!      cimas0 = (1.0e-12)
+!      cimas0 = 2.5e-10
+      IF ( .not. wetsfc(mgs) ) THEN
+      chmul1(mgs) =  fimt1(mgs)*(fimta(mgs) +   &
+     &                           (4.0e-03)*fimt2(mgs))*qhacw(mgs)
+      ENDIF
+!
+      qhmul1(mgs) =  chmul1(mgs)*(cimas0/rho0(mgs))
+
+
+         IF ( lhl .gt. 1 ) THEN
+           IF ( qx(mgs,lhl) .gt. qxmin(lhl) .and. (.not. wetsfchl(mgs)) ) THEN
+            tmp = fimt1(mgs)*(fimta(mgs) +   &
+     &                           (4.0e-03)*fimt2(mgs))*qhlacw(mgs)
+            chlmul1(mgs) =  tmp
+            qhlmul1(mgs) = cimas0*tmp*rhoinv(mgs)
+           ENDIF
+         ENDIF
+
+!      qsmul1(mgs) =  csmul1(mgs)*(cimas0/rho0(mgs))
+!
+      ENDIF ! ( ipconc .ge. 2 )
+      
+      end if ! (in temperature range)
+      
+      ENDIF ! ( itype1 .eq. 1 .or. itype2 .eq. 1)
+!
+      end do
+!
+!
+!
+!     end if
+!
+!     end do
+!
+!
+! ICE MULTIPLICATION FROM SNOW
+!   Lo and Passarelli 82 / Willis and Heymsfield 89 / Schuur and Rutledge 00b
+!   using kfrag as fragmentation rate (s-1) / 500 microns as char mean diam for max snow mix ratio
+!
+      csmul(:) = 0.0
+      qsmul(:) = 0.0
+      
+      IF ( isnwfrac /= 0 ) THEN
+      do mgs = 1,ngscnt
+       IF (temg(mgs) .gt. 265.0) THEN !{
+        if (xdia(mgs,ls,1) .gt. 100.e-6 .and. xdia(mgs,ls,1) .lt. 2.0e-3) then  ! equiv diameter 100microns to 2mm
+
+        tmp = rhoinv(mgs)*pi*xdn(mgs,ls)*cx(mgs,ls)*(500.e-6)**3
+        qsmul(mgs) = Max( kfrag*( qx(mgs,ls) - tmp ) , 0.0 )
+
+        qsmul(mgs) = Min( qxmxd(mgs,li), qsmul(mgs) )
+        csmul(mgs) = Min( cxmxd(mgs,li), rho0(mgs)*qsmul(mgs)/mfrag )
+
+        endif
+       ENDIF !}
+      enddo
+      ENDIF
+
+!
+!  frozen rain-rain interaction....
+!
+!
+!
+!
+!  rain-ice interaction
+!
+!
+      do mgs = 1,ngscnt
+      qracif(mgs) = qraci(mgs)
+      cracif(mgs) = craci(mgs)
+!      ciacrf(mgs) = ciacr(mgs)
+      end do
+!
+! 
+!  vapor to pristine ice crystals   UP
+!
+!
+!
+!  compute the nucleation rate
+!
+!     do mgs = 1,ngscnt
+!     idqis = 0
+!     if ( ssi(mgs) .gt. 1.0 ) idqis = 1
+!     fiinit(mgs) = (felv(mgs)**2)/(cp*rw)
+!     dqisdt(mgs) = (qx(mgs,lv)-qis(mgs))/
+!    >  (1.0 + fiinit(mgs)*qis(mgs)/tsqr(mgs))
+!     qidsvp(mgs) = dqisdt(mgs)
+!     cnnt = min(cnit*exp(-temcg(mgs)*bta1),1.0e+09)
+!     qiint(mgs) = 
+!    >  il5(mgs)*idqis*(1.0*dtpinv)
+!    <  *min((6.88e-13)*cnnt/rho0(mgs), 0.25*dqisdt(mgs)) 
+!     end do
+!
+!  Meyers et al. (1992; JAS) and Ferrier (1994) primary ice nucleation
+!
+      cmassin = cimasn  ! 6.88e-13
+      do mgs = 1,ngscnt
+      qiint(mgs) = 0.0
+      ciint(mgs) = 0.0
+      qicicnt(mgs) = 0.0
+      cicint(mgs) = 0.0
+      qipipnt(mgs) = 0.0
+      cipint(mgs) = 0.0
+      ccitmp = 0.0
+      IF ( icenucopt == 1 .or. icenucopt == -10 .or. icenucopt == -11 ) THEN
+      if ( ( temg(mgs) .lt. 268.15 .or.  &
+!     : ( imeyers5 .and. temg(mgs) .lt.  273.0) ) .and.    &
+     & ( imeyers5 .and. temg(mgs) .lt.  272.0 .and. temgkm2(mgs) .lt. tfr) ) .and.    &
+     &    ciintmx .gt. (cx(mgs,li)+ccitmp)  &
+!     :    .and. cninm(mgs) .gt. 0.   &
+     &     ) then
+      fiinit(mgs) = (felv(mgs)**2)/(cp*rw)
+      dqisdt(mgs) = (qx(mgs,lv)-qis(mgs))/   &
+     &  (1.0 + fiinit(mgs)*qis(mgs)/tsqr(mgs))
+!      qidsvp(mgs) = dqisdt(mgs)
+      idqis = 0
+      if ( ssi(mgs) .gt. 1.0 ) THEN
+      idqis = 1 
+      dzfacp = max( float(kgsp(mgs)-kgs(mgs)), 0.0 )
+      dzfacm = max( float(kgs(mgs)-kgsm(mgs)), 0.0 )
+      qiint(mgs) =   &
+     &  idqis*il5(mgs)   &
+     &  *(cmassin/rho0(mgs))   &
+     &  *max(0.0,wvel(mgs))   &
+     &  *max((cninp(mgs)-cninm(mgs)),0.0)/gz(igs(mgs),jgs,kgs(mgs))   &
+     &  /((dzfacp+dzfacm))
+
+      qiint(mgs) = min(qiint(mgs), max(0.25*dqisdt(mgs),0.0)) 
+      ciint(mgs) = qiint(mgs)*rho0(mgs)/cmassin
+!
+! limit new crystals so it does not increase the current concentration
+!  above ciintmx 20,000 per liter (2.e7 per m**3)
+!
+!      ciintmx = 1.e9
+!      ciintmx = 1.e9
+      IF ( icenucopt /= -10 ) THEN
+      
+        IF ( lcin > 1 ) THEN
+          ciint(mgs) = Min(ciint(mgs), ccin(mgs))
+          ccin(mgs) = ccin(mgs) - ciint(mgs)
+          qiint(mgs) = ciint(mgs)*cmassin/rho0(mgs)
+        ELSEIF ( lcina > 1 ) THEN
+          ciint(mgs) = Max(0.0, Min( ciint(mgs), Min( cnina(mgs), ciintmx ) - cina(mgs) ))
+          qiint(mgs) = ciint(mgs)*cmassin/rho0(mgs)
+      
+        ELSEIF ( icenucopt == 1 .and. ciint(mgs) .gt. Max(0.0, ciintmx - cx(mgs,li) - ccitmp )*dtpinv  ) THEN
+          ciint(mgs) = Max(0.0, ciintmx - (cx(mgs,li)) )*dtpinv 
+          qiint(mgs) = ciint(mgs)*cmassin/rho0(mgs)
+
+        ELSEIF ( icenucopt == -11 .and. dtp*ciint(mgs) .gt. ( cnina(mgs) - (cx(mgs,li) - ccitmp))) THEN
+          ciint(mgs) = Max(0.0,  cnina(mgs) - (cx(mgs,li)+ccitmp)*dtpinv )
+          qiint(mgs) = ciint(mgs)*cmassin/rho0(mgs)
+
+        ENDIF
+      ENDIF
+      
+      end if
+      endif
+
+      ELSEIF ( icenucopt == 2 .or. icenucopt == -1 .or. icenucopt == -2 ) THEN
+      
+        IF ( ( temg(mgs) .lt. 268.15 .and. ssw(mgs) > 1.0 ) .or. ssi(mgs) > 1.25 ) THEN
+          IF ( lcin > 1 ) THEN
+           ciint(mgs) = Min(cnina(mgs), ccin(mgs))
+           ciint(mgs) = Min( ciint(mgs), Max(0.0, ciintmx - (cx(mgs,li) - ccitmp) ) ) ! do not initiate ice beyond concentration of ciintmx
+           ccin(mgs) = ccin(mgs) - ciint(mgs)
+           ciint(mgs) = ciint(mgs)*dtpinv ! convert total initiation to a rate
+          ELSE
+           ciint(mgs) = Max( 0.0, cnina(mgs) - cina(mgs) )*dtpinv
+          ENDIF
+          qiint(mgs) = ciint(mgs)*cmassin/rho0(mgs)
+
+          fiinit(mgs) = (felv(mgs)**2)/(cp*rw)
+          dqisdt(mgs) = (qx(mgs,lv)-qis(mgs))/(1.0 + fiinit(mgs)*qis(mgs)/tsqr(mgs))
+          qiint(mgs) = min(qiint(mgs), max(0.25*dqisdt(mgs),0.0))
+          ciint(mgs) = qiint(mgs)*rho0(mgs)/cmassin
+        ENDIF
+      
+      
+      
+      ELSEIF ( icenucopt == 3 ) THEN
+        IF (  temg(mgs) .lt. 268.15 ) THEN
+          IF ( lcin > 1 ) THEN
+           ciint(mgs) = Min(cnina(mgs), ccin(mgs))
+           ciint(mgs) = Min( ciint(mgs), Max(0.0, ciintmx - (cx(mgs,li) + ccitmp) ) ) ! do not initiate ice beyond concentration of ciintmx
+           ccin(mgs) = ccin(mgs) - ciint(mgs)
+           ciint(mgs) = ciint(mgs)*dtpinv ! convert total initiation to a rate
+          ELSE
+           ciint(mgs) = Max( 0.0, cnina(mgs) - cina(mgs) )*dtpinv
+          ENDIF
+          qiint(mgs) = ciint(mgs)*cmassin/rho0(mgs)
+        ENDIF
+
+      ENDIF
+!
+      if ( xplate(mgs) .eq. 1 ) then
+      qipipnt(mgs) = qiint(mgs)
+      cipint(mgs) = ciint(mgs)
+      end if
+!
+      if ( xcolmn(mgs) .eq. 1 ) then
+      qicicnt(mgs) = qiint(mgs)
+      cicint(mgs) = ciint(mgs)
+      end if
+!
+!     qipipnt(mgs) = 0.0
+!     qicicnt(mgs) = qiint(mgs)
+!
+      end do
+!
+! 
+
+!
+!  vapor to cloud droplets   UP
+!
+      if (ndebug .gt. 0 ) write(0,*) 'dbg = 8'
+!
+!
+      if (ndebug .gt. 0 ) write(0,*) 'Collection: set 3-component'
+!
+!  time for riming....
+!
+!     rimtim = 240.0
+!     dtrim = rimtim
+!     xacrtim  = 120.0
+!     tranfr = 0.50
+!     tranfw = 0.50
+!
+!  coefficients for riming
+!
+!     rimc1 = 300.00
+!     rimc2 = 0.44
+!
+! 
+!  zero som arrays
+!
+!
+      do mgs = 1,ngscnt
+      qrshr(mgs) = 0.0
+      qsshrp(mgs) = 0.0
+      qhshrp(mgs) = 0.0
+      end do
+!
+!
+!  first sum all of the shed rain
+!
+!
+      do mgs = 1,ngscnt
+      qrshr(mgs) = qsshr(mgs) + qhshr(mgs) + qhlshr(mgs)
+      crshr(mgs) = chshrr(mgs)/rzxh(mgs) + chlshrr(mgs)/rzxhl(mgs)
+      IF ( ipconc .ge. 3 ) THEN
+!       crshr(mgs) = Max(crshr(mgs), rho0(mgs)*qrshr(mgs)/(xdn(mgs,lr)*vr1mm) )
+      ENDIF
+      end do 
+!
+!
+!
+
+!
+!
+!
+!
+      IF ( ipconc .ge. 1 ) THEN
+!
+!
+!  concentration production terms
+!
+!  YYY
+!
+!
+!       DO mgs = 1,ngscnt
+       pccwi(:) = 0.0
+       pccwd(:) = 0.0
+       pccwdacc(:) = 0.0
+       pccii(:) = 0.0
+       pccin(:) = 0.0
+       pccid(:) = 0.0
+       pcisi(:) = 0.0
+       pcisd(:) = 0.0
+       pcrwi(:) = 0.0
+       pcrwd(:) = 0.0
+       pcswi(:) = 0.0
+       pcswd(:) = 0.0
+       pchwi(:) = 0.0
+       pchwd(:) = 0.0
+       pchli(:) = 0.0
+       pchld(:) = 0.0
+!       ENDDO
+!
+!  Cloud ice
+!
+!      IF ( ipconc .ge. 1 ) THEN
+
+      IF ( warmonly < 0.5 ) THEN
+      IF ( ffrzs < 1.0 ) THEN
+      do mgs = 1,ngscnt
+      pccii(mgs) =   &
+     &   il5(mgs)*cicint(mgs)  &
+     &  +il5(mgs)*(cwfrzc(mgs)+cwctfzc(mgs)   &
+     &  +cicichr(mgs))   &
+     &  +chmul1(mgs)   &
+     &  +chlmul1(mgs)    &
+     &  + csplinter(mgs) + csplinter2(mgs)   &
+     &  +csmul(mgs)
+     
+       pccii(mgs) = pccii(mgs)*(1.0 - ffrzs)
+       
+!     >  + nsplinter*(crfrzf(mgs) + crfrz(mgs))
+      pccid(mgs) =   &
+     &   il5(mgs)*(-cscni(mgs) - cscnvi(mgs) & ! - cwaci(mgs)   &
+     &  -craci(mgs)    &
+     &  -csaci(mgs)   &
+     &  -chaci(mgs) - chlaci(mgs)   &
+     &  -chcni(mgs))   &
+     &  +il5(mgs)*cisbv(mgs)   &
+     &  -(1.-il5(mgs))*cimlr(mgs)
+
+      pccin(mgs) = ciint(mgs)
+      
+
+      end do
+      ENDIF ! ffrzs
+      ELSEIF ( warmonly < 0.8 ) THEN
+      do mgs = 1,ngscnt
+      
+!      qiint(mgs) = 0.0
+!      cicint(mgs) = 0.0
+!      qicicnt(mgs) = 0.0
+      
+      pccii(mgs) =   &
+     &   il5(mgs)*cicint(mgs)   &
+     &  +il5(mgs)*(cwfrzc(mgs)+cwctfzc(mgs)   &
+     &  +cicichr(mgs))   &
+     &  +chmul1(mgs)   &
+     &  +chlmul1(mgs)    &
+     &  + csplinter(mgs) + csplinter2(mgs)   &
+     &  +csmul(mgs)
+     
+       pccii(mgs) = pccii(mgs)*(1. - ffrzs)
+      pccid(mgs) =   &
+!     &   il5(mgs)*(-cscni(mgs) - cscnvi(mgs) & ! - cwaci(mgs)   &
+!     &  -craci(mgs)    &
+!     &  -csaci(mgs)   &
+!     &  -chaci(mgs) - chlaci(mgs)   &
+!     &  -chcni(mgs))   &
+     &  +il5(mgs)*cisbv(mgs)   &
+     &  -(1.-il5(mgs))*cimlr(mgs)
+
+      pccin(mgs) = ciint(mgs)
+
+      end do
+      ENDIF ! warmonly
+
+      
+!      ENDIF ! ( ipconc .ge. 1 )
+!
+!  Cloud water
+!
+      IF ( ipconc .ge. 2 ) THEN
+      
+      do mgs = 1,ngscnt
+      pccwi(mgs) =  (0.0) ! + (1-il5(mgs))*(-cirmlw(mgs))
+      
+      IF ( warmonly < 0.5 ) THEN
+      pccwd(mgs) =    &
+     &  - cautn(mgs) +   &
+     &  il5(mgs)*(-ciacw(mgs)-cwfrzp(mgs)-cwctfzp(mgs)   &
+     &  -cwfrzc(mgs)-cwctfzc(mgs)   &
+     &   )   &
+     &  -cracw(mgs) -csacw(mgs)  -chacw(mgs) - chlacw(mgs)
+
+
+      ELSEIF ( warmonly < 0.8 ) THEN
+      pccwd(mgs) =    &
+     &  - cautn(mgs) +   &
+     &  il5(mgs)*(  &
+     & -ciacw(mgs)-cwfrzp(mgs)-cwctfzp(mgs)   &
+     &  -cwfrzc(mgs)-cwctfzc(mgs)   &
+     &   )   &
+     &  -cracw(mgs) -chacw(mgs) -chlacw(mgs) 
+      ELSE
+      
+!       tmp3d(igs(mgs),jy,kgs(mgs)) = crcnw(mgs)
+
+!       cracw(mgs) = 0.0 ! turn off accretion
+!       qracw(mgs) = 0.0
+!       crcev(mgs) = 0.0 ! turn off evap
+!       qrcev(mgs) = 0.0 ! turn off evap
+!       cracr(mgs) = 0.0 ! turn off self collection
+       
+       
+!       cautn(mgs) = 0.0 
+!       crcnw(mgs) = 0.0
+!       qrcnw(mgs) = 0.0
+
+      pccwd(mgs) =    &
+     &  - cautn(mgs) -cracw(mgs)
+      ENDIF
+
+
+      IF ( .false. .and. exwmindiam > 0.0 .and. ccwresv(mgs) > 0.0 ) THEN
+      pccwdacc(mgs) =    &
+     &  il5(mgs)*(-ciacw(mgs)  &
+     &   )   &
+     &  -cracw(mgs) -csacw(mgs)  -chacw(mgs) - chlacw(mgs)
+
+      IF ( -pccwdacc(mgs)*dtp .gt. cx(mgs,lc) - ccwresv(mgs) ) THEN
+
+       frac = -(cx(mgs,lc) - ccwresv(mgs) )/(pccwdacc(mgs)*dtp)
+       pccwdacc(mgs) = -(cx(mgs,lc) - ccwresv(mgs) )*dtpinv
+
+        ciacw(mgs)   = frac*ciacw(mgs)
+        cracw(mgs)   = frac*cracw(mgs)
+        csacw(mgs)   = frac*csacw(mgs)
+        chacw(mgs)   = frac*chacw(mgs)
+        cautn(mgs)   = frac*cautn(mgs)
+       
+        IF ( lhl .gt. 1 ) chlacw(mgs)   = frac*chlacw(mgs)
+
+! resum
+      pccwd(mgs) =    &
+     &  - cautn(mgs) +   &
+     &  il5(mgs)*(-ciacw(mgs)-cwfrzp(mgs)-cwctfzp(mgs)   &
+     &  -cwfrzc(mgs)-cwctfzc(mgs)   &
+     &   )   &
+     &  -cracw(mgs) -csacw(mgs)  -chacw(mgs) - chlacw(mgs)
+
+      ENDIF
+
+      ENDIF
+
+
+      IF ( -pccwd(mgs)*dtp .gt. cx(mgs,lc) ) THEN
+!       write(0,*) 'OUCH! pccwd(mgs)*dtp .gt. ccw(mgs) ',pccwd(mgs),cx(mgs,lc)
+!       write(0,*) 'qc = ',qx(mgs,lc)
+!       write(0,*) -ciacw(mgs)-cwfrzp(mgs)-cwctfzp(mgs)-cwfrzc(mgs)-cwctfzc(mgs)
+!       write(0,*)  -cracw(mgs) -csacw(mgs)  -chacw(mgs)
+!       write(0,*) - cautn(mgs)
+
+       frac = -cx(mgs,lc)/(pccwd(mgs)*dtp)
+       pccwd(mgs) = -cx(mgs,lc)*dtpinv
+
+        ciacw(mgs)   = frac*ciacw(mgs)
+        cwfrzp(mgs)  = frac*cwfrzp(mgs)
+        cwctfzp(mgs) = frac*cwctfzp(mgs)
+        cwfrzc(mgs)  = frac*cwfrzc(mgs)
+        cwctfzc(mgs) = frac*cwctfzc(mgs)
+        cwctfz(mgs) = frac*cwctfz(mgs)
+        cracw(mgs)   = frac*cracw(mgs)
+        csacw(mgs)   = frac*csacw(mgs)
+        chacw(mgs)   = frac*chacw(mgs)
+        cautn(mgs)   = frac*cautn(mgs)
+       
+        pccii(mgs) = pccii(mgs) - (1.-frac)*il5(mgs)*(cwfrzc(mgs)+cwctfzc(mgs))*(1. - ffrzs)
+        IF ( lhl .gt. 1 ) chlacw(mgs)   = frac*chlacw(mgs)
+
+!       STOP
+      ENDIF
+
+      end do
+
+      ENDIF ! ipconc
+
+!
+!  Rain
+!
+      IF ( ipconc .ge. 3 ) THEN
+
+      do mgs = 1,ngscnt
+
+      IF ( warmonly < 0.5 ) THEN
+      pcrwi(mgs) = &
+!     >   cracw(mgs) +    &
+     &   crcnw(mgs)   &
+     &  +(1-il5(mgs))*(   &
+     &    -chmlrr(mgs)/rzxh(mgs)   &
+     &    -chlmlrr(mgs)/rzxhl(mgs)   &
+!     &    -csmlr(mgs)/rzxs(mgs)     &
+     &   -csmlrr(mgs)     &
+     &   - cimlr(mgs) )   &
+     &  -crshr(mgs)             !null at this point when wet snow/graupel included
+      pcrwd(mgs) =   &
+     &   il5(mgs)*(-ciacr(mgs) - crfrz(mgs) ) & ! - cipacr(mgs))
+!     >  -csacr(mgs)   &
+     &  - chacr(mgs) - chlacr(mgs)   &
+     &  +crcev(mgs)   &
+     &  - cracr(mgs)
+!     >  -il5(mgs)*ciracr(mgs)
+      ELSEIF ( warmonly < 0.8 ) THEN
+       pcrwi(mgs) = &
+     &   crcnw(mgs)   &
+     &  +(1-il5(mgs))*(   &
+     &    -chmlrr(mgs)/rzxh(mgs)    &
+     &    -chlmlrr(mgs)/rzxhl(mgs)   &
+!     &    -csmlr(mgs)     &
+     &   -csmlrr(mgs)     &
+     &   - cimlr(mgs) )   &
+     &  -crshr(mgs)             !null at this point when wet snow/graupel included
+      pcrwd(mgs) =   &
+     &   il5(mgs)*( - crfrz(mgs) ) & ! - cipacr(mgs))
+     &  - chacr(mgs)    &
+     &  - chlacr(mgs)    &
+     &  +crcev(mgs)   &
+     &  - cracr(mgs)
+      ELSE
+      pcrwi(mgs) =   &
+     &   crcnw(mgs)
+      pcrwd(mgs) =   &
+     &  +crcev(mgs)   &
+     &  - cracr(mgs)
+
+!        tmp3d(igs(mgs),jy,kgs(mgs)) = vtxbar(mgs,lr,1) ! crcnw(mgs) ! (pcrwi(mgs) + pcrwd(mgs))
+!        pcrwi(mgs) = 0.0
+!        pcrwd(mgs) = 0.0
+!        qrcnw(mgs) = 0.0
+
+      ENDIF
+
+
+      frac = 0.0
+      IF ( -pcrwd(mgs)*dtp .gt. cx(mgs,lr) ) THEN
+!       write(0,*) 'OUCH! pcrwd(mgs)*dtp .gt. crw(mgs) ',pcrwd(mgs)*dtp,cx(mgs,lr),mgs,igs(mgs),kgs(mgs)
+!       write(0,*) -ciacr(mgs)
+!       write(0,*) -crfrz(mgs)
+!       write(0,*) -chacr(mgs)
+!       write(0,*)  crcev(mgs)
+!       write(0,*)  -cracr(mgs)
+
+       frac =  -cx(mgs,lr)/(pcrwd(mgs)*dtp)
+       pcrwd(mgs) = -cx(mgs,lr)*dtpinv
+
+        ciacr(mgs) = frac*ciacr(mgs)
+        ciacrf(mgs) = frac*ciacrf(mgs)
+        ciacrs(mgs) = frac*ciacrs(mgs)
+        crfrz(mgs) = frac*crfrz(mgs)
+        crfrzf(mgs) = frac*crfrzf(mgs)
+        crfrzs(mgs) = frac*crfrzs(mgs)
+        chacr(mgs) = frac*chacr(mgs)
+        chlacr(mgs) = frac*chlacr(mgs)
+        crcev(mgs) = frac*crcev(mgs)
+        cracr(mgs) = frac*cracr(mgs)
+
+!       STOP
+      ENDIF
+
+      end do
+
+      ENDIF
+
+
+      IF ( warmonly < 0.5 ) THEN
+
+!
+!  Snow
+!
+      IF ( ipconc .ge. 4 ) THEN !
+
+      do mgs = 1,ngscnt
+      pcswi(mgs) =   &
+     &   il5(mgs)*(cscnis(mgs) + cscnvis(mgs) )    &
+     &  + cscnh(mgs)
+      
+      IF (  ffrzs > 0.0 ) THEN
+       pcswi(mgs) =  pcswi(mgs) + ffrzs* (  &
+     &   il5(mgs)*cicint(mgs)   &
+     &  +il5(mgs)*(cwfrzc(mgs)+cwctfzc(mgs)   &
+     &  +cicichr(mgs))  &
+     &  +chmul1(mgs)   &
+     &  +chlmul1(mgs)    &
+     &  + csplinter(mgs) + csplinter2(mgs)   &
+     &  +csmul(mgs) )
+      ENDIF
+
+      
+      IF ( ess0 < 0.0 ) THEN
+         csacs(mgs) = Max(0.0, csacs(mgs) - (ifrzs)*(crfrzs(mgs) + ciacrs(mgs)))
+      ENDIF
+      
+      pcswd(mgs) = &
+!     :  cracs(mgs)     &
+     &  -chacs(mgs) - chlacs(mgs)   &
+     &  -chcns(mgs)   &
+     &  +(1-il5(mgs))*csmlr(mgs) + csshr(mgs) & ! + csshrp(mgs)
+!     >  +il5(mgs)*(cssbv(mgs))   &
+     &   + cssbv(mgs)   &
+     &  - csacs(mgs)
+
+      frac = 0.0
+      IF ( imixedphase == 0 ) THEN
+        IF ( cx(mgs,ls) + dtp*(pcswi(mgs) + pcswd(mgs)) < 0.0 ) THEN
+         frac = (-cx(mgs,ls) + pcswi(mgs)*dtp)/(pcswd(mgs)*dtp)
+         
+           pqswd(mgs) = frac*pqswd(mgs)
+           
+           chacs(mgs)  = frac*chacs(mgs) 
+           chlacs(mgs) = frac*chlacs(mgs)
+           chcns(mgs)  = frac*chcns(mgs) 
+           csmlr(mgs)  = frac*csmlr(mgs) 
+           csshr(mgs)  = frac*csshr(mgs) 
+           cssbv(mgs)  = frac*cssbv(mgs) 
+           csacs(mgs)  = frac*csacs(mgs)
+      
+        ENDIF
+      ENDIF
+
+
+      
+      pccii(mgs) =  pccii(mgs) &
+     &  + (1. - ifrzs)*crfrzs(mgs) &
+     &  + (1. - ifrzs)*ciacrs(mgs)
+
+      pcswi(mgs) =  pcswi(mgs) &
+     &  + (ifrzs)*crfrzs(mgs) &
+     &  + (ifrzs)*ciacrs(mgs)
+
+      end do
+
+      ENDIF
+
+!
+!  Graupel
+!
+      IF ( ipconc .ge. 5 ) THEN !
+      do mgs = 1,ngscnt
+      pchwi(mgs) =   &
+     &  +ifrzg*(crfrzf(mgs)   &
+     & +il5(mgs)*(ciacrf(mgs) ))    &
+     & + chcnsh(mgs) + chcnih(mgs) + chcnhl(mgs)
+
+      pchwd(mgs) =   &
+     &  (1-il5(mgs))*chmlr(mgs) &
+!     >  + il5(mgs)*chsbv(mgs)   &
+     &  + chsbv(mgs)   &
+     &  - il5(mgs)*chlcnh(mgs) &
+     &  - cscnh(mgs)
+      end do
+!
+
+!
+!  Hail
+!
+      IF ( lhl .gt. 1 ) THEN !
+      do mgs = 1,ngscnt
+      pchli(mgs) = (1.0-ifrzg)*(crfrzf(mgs) +il5(mgs)*(ciacrf(mgs) ))  &
+     & + chlcnh(mgs) *rzxhlh(mgs)
+
+      pchld(mgs) =   &
+     &  (1-il5(mgs))*chlmlr(mgs)   &
+!     >  + il5(mgs)*chlsbv(mgs)   &
+     &  + chlsbv(mgs) - chcnhl(mgs)
+      
+!      IF ( pchli(mgs) .ne. 0. .or. pchld(mgs) .ne. 0 ) THEN
+!       write(0,*) 'dr: pchli,pchld = ', pchli(mgs),pchld(mgs), igs(mgs),kgs(mgs)
+!      ENDIF
+      end do
+      
+      ENDIF
+!
+
+      ENDIF ! (ipconc .ge. 5 )
+
+      ELSEIF ( warmonly < 0.8 ) THEN
+
+!
+!  Graupel
+!
+      IF ( ipconc .ge. 5 ) THEN !
+      do mgs = 1,ngscnt
+      pchwi(mgs) =   &
+     &  +ifrzg*(crfrzf(mgs) )
+
+      pchwd(mgs) =   &
+     &  (1-il5(mgs))*chmlr(mgs) &
+     &  - il5(mgs)*chlcnh(mgs)
+      end do
+!
+!  Hail
+!
+      IF ( lhl .gt. 1 ) THEN !
+      do mgs = 1,ngscnt
+      pchli(mgs) = (1.0-ifrzg)*(crfrzf(mgs) +il5(mgs)*(ciacrf(mgs) ))  &
+     & + chlcnh(mgs) *rzxhl(mgs)/rzxh(mgs)
+
+      pchld(mgs) =   &
+     &  (1-il5(mgs))*chlmlr(mgs) !  &
+!     >  + il5(mgs)*chlsbv(mgs)   &
+!     &  + chlsbv(mgs)
+
+!      IF ( pchli(mgs) .ne. 0. .or. pchld(mgs) .ne. 0 ) THEN
+!       write(0,*) 'dr: pchli,pchld = ', pchli(mgs),pchld(mgs), igs(mgs),kgs(mgs)
+!      ENDIF
+      end do
+
+      ENDIF
+
+      ENDIF ! ipconc >= 5
+
+      ENDIF ! warmonly
+
+!
+
+!
+!  Balance and checks for continuity.....within machine precision...
+!
+      do mgs = 1,ngscnt
+      pctot(mgs)   = pccwi(mgs) +pccwd(mgs) +   &
+     &               pccii(mgs) +pccid(mgs) +   &
+     &               pcrwi(mgs) +pcrwd(mgs) +   &
+     &               pcswi(mgs) +pcswd(mgs) +   &
+     &               pchwi(mgs) +pchwd(mgs) +   &
+     &               pchli(mgs) +pchld(mgs)
+      end do
+!
+!
+      ENDIF ! ( ipconc .ge. 1 )
+!
+!
+!
+!
+!
+!  GOGO
+!  production terms for mass
+!
+!
+       pqwvi(:) = 0.0
+       pqwvd(:) = 0.0
+       pqcwi(:) = 0.0
+       pqcwd(:) = 0.0
+       pqcwdacc(:) = 0.0
+       pqcii(:) = 0.0
+       pqcid(:) = 0.0
+       pqrwi(:) = 0.0
+       pqrwd(:) = 0.0
+       pqswi(:) = 0.0
+       pqswd(:) = 0.0
+       pqhwi(:) = 0.0
+       pqhwd(:) = 0.0
+       pqhli(:) = 0.0
+       pqhld(:) = 0.0
+       pqlwsi(:) = 0.0
+       pqlwsd(:) = 0.0
+       pqlwhi(:) = 0.0
+       pqlwhd(:) = 0.0
+       pqlwhli(:) = 0.0
+       pqlwhld(:) = 0.0
+!
+!  Vapor
+!
+      IF ( warmonly < 0.5 ) THEN
+      do mgs = 1,ngscnt
+      
+! NOTE: ANY CHANGES HERE ALSO NEED TO GO INTO THE RESUM FARTHER DOWN!
+      pqwvi(mgs) =    &
+     &  -Min(0.0, qrcev(mgs))   &
+     &  -Min(0.0, qhcev(mgs))   &
+     &  -Min(0.0, qhlcev(mgs))   &
+     &  -Min(0.0, qscev(mgs))   &
+!     >  +il5(mgs)*(-qhsbv(mgs) - qhlsbv(mgs) )   &
+     &  -qhsbv(mgs) - qhlsbv(mgs)   &
+     &  -qssbv(mgs)    &
+     &  -il5(mgs)*qisbv(mgs)
+      
+      pqwvd(mgs) =     &
+     &  -Max(0.0, qrcev(mgs))   &
+     &  -Max(0.0, qhcev(mgs))   &
+     &  -Max(0.0, qhlcev(mgs))   &
+     &  -Max(0.0, qscev(mgs))   &
+     &  +il5(mgs)*(-qiint(mgs)   &
+     &  -qhdpv(mgs) -qsdpv(mgs) - qhldpv(mgs))   &
+     &  -il5(mgs)*qidpv(mgs)  
+      
+      end do
+
+      ELSEIF ( warmonly < 0.8 ) THEN
+      do mgs = 1,ngscnt
+      pqwvi(mgs) =    &
+     &  -Min(0.0, qrcev(mgs)) &
+     &  -il5(mgs)*qisbv(mgs)
+      pqwvd(mgs) =     &
+     &  +il5(mgs)*(-qiint(mgs)   &
+!     &  -qhdpv(mgs) ) & !- qhldpv(mgs))   &
+     &  -qhdpv(mgs) - qhldpv(mgs))   &
+!     &  -qhdpv(mgs) -qsdpv(mgs) - qhldpv(mgs))   &
+     &  -Max(0.0, qrcev(mgs))     &
+     &  -il5(mgs)*qidpv(mgs)  
+      end do
+
+      ELSE
+      do mgs = 1,ngscnt
+      pqwvi(mgs) =    &
+     &  -Min(0.0, qrcev(mgs))
+      pqwvd(mgs) =     &
+     &  -Max(0.0, qrcev(mgs))
+      end do
+
+      ENDIF ! warmonly
+!
+!  Cloud water
+!
+      do mgs = 1,ngscnt
+
+      pqcwi(mgs) =  (0.0) + qwcnr(mgs)
+
+      IF ( warmonly < 0.5 ) THEN
+      pqcwd(mgs) =    &
+     &  il5(mgs)*(-qiacw(mgs)-qwfrz(mgs)-qwctfz(mgs))   &
+     &  -il5(mgs)*(qiihr(mgs))   &
+     &  -qracw(mgs) -qsacw(mgs) -qrcnw(mgs) -qhacw(mgs) - qhlacw(mgs)  !&
+!     &  -il5(mgs)*(qwfrzp(mgs))
+      ELSEIF ( warmonly < 0.8 ) THEN
+      pqcwd(mgs) =    &
+     &  il5(mgs)*(-qiacw(mgs)-qwfrz(mgs)-qwctfz(mgs))   &
+     &  -il5(mgs)*(qiihr(mgs))   &
+     &  -qracw(mgs) -qrcnw(mgs) -qhacw(mgs) -qhlacw(mgs)
+      ELSE
+      pqcwd(mgs) =    &
+     &  -qracw(mgs) - qrcnw(mgs)
+      ENDIF
+
+
+      IF ( .false. .and. exwmindiam > 0.0 .and. ccwresv(mgs) > 0.0 ) THEN
+      pqcwdacc(mgs) =    &
+     &  il5(mgs)*(-qiacw(mgs) )   &
+     &  -qracw(mgs) -qsacw(mgs)  -qhacw(mgs) - qhlacw(mgs)
+ 
+      IF ( -pqcwdacc(mgs)*dtp .gt. qx(mgs,lc) - qcwresv(mgs) ) THEN
+      
+       frac = -Max(0.0,qx(mgs,lc))/(pqcwdacc(mgs)*dtp)
+       pqcwdacc(mgs) = -qx(mgs,lc)*dtpinv
+        qracw(mgs)   = frac*qracw(mgs)
+        qsacw(mgs)   = frac*qsacw(mgs)
+        qhacw(mgs)   = frac*qhacw(mgs)
+        qhlacw(mgs)   = frac*qhlacw(mgs)
+        vhacw(mgs)   = frac*vhacw(mgs)
+
+! resum
+      pccwd(mgs) =    &
+     &  - cautn(mgs) +   &
+     &  il5(mgs)*(-ciacw(mgs)-cwfrzp(mgs)-cwctfzp(mgs)   &
+     &  -cwfrzc(mgs)-cwctfzc(mgs)   &
+     &   )   &
+     &  -cracw(mgs) -csacw(mgs)  -chacw(mgs) - chlacw(mgs)
+
+      ENDIF
+
+      ENDIF
+
+
+      IF ( pqcwd(mgs) .lt. 0.0 .and. -pqcwd(mgs)*dtp .gt. qx(mgs,lc) ) THEN
+
+       frac = -Max(0.0,qx(mgs,lc))/(pqcwd(mgs)*dtp)
+       pqcwd(mgs) = -qx(mgs,lc)*dtpinv
+
+        qiacw(mgs)   = frac*qiacw(mgs)
+!        qwfrzp(mgs)  = frac*qwfrzp(mgs)
+!        qwctfzp(mgs) = frac*qwctfzp(mgs)
+        qwfrzc(mgs)  = frac*qwfrzc(mgs)
+        qwfrzis(mgs)  = frac*qwfrzis(mgs)
+        qwfrz(mgs)  = frac*qwfrz(mgs)
+        qwctfzc(mgs) = frac*qwctfzc(mgs)
+        qwctfzis(mgs) = frac*qwctfzis(mgs)
+        qwctfz(mgs) = frac*qwctfz(mgs)
+        qracw(mgs)   = frac*qracw(mgs)
+        qsacw(mgs)   = frac*qsacw(mgs)
+        qhacw(mgs)   = frac*qhacw(mgs)
+        vhacw(mgs)   = frac*vhacw(mgs)
+        qrcnw(mgs)   = frac*qrcnw(mgs)
+        qwfrzp(mgs)  = frac*qwfrzp(mgs)
+        IF ( lhl .gt. 1 ) THEN
+          qhlacw(mgs)   = frac*qhlacw(mgs)
+          vhlacw(mgs)   = frac*vhlacw(mgs)
+        ENDIF
+!        IF ( lzh .gt. 1 ) zhacw(mgs) = frac*zhacw(mgs)
+
+!       STOP
+      ENDIF
+      
+
+      end do
+!
+!  Cloud ice
+!
+      IF ( warmonly < 0.5 ) THEN
+
+      do mgs = 1,ngscnt
+      IF ( ffrzs < 1.0 ) THEN
+      pqcii(mgs) =     &
+     &   il5(mgs)*qicicnt(mgs)    &
+     &  +il5(mgs)*(qwfrzc(mgs)+qwctfzc(mgs))   &
+     &  +il5(mgs)*(qicichr(mgs))  &
+     &  +qsmul(mgs)               &
+     &  +qhmul1(mgs) + qhlmul1(mgs)   &
+     & + qsplinter(mgs) + qsplinter2(mgs)
+!     > + cimas0*nsplinter*(crfrzf(mgs) + crfrz(mgs))/rho0(mgs)
+      ENDIF
+       
+       pqcii(mgs) = pqcii(mgs)*(1.0 - ffrzs) &
+     &  +il5(mgs)*qidpv(mgs)    &
+     &  +il5(mgs)*qiacw(mgs)
+       
+      pqcid(mgs) =     &
+     &   il5(mgs)*(-qscni(mgs) - qscnvi(mgs)    & ! -qwaci(mgs)    &
+     &  -qraci(mgs)    &
+     &  -qsaci(mgs) )   &
+     &  -qhaci(mgs)   &
+     &  -qhlaci(mgs)    &
+     &  +il5(mgs)*qisbv(mgs)    &
+     &  +(1.-il5(mgs))*qimlr(mgs)   &
+     &  - qhcni(mgs)
+      end do
+
+      
+      ELSEIF ( warmonly < 0.8 ) THEN
+
+      do mgs = 1,ngscnt
+      pqcii(mgs) =     &
+     &   il5(mgs)*qicicnt(mgs)*(1. - ffrzs)    &
+     &  +il5(mgs)*(qwfrzc(mgs)+qwctfzc(mgs))*(1. - ffrzs)   &
+     &  +il5(mgs)*(qicichr(mgs))*(1. - ffrzs)   &
+!     &  +il5(mgs)*(qicichr(mgs))   &
+!     &  +qsmul(mgs)               &
+     &  +qhmul1(mgs) + qhlmul1(mgs)   &
+     & + qsplinter(mgs) + qsplinter2(mgs) &
+     &  +il5(mgs)*qidpv(mgs)    &
+     &  +il5(mgs)*qiacw(mgs)  ! & ! (qiacwi(mgs)+qwacii(mgs))   &
+!     &  +il5(mgs)*(qwfrzc(mgs)+qwctfzc(mgs))   &
+!     &  +il5(mgs)*(qicichr(mgs))   &
+!     &  +qsmul(mgs)               &
+!     &  +qhmul1(mgs) + qhlmul1(mgs)   &
+!     & + qsplinter(mgs) + qsplinter2(mgs)
+
+      pqcid(mgs) =     &
+!     &   il5(mgs)*(-qscni(mgs) - qscnvi(mgs)    & ! -qwaci(mgs)    &
+!     &  -qraci(mgs)    &
+!     &  -qsaci(mgs) )   &
+!     &  -qhaci(mgs)   &
+!     &  -qhlaci(mgs)    &
+     &  +il5(mgs)*qisbv(mgs)    &
+     &  +(1.-il5(mgs))*qimlr(mgs)  ! &
+!     &  - qhcni(mgs)
+      end do
+
+      ENDIF
+!
+!  Rain
+!
+
+      do mgs = 1,ngscnt
+      IF ( warmonly < 0.5 ) THEN
+      pqrwi(mgs) =     &
+     &   qracw(mgs) + qrcnw(mgs) + Max(0.0, qrcev(mgs))   &
+     &  +(1-il5(mgs))*(   &
+     &    -qhmlr(mgs)                 &            !null at this point when wet snow/graupel included
+     &    -qsmlr(mgs)  - qhlmlr(mgs)     &
+     &    -qimlr(mgs))   &
+     &    -qsshr(mgs)       &                      !null at this point when wet snow/graupel included
+     &    -qhshr(mgs)       &                      !null at this point when wet snow/graupel included
+     &    -qhlshr(mgs)
+      pqrwd(mgs) =     &
+     &  il5(mgs)*(-qiacr(mgs)-qrfrz(mgs))    &
+     &  - qsacr(mgs) - qhacr(mgs) - qhlacr(mgs) - qwcnr(mgs)   &
+     &  + Min(0.0,qrcev(mgs))
+      ELSEIF ( warmonly < 0.8 ) THEN
+      pqrwi(mgs) =     &
+     &   qracw(mgs) + qrcnw(mgs) + Max(0.0, qrcev(mgs))   &
+     &  +(1-il5(mgs))*(   &
+     &    -qhmlr(mgs)                 &            !null at this point when wet snow/graupel included
+     &    -qhshr(mgs)                 &           !null at this point when wet snow/graupel included
+     &    -qhlmlr(mgs)                 &            !null at this point when wet snow/graupel included
+     &    -qhlshr(mgs) )                           !null at this point when wet snow/graupel included
+      pqrwd(mgs) =     &
+     &  il5(mgs)*(-qrfrz(mgs))    &
+     &   - qhacr(mgs)    &
+     &   - qhlacr(mgs)    &
+     &  + Min(0.0,qrcev(mgs))
+      ELSE
+      pqrwi(mgs) =     &
+     &   qracw(mgs) + qrcnw(mgs) + Max(0.0, qrcev(mgs))
+      pqrwd(mgs) =  Min(0.0,qrcev(mgs))
+      ENDIF ! warmonly
+
 
  !      IF ( pqrwd(mgs) .lt. 0.0 .and. -(pqrwd(mgs) + pqrwi(mgs))*dtp .gt. qx(mgs,lr)  ) THEN
       IF ( pqrwd(mgs) .lt. 0.0 .and. -(pqrwd(mgs) + pqrwi(mgs))*dtp .gt. qx(mgs,lr)  ) THEN
 
-       frac = (-qx(mgs,lr) + pqrwi(mgs)*dtp)/(pqrwd(mgs)*dtp)
-!       pqrwd(mgs) = -qx(mgs,lr)/dtp  + pqrwi(mgs)
+       frac = (-qx(mgs,lr) + pqrwi(mgs)*dtp)/(pqrwd(mgs)*dtp)
+!       pqrwd(mgs) = -qx(mgs,lr)*dtpinv  + pqrwi(mgs)
+
+       pqwvi(mgs) = pqwvi(mgs)    &
+     &  + Min(0.0, qrcev(mgs))   &
+     &  - frac*Min(0.0, qrcev(mgs))
+       pqwvd(mgs) =  pqwvd(mgs)   &
+     &  + Max(0.0, qrcev(mgs))   &
+     &  - frac*Max(0.0, qrcev(mgs))
+
+       qiacr(mgs)  = frac*qiacr(mgs)
+       qiacrf(mgs) = frac*qiacrf(mgs)
+       qiacrs(mgs) = frac*qiacrs(mgs)
+       viacrf(mgs) = frac*viacrf(mgs)
+       qrfrz(mgs)  = frac*qrfrz(mgs) 
+       qrfrzs(mgs) = frac*qrfrzs(mgs) 
+       qrfrzf(mgs) = frac*qrfrzf(mgs)
+       vrfrzf(mgs) = frac*vrfrzf(mgs)
+       qsacr(mgs)  = frac*qsacr(mgs)
+       qhacr(mgs)  = frac*qhacr(mgs)
+       vhacr(mgs)  = frac*vhacr(mgs)
+       qrcev(mgs)  = frac*qrcev(mgs)
+       qhlacr(mgs) = frac*qhlacr(mgs)
+       vhlacr(mgs) = frac*vhlacr(mgs)
+!       qhcev(mgs)  = frac*qhcev(mgs)
+
+
+      IF ( warmonly < 0.5 ) THEN
+       pqrwd(mgs) =     &
+     &  il5(mgs)*(-qiacr(mgs)-qrfrz(mgs) - qsacr(mgs))    &
+     &  - qhacr(mgs) - qhlacr(mgs) - qwcnr(mgs)   &
+     &  + Min(0.0,qrcev(mgs))
+      ELSEIF ( warmonly < 0.8 ) THEN
+      pqrwd(mgs) =     &
+     &  il5(mgs)*(-qrfrz(mgs))    &
+     &   - qhacr(mgs)    &
+     &   - qhlacr(mgs)    &
+     &  + Min(0.0,qrcev(mgs))
+      ELSE
+       pqrwd(mgs) =  Min(0.0,qrcev(mgs))
+      ENDIF ! warmonly
+
+!
+! Resum for vapor since qrcev has changed
+!
+      IF ( qrcev(mgs) .ne. 0.0 ) THEN
+       pqwvi(mgs) =    &
+     &  -Min(0.0, qrcev(mgs))   &
+     &  -Min(0.0, qhcev(mgs))   &
+     &  -Min(0.0, qhlcev(mgs))   &
+     &  -Min(0.0, qscev(mgs))   &
+!     >  +il5(mgs)*(-qhsbv(mgs)  - qhlsbv(mgs) )   &
+     &  -qhsbv(mgs)  - qhlsbv(mgs)   &
+     &  -qssbv(mgs)    &
+     &  -il5(mgs)*qisbv(mgs) 
+     
+       pqwvd(mgs) =     &
+     &  -Max(0.0, qrcev(mgs))   &
+     &  -Max(0.0, qhcev(mgs))   &
+     &  -Max(0.0, qhlcev(mgs))   &
+     &  -Max(0.0, qscev(mgs))   &
+     &  +il5(mgs)*(-qiint(mgs)   &
+     &  -qhdpv(mgs) -qsdpv(mgs) - qhldpv(mgs))   &
+     &  -il5(mgs)*qidpv(mgs)  
+
+       ENDIF
+
+
+!       STOP
+      ENDIF
+      end do
+
+      IF ( warmonly < 0.5 ) THEN
+
+!
+!  Snow
+!
+      do mgs = 1,ngscnt
+      pqswi(mgs) =     &
+     &   il5(mgs)*(qscni(mgs)+qsaci(mgs)+qsdpv(mgs)   &
+     &   + qscnvi(mgs)                        &
+     &   + ifrzs*(qiacrs(mgs) + qrfrzs(mgs))  &
+     &   + il5(mgs)*( qwfrzc(mgs) + qwctfzc(mgs) + qicichr(mgs) )*ffrzs   &
+     &   + il2(mgs)*qsacr(mgs))   &
+     &   + il5(mgs)*qicicnt(mgs)*ffrzs        &
+     &   + il3(mgs)*(qiacrf(mgs)+qracif(mgs)) & ! only applies for ipconc <= 3
+     &   + Max(0.0, qscev(mgs))   &
+     &   + qsacw(mgs) + qscnh(mgs) &
+     &  + ffrzs*(qsmul(mgs)               &
+     &  +qhmul1(mgs) + qhlmul1(mgs)   &
+     & + qsplinter(mgs) + qsplinter2(mgs))
+      pqswd(mgs) =    &
+!     >  -qfacs(mgs) ! -qwacs(mgs)   &
+     &  -qracs(mgs)*(1-il2(mgs)) -qhacs(mgs) - qhlacs(mgs)   &
+     &  -qhcns(mgs)   &
+     &  +(1-il5(mgs))*qsmlr(mgs) + qsshr(mgs)    &    !null at this point when wet snow included
+!     >  +il5(mgs)*(qssbv(mgs))   &
+     &  + (qssbv(mgs))   &
+     &  + Min(0.0, qscev(mgs))  &
+     &  -qsmul(mgs)
+      
+      
+      IF ( imixedphase == 0 .and. pqswd(mgs) .lt. 0.0  ) THEN
+        IF ( qx(mgs,ls) + dtp*(pqswi(mgs) + pqswd(mgs)) < 0.0 ) THEN
+         frac = (-qx(mgs,ls) + pqswi(mgs)*dtp)/(pqswd(mgs)*dtp)
+         
+           pqswd(mgs) = frac*pqswd(mgs)
+           
+           qracs(mgs)  = frac*qracs(mgs) ! only used for single moment at this time
+           qhacs(mgs)  = frac*qhacs(mgs) 
+           qhlacs(mgs) = frac*qhlacs(mgs)
+           qhcns(mgs)  = frac*qhcns(mgs) 
+           qsmlr(mgs)  = frac*qsmlr(mgs) 
+           qsshr(mgs)  = frac*qsshr(mgs) 
+           qssbv(mgs)  = frac*qssbv(mgs) 
+           qsmul(mgs)  = frac*qsmul(mgs) 
+           IF ( qscev(mgs) < 0.0 ) qscev(mgs) = frac*qscev(mgs)
+
+        ENDIF
+      ENDIF
+      
+      pqcii(mgs) =  pqcii(mgs) &
+     &  + (1. - ifrzs)*qrfrzs(mgs) &
+     &  + (1. - ifrzs)*qiacrs(mgs)
+      
+      end do 
+      
+!
+!  Graupel
+!
+      do mgs = 1,ngscnt
+      pqhwi(mgs) =    &
+     &  +il5(mgs)*ifrzg*(qrfrzf(mgs)  + (1-il3(mgs))*(qiacrf(mgs)+qracif(mgs)))   &
+     &  + (1-il2(mgs))*(qracs(mgs) + qsacr(mgs))  &
+     &  +il5(mgs)*(qhdpv(mgs))   &
+     &  +Max(0.0, qhcev(mgs))   &
+     &  +qhacr(mgs)+qhacw(mgs)   &
+     &  +qhacs(mgs)+qhaci(mgs)   &
+     &  + qhcns(mgs) + qhcni(mgs) + qhcnhl(mgs)
+      pqhwd(mgs) =     &
+     &   qhshr(mgs)                &    !null at this point when wet graupel included
+     &  +(1-il5(mgs))*qhmlr(mgs)   &    !null at this point when wet graupel included
+!     >  +il5(mgs)*qhsbv(mgs)   &
+     &  + qhsbv(mgs)   &
+     &  + Min(0.0, qhcev(mgs))   &
+     &  -qhmul1(mgs) - qhlcnh(mgs) - qscnh(mgs)  &
+     &  - qsplinter(mgs) - qsplinter2(mgs)
+!     > - cimas0*nsplinter*(crfrzf(mgs) + crfrz(mgs))/rho0(mgs)
+      end do
+
+!
+!  Hail
+!
+      IF ( lhl .gt. 1 ) THEN
+
+      do mgs = 1,ngscnt
+      pqhli(mgs) =    &
+     &  +il5(mgs)*(qhldpv(mgs) + (1.0-ifrzg)*(qiacrf(mgs)+qrfrzf(mgs)  + qracif(mgs)))   &
+     &  +Max(0.0, qhlcev(mgs))   &
+     &  +qhlacr(mgs)+qhlacw(mgs)   &
+     &  +qhlacs(mgs)+qhlaci(mgs)   &
+     &  + qhlcnh(mgs)
+      pqhld(mgs) =     &
+     &   qhlshr(mgs)    &
+     &  +(1-il5(mgs))*qhlmlr(mgs)    &
+!     >  +il5(mgs)*qhlsbv(mgs)   &
+     &  + qhlsbv(mgs)   &
+     &  + Min(0.0, qhlcev(mgs))   &
+     &  -qhlmul1(mgs) - qhcnhl(mgs)
+      end do
+      
+      ENDIF ! lhl
+
+      ELSEIF ( warmonly < 0.8 ) THEN
+!
+!  Graupel
+!
+      do mgs = 1,ngscnt
+      pqhwi(mgs) =    &
+     &  +il5(mgs)*ifrzg*(qrfrzf(mgs) )   &
+     &  +il5(mgs)*(qhdpv(mgs))   &
+     &  +qhacr(mgs)+qhacw(mgs)   
+      pqhwd(mgs) =     &
+     &   qhshr(mgs)                &    !null at this point when wet graupel included
+     &  - qhlcnh(mgs)   &
+     &  - qhmul1(mgs)   &
+     &  - qsplinter(mgs) - qsplinter2(mgs) &
+     &  +(1-il5(mgs))*qhmlr(mgs)        !null at this point when wet graupel included
+       end do
+
+!
+!  Hail
+!
+      IF ( lhl .gt. 1 ) THEN
+
+      do mgs = 1,ngscnt
+      pqhli(mgs) =    &
+     &  +il5(mgs)*(qhldpv(mgs) ) & ! + (1.0-ifrzg)*(qiacrf(mgs)+qrfrzf(mgs)  + qracif(mgs)))   &
+     &  +qhlacr(mgs)+qhlacw(mgs)   &
+!     &  +qhlacs(mgs)+qhlaci(mgs)   &
+     &  + qhlcnh(mgs)
+      pqhld(mgs) =     &
+     &   qhlshr(mgs)    &
+     &  +(1-il5(mgs))*qhlmlr(mgs)    &
+!     >  +il5(mgs)*qhlsbv(mgs)   &
+     &  + qhlsbv(mgs)   &
+     &  -qhlmul1(mgs) - qhcnhl(mgs)
+
+      end do
+
+      ENDIF ! lhl
+
+      ENDIF ! warmonly
+
+!
+!  Liquid water on snow and graupel
+!
+
+      vhmlr(:) = 0.0
+      vhlmlr(:) = 0.0
+      vhfzh(:) = 0.0
+      vhlfzhl(:) = 0.0
+
+      IF ( mixedphase ) THEN
+      ELSE ! set arrays for non-mixedphase graupel
+      
+!        vhshdr(:) = 0.0
+        vhmlr(:) = qhmlr(:) ! not actually volume, but treated as q in rate equation
+!        vhsoak(:) = 0.0
+
+!        vhlshdr(:) = 0.0
+        vhlmlr(:) = qhlmlr(:) ! not actually volume, but treated as q in rate equation
+!        vhlmlr(:) = rho0(:)*qhlmlr(:)/xdn(:,lhl) 
+!        vhlsoak(:) = 0.0
+      
+      ENDIF  ! mixedphase
+
+
+
+!
+!  Snow volume
+!
+      IF ( lvol(ls) .gt. 1 ) THEN
+      do mgs = 1,ngscnt
+!      pvswi(mgs) = rho0(mgs)*( pqswi(mgs) )/xdn0(ls)
+
+      pvswi(mgs) = rho0(mgs)*(    &
+!aps     >   il5*qsfzs(mgs)/xdn(mgs,ls)   &
+!aps     >  -il5*qsfzs(mgs)/xdn(mgs,lr)   &
+     &  +il5(mgs)*(qscni(mgs)+qsaci(mgs)+qsdpv(mgs)   &
+     &   + qscnvi(mgs) + (1. - ifrzs)*qiacrs(mgs) &
+     &   + (1. - ifrzs)*qrfrzs(mgs)  &
+     &  )/xdn0(ls)   &
+     &    + (qsacr(mgs))/rimdn(mgs,ls) ) + vsacw(mgs)
+!     >   + (qsacw(mgs) + qsacr(mgs))/rimdn(mgs,ls) )
+      pvswd(mgs) = rho0(mgs)*( pqswd(mgs) )/xdn0(ls)  &
+!     >  -qhacs(mgs)
+!     >  -qhcns(mgs)
+!     >  +(1-il5(mgs))*qsmlr(mgs) + qsshr(mgs)
+!     >  +il5(mgs)*(qssbv(mgs))
+     &   -rho0(mgs)*qsmul(mgs)/xdn0(ls)
+!aps     >   +rho0(mgs)*(1-il5(mgs))*(
+!aps     >             qsmlr(mgs)/xdn(mgs,ls)
+!aps     >    +(qscev-qsmlr(mgs))/xdn(mgs,lr) )
+      end do
+
+!aps      IF (mixedphase) THEN
+!aps        pvswd(mgs) = pvswd(mgs)
+!aps     >   + rho0(mgs)*qsshr(mgs)/xdn(mgs,lr)
+!aps      ENDIF
+
+      ENDIF
+!
+!  Graupel volume
+!
+      IF ( lvol(lh) .gt. 1 ) THEN
+      DO mgs = 1,ngscnt
+!      pvhwi(mgs) = rho0(mgs)*( (pqhwi(mgs) )/xdn0(lh) )
+
+!      pvhwi(mgs) = rho0(mgs)*( (pqhwi(mgs) - il5(mgs)*qrfrzf(mgs) )/xdn0(lh) !
+!     :  +  il5(mgs)*qrfrzf(mgs)/rhofrz )
+
+      pvhwi(mgs) = rho0(mgs)*(   &
+     &  +il5(mgs)*( ifrzg*qracif(mgs))/rhofrz   &
+!erm     >  + il5(mgs)*qhfzh(mgs)/rhofrz !aps: or use xdnmx(lh)?   &
+     &  + (  il5(mgs)*qhdpv(mgs)/qhdpvdn   &
+     &     + (qhacs(mgs) + qhaci(mgs))/qhacidn ) )   &
+     &  +   rho0(mgs)*Max(0.0, qhcev(mgs))/1000.   & ! only used in mixed phase: evaporation/condensation of liquid water coating
+!     >     + qhacs(mgs) + qhaci(mgs) )/xdn0(ls) )   &
+     &  + vhcns(mgs)   &
+     &  + vhacr(mgs) + vhacw(mgs)  + vhfzh(mgs)   & ! qhacw(mgs)/rimdn(mgs,lh)
+!     >  + vhfrh(mgs)   &
+     &  + vhcni(mgs) + ifrzg*(viacrf(mgs) + vrfrzf(mgs))
+!     >  +qhacr(mgs)/raindn(mgs,lh) + qhacw(mgs)/rimdn(mgs,lh)
+      
+!      pvhwd(mgs) = rho0(mgs)*(pqhwd(mgs) )/xdn0(lh)
+
+      pvhwd(mgs) = rho0(mgs)*(   &
+!     >   qhshr(mgs)/xdn0(lr)   &
+!     >  - il5(mgs)*qhfzh(mgs)/xdn(mgs,lr)   &
+     &  +( (1-il5(mgs))*vhmlr(mgs)    &
+!     >     +il5(mgs)*qhsbv(mgs)   &
+     &     + qhsbv(mgs)   &
+     &     + Min(0.0, qhcev(mgs))   &
+     &     -qhmul1(mgs) )/xdn(mgs,lh) )   &
+     &  - vhlcnh(mgs) + vhshdr(mgs) - vhsoak(mgs) - vscnh(mgs)
+
+!      IF (mixedphase) THEN
+!       pvhwd(mgs) = pvhwd(mgs) 
+!     >  + rho0(mgs)*qhshr(mgs)/xdn(mgs,lh) !xdn(mgs,lr)
+!      ENDIF
+
+      IF ( .false. .and. ny .eq. 2 .and. kgs(mgs) .eq. 9 .and. igs(mgs) .eq. 19 ) THEN
+
+      write(iunit,*)
+      write(iunit,*)   'Graupel at ',igs(mgs),kgs(mgs)
+!
+      write(iunit,*)   il5(mgs)*qrfrzf(mgs), qrfrzf(mgs) - qrfrz(mgs)
+      write(iunit,*)   il5(mgs)*qiacrf(mgs)
+      write(iunit,*)   il5(mgs)*qracif(mgs)
+      write(iunit,*)   'qhcns',qhcns(mgs)
+      write(iunit,*)   'qhcni',qhcni(mgs)
+      write(iunit,*)   il5(mgs)*(qhdpv(mgs))
+      write(iunit,*)   'qhacr ',qhacr(mgs)
+      write(iunit,*)   'qhacw', qhacw(mgs)
+      write(iunit,*)   'qhacs', qhacs(mgs)
+      write(iunit,*)   'qhaci', qhaci(mgs)
+      write(iunit,*)   'pqhwi = ',pqhwi(mgs)
+      write(iunit,*)
+      write(iunit,*) 'qhcev',qhcev(mgs)
+      write(iunit,*)
+      write(iunit,*)   'qhshr',qhshr(mgs)
+      write(iunit,*)  'qhmlr', (1-il5(mgs))*qhmlr(mgs)
+      write(iunit,*)   'qhsbv', qhsbv(mgs)
+      write(iunit,*)   'qhlcnh',-qhlcnh(mgs)
+      write(iunit,*)   'qhmul1',-qhmul1(mgs)
+      write(iunit,*)   'pqhwd = ', pqhwd(mgs)
+      write(iunit,*)
+      write(iunit,*)  'Volume'
+      write(iunit,*)
+      write(iunit,*)  'pvhwi',pvhwi(mgs)
+      write(iunit,*)   'vhcns', vhcns(mgs)
+      write(iunit,*)  'vhacr,vhacw',vhacr(mgs), vhacw(mgs) ! qhacw(mgs)/rimdn(mgs,lh)
+      write(iunit,*)  'vhcni',vhcni(mgs)
+      write(iunit,*)
+      write(iunit,*)  'pvhwd',pvhwd(mgs)
+      write(iunit,*)  'vhlcnh,vhshdr,vhsoak ', vhlcnh(mgs),  vhshdr(mgs), vhsoak(mgs)
+      write(iunit,*)  'vhmlr', vhmlr(mgs)
+      write(iunit,*)
+!      write(iunit,*)
+!      write(iunit,*)
+!      write(iunit,*)
+      write(iunit,*)  'Concentration'
+      write(iunit,*)   pchwi(mgs),pchwd(mgs)
+      write(iunit,*)  crfrzf(mgs)
+      write(iunit,*)  chcns(mgs)
+      write(iunit,*)  ciacrf(mgs)
+
+
+      ENDIF
+
+
+      ENDDO
+
+      ENDIF
+!
+!
+!
+
+!
+!  Hail volume
+!
+      IF ( lhl .gt. 1 ) THEN
+      IF ( lvol(lhl) .gt. 1 ) THEN
+      DO mgs = 1,ngscnt
+
+      pvhli(mgs) = rho0(mgs)*(   &
+     &  + (  il5(mgs)*(((1.0-ifrzg)*qracif(mgs))/rhofrz  + qhldpv(mgs) )   &
+!     &  +    Max(0.0, qhlcev(mgs))   &
+!     &     + qhlacs(mgs) + qhlaci(mgs) )/xdnmn(lhl) )   & ! xdn0(ls) )   &
+!     &     + qhlacs(mgs) + qhlaci(mgs) )/xdnmn(lh) )   &  ! yes, this is 'lh' on purpose
+     &     + qhlacs(mgs) + qhlaci(mgs) )/500. )   &  ! changed to 500 instead of min graupel density to keep hail density from dropping too much
+     &  +   rho0(mgs)*Max(0.0, qhlcev(mgs))/1000.   &
+     &  + vhlcnhl(mgs) + (1.0-ifrzg)*(viacrf(mgs) + vrfrzf(mgs))  & 
+     &  + vhlacr(mgs) + vhlacw(mgs) + vhlfzhl(mgs) ! qhlacw(mgs)/rimdn(mgs,lhl)
+      
+      pvhld(mgs) = rho0(mgs)*(   &
+     &  +(  qhlsbv(mgs)   &
+     &     + Min(0.0, qhlcev(mgs))   &
+     &     -qhlmul1(mgs) )/xdn(mgs,lhl) ) &
+!     &   + vhlmlr(mgs)                    &
+     &   + rho0(mgs)*(1-il5(mgs))*vhlmlr(mgs)/xdn(mgs,lhl)  &
+     &   + vhlshdr(mgs) - vhlsoak(mgs)
+
+
+      ENDDO
+      
+      ENDIF
+      ENDIF
 
-       pqwvi(mgs) = pqwvi(mgs)    &
-     &  + Min(0.0, qrcev(mgs))   &
-     &  - frac*Min(0.0, qrcev(mgs))
-       pqwvd(mgs) =  pqwvd(mgs)   &
-     &  + Max(0.0, qrcev(mgs))   &
-     &  - frac*Max(0.0, qrcev(mgs))
 
-       qiacr(mgs)  = frac*qiacr(mgs)
-       qiacrf(mgs) = frac*qiacrf(mgs)
-       qiacrs(mgs) = frac*qiacrs(mgs)
-       viacrf(mgs) = frac*viacrf(mgs)
-       qrfrz(mgs)  = frac*qrfrz(mgs) 
-       qrfrzs(mgs) = frac*qrfrzs(mgs) 
-       qrfrzf(mgs) = frac*qrfrzf(mgs)
-       vrfrzf(mgs) = frac*vrfrzf(mgs)
-       qsacr(mgs)  = frac*qsacr(mgs)
-       qhacr(mgs)  = frac*qhacr(mgs)
-       vhacr(mgs)  = frac*vhacr(mgs)
-       qrcev(mgs)  = frac*qrcev(mgs)
-       qhlacr(mgs) = frac*qhlacr(mgs)
-       vhlacr(mgs) = frac*vhlacr(mgs)
-!       qhcev(mgs)  = frac*qhcev(mgs)
+      if ( ndebug .ge. 1 ) then
+      do mgs = 1,ngscnt
+!
+      ptotal(mgs) = 0.
+      ptotal(mgs) = ptotal(mgs)     &
+     &  + pqwvi(mgs) + pqwvd(mgs)   &
+     &  + pqcwi(mgs) + pqcwd(mgs)   &
+     &  + pqcii(mgs) + pqcid(mgs)   &
+     &  + pqrwi(mgs) + pqrwd(mgs)   &
+     &  + pqswi(mgs) + pqswd(mgs)   &
+     &  + pqhwi(mgs) + pqhwd(mgs)   &
+     &  + pqhli(mgs) + pqhld(mgs)
+!
+      
+      
+      ENDDO
+      
+      do mgs = 1,ngscnt
+
+      if ( ( (ndebug .ge. 0  ) .and. abs(ptotal(mgs)) .gt. eqtot )   &
+!      if ( (  abs(ptotal(mgs)) .gt. eqtot )
+!     :    .or. pqswi(mgs)*dtp .gt. 1.e-3
+!     :    .or. pqhwi(mgs)*dtp .gt. 1.e-3
+!     :     .or. dtp*(pqrwi(mgs)+pqrwd(mgs)) .gt. 10.0e-3
+!     :     .or. dtp*(pccii(mgs)+pccid(mgs)) .gt. 1.e7
+!     :     .or. dtp*(pcipi(mgs)+pcipd(mgs)) .gt. 1.e7    &
+     &  .or.  .not. (ptotal(mgs) .lt. 1.0 .and.  ptotal(mgs) .gt. -1.0)   & ! this line is basically checking for NaNs
+     &              ) then
+      write(iunit,*) 'YIKES! ','ptotal1',mgs,igs(mgs),jgs,   &
+     &       kgs(mgs),ptotal(mgs)
+
+      write(iunit,*) 't7: ', t7(igs(mgs),jgs,kgs(mgs))
+      write(iunit,*)  'cci,ccw,crw,rdia: ',cx(mgs,li),cx(mgs,lc),cx(mgs,lr),0.5*xdia(mgs,lr,1)
+      write(iunit,*)  'qc,qi,qr : ',qx(mgs,lc),qx(mgs,li),qx(mgs,lr)
+      write(iunit,*)  'rmas, qrcalc : ',xmas(mgs,lr),xmas(mgs,lr)*cx(mgs,lr)/rho0(mgs)
+      write(iunit,*)  'vti,vtc,eiw,vtr: ',vtxbar(mgs,li,1),vtxbar(mgs,lc,1),eiw(mgs),vtxbar(mgs,lr,1)
+      write(iunit,*)  'cidia,cwdia,qcmxd: ', xdia(mgs,li,1),xdia(mgs,lc,1),qcmxd(mgs)
+      write(iunit,*)  'snow: ',qx(mgs,ls),cx(mgs,ls),swvent(mgs),vtxbar(mgs,ls,1),xdia(mgs,ls,1)
+      write(iunit,*)  'graupel: ',qx(mgs,lh),cx(mgs,lh),hwvent(mgs),vtxbar(mgs,lh,1),xdia(mgs,lh,1)
+      IF ( lhl .gt. 1 ) write(iunit,*)  'hail: ',qx(mgs,lhl),cx(mgs,lhl),hlvent(mgs),vtxbar(mgs,lhl,1),xdia(mgs,lhl,1)
+
+
+      write(iunit,*)  'li: ',xdia(mgs,li,1),xdia(mgs,li,2),xmas(mgs,li),qx(mgs,li),   &
+     &         vtxbar(mgs,li,1)
+
+
+      write(iunit,*)  'rain cx,xv : ',cx(mgs,lr),xv(mgs,lr)
+      write(iunit,*)  'temcg = ', temcg(mgs)
+
+      write(iunit,*) 'v ', pqwvi(mgs) ,pqwvd(mgs)
+      write(iunit,*) 'c ', pqcwi(mgs) ,pqcwd(mgs)
+      write(iunit,*) 'ci', pqcii(mgs) ,pqcid(mgs)
+      write(iunit,*) 'r ', pqrwi(mgs) ,pqrwd(mgs)
+      write(iunit,*) 's ', pqswi(mgs) ,pqswd(mgs)
+      write(iunit,*) 'h ', pqhwi(mgs) ,pqhwd(mgs)
+      write(iunit,*) 'hl', pqhli(mgs) ,pqhld(mgs)
+       tmp =  pqwvi(mgs) + pqwvd(mgs)   &
+     &  + pqcwi(mgs) + pqcwd(mgs)   &
+     &  + pqcii(mgs) + pqcid(mgs)   &
+     &  + pqrwi(mgs) + pqrwd(mgs)   &
+     &  + pqswi(mgs) + pqswd(mgs)   &
+     &  + pqhwi(mgs) + pqhwd(mgs)   &
+     &  + pqhli(mgs) + pqhld(mgs)
+
+      write(iunit,*) 'total = ',tmp
+      write(iunit,*) 'END OF OUTPUT OF SOURCE AND SINK'
+
+!
+!  print production terms
+!
+      write(iunit,*)
+      write(iunit,*)   'Vapor'
+!
+      write(iunit,*)   -Min(0.0,qrcev(mgs))
+      write(iunit,*)   -il5(mgs)*qhsbv(mgs)
+      write(iunit,*)   -il5(mgs)*qhlsbv(mgs)
+      write(iunit,*)   -il5(mgs)*qssbv(mgs)
+      write(iunit,*)   -il5(mgs)*qisbv(mgs)
+      write(iunit,*)    'pqwvi= ', pqwvi(mgs)
+      write(iunit,*)   -Max(0.0,qrcev(mgs))
+      write(iunit,*)   -Max(0.0,qhcev(mgs))
+      write(iunit,*)   -Max(0.0,qhlcev(mgs))
+      write(iunit,*)   -Max(0.0,qscev(mgs))
+      write(iunit,*)   -il5(mgs)*qiint(mgs)
+      write(iunit,*)   -il5(mgs)*qhdpv(mgs)
+      write(iunit,*)   -il5(mgs)*qhldpv(mgs)
+      write(iunit,*)   -il5(mgs)*qsdpv(mgs)
+      write(iunit,*)   -il5(mgs)*qidpv(mgs)
+      write(iunit,*)    'pqwvd = ', pqwvd(mgs)
+!
+      write(iunit,*)
+      write(iunit,*)   'Cloud ice'
+!
+      write(iunit,*)   il5(mgs)*qicicnt(mgs)
+      write(iunit,*)   il5(mgs)*qidpv(mgs)
+      write(iunit,*)   il5(mgs)*qiacw(mgs)
+      write(iunit,*)   il5(mgs)*qwfrzc(mgs)
+      write(iunit,*)   il5(mgs)*qwctfzc(mgs)
+      write(iunit,*)   il5(mgs)*qicichr(mgs)
+      write(iunit,*)   qhmul1(mgs)
+      write(iunit,*)   qhlmul1(mgs)
+      write(iunit,*)   'pqcii = ', pqcii(mgs)
+      write(iunit,*)   -il5(mgs)*qscni(mgs)
+      write(iunit,*)   -il5(mgs)*qscnvi(mgs)
+      write(iunit,*)   -il5(mgs)*qraci(mgs)
+      write(iunit,*)   -il5(mgs)*qsaci(mgs)
+      write(iunit,*)   -il5(mgs)*qhaci(mgs)
+      write(iunit,*)   -il5(mgs)*qhlaci(mgs)
+      write(iunit,*)   il5(mgs)*qisbv(mgs)
+      write(iunit,*)   (1.-il5(mgs))*qimlr(mgs)
+      write(iunit,*)   -il5(mgs)*qhcni(mgs)
+      write(iunit,*)   'pqcid = ', pqcid(mgs)
+      write(iunit,*)   ' Conc:'
+      write(iunit,*)   pccii(mgs),pccid(mgs)
+      write(iunit,*)   il5(mgs),cicint(mgs)
+      write(iunit,*)   cwacii(mgs),cwfrzc(mgs),cwctfzc(mgs)
+      write(iunit,*)   cicichr(mgs)
+      write(iunit,*)   chmul1(mgs)
+      write(iunit,*)   chlmul1(mgs)
+      write(iunit,*)   csmul(mgs)
+!
+!
+!
+!
+      write(iunit,*)
+      write(iunit,*)   'Cloud water'
+!
+      write(iunit,*)   'pqcwi =', pqcwi(mgs)
+      write(iunit,*)   -il5(mgs)*qiacw(mgs)
+      write(iunit,*)   -il5(mgs)*qwfrzc(mgs)
+      write(iunit,*)   -il5(mgs)*qwctfzc(mgs)
+      write(iunit,*)   -il5(mgs)*qwctfzis(mgs)
+!      write(iunit,*)   -il5(mgs)*qwfrzp(mgs)
+!      write(iunit,*)   -il5(mgs)*qwctfzp(mgs)
+      write(iunit,*)   -il5(mgs)*qiihr(mgs)
+      write(iunit,*)   -il5(mgs)*qicichr(mgs)
+      write(iunit,*)   -il5(mgs)*qipiphr(mgs)
+      write(iunit,*)   -qracw(mgs)
+      write(iunit,*)   -qsacw(mgs)
+      write(iunit,*)   -qrcnw(mgs)
+      write(iunit,*)   -qhacw(mgs)
+      write(iunit,*)   -qhlacw(mgs)
+      write(iunit,*)   'pqcwd = ', pqcwd(mgs)
+
+
+      write(iunit,*)
+      write(iunit,*)  'Concentration:'
+      write(iunit,*)   -cautn(mgs)
+      write(iunit,*)   -cracw(mgs)
+      write(iunit,*)   -csacw(mgs)
+      write(iunit,*)   -chacw(mgs)
+      write(iunit,*)  -ciacw(mgs)
+      write(iunit,*)  -cwfrzp(mgs)
+      write(iunit,*)  -cwctfzp(mgs)
+      write(iunit,*)  -cwfrzc(mgs)
+      write(iunit,*)  -cwctfzc(mgs)
+      write(iunit,*)   pccwd(mgs)
+!
+      write(iunit,*)
+      write(iunit,*)      'Rain '
+!
+      write(iunit,*)      qracw(mgs)
+      write(iunit,*)      qrcnw(mgs)
+      write(iunit,*)      Max(0.0, qrcev(mgs))
+      write(iunit,*)       -(1-il5(mgs))*qhmlr(mgs)
+      write(iunit,*)       -(1-il5(mgs))*qhlmlr(mgs)
+      write(iunit,*)       -(1-il5(mgs))*qsmlr(mgs)
+      write(iunit,*)       -(1-il5(mgs))*qimlr(mgs)
+      write(iunit,*)       -qrshr(mgs)
+      write(iunit,*)       'pqrwi = ', pqrwi(mgs)    
+      write(iunit,*)        -qsshr(mgs)     
+      write(iunit,*)        -qhshr(mgs)     
+      write(iunit,*)        -qhlshr(mgs)
+      write(iunit,*)        -il5(mgs)*qiacr(mgs),qiacr(mgs), qiacrf(mgs)
+      write(iunit,*)        -il5(mgs)*qrfrz(mgs)
+      write(iunit,*)        -qsacr(mgs)
+      write(iunit,*)        -qhacr(mgs)
+      write(iunit,*)        -qhlacr(mgs)
+      write(iunit,*)        qrcev(mgs)
+      write(iunit,*)       'pqrwd = ', pqrwd(mgs) 
+      write(iunit,*)       'fhw, fhlw = ',fhw(mgs),fhlw(mgs)
+      write(iunit,*)        'qrzfac = ', qrzfac(mgs)
+!
+      
+      write(iunit,*)
+      write(iunit,*)  'Rain concentration'
+      write(iunit,*)  pcrwi(mgs) 
+      write(iunit,*)    crcnw(mgs)
+      write(iunit,*)    1-il5(mgs)
+      write(iunit,*)   -chmlr(mgs),-csmlr(mgs)
+      write(iunit,*)     -crshr(mgs)
+      write(iunit,*)  pcrwd(mgs) 
+      write(iunit,*)    il5(mgs)
+      write(iunit,*)   -ciacr(mgs),-crfrz(mgs) 
+      write(iunit,*)   -csacr(mgs),-chacr(mgs)
+      write(iunit,*)   +crcev(mgs)
+      write(iunit,*)   cracr(mgs)
+!      write(iunit,*)   -il5(mgs)*ciracr(mgs)
+
+
+      write(iunit,*)
+      write(iunit,*)   'Snow'
+!
+      write(iunit,*)        il5(mgs)*qscni(mgs), qscnvi(mgs)
+      write(iunit,*)        il5(mgs)*qsaci(mgs)
+      write(iunit,*)        il5(mgs)*qrfrzs(mgs)
+      write(iunit,*)        il5(mgs)*qiacrs(mgs),il3(mgs)*(qiacrf(mgs)+qracif(mgs)),il3(mgs),qiacrf(mgs),qracif(mgs)
+      write(iunit,*)        il5(mgs)*qsdpv(mgs), qscev(mgs)
+      write(iunit,*)        qsacw(mgs)
+      write(iunit,*)        qsacr(mgs), qscnh(mgs)
+       write(iunit,*)        'pqswi = ',pqswi(mgs)
+      write(iunit,*)        -qhcns(mgs)
+      write(iunit,*)        -qracs(mgs)
+      write(iunit,*)        -qhacs(mgs)
+      write(iunit,*)        -qhlacs(mgs)
+      write(iunit,*)       (1-il5(mgs))*qsmlr(mgs)
+      write(iunit,*)       qsshr(mgs)
+!      write(iunit,*)       qsshrp(mgs)
+      write(iunit,*)       il5(mgs)*(qssbv(mgs))
+      write(iunit,*)       'pqswd = ', pqswd(mgs)
+      write(iunit,*)   -qracs(mgs)*(1-il2(mgs)) , qhacs(mgs) , qhlacs(mgs)   
+      write(iunit,*)   -qhcns(mgs)   
+      write(iunit,*)   +(1-il5(mgs))*qsmlr(mgs) , qsshr(mgs)     
+      write(iunit,*)   (qssbv(mgs))   
+      write(iunit,*)   Min(0.0, qscev(mgs))  
+      write(iunit,*)   -qsmul(mgs)
+!
+!
+      write(iunit,*)
+      write(iunit,*)   'Graupel'
+!
+      write(iunit,*)   il5(mgs)*qrfrzf(mgs), qrfrzf(mgs) - qrfrz(mgs)
+      write(iunit,*)   il5(mgs)*qiacrf(mgs)
+      write(iunit,*)   il5(mgs)*qracif(mgs)
+      write(iunit,*)   qhcns(mgs)
+      write(iunit,*)   qhcni(mgs)
+      write(iunit,*)   il5(mgs)*(qhdpv(mgs))
+      write(iunit,*)   qhacr(mgs)
+      write(iunit,*)   qhacw(mgs)
+      write(iunit,*)   qhacs(mgs)
+      write(iunit,*)   qhaci(mgs)
+      write(iunit,*)   'pqhwi = ',pqhwi(mgs)
+      write(iunit,*)
+      write(iunit,*)   qhshr(mgs)
+      write(iunit,*)   (1-il5(mgs))*qhmlr(mgs)
+      write(iunit,*)   il5(mgs),qhsbv(mgs)
+      write(iunit,*)   -qhlcnh(mgs)
+      write(iunit,*)   -qhmul1(mgs)
+      write(iunit,*)   'pqhwd = ', pqhwd(mgs)
+      write(iunit,*)  'Concentration'
+      write(iunit,*)   pchwi(mgs),pchwd(mgs)
+      write(iunit,*)  crfrzf(mgs)
+      write(iunit,*)  chcns(mgs)
+      write(iunit,*)  ciacrf(mgs)
+
+!
+      write(iunit,*)
+      write(iunit,*)   'Hail'
+!
+      write(iunit,*)   qhlcnh(mgs)
+      write(iunit,*)   il5(mgs)*(qhldpv(mgs))
+      write(iunit,*)   qhlacr(mgs)
+      write(iunit,*)   qhlacw(mgs)
+      write(iunit,*)   qhlacs(mgs)
+      write(iunit,*)   qhlaci(mgs)
+      write(iunit,*)   pqhli(mgs)
+      write(iunit,*)
+      write(iunit,*)   qhlshr(mgs)
+      write(iunit,*)   (1-il5(mgs))*qhlmlr(mgs)
+      write(iunit,*)   il5(mgs)*qhlsbv(mgs)
+      write(iunit,*)   pqhld(mgs)
+      write(iunit,*)  'Concentration'
+      write(iunit,*)   pchli(mgs),pchld(mgs)
+      write(iunit,*)  chlcnh(mgs)
+!
+!  Balance and checks for continuity.....within machine precision...
+!
+!
+      write(iunit,*) 'END OF OUTPUT OF SOURCE AND SINK'
+      write(iunit,*) 'PTOTAL',ptotal(mgs)
+!
+      end if ! ptotal out of bounds or NaN
+!
+      end do
+!
 
+      end if ! ( nstep/12*12 .eq. nstep )
 
+!
+!  latent heating from phase changes (except qcw, qci cond, and evap)
+!
+      do mgs = 1,ngscnt
       IF ( warmonly < 0.5 ) THEN
-       pqrwd(mgs) =     &
-     &  il5(mgs)*(-qiacr(mgs)-qrfrz(mgs) - qsacr(mgs))    &
-     &  - qhacr(mgs) - qhlacr(mgs) - qwcnr(mgs)   &
-     &  + Min(0.0,qrcev(mgs))
+      pfrz(mgs) =    &
+     &  (1-il5(mgs))*   &
+     &  (qhmlr(mgs)+qsmlr(mgs)+qhlmlr(mgs))   & !+qhmlh(mgs))   &
+     &  +il5(mgs)*(qhfzh(mgs)+qsfzs(mgs)+qhlfzhl(mgs))   &
+     &  +il5(mgs)*(1-imixedphase)*(   &
+     &   qsacw(mgs)+qhacw(mgs) + qhlacw(mgs)   &
+     &  +qsacr(mgs)+qhacr(mgs) + qhlacr(mgs)   &
+     &  +qsshr(mgs)   &
+     &  +qhshr(mgs)   &
+     &  +qhlshr(mgs) +qrfrz(mgs)+qiacr(mgs)  &
+     &  )  &
+     &  +il5(mgs)*(qwfrz(mgs)    &
+     &  +qwctfz(mgs)+qiihr(mgs)   &
+     &  +qiacw(mgs))
+      pmlt(mgs) =    &
+     &  (1-il5(mgs))*   &
+     &  (qhmlr(mgs)+qsmlr(mgs)+qhlmlr(mgs))    !+qhmlh(mgs))   
+      ! NOTE: psub is sum of sublimation and deposition
+      psub(mgs) =    &
+     &   il5(mgs)*(   &
+     &  + qsdpv(mgs) + qhdpv(mgs)   &
+     &  + qhldpv(mgs)    &
+     &  + qidpv(mgs) + qisbv(mgs) )   &
+     &   + qssbv(mgs)  + qhsbv(mgs) + qhlsbv(mgs)   &
+     &  +il5(mgs)*(qiint(mgs))
+      pvap(mgs) =    &
+     &   qrcev(mgs) + qhcev(mgs) + qscev(mgs) + qhlcev(mgs)
+      pevap(mgs) =    &
+     &   Min(0.0,qrcev(mgs)) + Min(0.0,qhcev(mgs)) + Min(0.0,qscev(mgs)) + Min(0.0,qhlcev(mgs))
+      ! NOTE: pdep is the deposition part only
+      pdep(mgs) =    &
+     &   il5(mgs)*(   &
+     &  + qsdpv(mgs) + qhdpv(mgs)   &
+     &  + qhldpv(mgs)    &
+     &  + qidpv(mgs) + qiint(mgs) )   & ! 2.9.2016 added qiint
+     &  +il5(mgs)*(qiint(mgs))
       ELSEIF ( warmonly < 0.8 ) THEN
-      pqrwd(mgs) =     &
-     &  il5(mgs)*(-qrfrz(mgs))    &
-     &   - qhacr(mgs)    &
-     &   - qhlacr(mgs)    &
-     &  + Min(0.0,qrcev(mgs))
+      pfrz(mgs) =    &
+     &  (1-il5(mgs))*   &
+     &  (qhmlr(mgs)+qhlmlr(mgs))   & !+qhmlh(mgs))   &
+     &  +il5(mgs)*(qhfzh(mgs)+qhlfzhl(mgs))   &
+     &  +il5(mgs)*(   &
+     &  +qhshr(mgs)   &
+     &  +qhlshr(mgs)   &
+     &  +qrfrz(mgs)+qwfrz(mgs)   &
+     &  +qwctfz(mgs)+qiihr(mgs)   &
+     &  +qiacw(mgs)                &
+     & +qhacw(mgs) + qhlacw(mgs)   &
+     & +qhacr(mgs) + qhlacr(mgs)  ) 
+      psub(mgs) =  0.0 +  &
+     &   il5(mgs)*(   &
+     &  + qhdpv(mgs)   &
+     &  + qhldpv(mgs)    &
+     &  + qidpv(mgs) + qisbv(mgs) )   &
+     &  +il5(mgs)*(qiint(mgs))
+      pvap(mgs) =    &
+     &   qrcev(mgs) + qhcev(mgs) + qhlcev(mgs) ! + qscev(mgs) 
       ELSE
-       pqrwd(mgs) =  Min(0.0,qrcev(mgs))
+      pfrz(mgs) = 0.0
+      psub(mgs) = 0.0
+      pvap(mgs) = qrcev(mgs)
       ENDIF ! warmonly
-
-!
-! Resum for vapor since qrcev has changed
-!
-      IF ( qrcev(mgs) .ne. 0.0 ) THEN
-       pqwvi(mgs) =    &
-     &  -Min(0.0, qrcev(mgs))   &
-     &  -Min(0.0, qhcev(mgs))   &
-     &  -Min(0.0, qhlcev(mgs))   &
-     &  -Min(0.0, qscev(mgs))   &
-!     >  +il5(mgs)*(-qhsbv(mgs)  - qhlsbv(mgs) )   &
-     &  -qhsbv(mgs)  - qhlsbv(mgs)   &
-     &  -qssbv(mgs)    &
-     &  -il5(mgs)*qisbv(mgs) 
-     
-       pqwvd(mgs) =     &
-     &  -Max(0.0, qrcev(mgs))   &
-     &  -Max(0.0, qhcev(mgs))   &
-     &  -Max(0.0, qhlcev(mgs))   &
-     &  -Max(0.0, qscev(mgs))   &
-     &  +il5(mgs)*(-qiint(mgs)   &
-     &  -qhdpv(mgs) -qsdpv(mgs) - qhldpv(mgs))   &
-     &  -il5(mgs)*qidpv(mgs)  
-
-       ENDIF
-
-
-!       STOP
+      ptem(mgs) =    &
+     &  (1./pi0(mgs))*   &
+     &  (felfcp(mgs)*pfrz(mgs)   &
+     &  +felscp(mgs)*psub(mgs)    &
+     &  +felvcp(mgs)*pvap(mgs))
+      thetap(mgs) = thetap(mgs) + dtp*ptem(mgs)
+      ptem2(mgs) = ptem(mgs)
+      IF ( eqtset > 2 ) THEN
+        pipert(mgs) = pipert(mgs) + (felfpi(mgs)*pfrz(mgs)   &
+     &  +felspi(mgs)*psub(mgs)    &
+     &  +felvpi(mgs)*pvap(mgs))*dtp
       ENDIF
       end do
 
-      IF ( warmonly < 0.5 ) THEN
 
-!
-!  Snow
-!
-      do mgs = 1,ngscnt
-      pqswi(mgs) =     &
-     &   il5(mgs)*(qscni(mgs)+qsaci(mgs)+qsdpv(mgs)   &
-     &   + qscnvi(mgs)                        &
-     &   + ifrzs*(qiacrs(mgs) + qrfrzs(mgs))  &
-     &   + il5(mgs)*( qwfrzc(mgs) + qwctfzc(mgs) + qicichr(mgs) )*ffrzs   &
-     &   + il2(mgs)*qsacr(mgs))   &
-     &   + il5(mgs)*qicicnt(mgs)*ffrzs        &
-     &   + il3(mgs)*(qiacrf(mgs)+qracif(mgs)) &
-     &   + Max(0.0, qscev(mgs))   &
-     &   + qsacw(mgs) + qscnh(mgs) &
-     &  + ffrzs*(qsmul(mgs)               &
-     &  +qhmul1(mgs) + qhlmul1(mgs)   &
-     & + qsplinter(mgs) + qsplinter2(mgs))
-      pqswd(mgs) =    &
-!     >  -qfacs(mgs) ! -qwacs(mgs)   &
-     &  -qracs(mgs)*(1-il2(mgs)) -qhacs(mgs) - qhlacs(mgs)   &
-     &  -qhcns(mgs)   &
-     &  +(1-il5(mgs))*qsmlr(mgs) + qsshr(mgs)    &    !null at this point when wet snow included
-!     >  +il5(mgs)*(qssbv(mgs))   &
-     &  + (qssbv(mgs))   &
-     &  + Min(0.0, qscev(mgs))  &
-     &  -qsmul(mgs)
-      
-      
-      IF ( imixedphase == 0 .and. pqswd(mgs) .lt. 0.0  ) THEN
-        IF ( qx(mgs,ls) + dtp*(pqswi(mgs) + pqswd(mgs)) < 0.0 ) THEN
-         frac = (-qx(mgs,ls) + pqswi(mgs)*dtp)/(pqswd(mgs)*dtp)
-         
-           pqswd(mgs) = frac*pqswd(mgs)
-           
-           qracs(mgs)  = frac*qracs(mgs) ! only used for single moment at this time
-           qhacs(mgs)  = frac*qhacs(mgs) 
-           qhlacs(mgs) = frac*qhlacs(mgs)
-           qhcns(mgs)  = frac*qhcns(mgs) 
-           qsmlr(mgs)  = frac*qsmlr(mgs) 
-           qsshr(mgs)  = frac*qsshr(mgs) 
-           qssbv(mgs)  = frac*qssbv(mgs) 
-           qsmul(mgs)  = frac*qsmul(mgs) 
-           IF ( qscev(mgs) < 0.0 ) qscev(mgs) = frac*qscev(mgs)
 
-        ENDIF
-      ENDIF
-      
-      pqcii(mgs) =  pqcii(mgs) &
-     &  + (1. - ifrzs)*qrfrzs(mgs) &
-     &  + (1. - ifrzs)*qiacrs(mgs)
-      
-      end do 
-      
-!
-!  Graupel
+!  production of space charge ! use values from previous time step
 !
-      do mgs = 1,ngscnt
-      pqhwi(mgs) =    &
-     &  +il5(mgs)*ifrzg*(qrfrzf(mgs)  + (1-il3(mgs))*(qiacrf(mgs)+qracif(mgs)))   &
-     &  + (1-il2(mgs))*(qracs(mgs) + qsacr(mgs))  &
-     &  +il5(mgs)*(qhdpv(mgs))   &
-     &  +Max(0.0, qhcev(mgs))   &
-     &  +qhacr(mgs)+qhacw(mgs)   &
-     &  +qhacs(mgs)+qhaci(mgs)   &
-     &  + qhcns(mgs) + qhcni(mgs) + qhcnhl(mgs)
-      pqhwd(mgs) =     &
-     &   qhshr(mgs)                &    !null at this point when wet graupel included
-     &  +(1-il5(mgs))*qhmlr(mgs)   &    !null at this point when wet graupel included
-!     >  +il5(mgs)*qhsbv(mgs)   &
-     &  + qhsbv(mgs)   &
-     &  + Min(0.0, qhcev(mgs))   &
-     &  -qhmul1(mgs) - qhlcnh(mgs) - qscnh(mgs)  &
-     &  - qsplinter(mgs) - qsplinter2(mgs)
-!     > - cimas0*nsplinter*(crfrzf(mgs) + crfrz(mgs))/rho0(mgs)
-      end do
-
 !
-!  Hail
 !
-      IF ( lhl .gt. 1 ) THEN
-
-      do mgs = 1,ngscnt
-      pqhli(mgs) =    &
-     &  +il5(mgs)*(qhldpv(mgs) + (1.0-ifrzg)*(qiacrf(mgs)+qrfrzf(mgs)  + qracif(mgs)))   &
-     &  +Max(0.0, qhlcev(mgs))   &
-     &  +qhlacr(mgs)+qhlacw(mgs)   &
-     &  +qhlacs(mgs)+qhlaci(mgs)   &
-     &  + qhlcnh(mgs)
-      pqhld(mgs) =     &
-     &   qhlshr(mgs)    &
-     &  +(1-il5(mgs))*qhlmlr(mgs)    &
-!     >  +il5(mgs)*qhlsbv(mgs)   &
-     &  + qhlsbv(mgs)   &
-     &  + Min(0.0, qhlcev(mgs))   &
-     &  -qhlmul1(mgs) - qhcnhl(mgs)
+!  space charge production
+!  do transfer during conversion
+!  accretion, etc
+!
+      if ( ipelec .ge. 1 .and. itest .eq. 1 ) then
+      do mgs = 1,ngscnt
+      fscrw(mgs) = 0.0
+      if ( qx(mgs,lr) .gt. qxmin(lr) ) then
+      fscrw(mgs) = scx(mgs,lr)/qx(mgs,lr)
+!      if (abs(fscrw(mgs)).gt.1) write(0,*) 'fscrw(mgs),scx(mgs,lr),qx(mgs,lr)=',fscrw(mgs),scx(mgs,lr),qx(mgs,lr)
+      end if
       end do
-      
-      ENDIF ! lhl
+      end if
 
-      ELSEIF ( warmonly < 0.8 ) THEN
 !
-!  Graupel
+!  space charge production
+!  do transfer during conversion
+!  accretion, etc
 !
+      if ( ipelec .ge. 1 .and. itest .eq. 1 ) then
       do mgs = 1,ngscnt
-      pqhwi(mgs) =    &
-     &  +il5(mgs)*ifrzg*(qrfrzf(mgs) )   &
-     &  +il5(mgs)*(qhdpv(mgs))   &
-     &  +qhacr(mgs)+qhacw(mgs)   
-      pqhwd(mgs) =     &
-     &   qhshr(mgs)                &    !null at this point when wet graupel included
-     &  - qhlcnh(mgs)   &
-     &  - qhmul1(mgs)   &
-     &  - qsplinter(mgs) - qsplinter2(mgs) &
-     &  +(1-il5(mgs))*qhmlr(mgs)        !null at this point when wet graupel included
-       end do
+      fsccw(mgs) = 0.0
+      if ( qx(mgs,lc) .gt. qxmin(lc) ) then
+      fsccw(mgs) = scx(mgs,lc)/qx(mgs,lc)
+      end if
+      end do
+      end if
 
 !
-!  Hail
+!  space charge production
+!  do transfer during conversion
+!  accretion, etc
 !
-      IF ( lhl .gt. 1 ) THEN
-
+      if ( ipelec .ge. 1 .and. itest .eq. 1 ) then
       do mgs = 1,ngscnt
-      pqhli(mgs) =    &
-     &  +il5(mgs)*(qhldpv(mgs) ) & ! + (1.0-ifrzg)*(qiacrf(mgs)+qrfrzf(mgs)  + qracif(mgs)))   &
-     &  +qhlacr(mgs)+qhlacw(mgs)   &
-!     &  +qhlacs(mgs)+qhlaci(mgs)   &
-     &  + qhlcnh(mgs)
-      pqhld(mgs) =     &
-     &   qhlshr(mgs)    &
-     &  +(1-il5(mgs))*qhlmlr(mgs)    &
-!     >  +il5(mgs)*qhlsbv(mgs)   &
-     &  + qhlsbv(mgs)   &
-     &  -qhlmul1(mgs) - qhcnhl(mgs)
-
+      fscci(mgs) = 0.0
+      if ( qx(mgs,li) .gt. qxmin(li) ) then
+      fscci(mgs) = scx(mgs,li)/qx(mgs,li)
+      end if
       end do
+      end if
 
-      ENDIF ! lhl
-
-      ENDIF ! warmonly
+      ! ice spheres
+      fscis(:) = 0.0
+      IF ( lis > 1 ) THEN
+      if ( ipelec .ge. 1 .and. itest .eq. 1 ) then
+      do mgs = 1,ngscnt
+      if ( qx(mgs,lis) .gt. qxmin(lis) ) then
+      fscis(mgs) = scx(mgs,lis)/qx(mgs,lis)
+      end if
+      end do
+      end if
+      ENDIF
 
 !
-!  Liquid water on snow and graupel
+!  space charge production
+!  do transfer during conversion
+!  accretion, etc
 !
-
-      vhmlr(:) = 0.0
-      vhlmlr(:) = 0.0
-      vhfzh(:) = 0.0
-      vhlfzhl(:) = 0.0
-
-      IF ( mixedphase ) THEN
-      ELSE ! set arrays for non-mixedphase graupel
-      
-!        vhshdr(:) = 0.0
-        vhmlr(:) = qhmlr(:) ! not actually volume, but treated as q in rate equation
-!        vhsoak(:) = 0.0
-
-!        vhlshdr(:) = 0.0
-        vhlmlr(:) = qhlmlr(:) ! not actually volume, but treated as q in rate equation
-!        vhlmlr(:) = rho0(:)*qhlmlr(:)/xdn(:,lhl) 
-!        vhlsoak(:) = 0.0
-      
-      ENDIF  ! mixedphase
-
-
+      if ( ipelec .ge. 1 .and. itest .eq. 1 ) then
+      do mgs = 1,ngscnt
+      fscsw(mgs) = 0.0
+      if ( qx(mgs,ls) .gt. qxmin(ls) ) then
+      fscsw(mgs) = scx(mgs,ls)/qx(mgs,ls)
+      end if
+      end do
+      end if
 
 !
-!  Snow volume
+!  space charge production
+!  do transfer during conversion
+!  accretion, etc
 !
-      IF ( lvol(ls) .gt. 1 ) THEN
+      if ( ipelec .ge. 1 .and. itest .eq. 1 ) then
       do mgs = 1,ngscnt
-!      pvswi(mgs) = rho0(mgs)*( pqswi(mgs) )/xdn0(ls)
-
-      pvswi(mgs) = rho0(mgs)*(    &
-!aps     >   il5*qsfzs(mgs)/xdn(mgs,ls)   &
-!aps     >  -il5*qsfzs(mgs)/xdn(mgs,lr)   &
-     &  +il5(mgs)*(qscni(mgs)+qsaci(mgs)+qsdpv(mgs)   &
-     &   + qscnvi(mgs) + (1. - ifrzs)*qiacrs(mgs) &
-     &   + (1. - ifrzs)*qrfrzs(mgs)  &
-     &  )/xdn0(ls)   &
-     &    + (qsacr(mgs))/rimdn(mgs,ls) ) + vsacw(mgs)
-!     >   + (qsacw(mgs) + qsacr(mgs))/rimdn(mgs,ls) )
-      pvswd(mgs) = rho0(mgs)*( pqswd(mgs) )/xdn0(ls)  &
-!     >  -qhacs(mgs)
-!     >  -qhcns(mgs)
-!     >  +(1-il5(mgs))*qsmlr(mgs) + qsshr(mgs)
-!     >  +il5(mgs)*(qssbv(mgs))
-     &   -rho0(mgs)*qsmul(mgs)/xdn0(ls)
-!aps     >   +rho0(mgs)*(1-il5(mgs))*(
-!aps     >             qsmlr(mgs)/xdn(mgs,ls)
-!aps     >    +(qscev-qsmlr(mgs))/xdn(mgs,lr) )
+      fschw(mgs) = 0.0
+      if ( qx(mgs,lh) .gt. qxmin(lh) ) then
+      fschw(mgs) = scx(mgs,lh)/qx(mgs,lh)
+      end if
       end do
+      end if
 
-!aps      IF (mixedphase) THEN
-!aps        pvswd(mgs) = pvswd(mgs)
-!aps     >   + rho0(mgs)*qsshr(mgs)/xdn(mgs,lr)
-!aps      ENDIF
-
-      ENDIF
 !
-!  Graupel volume
+!  space charge production
+!  do transfer during conversion
+!  accretion, etc
 !
-      IF ( lvol(lh) .gt. 1 ) THEN
-      DO mgs = 1,ngscnt
-!      pvhwi(mgs) = rho0(mgs)*( (pqhwi(mgs) )/xdn0(lh) )
-
-!      pvhwi(mgs) = rho0(mgs)*( (pqhwi(mgs) - il5(mgs)*qrfrzf(mgs) )/xdn0(lh) !
-!     :  +  il5(mgs)*qrfrzf(mgs)/rhofrz )
-
-      pvhwi(mgs) = rho0(mgs)*(   &
-     &  +il5(mgs)*( qracif(mgs))/rhofrz   &
-!erm     >  + il5(mgs)*qhfzh(mgs)/rhofrz !aps: or use xdnmx(lh)?   &
-     &  + (  il5(mgs)*qhdpv(mgs)   &
-     &     + qhacs(mgs) + qhaci(mgs) )/xdnmn(lh) )   &
-     &  +   rho0(mgs)*Max(0.0, qhcev(mgs))/1000.   & ! only used in mixed phase: evaporation of liquid water coating
-!     >     + qhacs(mgs) + qhaci(mgs) )/xdn0(ls) )   &
-     &  + vhcns(mgs)   &
-     &  + vhacr(mgs) + vhacw(mgs)  + vhfzh(mgs)   & ! qhacw(mgs)/rimdn(mgs,lh)
-!     >  + vhfrh(mgs)   &
-     &  + vhcni(mgs) + ifrzg*(viacrf(mgs) + vrfrzf(mgs))
-!     >  +qhacr(mgs)/raindn(mgs,lh) + qhacw(mgs)/rimdn(mgs,lh)
-      
-!      pvhwd(mgs) = rho0(mgs)*(pqhwd(mgs) )/xdn0(lh)
-
-      pvhwd(mgs) = rho0(mgs)*(   &
-!     >   qhshr(mgs)/xdn0(lr)   &
-!     >  - il5(mgs)*qhfzh(mgs)/xdn(mgs,lr)   &
-     &  +( (1-il5(mgs))*vhmlr(mgs)    &
-!     >     +il5(mgs)*qhsbv(mgs)   &
-     &     + qhsbv(mgs)   &
-     &     + Min(0.0, qhcev(mgs))   &
-     &     -qhmul1(mgs) )/xdn(mgs,lh) )   &
-     &  - vhlcnh(mgs) + vhshdr(mgs) - vhsoak(mgs) - vscnh(mgs)
+      fschl(:) = 0.
+      if ( lhl .gt. 1 .and. ipelec .ge. 1 .and. itest .eq. 1 ) then
+      do mgs = 1,ngscnt
+      if ( qx(mgs,lhl) .gt. qxmin(lhl) ) then
+      fschl(mgs) = scx(mgs,lhl)/qx(mgs,lhl)
+      end if
+      end do
+      end if
 
-!      IF (mixedphase) THEN
-!       pvhwd(mgs) = pvhwd(mgs) 
-!     >  + rho0(mgs)*qhshr(mgs)/xdn(mgs,lh) !xdn(mgs,lr)
-!      ENDIF
 
-      IF ( .false. .and. ny .eq. 2 .and. kgs(mgs) .eq. 9 .and. igs(mgs) .eq. 19 ) THEN
+      schmlr(:) = 0.0
+      scsmlr(:) = 0.0
+      schshr(:) = 0.0
+      scsshr(:) = 0.0
+      scsdep(:) = 0.0
 
-      write(iunit,*)
-      write(iunit,*)   'Graupel at ',igs(mgs),kgs(mgs)
 !
-      write(iunit,*)   il5(mgs)*qrfrzf(mgs), qrfrzf(mgs) - qrfrz(mgs)
-      write(iunit,*)   il5(mgs)*qiacrf(mgs)
-      write(iunit,*)   il5(mgs)*qracif(mgs)
-      write(iunit,*)   'qhcns',qhcns(mgs)
-      write(iunit,*)   'qhcni',qhcni(mgs)
-      write(iunit,*)   il5(mgs)*(qhdpv(mgs))
-      write(iunit,*)   'qhacr ',qhacr(mgs)
-      write(iunit,*)   'qhacw', qhacw(mgs)
-      write(iunit,*)   'qhacs', qhacs(mgs)
-      write(iunit,*)   'qhaci', qhaci(mgs)
-      write(iunit,*)   'pqhwi = ',pqhwi(mgs)
-      write(iunit,*)
-      write(iunit,*) 'qhcev',qhcev(mgs)
-      write(iunit,*)
-      write(iunit,*)   'qhshr',qhshr(mgs)
-      write(iunit,*)  'qhmlr', (1-il5(mgs))*qhmlr(mgs)
-      write(iunit,*)   'qhsbv', qhsbv(mgs)
-      write(iunit,*)   'qhlcnh',-qhlcnh(mgs)
-      write(iunit,*)   'qhmul1',-qhmul1(mgs)
-      write(iunit,*)   'pqhwd = ', pqhwd(mgs)
-      write(iunit,*)
-      write(iunit,*)  'Volume'
-      write(iunit,*)
-      write(iunit,*)  'pvhwi',pvhwi(mgs)
-      write(iunit,*)   'vhcns', vhcns(mgs)
-      write(iunit,*)  'vhacr,vhacw',vhacr(mgs), vhacw(mgs) ! qhacw(mgs)/rimdn(mgs,lh)
-      write(iunit,*)  'vhcni',vhcni(mgs)
-      write(iunit,*)
-      write(iunit,*)  'pvhwd',pvhwd(mgs)
-      write(iunit,*)  'vhlcnh,vhshdr,vhsoak ', vhlcnh(mgs),  vhshdr(mgs), vhsoak(mgs)
-      write(iunit,*)  'vhmlr', vhmlr(mgs)
-      write(iunit,*)
-!      write(iunit,*)
-!      write(iunit,*)
-!      write(iunit,*)
-      write(iunit,*)  'Concentration'
-      write(iunit,*)   pchwi(mgs),pchwd(mgs)
-      write(iunit,*)  crfrzf(mgs)
-      write(iunit,*)  chcns(mgs)
-      write(iunit,*)  ciacrf(mgs)
-
+!
+!
+!SSSS
+!
+!  Charge production from mass transfer
+!
+!  Cloud ice
+!
+      if ( ipelec .ge. 1 .and. itest .eq. 1 ) then
+      do mgs = 1,ngscnt
+      psccimi(mgs) =    &
+     &   il5(mgs)*(fsccw(mgs)*qiacw(mgs)+fsccw(mgs)*qwfrzc(mgs)   &
+     &  +fsccw(mgs)*qwctfzc(mgs)+fsccw(mgs)*qicichr(mgs))   &
+!     >  +il5(mgs)*fscci(mgs)*qwacii(mgs))   &
+     &  +il5(mgs)*fscrw(mgs)*(1. - ifrzs)*qrfrzs(mgs)   &
+     &  +fschw(mgs)*qhmul1(mgs)   &
+     &  +fschl(mgs)*qhlmul1(mgs)  &
+     &  +fscsw(mgs)*qsmul(mgs)
+      psccimd(mgs) =    &
+     &   il5(mgs)*(-fscci(mgs)*qscni(mgs)   & ! -fscci(mgs)*qwaci(mgs)   &
+     &  -fscci(mgs)*qsaci(mgs))  -fscci(mgs)*qraci(mgs)   &
+     &  -fscci(mgs)*qhaci(mgs) -fscci(mgs)*qhlaci(mgs)
+      end do
+      end if
 
+!  ice spheres
+!
+      IF ( lis > 1 ) THEN
+      if ( ipelec .ge. 1 .and. itest .eq. 1 ) then
+      do mgs = 1,ngscnt
+      pscismi(mgs) =    &
+     &   il5(mgs)*(fsccw(mgs)*qwfrzis(mgs)   &
+     &  +fsccw(mgs)*qwctfzis(mgs)) !  &
+!     &  +fschw(mgs)*qhmul1(mgs)   &
+!     &  +fschl(mgs)*qhlmul1(mgs)  &
+!     &  +fscsw(mgs)*qsmul(mgs)
+      pscismd(mgs) =  0.0   &
+!     &   il5(mgs)*(-fscci(mgs)*qscni(mgs)   & ! -fscci(mgs)*qwaci(mgs)   &
+!     &  -fscci(mgs)*qsacis(mgs)) & ! -fscci(mgs)*qraci(mgs)   &
+     &  -fscis(mgs)*qhacis(mgs) -fscis(mgs)*qhlacis(mgs)
+      end do
+      end if
       ENDIF
 
 
-      ENDDO
-
-      ENDIF
 !
 !
+!  Cloud water
 !
+      if ( ipelec .ge. 1 .and. itest .eq. 1 ) then
+      do mgs = 1,ngscnt
+      psccwmi(mgs) = 0.0
+      psccwmd(mgs) =    &
+     &  -fsccw(mgs)*qracw(mgs)-fsccw(mgs)*qrcnw(mgs)   &
+     &  +il5(mgs)*(-fsccw(mgs)*qiacw(mgs)   &
+     &  -fsccw(mgs)*qwctfz(mgs)    & ! -fsccw(mgs)*qwctfzp(mgs)
+     &  -fsccw(mgs)*qwfrz(mgs) )   & ! -fsccw(mgs)*qwfrzp(mgs))
+     &  -fsccw(mgs)*qiihr(mgs)   &
+     &  -fsccw(mgs)*qsacw(mgs) -fsccw(mgs)*qhacw(mgs)  -fsccw(mgs)*qhlacw(mgs)
+      end do
+      end if
 
+      mixedphasefac = 1.0
+      IF ( mixedphase ) mixedphasefac = 0.0
 !
-!  Hail volume
+!  Snow
 !
-      IF ( lhl .gt. 1 ) THEN
-      IF ( lvol(lhl) .gt. 1 ) THEN
-      DO mgs = 1,ngscnt
-
-      pvhli(mgs) = rho0(mgs)*(   &
-     &  + (  il5(mgs)*qhldpv(mgs)   &
-!     &  +    Max(0.0, qhlcev(mgs))   &
-!     &     + qhlacs(mgs) + qhlaci(mgs) )/xdnmn(lhl) )   & ! xdn0(ls) )   &
-!     &     + qhlacs(mgs) + qhlaci(mgs) )/xdnmn(lh) )   &  ! yes, this is 'lh' on purpose
-     &     + qhlacs(mgs) + qhlaci(mgs) )/500. )   &  ! changed to 500 instead of min graupel density to keep hail density from dropping too much
-     &  +   rho0(mgs)*Max(0.0, qhlcev(mgs))/1000.   &
-     &  + vhlcnhl(mgs) + (1.0-ifrzg)*(viacrf(mgs) + vrfrzf(mgs))  & 
-     &  + vhlacr(mgs) + vhlacw(mgs) + vhlfzhl(mgs) ! qhlacw(mgs)/rimdn(mgs,lhl)
-      
-      pvhld(mgs) = rho0(mgs)*(   &
-     &  +(  qhlsbv(mgs)   &
-     &     + Min(0.0, qhlcev(mgs))   &
-     &     -qhlmul1(mgs) )/xdn(mgs,lhl) ) &
-!     &   + vhlmlr(mgs)                    &
-     &   + rho0(mgs)*(1-il5(mgs))*vhlmlr(mgs)/xdn(mgs,lhl)  &
-     &   + vhlshdr(mgs) - vhlsoak(mgs)
-
-
-      ENDDO
-      
-      ENDIF
+      if ( ipelec .ge. 1 .and. itest .eq. 1 ) then
+      do mgs = 1,ngscnt
+      pscswmi(mgs) =    &
+     &  +il5(mgs)*(fscci(mgs)*qscni(mgs)+fscci(mgs)*qsaci(mgs)   &
+     &  +fscrw(mgs)*ifrzs*qrfrzs(mgs))   &
+     &  +fsccw(mgs)*qsacw(mgs)+fscrw(mgs)*qsacr(mgs)
+      pscswmd(mgs) =    &
+!     >  -fscsw(mgs)*qracs(mgs) ! -fscsw(mgs)*qwacs(mgs)   &
+     &  - fscsw(mgs)*qhacs(mgs) - fscsw(mgs)*qhlacs(mgs)   &
+     &  +(1-il5(mgs))*fscsw(mgs)*qsmlr(mgs)*mixedphasefac &
+!     &   + fscsw(mgs)*qsshr(mgs) &
+     &  -fscsw(mgs)*qsmul(mgs)  &
+!       + fscsw(mgs)*max(0.0,qscev(mgs))  &
+        + fscsw(mgs)*min(0.0,qscev(mgs))
+
+      fscsw2(mgs) = 0.0
+      tmp =  qx(mgs,ls) + dtp*(pqswi(mgs) + pqswd(mgs) - qsshr(mgs)) ! should this add back the shed rain mass? probably!
+      IF ( tmp > qxmin(ls) .and. qsshr(mgs) < 0.0 ) THEN
+        chgtmp = scx(mgs,ls) + dtp*(pscswmi(mgs) - pscswmd(mgs))
+        fscsw2(mgs) = chgtmp/tmp
+        pscswmd(mgs) =  pscswmd(mgs) + fscsw2(mgs)*qsshr(mgs)
       ENDIF
 
+        il = ls
+        IF ( Abs( fscsw2(mgs)*qsshr(mgs)) > 1.e-8  ) THEN
+          write(0,*) 'Problem with scs = ',il,scx(mgs,il),pqswi(mgs),pqswd(mgs),qsshr(mgs),mgs,igs(mgs),kgs(mgs)
+      write(0,*) 'qs,pqswi(mgs),pqswd(mgs),qsnew ',qx(mgs,ls),pqswi(mgs),pqswd(mgs),qx(mgs,ls) + dtp*(pqswi(mgs)+pqswd(mgs))
+      write(0,*) ' -qracs(mgs)*(1-il2(mgs)) , qhacs(mgs) , qhlacs(mgs)',  -qracs(mgs)*(1-il2(mgs)) , qhacs(mgs) , qhlacs(mgs)   
+      write(0,*) ' -qhcns(mgs)',  -qhcns(mgs)   
+      write(0,*)  '+(1-il5(mgs))*qsmlr(mgs) , qsshr(mgs) ', (1-il5(mgs))*qsmlr(mgs) , qsshr(mgs)        !null at this point when wet snow included
+      write(0,*)  'qssbv', (qssbv(mgs))   
+      write(0,*)   'qscev', Min(0.0, qscev(mgs))  
+      write(0,*)   '-qsmul',-qsmul(mgs)
+ 
+      write(0,*)   'pqswi',pqswi(mgs)
+!      write(0,*)   il5(mgs)*(qscni(mgs)+qsaci(mgs)+qsdpv(mgs)   &
+!      write(0,*)    + qscnvi(mgs)                        &
+!     write(0,*)   + ifrzs*(qiacrs(mgs) + qrfrzs(mgs))  &
+!      write(0,*)   + il2(mgs)*qsacr(mgs))   
+!      write(0,*)   + il3(mgs)*(qiacrf(mgs)+qracif(mgs)) 
+      write(0,*)    'qscev',Max(0.0, qscev(mgs))   
+      write(0,*)     'qsacw(mgs) , qscnh(mgs)',qsacw(mgs) , qscnh(mgs)
+
+        write(0,*) 'rank,temperature = ',my_rank,temcg(mgs)
+          write(0,*) 'tmp, chgtmp, qs, scs,fscsw = ',tmp,chgtmp,qx(mgs,ls),scx(mgs,ls),fscsw(mgs)
+        write(0,*) 'tmp,chgtmp, fscsw2, qsshr,fscsw2(mgs)*qsshr(mgs) ',tmp,chgtmp,fscsw2(mgs), qsshr(mgs), fscsw2(mgs)*qsshr(mgs)
+        write(0,*) 'pscswmd new,old = ',pscswmd(mgs), pscswmd(mgs) - fscsw2(mgs)*qsshr(mgs)
+        write(0,*)  psccwi(mgs), psccwd(mgs)
+        write(0,*)  psccii(mgs), psccid(mgs)
+        write(0,*)  pscrwi(mgs), pscrwd(mgs)
+        write(0,*)  pscswi(mgs), pscswd(mgs)
+        write(0,*)  pschwi(mgs), pschwd(mgs)
+        write(0,*)  pschli(mgs), pschld(mgs)
+        write(0,*)  pscpii(mgs) ,pscpid(mgs)
+        write(0,*)  pscnii(mgs) ,pscnid(mgs)
+        write(0,*)
+        write(0,*)  psccwmi(mgs), psccwmd(mgs)
+        write(0,*)  psccimi(mgs), psccimd(mgs)
+        write(0,*)  pscrwmi(mgs), pscrwmd(mgs)
+        write(0,*)  pscswmi(mgs), pscswmd(mgs), pscswmd(mgs) - fscsw2(mgs)*qsshr(mgs)
+        write(0,*)  pschwmi(mgs), pschwmd(mgs)
+        write(0,*)  pschlmi(mgs), pschlmd(mgs)
+
+     write(0,*)  'pscswmd(mgs)'
+     write(0,*) - fscsw(mgs)*qhacs(mgs), - fscsw(mgs)*qhlacs(mgs)
+     write(0,*)  +(1-il5(mgs))*fscsw(mgs)*qsmlr(mgs), fscrw(mgs)*qsshr(mgs)
+     write(0,*)  -fscsw(mgs)*qsmul(mgs)
+     write(0,*) qhacs(mgs), qhlacs(mgs),qsmlr(mgs),qsshr(mgs) ,qsmul(mgs)
+     write(0,*)
+     write(0,*)  fschw(mgs),fscsw(mgs),fschl(mgs)
+     write(0,*)  fsccw(mgs),fscci(mgs),fscrw(mgs)
+
+!      tmp =  qx(mgs,ls) + dtp*(pqswi(mgs) + pqswd(mgs) - qsshr(mgs)) ! should this add back the shed rain mass? probably!
+!      chgtmp = 0.0
+!      IF ( tmp > qxmin(ls) .and. qsshr(mgs) < 0.0 ) THEN
+!        chgtmp = scx(mgs,ls) + dtp*(pscswmi(mgs) - pscswmd(mgs))
+!       ! fscsw2(mgs) = chgtmp/tmp
+!       ! pscswmd(mgs) =  pscswmd(mgs) + fscsw2(mgs)*qsshr(mgs)
+!      ENDIF
+!      write(0,*) 'tmp,chgtmp, fscsw2, qsshr,fscsw2(mgs)*qsshr(mgs) ',tmp,chgtmp,fscsw2(mgs), qsshr(mgs), fscsw2(mgs)*qsshr(mgs)
+
+       ENDIF
+      end do
+      end if
 
-      if ( ndebug .ge. 1 ) then
-      do mgs = 1,ngscnt
-!
-      ptotal(mgs) = 0.
-      ptotal(mgs) = ptotal(mgs)     &
-     &  + pqwvi(mgs) + pqwvd(mgs)   &
-     &  + pqcwi(mgs) + pqcwd(mgs)   &
-     &  + pqcii(mgs) + pqcid(mgs)   &
-     &  + pqrwi(mgs) + pqrwd(mgs)   &
-     &  + pqswi(mgs) + pqswd(mgs)   &
-     &  + pqhwi(mgs) + pqhwd(mgs)   &
-     &  + pqhli(mgs) + pqhld(mgs)
 !
-      
-      
-      ENDDO
-      
+!
+!  Graupel
+!
+      if ( ipelec .ge. 1 .and. itest .eq. 1 ) then
       do mgs = 1,ngscnt
+      pschwmi(mgs) =    &
+     &  +il5(mgs)*(fscci(mgs)*qracif(mgs)+fscrw(mgs)*qiacrf(mgs)   &
+     &  +fscrw(mgs)*qrfrz(mgs))   &
+     &  +fscrw(mgs)*qhacr(mgs)+fsccw(mgs)*qhacw(mgs)   &
+     &  +fscsw(mgs)*qhacs(mgs)+fscci(mgs)*qhaci(mgs)   &
+     &  +fscis(mgs)*qhacis(mgs) 
+      pschwmd(mgs) =    &
+     &  - fschw(mgs)*qhlcnh(mgs)   &
+!     &  + fschw(mgs)*qhshr(mgs)    &
+     &  +(1-il5(mgs))*fschw(mgs)*qhmlr(mgs)*mixedphasefac   &
+     &  -fschw(mgs)*qhmul1(mgs)
+
+      fschw2(mgs) = 0.0
+      tmp =  qx(mgs,lh) + dtp*(pqhwi(mgs) + pqhwd(mgs) - qhshr(mgs)) ! should this add back the shed rain mass? probably!
+      IF ( tmp > qxmin(lh) .and. qhshr(mgs) < 0.0 ) THEN
+        chgtmp = scx(mgs,lh) + dtp*(pschwmi(mgs) - pschwmd(mgs))
+        fschw2(mgs) = chgtmp/tmp
+        pschwmd(mgs) =  pschwmd(mgs) + fschw2(mgs)*qhshr(mgs)
+      ENDIF
 
-      if ( ( (ndebug .ge. 0  ) .and. abs(ptotal(mgs)) .gt. eqtot )   &
-!      if ( (  abs(ptotal(mgs)) .gt. eqtot )
-!     :    .or. pqswi(mgs)*dtp .gt. 1.e-3
-!     :    .or. pqhwi(mgs)*dtp .gt. 1.e-3
-!     :     .or. dtp*(pqrwi(mgs)+pqrwd(mgs)) .gt. 10.0e-3
-!     :     .or. dtp*(pccii(mgs)+pccid(mgs)) .gt. 1.e7
-!     :     .or. dtp*(pcipi(mgs)+pcipd(mgs)) .gt. 1.e7    &
-     &  .or.  .not. (ptotal(mgs) .lt. 1.0 .and.  ptotal(mgs) .gt. -1.0)   & ! this line is basically checking for NaNs
-     &              ) then
-      write(iunit,*) 'YIKES! ','ptotal1',mgs,igs(mgs),jgs,   &
-     &       kgs(mgs),ptotal(mgs)
-
-      write(iunit,*) 't7: ', t7(igs(mgs),jgs,kgs(mgs))
-      write(iunit,*)  'cci,ccw,crw,rdia: ',cx(mgs,li),cx(mgs,lc),cx(mgs,lr),0.5*xdia(mgs,lr,1)
-      write(iunit,*)  'qc,qi,qr : ',qx(mgs,lc),qx(mgs,li),qx(mgs,lr)
-      write(iunit,*)  'rmas, qrcalc : ',xmas(mgs,lr),xmas(mgs,lr)*cx(mgs,lr)/rho0(mgs)
-      write(iunit,*)  'vti,vtc,eiw,vtr: ',vtxbar(mgs,li,1),vtxbar(mgs,lc,1),eiw(mgs),vtxbar(mgs,lr,1)
-      write(iunit,*)  'cidia,cwdia,qcmxd: ', xdia(mgs,li,1),xdia(mgs,lc,1),qcmxd(mgs)
-      write(iunit,*)  'snow: ',qx(mgs,ls),cx(mgs,ls),swvent(mgs),vtxbar(mgs,ls,1),xdia(mgs,ls,1)
-      write(iunit,*)  'graupel: ',qx(mgs,lh),cx(mgs,lh),hwvent(mgs),vtxbar(mgs,lh,1),xdia(mgs,lh,1)
-      IF ( lhl .gt. 1 ) write(iunit,*)  'hail: ',qx(mgs,lhl),cx(mgs,lhl),hlvent(mgs),vtxbar(mgs,lhl,1),xdia(mgs,lhl,1)
+      end do
+      end if
 
 
-      write(iunit,*)  'li: ',xdia(mgs,li,1),xdia(mgs,li,2),xmas(mgs,li),qx(mgs,li),   &
-     &         vtxbar(mgs,li,1)
+!
+!
+!  Hail
+!
+      if ( ipelec .ge. 1 .and. itest .eq. 1 ) then
 
+      pschlmi(:) = 0.0
+      pschlmd(:) = 0.0
 
-      write(iunit,*)  'rain cx,xv : ',cx(mgs,lr),xv(mgs,lr)
-      write(iunit,*)  'temcg = ', temcg(mgs)
+      IF ( lhl .gt. 1 ) THEN
+      do mgs = 1,ngscnt
+      pschlmi(mgs) =    &
+     &  +fscrw(mgs)*qhlacr(mgs)+fsccw(mgs)*qhlacw(mgs)   &
+     &  +fscsw(mgs)*qhlacs(mgs)+fscci(mgs)*qhlaci(mgs)   &
+     &  + fschw(mgs)*qhlcnh(mgs) &
+     &  + fscis(mgs)*qhlacis(mgs)
+      pschlmd(mgs) =    &
+!     &  + fschl(mgs)*qhlshr(mgs)    &
+     &  +(1-il5(mgs))*fschl(mgs)*qhlmlr(mgs)*mixedphasefac    &
+     &  -fschl(mgs)*qhlmul1(mgs)
+
+       fschl2(mgs) = 0.0
+      tmp =  qx(mgs,lhl) + dtp*(pqhli(mgs) + pqhld(mgs) - qhlshr(mgs)) ! should this add back the shed rain mass? probably!
+      IF ( tmp > qxmin(lhl) .and. qhlshr(mgs) < 0.0 ) THEN
+        chgtmp = scx(mgs,lhl) + dtp*(pschlmi(mgs) - pschlmd(mgs))
+        fschl2(mgs) = chgtmp/tmp
+        pschlmd(mgs) =  pschlmd(mgs) + fschl2(mgs)*qhlshr(mgs)
+      ENDIF
 
-      write(iunit,*) 'v ', pqwvi(mgs) ,pqwvd(mgs)
-      write(iunit,*) 'c ', pqcwi(mgs) ,pqcwd(mgs)
-      write(iunit,*) 'ci', pqcii(mgs) ,pqcid(mgs)
-      write(iunit,*) 'r ', pqrwi(mgs) ,pqrwd(mgs)
-      write(iunit,*) 's ', pqswi(mgs) ,pqswd(mgs)
-      write(iunit,*) 'h ', pqhwi(mgs) ,pqhwd(mgs)
-      write(iunit,*) 'hl', pqhli(mgs) ,pqhld(mgs)
-       tmp =  pqwvi(mgs) + pqwvd(mgs)   &
-     &  + pqcwi(mgs) + pqcwd(mgs)   &
-     &  + pqcii(mgs) + pqcid(mgs)   &
-     &  + pqrwi(mgs) + pqrwd(mgs)   &
-     &  + pqswi(mgs) + pqswd(mgs)   &
-     &  + pqhwi(mgs) + pqhwd(mgs)   &
-     &  + pqhli(mgs) + pqhld(mgs)
+      end do
+      end if
+      ENDIF
 
-      write(iunit,*) 'total = ',tmp
-      write(iunit,*) 'END OF OUTPUT OF SOURCE AND SINK'
 
 !
-!  print production terms
-!
-      write(iunit,*)
-      write(iunit,*)   'Vapor'
+!  Rain
 !
-      write(iunit,*)   -Min(0.0,qrcev(mgs))
-      write(iunit,*)   -il5(mgs)*qhsbv(mgs)
-      write(iunit,*)   -il5(mgs)*qhlsbv(mgs)
-      write(iunit,*)   -il5(mgs)*qssbv(mgs)
-      write(iunit,*)   -il5(mgs)*qisbv(mgs)
-      write(iunit,*)    'pqwvi= ', pqwvi(mgs)
-      write(iunit,*)   -Max(0.0,qrcev(mgs))
-      write(iunit,*)   -Max(0.0,qhcev(mgs))
-      write(iunit,*)   -Max(0.0,qhlcev(mgs))
-      write(iunit,*)   -Max(0.0,qscev(mgs))
-      write(iunit,*)   -il5(mgs)*qiint(mgs)
-      write(iunit,*)   -il5(mgs)*qhdpv(mgs)
-      write(iunit,*)   -il5(mgs)*qhldpv(mgs)
-      write(iunit,*)   -il5(mgs)*qsdpv(mgs)
-      write(iunit,*)   -il5(mgs)*qidpv(mgs)
-      write(iunit,*)    'pqwvd = ', pqwvd(mgs)
+      if ( ipelec .ge. 1 .and. itest .eq. 1 ) then
+      do mgs = 1,ngscnt
+      pscrwmi(mgs) =    &
+     &    +fsccw(mgs)*qracw(mgs) +fsccw(mgs)*qrcnw(mgs)    &
+     &  +(1-il5(mgs))*   &
+     &   (-fschl(mgs)*qhlmlr(mgs) - fschw(mgs)*qhmlr(mgs)-fscsw(mgs)*qsmlr(mgs))*mixedphasefac   &
+!     &    -fschl2(mgs)*qhlshr(mgs) - fschw2(mgs)*qhshr(mgs) - fscsw(mgs)*qsshr(mgs) ! -fscsw2(mgs)*qsshr(mgs)
+     &    -fschl2(mgs)*qhlshr(mgs) - fschw2(mgs)*qhshr(mgs) -fscsw2(mgs)*qsshr(mgs)
+      pscrwmd(mgs) =     &
+     &  + il5(mgs)*(-fscrw(mgs)*qiacr(mgs)-fscrw(mgs)*qrfrz(mgs))    &
+     &  -fscrw(mgs)*qsacr(mgs)-fscrw(mgs)*qhacr(mgs) - fscrw(mgs)*qhlacr(mgs)  &
+!       + fscrw(mgs)*max(0.0,qrcev(mgs))  &
+        + fscrw(mgs)*min(0.0,qrcev(mgs))
+      end do
+      end if
+
+      pscpii(:) = 0.0 ! positive ion charge production here
+     pscpid(:) = 0.0 
+     pscnii(:) = 0.0 ! negative ion charge production here
+     pscnid(:) = 0.0 
 !
-      write(iunit,*)
-      write(iunit,*)   'Cloud ice'
 !
-      write(iunit,*)   il5(mgs)*qicicnt(mgs)
-      write(iunit,*)   il5(mgs)*qidpv(mgs)
-      write(iunit,*)   il5(mgs)*qiacw(mgs)
-      write(iunit,*)   il5(mgs)*qwfrzc(mgs)
-      write(iunit,*)   il5(mgs)*qwctfzc(mgs)
-      write(iunit,*)   il5(mgs)*qicichr(mgs)
-      write(iunit,*)   qhmul1(mgs)
-      write(iunit,*)   qhlmul1(mgs)
-      write(iunit,*)   'pqcii = ', pqcii(mgs)
-      write(iunit,*)   -il5(mgs)*qscni(mgs)
-      write(iunit,*)   -il5(mgs)*qscnvi(mgs)
-      write(iunit,*)   -il5(mgs)*qraci(mgs)
-      write(iunit,*)   -il5(mgs)*qsaci(mgs)
-      write(iunit,*)   -il5(mgs)*qhaci(mgs)
-      write(iunit,*)   -il5(mgs)*qhlaci(mgs)
-      write(iunit,*)   il5(mgs)*qisbv(mgs)
-      write(iunit,*)   (1.-il5(mgs))*qimlr(mgs)
-      write(iunit,*)   -il5(mgs)*qhcni(mgs)
-      write(iunit,*)   'pqcid = ', pqcid(mgs)
-      write(iunit,*)   ' Conc:'
-      write(iunit,*)   pccii(mgs),pccid(mgs)
-      write(iunit,*)   il5(mgs),cicint(mgs)
-      write(iunit,*)   cwacii(mgs),cwfrzc(mgs),cwctfzc(mgs)
-      write(iunit,*)   cicichr(mgs)
-      write(iunit,*)   chmul1(mgs)
-      write(iunit,*)   chlmul1(mgs)
-      write(iunit,*)   csmul(mgs)
+! Collisional Charging transfers (inductive/noninductive)
 !
 !
+!  rain water
 !
+      if ( ipelec .ge. 1 .and. itest .eq. 1 ) then
+      do mgs = 1,ngscnt
+      pscrwi(mgs) = 0.0
+      pscrwd(mgs) = 0.0
+
+      pscrwi(mgs) =  pscrwi(mgs)  &
+     & + max(-schacr(mgs),0.0)    &
+     & + max(-scsacr(mgs),0.0)    &
+     & + max(scsshr(mgs),0.0)     & !Canosa & List 93
+     & + max(schshr(mgs),0.0)       !Canosa & List 93
+
+      pscrwd(mgs) =  pscrwd(mgs)  &
+     & + min(-schacr(mgs),0.0)    &
+     & + min(-scsacr(mgs),0.0)    &
+     & + min(scsshr(mgs),0.0)     & !Canosa & List 93
+     & + min(schshr(mgs),0.0)       !Canosa & List 93
+
+      end do
+      end if
+
 !
-      write(iunit,*)
-      write(iunit,*)   'Cloud water'
+!  cloud water
 !
-      write(iunit,*)   'pqcwi =', pqcwi(mgs)
-      write(iunit,*)   -il5(mgs)*qiacw(mgs)
-      write(iunit,*)   -il5(mgs)*qwfrzc(mgs)
-      write(iunit,*)   -il5(mgs)*qwctfzc(mgs)
-      write(iunit,*)   -il5(mgs)*qwctfzis(mgs)
-!      write(iunit,*)   -il5(mgs)*qwfrzp(mgs)
-!      write(iunit,*)   -il5(mgs)*qwctfzp(mgs)
-      write(iunit,*)   -il5(mgs)*qiihr(mgs)
-      write(iunit,*)   -il5(mgs)*qicichr(mgs)
-      write(iunit,*)   -il5(mgs)*qipiphr(mgs)
-      write(iunit,*)   -qracw(mgs)
-      write(iunit,*)   -qsacw(mgs)
-      write(iunit,*)   -qrcnw(mgs)
-      write(iunit,*)   -qhacw(mgs)
-      write(iunit,*)   -qhlacw(mgs)
-      write(iunit,*)   'pqcwd = ', pqcwd(mgs)
+      if ( ipelec .ge. 1 .and. itest .eq. 1 ) then
+      do mgs = 1,ngscnt
+      psccwi(mgs) = 0.0
+      psccwd(mgs) = 0.0
 
+      psccwi(mgs) =  psccwi(mgs)   &
+     & + max(-schacw(mgs),0.0)   &
+     & + max(-schlacw(mgs),0.0)   &
+     & + max(-scsacw(mgs),0.0)  
+
+      psccwd(mgs) =  psccwd(mgs)   &
+     & + min(-schacw(mgs),0.0)   &
+     & + min(-schlacw(mgs),0.0)   &
+     & + min(-scsacw(mgs),0.0)   
+
+!      end do
+!      end if
+
+       qcwtmp(mgs) = Max(0.0,qx(mgs,lc) +   &
+     &   dtp*(pqcwi(mgs)+pqcwd(mgs)) )
+
+       IF ( qcwtmp(mgs) .gt. qxmin(lc) ) then
+       
+      IF ( ipconc .lt. 2 ) THEN
+       ccwtmp = cwccn
+       ccwtmp = Max(1.0,qcwtmp(mgs)*rho0(mgs)/xmas(mgs,lc))
+      ELSE
+ 
+       ccwtmp = Max(0.001, cx(mgs,lc) + dtp*(pccwi(mgs)+pccwd(mgs)) )
+      
+      ENDIF ! ( ipconc .lt. 2 )
+
+      
+       cpqc = (scx(mgs,lc)   &
+     &   +dtp*(psccwi(mgs)+psccwd(mgs)   &
+     &   +psccwmi(mgs)+psccwmd(mgs)))/ccwtmp
+      
+         IF ( Abs(cpqc) .gt. scwppmx .and.   &
+     &       ( psccwi(mgs)+psccwd(mgs) ) .ne. 0.0 .and.   &
+     &    Sign(1.0,scx(mgs,lc)) .eq.   &
+     &        Sign(1.0,( psccwi(mgs)+psccwd(mgs) )) ) THEN
+          
+           cpqc0 = Sign(scwppmx,cpqc)
+          
+           scfac = (cpqc0*ccwtmp - scx(mgs,lc) -   &
+     &       dtp*(psccwmi(mgs)+psccwmd(mgs)))/   &
+     &              ( dtp*(psccwi(mgs)+psccwd(mgs)) )
+!           IF ( scfac .gt. 1.0 .or. scfac .lt. 0.0 ) THEN
+           IF ( scfac .gt. 1.0 ) THEN
+             write(iunit,*) 'OUCH: scwfac = ',scfac
+             write(0,*) 'OUCH: scwfac = ',scfac
+           ENDIF
+          scfac = Max(scfac,0.0)
+          scfac = Min(scfac,1.0)
+        
+!        IF ( scfac .lt. 1.0 .and. scfac .gt. 0.0 ) THEN
+!        write(iunit,*) 'LOOK: sccwfac = ',scfac,cpqc,scx(mgs,lc),ccwtmp,
+!     : kgs(mgs),temg(mgs)
+!        ENDIF
+         
+        ELSE
+          scfac = 1.0
+        ENDIF
+      
+      ELSE
+       scfac = 0.0
+      ENDIF ! ( qcwtmp .gt. qxmin(lc) ) 
+      
+      IF ( scfac .lt. 1.0 .and. qx(mgs,lc) .gt. qxmin(lc) ) THEN
+       schacw(mgs) = scfac*schacw(mgs)
+       schlacw(mgs) = scfac*schlacw(mgs)
+       scsacw(mgs) = scfac*scsacw(mgs)
+
+      psccwi(mgs) = 0.0
+      psccwd(mgs) = 0.0
+      psccwi(mgs) =  psccwi(mgs)   &
+     & + max(-schacw(mgs),0.0)   &
+     & + max(-schlacw(mgs),0.0)   &
+     & + max(-scsacw(mgs),0.0)
+      psccwd(mgs) =  psccwd(mgs)   &
+     & + min(-schacw(mgs),0.0)   &
+     & + min(-schlacw(mgs),0.0)   &
+     & + min(-scsacw(mgs),0.0)
+      ENDIF
+      end do
+      
+      
+      end if
 
-      write(iunit,*)
-      write(iunit,*)  'Concentration:'
-      write(iunit,*)   -cautn(mgs)
-      write(iunit,*)   -cracw(mgs)
-      write(iunit,*)   -csacw(mgs)
-      write(iunit,*)   -chacw(mgs)
-      write(iunit,*)  -ciacw(mgs)
-      write(iunit,*)  -cwfrzp(mgs)
-      write(iunit,*)  -cwctfzp(mgs)
-      write(iunit,*)  -cwfrzc(mgs)
-      write(iunit,*)  -cwctfzc(mgs)
-      write(iunit,*)   pccwd(mgs)
-!
-      write(iunit,*)
-      write(iunit,*)      'Rain '
 !
-      write(iunit,*)      qracw(mgs)
-      write(iunit,*)      qrcnw(mgs)
-      write(iunit,*)      Max(0.0, qrcev(mgs))
-      write(iunit,*)       -(1-il5(mgs))*qhmlr(mgs)
-      write(iunit,*)       -(1-il5(mgs))*qhlmlr(mgs)
-      write(iunit,*)       -(1-il5(mgs))*qsmlr(mgs)
-      write(iunit,*)       -(1-il5(mgs))*qimlr(mgs)
-      write(iunit,*)       -qrshr(mgs)
-      write(iunit,*)       'pqrwi = ', pqrwi(mgs)    
-      write(iunit,*)        -qsshr(mgs)     
-      write(iunit,*)        -qhshr(mgs)     
-      write(iunit,*)        -qhlshr(mgs)
-      write(iunit,*)        -il5(mgs)*qiacr(mgs),qiacr(mgs), qiacrf(mgs)
-      write(iunit,*)        -il5(mgs)*qrfrz(mgs)
-      write(iunit,*)        -qsacr(mgs)
-      write(iunit,*)        -qhacr(mgs)
-      write(iunit,*)        -qhlacr(mgs)
-      write(iunit,*)        qrcev(mgs)
-      write(iunit,*)       'pqrwd = ', pqrwd(mgs) 
-      write(iunit,*)       'fhw, fhlw = ',fhw(mgs),fhlw(mgs)
-      write(iunit,*)        'qrzfac = ', qrzfac(mgs)
+!  cloud ice
 !
+      if ( ipelec .ge. 1 .and. itest .eq. 1 ) then
+      do mgs = 1,ngscnt
+      psccii(mgs) = 0.0
+      psccid(mgs) = 0.0
+      psccii(mgs) =  psccii(mgs)   &
+     & + max(-schaci(mgs),0.0)   &
+     & + max(-schlaci(mgs),0.0)   &
+     & + max(-scsaci(mgs),0.0)
+      psccid(mgs) =  psccid(mgs)   &
+     & + min(-schaci(mgs),0.0)   &
+     & + min(-schlaci(mgs),0.0)   &
+     & + min(-scsaci(mgs),0.0)
+
+      qcitmp = Max(0.0,qx(mgs,li) +   &
+     &   dtp*(pqcii(mgs)+pqcid(mgs)) )
+
+      IF ( qcitmp .gt. qxmin(li) ) then
+
+      IF ( ipconc .le. 0 ) THEN
+      
+      ccitmp = cnina(mgs)
+      IF ( cimn .gt. 1.0 ) THEN
+        cx(mgs,li) = Max(cimn,cx(mgs,li))
+      ENDIF
+      IF ( cimx .gt. 1.0 ) THEN
+        cx(mgs,li) = Min(cimx,cx(mgs,li))
+      ENDIF
+      IF ( itype1 .ge. 1 .or. itype2 .ge. 1 ) THEN 
+!        ccitmp = Max(ccitmp,qcitmp*rho0(mgs)/cimasx)
+        ccitmp = Min(ccitmp,qcitmp*rho0(mgs)/cimasn)
+      ENDIF
+      ccitmp = max(1.0,ccitmp)
+
+      ELSE
+ 
+       ccitmp = Max(0.001, cx(mgs,li) + dtp*(pccii(mgs)+pccid(mgs)) )
       
-      write(iunit,*)
-      write(iunit,*)  'Rain concentration'
-      write(iunit,*)  pcrwi(mgs) 
-      write(iunit,*)    crcnw(mgs)
-      write(iunit,*)    1-il5(mgs)
-      write(iunit,*)   -chmlr(mgs),-csmlr(mgs)
-      write(iunit,*)     -crshr(mgs)
-      write(iunit,*)  pcrwd(mgs) 
-      write(iunit,*)    il5(mgs)
-      write(iunit,*)   -ciacr(mgs),-crfrz(mgs) 
-      write(iunit,*)   -csacr(mgs),-chacr(mgs)
-      write(iunit,*)   +crcev(mgs)
-      write(iunit,*)   cracr(mgs)
-!      write(iunit,*)   -il5(mgs)*ciracr(mgs)
+      ENDIF ! ( ipconc .le. 0 )
+      
+      
+      cpci = (scx(mgs,li)   &
+     &   +dtp*( psccii(mgs)+psccid(mgs)   &
+     &         +psccimi(mgs)+psccimd(mgs)))/ccitmp
+      
+          IF ( Abs(cpci) .gt. scippmx .and.   &
+     &       ( psccii(mgs)+psccid(mgs) ) .ne. 0.0 .and.   &
+     &    Sign(1.0,scx(mgs,li)) .eq.   &
+     &        Sign(1.0,( psccii(mgs)+psccid(mgs) )) ) THEN
+          
+           cpci0 = Sign(scippmx,cpci)
+          
+           scfac = (cpci0*ccitmp - scx(mgs,li) -    &
+     &       dtp*(psccimi(mgs)+psccimd(mgs)))/   &
+     &              ( dtp*(psccii(mgs)+psccid(mgs)) )
+!           IF ( scfac .gt. 1.0 .or. scfac .lt. 0.0 ) THEN
+           IF ( scfac .gt. 1.0 ) THEN
+             write(iunit,*) 'OUCH: sccifac = ',scfac,   &
+     & dtp*(psccimi(mgs)+psccimd(mgs)),cpci,scx(mgs,li),ccitmp
+             write(0,*) 'OUCH: sccifac = ',scfac,   &
+     & dtp*(psccimi(mgs)+psccimd(mgs)),cpci,scx(mgs,li),ccitmp,   &
+     & kgs(mgs),temg(mgs)
+           ENDIF
+          scfac = Max(scfac,0.0)
+          scfac = Min(scfac,1.0)
+
+!        IF ( scfac .lt. 1.0 ) THEN
+!        write(iunit,*) 'LOOK: sccifac = ',scfac,cpci,scx(mgs,li),ccitmp,
+!     : kgs(mgs),temg(mgs)
+!        ENDIF
+         
+        ELSE
+          scfac = 1.0
+        ENDIF
+      ELSE
+       scfac = 0.0
+      ENDIF ! ( qcitmp .gt. qxmin(li) ) 
+
+      IF ( scfac .lt. 1.0 ) THEN
+
+
+       schaci(mgs) = scfac*schaci(mgs)
+       schlaci(mgs) = scfac*schlaci(mgs)
+       scsaci(mgs) = scfac*scsaci(mgs)
+
+      psccii(mgs) = 0.0
+      psccid(mgs) = 0.0
+      psccii(mgs) =  psccii(mgs)   &
+     & + max(-schaci(mgs),0.0)   &
+     & + max(-schlaci(mgs),0.0)   &
+     & + max(-scsaci(mgs),0.0)
+      psccid(mgs) =  psccid(mgs)   &
+     & + min(-schaci(mgs),0.0)   &
+     & + min(-schlaci(mgs),0.0)   &
+     & + min(-scsaci(mgs),0.0)
+      
+      ENDIF
+
+      end do
+      end if
+
+
+!
+!  ice spheres
+!
+      IF ( lis > 1 ) THEN
+      if ( ipelec .ge. 1 .and. itest .eq. 1 ) then
+      do mgs = 1,ngscnt
+      pscisi(mgs) = 0.0
+      pscisd(mgs) = 0.0
+      pscisi(mgs) =  pscisi(mgs)   &
+     & + max(-schacis(mgs),0.0)   &
+     & + max(-schlacis(mgs),0.0)   &
+     & + max(-scsacis(mgs),0.0)
+      pscisd(mgs) =  pscisd(mgs)   &
+     & + min(-schacis(mgs),0.0)   &
+     & + min(-schlacis(mgs),0.0)    &
+     & + min(-scsacis(mgs),0.0)
+
+      qcitmp = Max(0.0,qx(mgs,lis) +   &
+     &   dtp*(pqisi(mgs)+pqisd(mgs)) )
+
+      IF ( qcitmp .gt. qxmin(lis) ) then
+
+       ccitmp = Max(0.001, cx(mgs,lis) + dtp*(pcisi(mgs)+pcisd(mgs)) )
+      
+      cpci = (scx(mgs,lis)   &
+     &   +dtp*( pscisi(mgs)+pscisd(mgs)   &
+     &         +pscismi(mgs)+pscismd(mgs)))/ccitmp
+      
+          IF ( Abs(cpci) .gt. scippmx .and.   &
+     &       ( pscisi(mgs)+pscisd(mgs) ) .ne. 0.0 .and.   &
+     &    Sign(1.0,scx(mgs,lis)) .eq.   &
+     &        Sign(1.0,( pscisi(mgs)+pscisd(mgs) )) ) THEN
+          
+           cpci0 = Sign(scippmx,cpci)
+          
+           scfac = (cpci0*ccitmp - scx(mgs,lis) -    &
+     &       dtp*(pscismi(mgs)+pscismd(mgs)))/   &
+     &              ( dtp*(pscisi(mgs)+pscisd(mgs)) )
+!           IF ( scfac .gt. 1.0 .or. scfac .lt. 0.0 ) THEN
+           IF ( scfac .gt. 1.0 ) THEN
+             write(iunit,*) 'OUCH: sccifac = ',scfac,   &
+     & dtp*(pscismi(mgs)+pscismd(mgs)),cpci,scx(mgs,lis),ccitmp
+             write(0,*) 'OUCH: sccifac = ',scfac,   &
+     & dtp*(pscismi(mgs)+pscismd(mgs)),cpci,scx(mgs,lis),ccitmp,   &
+     & kgs(mgs),temg(mgs)
+           ENDIF
+          scfac = Max(scfac,0.0)
+          scfac = Min(scfac,1.0)
+
+!        IF ( scfac .lt. 1.0 ) THEN
+!        write(iunit,*) 'LOOK: sccifac = ',scfac,cpci,scx(mgs,li),ccitmp,
+!     : kgs(mgs),temg(mgs)
+!        ENDIF
+         
+        ELSE
+          scfac = 1.0
+        ENDIF
+      ELSE
+       scfac = 0.0
+      ENDIF ! ( qcitmp .gt. qxmin(li) ) 
+
+      IF ( scfac .lt. 1.0 ) THEN
+
+
+       schacis(mgs) = scfac*schacis(mgs)
+       schlacis(mgs) = scfac*schlacis(mgs)
+       scsacis(mgs) = scfac*scsacis(mgs)
+
+      pscisi(mgs) = 0.0
+      pscisd(mgs) = 0.0
+      pscisi(mgs) =  pscisi(mgs)   &
+     & + max(-schacis(mgs),0.0)   &
+     & + max(-schlacis(mgs),0.0)   &
+     & + max(-scsacis(mgs),0.0)
+      pscisd(mgs) =  pscisd(mgs)   &
+     & + min(-schacis(mgs),0.0)   &
+     & + min(-schlacis(mgs),0.0)   &
+     & + min(-scsacis(mgs),0.0)
+      
+      ENDIF
+
+      end do
+      end if
+      ENDIF ! lis > 1
 
 
-      write(iunit,*)
-      write(iunit,*)   'Snow'
-!
-      write(iunit,*)        il5(mgs)*qscni(mgs), qscnvi(mgs)
-      write(iunit,*)        il5(mgs)*qsaci(mgs)
-      write(iunit,*)        il5(mgs)*qrfrzs(mgs)
-      write(iunit,*)        il5(mgs)*qiacrs(mgs),il3(mgs)*(qiacrf(mgs)+qracif(mgs)),il3(mgs),qiacrf(mgs),qracif(mgs)
-      write(iunit,*)        il5(mgs)*qsdpv(mgs), qscev(mgs)
-      write(iunit,*)        qsacw(mgs)
-      write(iunit,*)        qsacr(mgs), qscnh(mgs)
-       write(iunit,*)        'pqswi = ',pqswi(mgs)
-      write(iunit,*)        -qhcns(mgs)
-      write(iunit,*)        -qracs(mgs)
-      write(iunit,*)        -qhacs(mgs)
-      write(iunit,*)        -qhlacs(mgs)
-      write(iunit,*)       (1-il5(mgs))*qsmlr(mgs)
-      write(iunit,*)       qsshr(mgs)
-!      write(iunit,*)       qsshrp(mgs)
-      write(iunit,*)       il5(mgs)*(qssbv(mgs))
-      write(iunit,*)       'pqswd = ', pqswd(mgs)
-      write(iunit,*)   -qracs(mgs)*(1-il2(mgs)) , qhacs(mgs) , qhlacs(mgs)   
-      write(iunit,*)   -qhcns(mgs)   
-      write(iunit,*)   +(1-il5(mgs))*qsmlr(mgs) , qsshr(mgs)
-      write(iunit,*)   (qssbv(mgs))   
-      write(iunit,*)   Min(0.0, qscev(mgs))  
-      write(iunit,*)   -qsmul(mgs)
-!
 !
-      write(iunit,*)
-      write(iunit,*)   'Graupel'
+!  snow
 !
-      write(iunit,*)   il5(mgs)*qrfrzf(mgs), qrfrzf(mgs) - qrfrz(mgs)
-      write(iunit,*)   il5(mgs)*qiacrf(mgs)
-      write(iunit,*)   il5(mgs)*qracif(mgs)
-      write(iunit,*)   qhcns(mgs)
-      write(iunit,*)   qhcni(mgs)
-      write(iunit,*)   il5(mgs)*(qhdpv(mgs))
-      write(iunit,*)   qhacr(mgs)
-      write(iunit,*)   qhacw(mgs)
-      write(iunit,*)   qhacs(mgs)
-      write(iunit,*)   qhaci(mgs)
-      write(iunit,*)   'pqhwi = ',pqhwi(mgs)
-      write(iunit,*)
-      write(iunit,*)   qhshr(mgs)
-      write(iunit,*)   (1-il5(mgs))*qhmlr(mgs)
-      write(iunit,*)   il5(mgs),qhsbv(mgs)
-      write(iunit,*)   -qhlcnh(mgs)
-      write(iunit,*)   -qhmul1(mgs)
-      write(iunit,*)   'pqhwd = ', pqhwd(mgs)
-      write(iunit,*)  'Concentration'
-      write(iunit,*)   pchwi(mgs),pchwd(mgs)
-      write(iunit,*)  crfrzf(mgs)
-      write(iunit,*)  chcns(mgs)
-      write(iunit,*)  ciacrf(mgs)
+      if ( ipelec .ge. 1 .and. itest .eq. 1 ) then
+      do mgs = 1,ngscnt
+      pscswi(mgs) = 0.0
+      pscswd(mgs) = 0.0
+
+      pscswi(mgs) =  pscswi(mgs)   &
+     & + max(scsaci(mgs),0.0)   &
+     & + max(scsacw(mgs),0.0)   &
+     & + max(scsacr(mgs),0.0)   &
+     & + max(-schacs(mgs),0.0)   &
+     & + max(-schlacs(mgs),0.0)  &
+     & + max(scsmlr(mgs),0.0)    &  !Drake
+     & + max(scsdep(mgs),0.0)    &  !Dong&Hallett
+     & - min(scsshr(mgs),0.0)       !Canosa & List 93
+      pscswd(mgs) =  pscswd(mgs)   &
+     & + min(scsaci(mgs),0.0)   &
+     & + min(scsacw(mgs),0.0)   &
+     & + min(scsacr(mgs),0.0)   &
+     & + min(-schacs(mgs),0.0)   &
+     & + min(-schlacs(mgs),0.0)  &
+!     > + min(-scfacs(mgs),0.0)
+     & + min(scsmlr(mgs),0.0)    &   !Drake, but always 0.? (since scsmlr >= 0)
+     & + min(scsdep(mgs),0.0)    &   !Dong&Hallett
+     & - max(scsshr(mgs),0.0)        !Canosa & List 93
+      end do
+      end if
 
 !
-      write(iunit,*)
-      write(iunit,*)   'Hail'
-!
-      write(iunit,*)   qhlcnh(mgs)
-      write(iunit,*)   il5(mgs)*(qhldpv(mgs))
-      write(iunit,*)   qhlacr(mgs)
-      write(iunit,*)   qhlacw(mgs)
-      write(iunit,*)   qhlacs(mgs)
-      write(iunit,*)   qhlaci(mgs)
-      write(iunit,*)   pqhli(mgs)
-      write(iunit,*)
-      write(iunit,*)   qhlshr(mgs)
-      write(iunit,*)   (1-il5(mgs))*qhlmlr(mgs)
-      write(iunit,*)   il5(mgs)*qhlsbv(mgs)
-      write(iunit,*)   pqhld(mgs)
-      write(iunit,*)  'Concentration'
-      write(iunit,*)   pchli(mgs),pchld(mgs)
-      write(iunit,*)  chlcnh(mgs)
+!  Graupel
 !
-!  Balance and checks for continuity.....within machine precision...
+      if ( ipelec .ge. 1 .and. itest .eq. 1 ) then
+      do mgs = 1,ngscnt
+      pschwi(mgs) = 0.0
+      pschwd(mgs) = 0.0
+
+      pschwi(mgs) =  pschwi(mgs)   &
+     & + max(schaci(mgs),0.0)   &
+!     > + max(schacip(mgs),0.0)   &
+!     > + max(schacir(mgs),0.0)   &
+     & + max(schacs(mgs),0.0)   &
+     & + max(schacw(mgs),0.0)   &
+     & + max(schacr(mgs),0.0)   &
+     & + max(schmlr(mgs),0.0)   & !Drake
+     & - min(schshr(mgs),0.0)     !Canosa & List 93
+      pschwd(mgs) =  pschwd(mgs)   &
+     & + min(schaci(mgs),0.0)   &
+!     > + min(schacip(mgs),0.0)   &
+!     > + min(schacir(mgs),0.0)   &
+     & + min(schacs(mgs),0.0)   &
+     & + min(schacw(mgs),0.0)   &
+     & + min(schacr(mgs),0.0)   &
+     & + min(schmlr(mgs),0.0)   & !Drake, but always 0.? (since schmlr >= 0)
+     & - max(schshr(mgs),0.0)     !Canosa & List 93
+      
+      IF ( lis > 1 ) THEN
+        pschwi(mgs) =  pschwi(mgs) + max(schacis(mgs),0.0)   
+        pschwd(mgs) =  pschwd(mgs) + min(schacis(mgs),0.0)
+      ENDIF
+      
+      end do
+      end if
+
 !
+!  Hail
 !
-      write(iunit,*) 'END OF OUTPUT OF SOURCE AND SINK'
-      write(iunit,*) 'PTOTAL',ptotal(mgs)
+      pschli(:) = 0.0
+      pschld(:) = 0.0
+
+      IF ( lhl .gt. 1 ) THEN
+      if ( ipelec .ge. 1 .and. itest .eq. 1 ) then
+      do mgs = 1,ngscnt
+
+      pschli(mgs) =  pschli(mgs)   &
+     & + max(schlaci(mgs),0.0)   &
+     & + max(schlacs(mgs),0.0)   &
+     & + max(schlacw(mgs),0.0)   &
+     & + max(schlacr(mgs),0.0)
+
+      pschld(mgs) =  pschld(mgs)   &
+     & + min(schlaci(mgs),0.0)   &
+     & + min(schlacs(mgs),0.0)   &
+     & + min(schlacw(mgs),0.0)   &
+     & + min(schlacr(mgs),0.0)
+
+      IF ( lis > 1 ) THEN
+        pschli(mgs) =  pschli(mgs) + max(schlacis(mgs),0.0)   
+        pschld(mgs) =  pschld(mgs) + min(schlacis(mgs),0.0)
+      ENDIF
+
+      end do
+      end if
+      ENDIF
+
 !
-      end if ! ptotal out of bounds or NaN
+! Ions
 !
+      pscpii(:) = 0.0 ! positive ion charge production here
+      pscpid(:) = 0.0 
+      pscnii(:) = 0.0 ! negative ion charge production here
+      pscnid(:) = 0.0
+      pscplii(:) = 0.0
+      pscplid(:) = 0.0
+      pscnlii(:) = 0.0
+      pscnlid(:) = 0.0      
+      
+      if ( ipelec .ge. 1 .and. itest .eq. 1 ) then
+      do mgs = 1,ngscnt
+       IF (largeion) THEN
+        ! Drop break-off from melting snow/graupel goes to large ions (Drake 1968)
+        ! Evaporating drops create large ions (Takahashi 1979)
+        ! Depositional growth through small ions (Dong & Hallett 1992)
+        ! Condensing drops remove small ions, but handled in ion attachment
+        pscnlii(mgs) =  pscnlii(mgs)  &
+     &               + min(fscrw(mgs),0.0)*max(-qrcev(mgs),0.0)  &
+     &               + min(fscsw(mgs),0.0)*max(-qscev(mgs),0.0)  &
+     &               + min(-schmlr(mgs),0.0)    &
+     &               + min(-scsmlr(mgs),0.0)
+        pscplii(mgs) =  pscplii(mgs)  &
+     &               + max(fscrw(mgs),0.0)*max(-qrcev(mgs),0.0)  &
+     &               + max(fscsw(mgs),0.0)*max(-qscev(mgs),0.0)  &
+     &               + max(-schmlr(mgs),0.0)    &
+     &               + max(-scsmlr(mgs),0.0)
+       ELSE
+        pscnii(mgs) =  pscnii(mgs)  &
+     &               - min(fscrw(mgs),0.0)*min(qrcev(mgs),0.0)  &
+     &               - min(fscsw(mgs),0.0)*min(qscev(mgs),0.0)  &
+     &               + min(-schmlr(mgs),0.0)    &
+     &               + min(-scsmlr(mgs),0.0)
+        pscpii(mgs) =  pscpii(mgs)  &
+     &               - max(fscrw(mgs),0.0)*min(qrcev(mgs),0.0)  &
+     &               - max(fscsw(mgs),0.0)*min(qscev(mgs),0.0)  &
+     &               + max(-schmlr(mgs),0.0)    &
+     &               + max(-scsmlr(mgs),0.0)
+      ENDIF
+
+        pscnid(mgs) =  pscnid(mgs)  &
+     &               - max(-scsdep(mgs),0.0)
+        pscpid(mgs) =  pscpid(mgs)  &
+     &               - min(-scsdep(mgs),0.0)
+
+
       end do
-!
 
-      end if ! ( nstep/12*12 .eq. nstep )
+      end if
 
 !
-!  latent heating from phase changes (except qcw, qci cond, and evap)
+!  continuity of space charge
 !
+      if ( ipelec .ge. 1 ) then
       do mgs = 1,ngscnt
-      IF ( warmonly < 0.5 ) THEN
-      pfrz(mgs) =    &
-     &  (1-il5(mgs))*   &
-     &  (qhmlr(mgs)+qsmlr(mgs)+qhlmlr(mgs))   & !+qhmlh(mgs))   &
-     &  +il5(mgs)*(qhfzh(mgs)+qsfzs(mgs)+qhlfzhl(mgs))   &
-     &  +il5(mgs)*(1-imixedphase)*(   &
-     &   qsacw(mgs)+qhacw(mgs) + qhlacw(mgs)   &
-     &  +qsacr(mgs)+qhacr(mgs) + qhlacr(mgs)   &
-     &  +qsshr(mgs)   &
-     &  +qhshr(mgs)   &
-     &  +qhlshr(mgs) +qrfrz(mgs)+qiacr(mgs)  &
-     &  )  &
-     &  +il5(mgs)*(qwfrz(mgs)    &
-     &  +qwctfz(mgs)+qiihr(mgs)   &
-     &  +qiacw(mgs))
-      pmlt(mgs) =    &
-     &  (1-il5(mgs))*   &
-     &  (qhmlr(mgs)+qsmlr(mgs)+qhlmlr(mgs))    !+qhmlh(mgs))   
-      ! NOTE: psub is sum of sublimation and deposition
-      psub(mgs) =    &
-     &   il5(mgs)*(   &
-     &  + qsdpv(mgs) + qhdpv(mgs)   &
-     &  + qhldpv(mgs)    &
-     &  + qidpv(mgs) + qisbv(mgs) )   &
-     &   + qssbv(mgs)  + qhsbv(mgs) + qhlsbv(mgs)   &
-     &  +il5(mgs)*(qiint(mgs))
-      pvap(mgs) =    &
-     &   qrcev(mgs) + qhcev(mgs) + qscev(mgs) + qhlcev(mgs)
-      pevap(mgs) =    &
-     &   Min(0.0,qrcev(mgs)) + Min(0.0,qhcev(mgs)) + Min(0.0,qscev(mgs)) + Min(0.0,qhlcev(mgs))
-      ! NOTE: pdep is the deposition part only
-      pdep(mgs) =    &
-     &   il5(mgs)*(   &
-     &  + qsdpv(mgs) + qhdpv(mgs)   &
-     &  + qhldpv(mgs)    &
-     &  + qidpv(mgs)  )  & 
-     &  +il5(mgs)*(qiint(mgs))
-      ELSEIF ( warmonly < 0.8 ) THEN
-      pfrz(mgs) =    &
-     &  (1-il5(mgs))*   &
-     &  (qhmlr(mgs)+qhlmlr(mgs))   & !+qhmlh(mgs))   &
-     &  +il5(mgs)*(qhfzh(mgs)+qhlfzhl(mgs))   &
-     &  +il5(mgs)*(   &
-     &  +qhshr(mgs)   &
-     &  +qhlshr(mgs)   &
-     &  +qrfrz(mgs)+qwfrz(mgs)   &
-     &  +qwctfz(mgs)+qiihr(mgs)   &
-     &  +qiacw(mgs)                &
-     & +qhacw(mgs) + qhlacw(mgs)   &
-     & +qhacr(mgs) + qhlacr(mgs)  ) 
-      psub(mgs) =  0.0 +  &
-     &   il5(mgs)*(   &
-     &  + qhdpv(mgs)   &
-     &  + qhldpv(mgs)    &
-     &  + qidpv(mgs) + qisbv(mgs) )   &
-     &  +il5(mgs)*(qiint(mgs))
-      pvap(mgs) =    &
-     &   qrcev(mgs) + qhcev(mgs) + qhlcev(mgs) ! + qscev(mgs) 
-      ELSE
-      pfrz(mgs) = 0.0
-      psub(mgs) = 0.0
-      pvap(mgs) = qrcev(mgs)
-      ENDIF ! warmonly
-      ptem(mgs) =    &
-     &  (1./pi0(mgs))*   &
-     &  (felfcp(mgs)*pfrz(mgs)   &
-     &  +felscp(mgs)*psub(mgs)    &
-     &  +felvcp(mgs)*pvap(mgs))
-      thetap(mgs) = thetap(mgs) + dtp*ptem(mgs)
-      IF ( eqtset > 2 ) THEN
-        pipert(mgs) = pipert(mgs) + (felfpi(mgs)*pfrz(mgs)   &
-     &  +felspi(mgs)*psub(mgs)    &
-     &  +felvpi(mgs)*pvap(mgs))*dtp
+      psctot(mgs) = psccwi(mgs) +psccwd(mgs) +   &
+     &              psccii(mgs) +psccid(mgs) +   &
+     &              pscrwi(mgs) +pscrwd(mgs) +   &
+     &              pscswi(mgs) +pscswd(mgs) +   &
+     &              pschwi(mgs) +pschwd(mgs) +       &
+     &              pschli(mgs) +pschld(mgs) +       &
+     &              pscpii(mgs) +pscpid(mgs) +       &
+     &              pscnii(mgs) +pscnid(mgs) +       &
+     &              pscplii(mgs) +pscplid(mgs) +       &
+     &              pscnlii(mgs) +pscnlid(mgs) +       &
+!
+     &              psccwmi(mgs) +psccwmd(mgs) +   &
+     &              psccimi(mgs) +psccimd(mgs) +   &
+     &              pscrwmi(mgs) +pscrwmd(mgs) +   &
+     &              pscswmi(mgs) +pscswmd(mgs) +   &
+     &              pschwmi(mgs) +pschwmd(mgs) +     &
+     &              pschlmi(mgs) +pschlmd(mgs)
+      IF ( .not. ( psctot(mgs) .gt. -1. .and. psctot(mgs) .lt. 1.0 ) .or.    &
+     &      Abs( psctot(mgs) ) .gt. esctot .or. Abs(pschwmi(mgs)) > 0.1 )  THEN
+
+!        write(iunit,*) 'yikes! psctot = ',psctot(mgs),'and esctot =',esctot,'at',mgs
+
+      IF ( .not. ( psctot(mgs) .gt. -1.0 .and. psctot(mgs) .lt. 1.0 ) .or.  &
+            Abs( psctot(mgs) ) .gt. 1.0 ) THEN
+        write(0,*)  psccwi(mgs), psccwd(mgs)
+        write(0,*)  psccii(mgs), psccid(mgs)
+        write(0,*)  pscrwi(mgs), pscrwd(mgs)
+        write(0,*)  pscswi(mgs), pscswd(mgs)
+        write(0,*)  pschwi(mgs), pschwd(mgs)
+        write(0,*)  pschli(mgs), pschld(mgs)
+        write(0,*)  pscpii(mgs) ,pscpid(mgs)
+        write(0,*)  pscnii(mgs) ,pscnid(mgs)
+        write(0,*)
+        write(0,*)  psccwmi(mgs), psccwmd(mgs)
+        write(0,*)  psccimi(mgs), psccimd(mgs)
+        write(0,*)  pscrwmi(mgs), pscrwmd(mgs)
+        write(0,*)  pscswmi(mgs), pscswmd(mgs)
+        write(0,*)  pschwmi(mgs), pschwmd(mgs)
+        write(0,*)  pschlmi(mgs), pschlmd(mgs)
+
+      DO il = lc,lhab
+       write(0,*) 'il,scx,qx = ',il,scx(mgs,il),qx(mgs,il)
+      ENDDO
+
+       STOP
+
+       ENDIF
       ENDIF
+
       end do
+      
+      ENDIF
+
+!      do mgs = 1,ngscnt
+!        psctotmx = Max( psctotmx, psctot(mgs) )
+!        psctotmn = Min( psctotmn, psctot(mgs) )
+!      end do
+
+! compute space charge arrays:
+
+    if (ipelec.ge.1) then
+
+     do mgs = 1,ngscnt
+
+      DO il = lc,lhl
+!      IF ( .not. (scx(mgs,il) > -1.e-6 .and. scx(mgs,il) < 1.e-6 ) .or. scx(mgs,il) > 1.e-9 ) THEN ! DEBUGTED
+      IF ( .not. (scx(mgs,il) > -1.e-6 .and. scx(mgs,il) < 1.e-6 ) ) THEN 
+        write(0,*) 'Problem1a with scx il = ',il,scx(mgs,il),mgs,igs(mgs),kgs(mgs),jyslab
+        write(0,*) 'psccw: ',psccwi(mgs),psccwd(mgs),psccwmi(mgs),psccwmd(mgs)
+        STOP
+      ENDIF
+      ENDDO
+
+     scx(mgs,lc) = scx(mgs,lc) +   &
+    &   dtp*(psccwi(mgs)+psccwd(mgs)+psccwmi(mgs)+psccwmd(mgs))
+     scx(mgs,li) = scx(mgs,li) +   &
+    &   dtp*(psccii(mgs)+psccid(mgs)+psccimi(mgs)+psccimd(mgs))
+     scx(mgs,lr) = scx(mgs,lr) +   &
+    &   dtp*(pscrwi(mgs)+pscrwd(mgs)+pscrwmi(mgs)+pscrwmd(mgs))
+     scx(mgs,ls) = scx(mgs,ls) +   &
+    &   dtp*(pscswi(mgs)+pscswd(mgs)+pscswmi(mgs)+pscswmd(mgs))
+     scx(mgs,lh) = scx(mgs,lh) +   &
+    &   dtp*(pschwi(mgs)+pschwd(mgs)+pschwmi(mgs)+pschwmd(mgs))
+
+
+     IF ( lhl .gt. 1 ) THEN
+     scx(mgs,lhl) = scx(mgs,lhl) +   &
+    &   dtp*(pschli(mgs)+pschld(mgs)+pschlmi(mgs)+pschlmd(mgs))
+     ENDIF
+
+      cionp(mgs) = cionp(mgs) +  &
+     &   dtp*eci*(pscpii(mgs)+pscpid(mgs)) ! #/m3 * C / C/m3. ! each ion has electron charge
 
+      cionn(mgs) = cionn(mgs) -  &
+     &   dtp*eci*(pscnii(mgs)+pscnid(mgs))
+
+      if ( largeion ) then
+      clionp(mgs) = clionp(mgs) +  &
+     &   dtp*eci*(pscplii(mgs)+pscplid(mgs))
+      clionn(mgs) = clionn(mgs) -  &
+     &   dtp*eci*(pscnlii(mgs)+pscnlid(mgs))
+      endif 
+
+
+     end do
+     end if ! (ipelec .ge. 1 )
+    
 
 
 
@@ -17155,17 +22242,11 @@ subroutine nssl_2mom_gs   &
 
 
       IF ( wrfchem_flag > 0 ) THEN
-! 20130917 acd_mb_washout start
         DO mgs = 1,ngscnt
-         evapprod2d(igs(mgs),kgs(mgs)) = -(qrcev(mgs) + qssbv(mgs)  + qhsbv(mgs) + qhlsbv(mgs)) ! - PRE(K) - EVPMS(K) - EVPMG(K)
+         evapprod2d(igs(mgs),kgs(mgs)) = -(qrcev(mgs) + qssbv(mgs)  + qhsbv(mgs) + qhlsbv(mgs)) 
          rainprod2d(igs(mgs),kgs(mgs)) = qrcnw(mgs) + qracw(mgs) + qsacw(mgs) + qhacw(mgs) + qhlacw(mgs) + &
-                                         qraci(mgs) + qsaci(mgs) + qhaci(mgs) + qhlaci(mgs) + qscni(mgs)     ! PRA(K) + PRC(K) + tqimelt(K)
-!         evapprod(k) = - PRE(K) - EPRDS(K) - EPRDG(K) 
-!         rainprod(k) = PRA(K) + PRC(K) + PSACWS(K) + PSACWG(K) + PGSACW(K) & 
-!                       + PRAI(K) + PRCI(K) + PRACI(K) + PRACIS(K) + &
-!                       + PRDS(K) + PRDG(K)
+                                         qraci(mgs) + qsaci(mgs) + qhaci(mgs) + qhlaci(mgs) + qscni(mgs)
         ENDDO
-! 20130917 acd_mb_washout end
       ENDIF
 !
 !
@@ -17202,18 +22283,18 @@ subroutine nssl_2mom_gs   &
       if( temg(mgs) .gt. tfr .and.   &
      &    qitmp(mgs) .gt. 0.0 ) then
       qx(mgs,lc) = qx(mgs,lc) + qitmp(mgs)
-!      pfrz(mgs) = pfrz(mgs) - qitmp(mgs)/dtp
+!      pfrz(mgs) = pfrz(mgs) - qitmp(mgs)*dtpinv
       ptem(mgs) =  ptem(mgs) +   &
      &  (1./pi0(mgs))*   &
-     &  felfcp(mgs)*(- qitmp(mgs)/dtp)  
+     &  felfcp(mgs)*(- qitmp(mgs)*dtpinv)  
       IF ( eqtset > 2 ) THEN
         pipert(mgs) = pipert(mgs) - (felfpi(mgs)*qitmp(mgs))
       ENDIF
-      pmlt(mgs) = pmlt(mgs) - qitmp(mgs)/dtp
+      pmlt(mgs) = pmlt(mgs) - qitmp(mgs)*dtpinv
       scx(mgs,lc) = scx(mgs,lc) + scx(mgs,li)
       thetap(mgs) = thetap(mgs) -   &
      &  fcc3(mgs)*qitmp(mgs)
-      ptimlw(mgs) = -fcc3(mgs)*qitmp(mgs)/dtp
+      ptimlw(mgs) = -fcc3(mgs)*qitmp(mgs)*dtpinv
       cx(mgs,lc) = cx(mgs,lc) + cx(mgs,li)
       qx(mgs,li) = 0.0
       cx(mgs,li) = 0.0
@@ -17228,7 +22309,7 @@ subroutine nssl_2mom_gs   &
 
 
 !      do mgs = 1,ngscnt
-!      qimlw(mgs) = (qcwtmp(mgs)-qx(mgs,lc))/dtp
+!      qimlw(mgs) = (qcwtmp(mgs)-qx(mgs,lc))*dtpinv
 !      end do
 !
 !  homogeneous freezing of cloud water
@@ -17282,10 +22363,10 @@ subroutine nssl_2mom_gs   &
       ELSE
         qx(mgs,li) = qx(mgs,li) + qtmp ! qx(mgs,lc)
       ENDIF
-      pfrz(mgs) = pfrz(mgs) + qtmp/dtp
+      pfrz(mgs) = pfrz(mgs) + qtmp*dtpinv
       ptem(mgs) =  ptem(mgs) +   &
      &  (1./pi0(mgs))*   &
-     &  felfcp(mgs)*(qtmp/dtp)  
+     &  felfcp(mgs)*(qtmp*dtpinv)  
 
       IF ( eqtset > 2 ) THEN
         pipert(mgs) = pipert(mgs) + felfpi(mgs)*qtmp
@@ -17322,12 +22403,12 @@ subroutine nssl_2mom_gs   &
 !      scx(mgs,li) = scx(mgs,li) + scx(mgs,lc)
       scx(mgs,li) = scx(mgs,li) + sctmp
 !      thetap(mgs) = thetap(mgs) + fcc3(mgs)*qx(mgs,lc)
-!      ptwfzi(mgs) = fcc3(mgs)*qx(mgs,lc)/dtp
+!      ptwfzi(mgs) = fcc3(mgs)*qx(mgs,lc)*dtpinv
 !      qx(mgs,lc) = 0.0
 !      cx(mgs,lc) = 0.0
 !      scx(mgs,lc) = 0.0
       thetap(mgs) = thetap(mgs) + fcc3(mgs)*qtmp
-      ptwfzi(mgs) = fcc3(mgs)*qtmp/dtp
+      ptwfzi(mgs) = fcc3(mgs)*qtmp*dtpinv
       qx(mgs,lc) = qx(mgs,lc) - qtmp
       cx(mgs,lc) = cx(mgs,lc) - ctmp
       scx(mgs,lc) = scx(mgs,lc) - sctmp
@@ -17337,7 +22418,7 @@ subroutine nssl_2mom_gs   &
       ENDIF ! warmonly
 !
 !      do mgs = 1,ngscnt
-!      qwfzi(mgs) = (qcwtmp(mgs)-qx(mgs,lc))/dtp   ! Not used?? (ERM)
+!      qwfzi(mgs) = (qcwtmp(mgs)-qx(mgs,lc))*dtpinv   ! Not used?? (ERM)
 !      end do
 !
 !  reset temporaries for cloud particles and vapor
@@ -17624,7 +22705,7 @@ subroutine nssl_2mom_gs   &
      &   qss(mgs) = (qx(mgs,lc)*qvs(mgs) + qitmp(mgs)*qis(mgs)) /   &
      &   (qx(mgs,lc) + qitmp(mgs))
       end if
-!      pceds(mgs) = (thetap(mgs) - thsave(mgs))/dtp
+!      pceds(mgs) = (thetap(mgs) - thsave(mgs))*dtpinv
 !      write(iunit,*) 'satadj2: mgs,iter = ',mgs,itertd,dqwv(mgs),qss(mgs),qx(mgs,lv),qx(mgs,lc)
       end do
 !
@@ -17658,6 +22739,38 @@ subroutine nssl_2mom_gs   &
 
 
 
+      IF ( ipelec >= 1 ) THEN
+
+      DO mgs = 1,ngscnt
+        t1(igs(mgs),jy,kgs(mgs)) = scsaci(mgs)
+        t2(igs(mgs),jy,kgs(mgs)) = schacs(mgs)
+        t3(igs(mgs),jy,kgs(mgs)) = schaci(mgs) + schacis(mgs)
+        t4(igs(mgs),jy,kgs(mgs)) = scsacw(mgs)
+        t5(igs(mgs),jy,kgs(mgs)) = schacw(mgs) + schlacw(mgs)
+        t6(igs(mgs),jy,kgs(mgs)) = schlacs(mgs)
+        t8(igs(mgs),jy,kgs(mgs)) = schlaci(mgs) + schlacis(mgs)
+!        IF ( igs(mgs) == 43 .and. kgs(mgs) == 47 ) THEN
+!          write(0,*) 'scsaci(mgs)',scsaci(mgs)
+!          write(0,*) 'schacs(mgs)',schacs(mgs)
+!          write(0,*) 'schaci(mgs)',schaci(mgs)
+!          write(0,*) 'scsacw(mgs)',scsacw(mgs)
+!          write(0,*) 'schacw(mgs) + schlacw(mgs)',schacw(mgs) + schlacw(mgs)
+!          write(0,*) 'schlacs(mgs)',schlacs(mgs)
+!          write(0,*) 'schlaci(mgs)',schlaci(mgs)
+!        ENDIF
+!        t1(igs(mgs),jy,kgs(mgs)) = 0
+!        t2(igs(mgs),jy,kgs(mgs)) = 0
+!        t3(igs(mgs),jy,kgs(mgs)) = 0
+!        t4(igs(mgs),jy,kgs(mgs)) = 0
+!        t5(igs(mgs),jy,kgs(mgs)) = 0
+!        t6(igs(mgs),jy,kgs(mgs)) = 0
+!        t8(igs(mgs),jy,kgs(mgs)) = 0
+
+      ENDDO
+
+      ENDIF
+
+
       if (ndebug .gt. 0 ) write(0,*) 'gs 11'
 
       do mgs = 1,ngscnt
@@ -17807,6 +22920,97 @@ subroutine nssl_2mom_gs   &
 
 
 
+! put scx arrays back into an array
+      IF ( lscw .gt. 1 .and. ipelec >= 1 ) THEN
+      do mgs = 1,ngscnt
+!     total space charge ! dont forget to repass array back to AN() as this is used in the driver
+         an(igs(mgs),jy,kgs(mgs),lscpi) = cionp(mgs)
+         an(igs(mgs),jy,kgs(mgs),lscni) = cionn(mgs)
+
+      if ( largeion ) then
+
+       if ( clionp(mgs) .gt. clionpmx ) then
+        an(igs(mgs),jy,kgs(mgs),lscpli) = clionpmx
+        an(igs(mgs),jy,kgs(mgs),lscpi)  = an(igs(mgs),jy,kgs(mgs),lscpi) + ( clionp(mgs) - clionpmx )
+       else
+        an(igs(mgs),jy,kgs(mgs),lscpli) = clionp(mgs)
+       endif
+       if ( clionn(mgs) .gt. clionnmx ) then
+        an(igs(mgs),jy,kgs(mgs),lscnli) = clionnmx
+        an(igs(mgs),jy,kgs(mgs),lscni)  = an(igs(mgs),jy,kgs(mgs),lscni) + ( clionn(mgs) - clionnmx )
+       else
+        an(igs(mgs),jy,kgs(mgs),lscnli) = clionn(mgs)
+       endif
+
+      end if
+
+      ENDDO
+      DO il = lc,lhab
+      do mgs = 1,ngscnt
+        tmp = an(igs(mgs),jy,kgs(mgs),lsc(il))
+        an(igs(mgs),jy,kgs(mgs),lsc(il)) = scx(mgs,il)
+!        IF ( .not. (scx(mgs,il) > -1.e-6 .and. scx(mgs,il) < 1.e-6 ) ) THEN
+!        IF ( Abs (scx(mgs,il) ) > 1000.e-9 .or. Abs(scx(mgs,il)) > 1.e-9 ) THEN ! DEBUGTED
+        IF ( Abs (scx(mgs,il) ) > 1000.e-9  ) THEN
+          write(0,*) 'Problem2 with scx il = ',il,scx(mgs,il),tmp,mgs,tmp-scx(mgs,il),(tmp-scx(mgs,il))*dtpinv
+          write(0,*) 'temper = ',temcg(mgs)
+          write(0,*) 'qx,cx = ',qx(mgs,il),cx(mgs,il)
+        write(0,*)  psccwi(mgs), psccwd(mgs)
+        write(0,*)  psccii(mgs), psccid(mgs)
+        write(0,*)  pscrwi(mgs), pscrwd(mgs)
+        write(0,*)  pscswi(mgs), pscswd(mgs)
+        write(0,*)  pschwi(mgs), pschwd(mgs)
+        write(0,*)  pschli(mgs), pschld(mgs)
+        write(0,*)  pscpii(mgs) ,pscpid(mgs)
+        write(0,*)  pscnii(mgs) ,pscnid(mgs)
+        write(0,*)
+        write(0,*)  psccwmi(mgs), psccwmd(mgs)
+        write(0,*)  psccimi(mgs), psccimd(mgs)
+        write(0,*)  pscrwmi(mgs), pscrwmd(mgs)
+        write(0,*)  pscswmi(mgs), pscswmd(mgs)
+        write(0,*)  pschwmi(mgs), pschwmd(mgs)
+        write(0,*)  pschlmi(mgs), pschlmd(mgs)
+
+        write(0,*) 'ci: tot, parts:', dtp*(psccii(mgs)+psccid(mgs)+psccimi(mgs)+psccimd(mgs)),dtp*psccii(mgs),dtp*psccid(mgs),dtp*psccimi(mgs),dtp*psccimd(mgs)
+
+        write(0,*) 'rain: tot, parts:', dtp*(pscrwi(mgs)+pscrwd(mgs)+pscrwmi(mgs)+pscrwmd(mgs)), dtp*pscrwi(mgs), dtp*pscrwd(mgs), dtp*pscrwmi(mgs), dtp*pscrwmd(mgs)
+
+     write(0,*) 'qs,qsold: ',qx(mgs,ls), qx(mgs,ls) - dtp*(pqswi(mgs)+pqswd(mgs))
+     write(0,*) 'cs,csold: ',cx(mgs,ls), cx(mgs,ls) - dtp*(pcswi(mgs)+pcswd(mgs))
+
+     
+     write(0,*)  'pscswmd(mgs)',fscsw(mgs),fscsw2(mgs)
+     write(0,*) - fscsw(mgs)*qhacs(mgs), - fscsw(mgs)*qhlacs(mgs)
+     write(0,*)  +(1-il5(mgs))*fscsw(mgs)*qsmlr(mgs)*mixedphasefac , fscrw(mgs)*qsshr(mgs)
+     write(0,*)  -fscsw(mgs)*qsmul(mgs)
+     write(0,*) qhacs(mgs), qhlacs(mgs),qsmlr(mgs),qsshr(mgs) ,qsmul(mgs), mixedphasefac
+     write(0,*)
+     write(0,*)  fschw(mgs),fscsw(mgs),fschl(mgs)
+     write(0,*)  fsccw(mgs),fscci(mgs),fscrw(mgs)
+
+     write(0,*)  'fscsw2(mgs)*qsshr(mgs), ', fscsw2(mgs)*qsshr(mgs)
+
+      tmp =  qx(mgs,ls) + dtp*(pqswi(mgs) + pqswd(mgs) - qsshr(mgs)) ! should this add back the shed rain mass? probably!
+      chgtmp = 0.0
+      IF ( tmp > qxmin(ls) .and. qsshr(mgs) < 0.0 ) THEN
+        chgtmp = scx(mgs,ls) + dtp*(pscswmi(mgs) - pscswmd(mgs))
+       ! fscsw2(mgs) = chgtmp/tmp
+       ! pscswmd(mgs) =  pscswmd(mgs) + fscsw2(mgs)*qsshr(mgs)
+      ENDIF
+      write(0,*) 'tmp,chgtmp, fscsw2, qsshr,fscsw2(mgs)*qsshr(mgs) ',tmp,chgtmp,fscsw2(mgs), qsshr(mgs), fscsw2(mgs)*qsshr(mgs)
+
+
+        STOP
+        ENDIF
+      end do
+      ENDDO
+
+      ENDIF
+
+!      write(0,*) 'SCW',MAXVAL(scx(:,lc)),MAXLOC(scx(:,lc)),MINVAL(scx(:,lc)),MINLOC(scx(:,lc))
+
+
+
       if (ndebug .gt. 0 ) write(0,*) 'gs 13'
 
  9998 continue
diff --git a/phys/module_mp_nudge_light.F b/phys/module_mp_nudge_light.F
new file mode 100644
index 0000000000..bb288af475
--- /dev/null
+++ b/phys/module_mp_nudge_light.F
@@ -0,0 +1,115 @@
+       MODULE module_mp_nudge_light
+
+!      lightning assimilation subroutine - Fierro et al. (2012, MWR)
+
+#ifdef DM_PARALLEL
+         USE module_dm, ONLY : &
+            local_communicator, mytask, ntasks, ntasks_x, ntasks_y,mytask_x, mytask_y
+#endif
+
+        CONTAINS
+
+         SUBROUTINE nudge_light(nx,ny,nz,qg,qv,gridlight,temp,press,dz,dx,dy,dt)
+
+          implicit none
+#ifdef DM_PARALLEL
+        INCLUDE 'mpif.h'
+#endif
+
+         real ::  RH= 0.95 ! minimum RH for nudging: larger RH -> larger grid volume activated for nudging
+         real ::  QG_TRESH=0.003 ! threshold nudging on graupel mass to further constraint nudging volume.
+         real ::  t_bot=273.15 !top of nudging layer
+         real ::  t_up= 253.15 ! bottom of nudging layer
+         real ::  MAX_RH= 1.02 
+         real ::  BB= 0.25 ! controls the slope of TANH curve
+         real ::  CC= 0.25 ! controls spacing of QG curves in eq 1 o
+         real ::  LVo=2.501E+06 ! Latent heat of vaporization - assume const
+         real ::  Rv=461.5
+         real ::  To=273.15
+         real ::  ep1=0.6222
+         real ::  ep2=611.73 ! in Pa
+         real ::  const=2.2 ! do not change
+
+         real AA ! controls how much % is increased above lowest threshold (set by RH) 
+
+          integer i,j,k,nx,ny,nz
+          real  gridlight(nx,ny)
+          real qg(nx,nz,ny)
+          real qv(nx,nz,ny)
+          real temp(nx,nz,ny) ! in deg Kelvin
+          real press(nx,nz,ny) ! in Pa
+          real qvsat ! in kg/kg
+          real esw ! in Pa
+          real angle
+          real nudge_coeff
+
+          real, dimension(nx,nz,ny), intent(in):: dz
+          real, intent(IN) :: dx,dy,dt
+          
+          double precision :: dv, total_vapor, tmp, total_vapor_out
+          integer mpi_error_code
+
+         if (maxval(gridlight).gt.0.) then
+         write(0,*) 'MAXVAL GRIDLIGHT',maxval(gridlight)
+!         write(0,*) 'MAXVAL ARRAYS',maxval(temp),maxval(press),maxval(qg),maxval(qv)
+!         write(0,*) 'dx,dy,dz',dx,dy,maxval(dz)
+         endif
+
+         AA = MAX_RH - RH
+        
+        nudge_coeff = 1/dt ! direct insertion as in Fierro et al. (2012).
+
+        total_vapor = 0.
+        
+        do i=1,nx
+           do k=1,nz
+              do j=1,ny
+              
+
+              dv = dx*dy*dz(i,k,j)
+
+!          for QVS: Clausius Clapeyron Equation (constant Latent Heat of
+!          Vaporization Lv) - Taken from Rogers and Yau (1989)
+
+           qvsat=(ep1/press(i,k,j))*(ep2*exp( (LVo/Rv)*((1./To)-(1./(temp(i,k,j)) ) ) ) )
+
+           angle=(1000.*qg(i,k,j))**const
+
+          if (gridlight(i,j).ge.1.) then
+          if (qg(i,k,j).lt.QG_TRESH) then
+          if (qv(i,k,j).lt.RH*qvsat) then 
+            if (temp(i,k,j).lt.t_bot.and.temp(i,k,j).gt.t_up) then 
+
+            tmp = RH*qvsat+AA*qvsat*tanh(BB*gridlight(i,j))*(1.-tanh(CC*angle))
+            
+            total_vapor = total_vapor + Min(1.,nudge_coeff*dt)*(tmp-qv(i,k,j))*dv
+
+            qv(i,k,j) = qv(i,k,j) + Min(1.,nudge_coeff*dt)*(tmp -qv(i,k,j))
+ 
+            endif
+          endif
+          endif
+          endif
+
+              enddo
+            enddo
+          enddo
+
+#ifdef DM_PARALLEL
+      CALL MPI_Reduce(total_vapor, total_vapor_out, 1, MPI_DOUBLE_PRECISION, MPI_SUM, 0, local_communicator, mpi_error_code)
+
+      
+      
+      IF ( mytask == 0 ) THEN
+         total_vapor = total_vapor_out
+#endif
+       write(0,*) 'Total vapor mass added: ',total_vapor
+       
+#ifdef DM_PARALLEL
+       ENDIF
+#endif
+       
+       
+        RETURN
+        END SUBROUTINE nudge_light
+        END MODULE module_mp_nudge_light
diff --git a/phys/module_physics_init.F b/phys/module_physics_init.F
index e84d73e6d4..63afef722c 100644
--- a/phys/module_physics_init.F
+++ b/phys/module_physics_init.F
@@ -225,6 +225,8 @@ SUBROUTINE phy_init ( id, config_flags, DT, restart, zfull, zhalf,     &
                          ,G_URB2D_mosaic,RN_URB2D_mosaic                                                      & ! danli mosaic 
                          ,TS_URB2D_mosaic                                                                     & ! danli mosaic 
                          ,TS_RUL2D_mosaic                                                                     & ! danli mosaic
+!                         ,qnn_curr   &
+!                         , F_QNN   &
                          )
 
 !-----------------------------------------------------------------
@@ -486,6 +488,7 @@ SUBROUTINE phy_init ( id, config_flags, DT, restart, zfull, zhalf,     &
    REAL,    OPTIONAL, DIMENSION(ims:ime,5,jms:jme), INTENT(IN ) :: CROPTYPE
 
 !   REAL, DIMENSION( ims:ime, kms:kme, jms:jme ),  OPTIONAL,  INTENT(INOUT ) ::   qnn_curr
+!   LOGICAL, OPTIONAL, intent(in) :: f_qnn
 
    INTEGER , OPTIONAL,  INTENT(OUT) :: STEPWTD
    REAL , OPTIONAL, INTENT(IN) :: WTDDT
@@ -1030,7 +1033,29 @@ SUBROUTINE phy_init ( id, config_flags, DT, restart, zfull, zhalf,     &
                 its, ite, jts, jte, kts, kte                       )
    ENDIF
 
-  ENDIF !}
+!   IF ( present( f_qnn ) ) THEN
+   IF ( f_qnn ) THEN
+! Initialize simple ccn field
+     IF ( scalar((ite+itf)/2,(kte+ktf)/2,(jte+jtf)/2,p_qnn) < 1.0 ) THEN ! initialize ccn if not already done
+       DO j=jts,jtf
+         DO k=kts,ktf
+          DO i=its,itf
+           IF ( config_flags%mp_physics == wdm5scheme .or. config_flags%mp_physics == wdm6scheme ) THEN
+             scalar(i,k,j,p_qnn) = ccn_conc
+           ELSEIF ( config_flags%mp_physics == nssl_2momccn ) THEN
+             scalar(i,k,j,p_qnn) = nssl_cccn/1.225
+             ccn_conc =  nssl_cccn/1.225
+           ELSE
+             scalar(i,k,j,p_qnn) = ccn_conc
+           ENDIF
+          ENDDO
+         ENDDO
+        ENDDO
+      ENDIF
+   ENDIF
+   ENDIF
+   
+!  ENDIF !}
 
 !-- convert zfull and zhalf to sigma values for ra_init (Eta CO2 needs these)
 !-- zfull/zhalf may be either zeta or eta
@@ -3732,7 +3757,7 @@ SUBROUTINE mp_init(RAINNC,SNOWNC,GRAUPELNC,config_flags,restart,warm_rain,
      SELECT CASE(config_flags%mp_physics)
      CASE (NSSL_2MOM,NSSL_2MOMCCN)
        IF ( config_flags%elec_physics > 0 ) THEN
-         nssl_ipelec_tmp = nssl_ipelec
+         nssl_ipelec_tmp = Max(1,nssl_ipelec)
        ELSE
          nssl_ipelec_tmp = 0.0
        ENDIF
diff --git a/share/module_check_a_mundo.F b/share/module_check_a_mundo.F
index a4ca7d1f6a..b1d44f3a1a 100644
--- a/share/module_check_a_mundo.F
+++ b/share/module_check_a_mundo.F
@@ -164,15 +164,15 @@ SUBROUTINE check_nml_consistency
 #endif
 
 !-----------------------------------------------------------------------
-! Check that NSSL microphysics is not allowed for WRF-NMM run 
+! Check that NSSL microphysics is not allowed for WRF-NMM run
 !-----------------------------------------------------------------------
-#if (NMM_CORE == 1) || (HWRF == 1) 
+#if (NMM_CORE == 1) || (HWRF == 1)
       DO i = 1, model_config_rec % max_dom
          IF ( model_config_rec % mp_physics(i) == nssl_2mom .OR. &
-              model_config_rec % mp_physics(i) == nssl_2momccn .OR. & 
-              model_config_rec % mp_physics(i) == nssl_1mom .OR. & 
-              model_config_rec % mp_physics(i) == nssl_1momlfo .OR. & 
-              model_config_rec % mp_physics(i) == nssl_2momg ) THEN 
+              model_config_rec % mp_physics(i) == nssl_2momccn .OR. &
+              model_config_rec % mp_physics(i) == nssl_1mom .OR. &
+              model_config_rec % mp_physics(i) == nssl_1momlfo .OR. &
+              model_config_rec % mp_physics(i) == nssl_2momg ) THEN
             wrf_err_message = '--- ERROR: Chosen microphysics scheme cannot run with WRF-NMM '
             CALL wrf_message ( wrf_err_message )
             wrf_err_message = '--- Fix mp_physics in namelist.input '
@@ -1949,6 +1949,41 @@ SUBROUTINE set_physics_rconfigs
          END IF
       ENDDO
 
+!-----------------------------------------------------------------------
+! Check for electrification options with NSSL scheme
+!-----------------------------------------------------------------------
+#if ( (EM_CORE == 1) && (WRF_ELEC == 1) )
+     IF ( model_config_rec % elec_physics > 0 ) THEN
+      DO i = 1, model_config_rec % max_dom
+       IF ( .not. ( model_config_rec % mp_physics(i) .EQ. NSSL_2MOM  .or. &
+                    model_config_rec % mp_physics(i) .EQ. NSSL_2MOMCCN ) ) THEN
+
+         wrf_err_message = '--- NOTE: Electrification only works with NSSL_2MOM or NSSL_2MOMCCN  ' 
+         CALL wrf_message ( wrf_err_message )
+!         model_config_rec % elec_physics = 0
+!         CALL wrf_error_fatal ( wrf_err_message )
+        ENDIF
+      ENDDO
+     ENDIF
+     
+     IF ( model_config_rec % max_dom > 1 ) THEN
+      DO i = 1, model_config_rec % max_dom - 1
+        IF ( model_config_rec % nssl_ipelec(i) > 0 ) THEN
+         model_config_rec % nssl_ipelec(i) = 0
+         wrf_err_message = '--- NOTE: nssl_ipelec should only be nonzero on innermost domain, setting:  ' // &
+                           'nssl_ipelec = 0 on this domain '
+         CALL wrf_message ( wrf_err_message )
+       
+        ENDIF
+      ENDDO
+     ENDIF
+
+#else
+         wrf_err_message = '--- NOTE: WRF is not compiled for electrification, setting: ' // &
+          'elec_physics = 0'
+         CALL wrf_message_fatal ( wrf_err_message )
+    model_config_rec % elec_physics = 0
+#endif
 !-----------------------------------------------------------------------
 ! Set the namelist parameters for the RRTMG radiation scheme if either
 ! ra_lw_physics = RRTMG_LWSCHEME or ra_sw_physics = RRTMG_SWSCHEME.
@@ -2013,6 +2048,7 @@ SUBROUTINE set_physics_rconfigs
          END IF
       END DO
 
+ 
    END SUBROUTINE set_physics_rconfigs
 
 
